# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.InputEventShortcut as py4godot_inputeventshortcut 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.CanvasGroup as py4godot_canvasgroup 
  import py4godot.classes.GrooveJoint2D as py4godot_groovejoint2d 
  import py4godot.classes.Marker2D as py4godot_marker2d 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.Tree as py4godot_tree 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.TouchScreenButton as py4godot_touchscreenbutton 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.ShapeCast2D as py4godot_shapecast2d 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.Skeleton2D as py4godot_skeleton2d 
  import py4godot.classes.BaseMaterial3D as py4godot_basematerial3d 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.ShaderMaterial as py4godot_shadermaterial 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.ORMMaterial3D as py4godot_ormmaterial3d 
  import py4godot.classes.InputEventFromWindow as py4godot_inputeventfromwindow 
  import py4godot.classes.PanoramaSkyMaterial as py4godot_panoramaskymaterial 
  import py4godot.classes.RichTextLabel as py4godot_richtextlabel 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.NavigationRegion2D as py4godot_navigationregion2d 
  import py4godot.classes.TabBar as py4godot_tabbar 
  import py4godot.classes.ParallaxBackground as py4godot_parallaxbackground 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.VisibleOnScreenEnabler2D as py4godot_visibleonscreenenabler2d 
  import py4godot.classes.Mesh as py4godot_mesh 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.GPUParticles2D as py4godot_gpuparticles2d 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.Node2D as py4godot_node2d 
  import py4godot.classes.AnimatedSprite2D as py4godot_animatedsprite2d 
  import py4godot.classes.NavigationLink2D as py4godot_navigationlink2d 
  import py4godot.classes.Path2D as py4godot_path2d 
  import py4godot.classes.LightOccluder2D as py4godot_lightoccluder2d 
  import py4godot.classes.Parallax2D as py4godot_parallax2d 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.InputEventKey as py4godot_inputeventkey 
  import py4godot.classes.FogMaterial as py4godot_fogmaterial 
  import py4godot.classes.StaticBody2D as py4godot_staticbody2d 
  import py4godot.classes.InputEventMouseMotion as py4godot_inputeventmousemotion 
  import py4godot.classes.AudioListener2D as py4godot_audiolistener2d 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.InputEventMouseButton as py4godot_inputeventmousebutton 
  import py4godot.classes.MultiMesh as py4godot_multimesh 
  import py4godot.classes.Container as py4godot_container 
  import py4godot.classes.TileMapLayer as py4godot_tilemaplayer 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.CollisionObject2D as py4godot_collisionobject2d 
  import py4godot.classes.CollisionPolygon2D as py4godot_collisionpolygon2d 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.InputEventScreenTouch as py4godot_inputeventscreentouch 
  import py4godot.classes.AudioStreamPlayer2D as py4godot_audiostreamplayer2d 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.MeshInstance2D as py4godot_meshinstance2d 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.Light2D as py4godot_light2d 
  import py4godot.classes.NavigationObstacle2D as py4godot_navigationobstacle2d 
  import py4godot.classes.PhysicalSkyMaterial as py4godot_physicalskymaterial 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.TabContainer as py4godot_tabcontainer 
  import py4godot.classes.DirectionalLight2D as py4godot_directionallight2d 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.InputEventJoypadMotion as py4godot_inputeventjoypadmotion 
  import py4godot.classes.CanvasModulate as py4godot_canvasmodulate 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.CPUParticles2D as py4godot_cpuparticles2d 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.ProceduralSkyMaterial as py4godot_proceduralskymaterial 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.PinJoint2D as py4godot_pinjoint2d 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.PointLight2D as py4godot_pointlight2d 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.InputEvent as py4godot_inputevent 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.RemoteTransform2D as py4godot_remotetransform2d 
  import py4godot.classes.TileMap as py4godot_tilemap 
  import py4godot.classes.Sprite2D as py4godot_sprite2d 
  import py4godot.classes.TextEdit as py4godot_textedit 
  import py4godot.classes.Font as py4godot_font 
  import py4godot.classes.Line2D as py4godot_line2d 
  import py4godot.classes.StyleBox as py4godot_stylebox 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.AnimatableBody2D as py4godot_animatablebody2d 
  import py4godot.classes.CharacterBody2D as py4godot_characterbody2d 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.GraphElement as py4godot_graphelement 
  import py4godot.classes.CollisionShape2D as py4godot_collisionshape2d 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.World2D as py4godot_world2d 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.Bone2D as py4godot_bone2d 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.InputEventMIDI as py4godot_inputeventmidi 
  import py4godot.classes.InputEventWithModifiers as py4godot_inputeventwithmodifiers 
  import py4godot.classes.GraphNode as py4godot_graphnode 
  import py4godot.classes.VisibleOnScreenNotifier2D as py4godot_visibleonscreennotifier2d 
  import py4godot.classes.InputEventGesture as py4godot_inputeventgesture 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.InputEventScreenDrag as py4godot_inputeventscreendrag 
  import py4godot.classes.RayCast2D as py4godot_raycast2d 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.TextServer as py4godot_textserver 
  import py4godot.classes.InputEventPanGesture as py4godot_inputeventpangesture 
  import py4godot.classes.DampedSpringJoint2D as py4godot_dampedspringjoint2d 
  import py4godot.classes.Material as py4godot_material 
  import py4godot.classes.Area2D as py4godot_area2d 
  import py4godot.classes.StandardMaterial3D as py4godot_standardmaterial3d 
  import py4godot.classes.PlaceholderMaterial as py4godot_placeholdermaterial 
  import py4godot.classes.InputEventAction as py4godot_inputeventaction 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.InputEventJoypadButton as py4godot_inputeventjoypadbutton 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.PhysicalBone2D as py4godot_physicalbone2d 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.Control as py4godot_control 
  import py4godot.classes.Joint2D as py4godot_joint2d 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.PathFollow2D as py4godot_pathfollow2d 
  import py4godot.classes.BackBufferCopy as py4godot_backbuffercopy 
  import py4godot.classes.FoldableContainer as py4godot_foldablecontainer 
  import py4godot.classes.PhysicsBody2D as py4godot_physicsbody2d 
  import py4godot.classes.RigidBody2D as py4godot_rigidbody2d 
  import py4godot.classes.MultiMeshInstance2D as py4godot_multimeshinstance2d 
  import py4godot.classes.ParallaxLayer as py4godot_parallaxlayer 
  import py4godot.classes.InputEventMouse as py4godot_inputeventmouse 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.ParticleProcessMaterial as py4godot_particleprocessmaterial 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.InputEventMagnifyGesture as py4godot_inputeventmagnifygesture 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.CanvasLayer as py4godot_canvaslayer 
  import py4godot.classes.Polygon2D as py4godot_polygon2d 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.Camera2D as py4godot_camera2d 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.CanvasItemMaterial as py4godot_canvasitemmaterial 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
import py4godot.classes.Node as py4godot_node 
from py4godot.wrappers.wrappers import CPPCanvasItemWrapper

class TextureFilter:
  TEXTURE_FILTER_PARENT_NODE = 0
  TEXTURE_FILTER_NEAREST = 1
  TEXTURE_FILTER_LINEAR = 2
  TEXTURE_FILTER_NEAREST_WITH_MIPMAPS = 3
  TEXTURE_FILTER_LINEAR_WITH_MIPMAPS = 4
  TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC = 5
  TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC = 6
  TEXTURE_FILTER_MAX = 7
class TextureRepeat:
  TEXTURE_REPEAT_PARENT_NODE = 0
  TEXTURE_REPEAT_DISABLED = 1
  TEXTURE_REPEAT_ENABLED = 2
  TEXTURE_REPEAT_MIRROR = 3
  TEXTURE_REPEAT_MAX = 4
class ClipChildrenMode:
  CLIP_CHILDREN_DISABLED = 0
  CLIP_CHILDREN_ONLY = 1
  CLIP_CHILDREN_AND_DRAW = 2
  CLIP_CHILDREN_MAX = 3


class CanvasItem(py4godot_node.Node):
  r'''
		Abstract base class for everything in 2D space. Canvas items are laid out in a tree; children inherit and extend their parent's transform. `CanvasItem` is extended by `Control` for GUI-related nodes, and by `Node2D` for 2D game objects.
		Any `CanvasItem` can draw. For this, `queue_redraw` is called by the engine, then `constant NOTIFICATION_DRAW` will be received on idle time to request a redraw. Because of this, canvas items don't need to be redrawn on every frame, improving the performance significantly. Several functions for drawing on the `CanvasItem` are provided (see `draw_*` functions). However, they can only be used inside `_draw`, its corresponding `Object._notification` or methods connected to the `signal draw` signal.
		Canvas items are drawn in tree order on their canvas layer. By default, children are on top of their parents, so a root `CanvasItem` will be drawn behind everything. This behavior can be changed on a per-item basis.
		A `CanvasItem` can be hidden, which will also hide its children. By adjusting various other properties of a `CanvasItem`, you can also modulate its color (via `modulate` or `self_modulate`), change its Z-index, blend mode, and more.
		Note that properties like transform, modulation, and visibility are only propagated to _direct_ `CanvasItem` child nodes. If there is a non-`CanvasItem` node in between, like `Node` or `AnimationPlayer`, the `CanvasItem` nodes below will have an independent position and `modulate` chain. See also `top_level`.
	'''
  NOTIFICATION_TRANSFORM_CHANGED:typing.ClassVar[int]

  NOTIFICATION_LOCAL_TRANSFORM_CHANGED:typing.ClassVar[int]

  NOTIFICATION_DRAW:typing.ClassVar[int]

  NOTIFICATION_VISIBILITY_CHANGED:typing.ClassVar[int]

  NOTIFICATION_ENTER_CANVAS:typing.ClassVar[int]

  NOTIFICATION_EXIT_CANVAS:typing.ClassVar[int]

  NOTIFICATION_WORLD_2D_CHANGED:typing.ClassVar[int]

  @staticmethod
  def constructor():
    class_ = CanvasItem.construct_without_init()
    class_._ptr = constructor(197,0, ())
    return class_
  @staticmethod
  def new():
    class_ = CanvasItem.construct_without_init()
    class_._ptr = constructor(197,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPCanvasItemWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(197,0, ())


  def generate_wrapper(self):
    return CPPCanvasItemWrapper()
  def init_signals(self):
    super().init_signals()
    draw_name = utils.py_string_to_string_name("draw")
    self.draw = signals.BuiltinSignal(self, draw_name)
    visibility_changed_name = utils.py_string_to_string_name("visibility_changed")
    self.visibility_changed = signals.BuiltinSignal(self, visibility_changed_name)
    hidden_name = utils.py_string_to_string_name("hidden")
    self.hidden = signals.BuiltinSignal(self, hidden_name)
    item_rect_changed_name = utils.py_string_to_string_name("item_rect_changed")
    self.item_rect_changed = signals.BuiltinSignal(self, item_rect_changed_name)

  @staticmethod
  def construct_without_init():
    cls = CanvasItem.__new__(CanvasItem)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'CanvasItem'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = CanvasItem.construct_without_init()
    cls._ptr = CPPCanvasItemWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = CanvasItem.construct_without_init()
    cls._ptr = CPPCanvasItemWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def visible(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_visible()
    return _ret
  @visible.setter
  def visible(self,  value:'bool'):
    self.set_visible(value)
  @property
  def modulate(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_modulate()
    return _ret
  @modulate.setter
  def modulate(self,  value:'Color'):
    self.set_modulate(value)
  @property
  def self_modulate(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_self_modulate()
    return _ret
  @self_modulate.setter
  def self_modulate(self,  value:'Color'):
    self.set_self_modulate(value)
  @property
  def show_behind_parent(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_draw_behind_parent_enabled()
    return _ret
  @show_behind_parent.setter
  def show_behind_parent(self,  value:'bool'):
    self.set_draw_behind_parent(value)
  @property
  def top_level(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_set_as_top_level()
    return _ret
  @top_level.setter
  def top_level(self,  value:'bool'):
    self.set_as_top_level(value)
  @property
  def clip_children(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_clip_children_mode()
    return _ret
  @clip_children.setter
  def clip_children(self,  value:'int'):
    self.set_clip_children_mode(value)
  @property
  def light_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_light_mask()
    return _ret
  @light_mask.setter
  def light_mask(self,  value:'int'):
    self.set_light_mask(value)
  @property
  def visibility_layer(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_visibility_layer()
    return _ret
  @visibility_layer.setter
  def visibility_layer(self,  value:'int'):
    self.set_visibility_layer(value)
  @property
  def z_index(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_z_index()
    return _ret
  @z_index.setter
  def z_index(self,  value:'int'):
    self.set_z_index(value)
  @property
  def z_as_relative(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_z_relative()
    return _ret
  @z_as_relative.setter
  def z_as_relative(self,  value:'bool'):
    self.set_z_as_relative(value)
  @property
  def y_sort_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_y_sort_enabled()
    return _ret
  @y_sort_enabled.setter
  def y_sort_enabled(self,  value:'bool'):
    self.set_y_sort_enabled(value)
  @property
  def texture_filter(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_texture_filter()
    return _ret
  @texture_filter.setter
  def texture_filter(self,  value:'int'):
    self.set_texture_filter(value)
  @property
  def texture_repeat(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_texture_repeat()
    return _ret
  @texture_repeat.setter
  def texture_repeat(self,  value:'int'):
    self.set_texture_repeat(value)
  @property
  def material(self) -> typing.Union['py4godot_canvasitemmaterial.CanvasItemMaterial']:
    r''''''
    _ret = self. get_material()
    return _ret
  @material.setter
  def material(self,  value:'py4godot_object.Object'):
    self.set_material(value)
  @property
  def use_parent_material(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_use_parent_material()
    return _ret
  @use_parent_material.setter
  def use_parent_material(self,  value:'bool'):
    self.set_use_parent_material(value)
  @functools.native_method
  def _draw(self) -> None:
    r'''
				Called when `CanvasItem` has been requested to redraw (after `queue_redraw` is called, either manually or by the engine).
				Corresponds to the `constant NOTIFICATION_DRAW` notification in `Object._notification`.
			'''




    self._ptr.call_with_return(180,tuple([]))

  @functools.native_method
  def get_canvas_item(self) -> typing.Union['RID']:
    r'''
				Returns the internal canvas item `RID` used by the `RenderingServer` for this node.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(181,tuple([]))
    return _ret


  @functools.native_method
  def set_visible(self, visible:'bool'   ) -> None:
    r''''''

    assert isinstance(visible, bool), 'visible must be bool'


    self.py__visible = visible






    self._ptr.call_with_return(182,tuple([visible]))

  @functools.native_method
  def is_visible(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(183,tuple([]))

    return _ret


  @functools.native_method
  def is_visible_in_tree(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the node is present in the `SceneTree`, its `visible` property is `true` and all its ancestors are also visible. If any ancestor is hidden, this node will not be visible in the scene tree, and is therefore not drawn (see `_draw`).
				Visibility is checked only in parent nodes that inherit from `CanvasItem`, `CanvasLayer`, and `Window`. If the parent is of any other type (such as `Node`, `AnimationPlayer`, or `Node3D`), it is assumed to be visible.
				**Note:** This method does not take `visibility_layer` into account, so even if this method returns `true`, the node might end up not being rendered.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(184,tuple([]))
    return _ret


  @functools.native_method
  def show(self) -> None:
    r'''
				Show the `CanvasItem` if it's currently hidden. This is equivalent to setting `visible` to `true`.
				**Note:** For controls that inherit `Popup`, the correct way to make them visible is to call one of the multiple `popup*()` functions instead.
			'''




    self._ptr.call_with_return(185,tuple([]))

  @functools.native_method
  def hide(self) -> None:
    r'''
				Hide the `CanvasItem` if it's currently visible. This is equivalent to setting `visible` to `false`.
			'''




    self._ptr.call_with_return(186,tuple([]))

  @functools.native_method
  def queue_redraw(self) -> None:
    r'''
				Queues the `CanvasItem` to redraw. During idle time, if `CanvasItem` is visible, `constant NOTIFICATION_DRAW` is sent and `_draw` is called. This only occurs **once** per frame, even if this method has been called multiple times.
			'''




    self._ptr.call_with_return(187,tuple([]))

  @functools.native_method
  def move_to_front(self) -> None:
    r'''
				Moves this node below its siblings, usually causing the node to draw on top of its siblings. Does nothing if this node does not have a parent. See also `Node.move_child`.
			'''




    self._ptr.call_with_return(188,tuple([]))

  @functools.native_method
  def set_as_top_level(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__top_level = enable






    self._ptr.call_with_return(189,tuple([enable]))

  @functools.native_method
  def is_set_as_top_level(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(190,tuple([]))

    return _ret


  @functools.native_method
  def set_light_mask(self, light_mask:'int'   ) -> None:
    r''''''

    assert isinstance(light_mask, (int, float)), 'light_mask must be int or float'


    self.py__light_mask = light_mask






    self._ptr.call_with_return(191,tuple([light_mask]))

  @functools.native_method
  def get_light_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(192,tuple([]))

    return _ret


  @functools.native_method
  def set_modulate(self, modulate:'Color'   ) -> None:
    r''''''

    assert(not modulate is None)
    assert isinstance(modulate, Color), 'modulate must be Color'


    self.py__modulate = modulate






    self._ptr.call_with_return(193,tuple([modulate._ptr]))

  @functools.native_method
  def get_modulate(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(194,tuple([]))

    return _ret


  @functools.native_method
  def set_self_modulate(self, self_modulate:'Color'   ) -> None:
    r''''''

    assert(not self_modulate is None)
    assert isinstance(self_modulate, Color), 'self_modulate must be Color'


    self.py__self_modulate = self_modulate






    self._ptr.call_with_return(195,tuple([self_modulate._ptr]))

  @functools.native_method
  def get_self_modulate(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(196,tuple([]))

    return _ret


  @functools.native_method
  def set_z_index(self, z_index:'int'   ) -> None:
    r''''''

    assert isinstance(z_index, (int, float)), 'z_index must be int or float'


    self.py__z_index = z_index






    self._ptr.call_with_return(197,tuple([z_index]))

  @functools.native_method
  def get_z_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(198,tuple([]))

    return _ret


  @functools.native_method
  def set_z_as_relative(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__z_as_relative = enable






    self._ptr.call_with_return(199,tuple([enable]))

  @functools.native_method
  def is_z_relative(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(200,tuple([]))

    return _ret


  @functools.native_method
  def set_y_sort_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__y_sort_enabled = enabled






    self._ptr.call_with_return(201,tuple([enabled]))

  @functools.native_method
  def is_y_sort_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(202,tuple([]))

    return _ret


  @functools.native_method
  def set_draw_behind_parent(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__show_behind_parent = enable






    self._ptr.call_with_return(203,tuple([enable]))

  @functools.native_method
  def is_draw_behind_parent_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(204,tuple([]))

    return _ret


  @functools.native_method
  def draw_line(self, from_:'Vector2'   , to:'Vector2'   , color:'Color'   , width:'float' =-1.0  , antialiased:'bool' =False  ) -> None:
    r'''
				Draws a line from a 2D point to another, with a given color and width. It can be optionally antialiased. The `from` and `to` positions are defined in local space. See also `draw_dashed_line`, `draw_multiline`, and `draw_polyline`.
				If `width` is negative, then a two-point primitive will be drawn instead of a four-point one. This means that when the CanvasItem is scaled, the line will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
			'''

    assert(not from_ is None)
    assert isinstance(from_, Vector2), 'from_ must be Vector2'
    assert(not to is None)
    assert isinstance(to, Vector2), 'to must be Vector2'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(antialiased, bool), 'antialiased must be bool'











    self._ptr.call_with_return(205,tuple([from_._ptr, to._ptr, color._ptr, width, antialiased]))

  @functools.native_method
  def draw_dashed_line(self, from_:'Vector2'   , to:'Vector2'   , color:'Color'   , width:'float' =-1.0  , dash:'float' =2.0  , aligned:'bool' =True  , antialiased:'bool' =False  ) -> None:
    r'''
				Draws a dashed line from a 2D point to another, with a given color and width. The `from` and `to` positions are defined in local space. See also `draw_line`, `draw_multiline`, and `draw_polyline`.
				If `width` is negative, then a two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the line parts will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
				`dash` is the length of each dash in pixels, with the gap between each dash being the same length. If `aligned` is `true`, the length of the first and last dashes may be shortened or lengthened to allow the line to begin and end at the precise points defined by `from` and `to`. Both ends are always symmetrical when `aligned` is `true`. If `aligned` is `false`, all dashes will have the same length, but the line may appear incomplete at the end due to the dash length not dividing evenly into the line length. Only full dashes are drawn when `aligned` is `false`.
				If `antialiased` is `true`, half transparent "feathers" will be attached to the boundary, making outlines smooth.
				**Note:** `antialiased` is only effective if `width` is greater than `0.0`.
			'''

    assert(not from_ is None)
    assert isinstance(from_, Vector2), 'from_ must be Vector2'
    assert(not to is None)
    assert isinstance(to, Vector2), 'to must be Vector2'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(dash, (int, float)), 'dash must be int or float'
    assert isinstance(aligned, bool), 'aligned must be bool'
    assert isinstance(antialiased, bool), 'antialiased must be bool'













    self._ptr.call_with_return(206,tuple([from_._ptr, to._ptr, color._ptr, width, dash, aligned, antialiased]))

  @functools.native_method
  def draw_polyline(self, points:'PackedVector2Array'   , color:'Color'   , width:'float' =-1.0  , antialiased:'bool' =False  ) -> None:
    r'''
				Draws interconnected line segments with a uniform `color` and `width` and optional antialiasing (supported only for positive `width`). The `points` array is defined in local space. When drawing large amounts of lines, this is faster than using individual `draw_line` calls. To draw disconnected lines, use `draw_multiline` instead. See also `draw_polygon`.
				If `width` is negative, it will be ignored and the polyline will be drawn using `constant RenderingServer.PRIMITIVE_LINE_STRIP`. This means that when the CanvasItem is scaled, the polyline will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
			'''

    assert(not points is None)
    assert isinstance(points, PackedVector2Array), 'points must be PackedVector2Array'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(antialiased, bool), 'antialiased must be bool'










    self._ptr.call_with_return(207,tuple([points._ptr, color._ptr, width, antialiased]))

  @functools.native_method
  def draw_polyline_colors(self, points:'PackedVector2Array'   , colors:'PackedColorArray'   , width:'float' =-1.0  , antialiased:'bool' =False  ) -> None:
    r'''
				Draws interconnected line segments with a uniform `width`, point-by-point coloring, and optional antialiasing (supported only for positive `width`). Colors assigned to line points match by index between `points` and `colors`, i.e. each line segment is filled with a gradient between the colors of the endpoints. The `points` array is defined in local space. When drawing large amounts of lines, this is faster than using individual `draw_line` calls. To draw disconnected lines, use `draw_multiline_colors` instead. See also `draw_polygon`.
				If `width` is negative, it will be ignored and the polyline will be drawn using `constant RenderingServer.PRIMITIVE_LINE_STRIP`. This means that when the CanvasItem is scaled, the polyline will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
			'''

    assert(not points is None)
    assert isinstance(points, PackedVector2Array), 'points must be PackedVector2Array'
    assert(not colors is None)
    assert isinstance(colors, PackedColorArray), 'colors must be PackedColorArray'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(antialiased, bool), 'antialiased must be bool'










    self._ptr.call_with_return(208,tuple([points._ptr, colors._ptr, width, antialiased]))

  @functools.native_method
  def draw_arc(self, center:'Vector2'   , radius:'float'   , start_angle:'float'   , end_angle:'float'   , point_count:'int'   , color:'Color'   , width:'float' =-1.0  , antialiased:'bool' =False  ) -> None:
    r'''
				Draws an unfilled arc between the given angles with a uniform `color` and `width` and optional antialiasing (supported only for positive `width`). The larger the value of `point_count`, the smoother the curve. `center` is defined in local space. For elliptical arcs, see `draw_ellipse_arc`. See also `draw_circle`.
				If `width` is negative, it will be ignored and the arc will be drawn using `constant RenderingServer.PRIMITIVE_LINE_STRIP`. This means that when the CanvasItem is scaled, the arc will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
				The arc is drawn from `start_angle` towards the value of `end_angle` so in clockwise direction if `start_angle < end_angle` and counter-clockwise otherwise. Passing the same angles but in reversed order will produce the same arc. If absolute difference of `start_angle` and `end_angle` is greater than `constant @GDScript.TAU` radians, then a full circle arc is drawn (i.e. arc will not overlap itself).
			'''

    assert(not center is None)
    assert isinstance(center, Vector2), 'center must be Vector2'
    assert isinstance(radius, (int, float)), 'radius must be int or float'
    assert isinstance(start_angle, (int, float)), 'start_angle must be int or float'
    assert isinstance(end_angle, (int, float)), 'end_angle must be int or float'
    assert isinstance(point_count, (int, float)), 'point_count must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(antialiased, bool), 'antialiased must be bool'














    self._ptr.call_with_return(209,tuple([center._ptr, radius, start_angle, end_angle, point_count, color._ptr, width, antialiased]))

  @functools.native_method
  def draw_multiline(self, points:'PackedVector2Array'   , color:'Color'   , width:'float' =-1.0  , antialiased:'bool' =False  ) -> None:
    r'''
				Draws multiple disconnected lines with a uniform `width` and `color`. Each line is defined by two consecutive points from `points` array in local space, i.e. i-th segment consists of `points`2 * i``, `points`2 * i + 1`` endpoints. When drawing large amounts of lines, this is faster than using individual `draw_line` calls. To draw interconnected lines, use `draw_polyline` instead.
				If `width` is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
				**Note:** `antialiased` is only effective if `width` is greater than `0.0`.
			'''

    assert(not points is None)
    assert isinstance(points, PackedVector2Array), 'points must be PackedVector2Array'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(antialiased, bool), 'antialiased must be bool'










    self._ptr.call_with_return(210,tuple([points._ptr, color._ptr, width, antialiased]))

  @functools.native_method
  def draw_multiline_colors(self, points:'PackedVector2Array'   , colors:'PackedColorArray'   , width:'float' =-1.0  , antialiased:'bool' =False  ) -> None:
    r'''
				Draws multiple disconnected lines with a uniform `width` and segment-by-segment coloring. Each segment is defined by two consecutive points from `points` array in local space and a corresponding color from `colors` array, i.e. i-th segment consists of `points`2 * i``, `points`2 * i + 1`` endpoints and has `colors_` color. When drawing large amounts of lines, this is faster than using individual `draw_line` calls. To draw interconnected lines, use `draw_polyline_colors` instead.
				If `width` is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
				**Note:** `antialiased` is only effective if `width` is greater than `0.0`.
			'''

    assert(not points is None)
    assert isinstance(points, PackedVector2Array), 'points must be PackedVector2Array'
    assert(not colors is None)
    assert isinstance(colors, PackedColorArray), 'colors must be PackedColorArray'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(antialiased, bool), 'antialiased must be bool'










    self._ptr.call_with_return(211,tuple([points._ptr, colors._ptr, width, antialiased]))

  @functools.native_method
  def draw_rect(self, rect:'Rect2'   , color:'Color'   , filled:'bool' =True  , width:'float' =-1.0  , antialiased:'bool' =False  ) -> None:
    r'''
				Draws a rectangle. If `filled` is `true`, the rectangle will be filled with the `color` specified. If `filled` is `false`, the rectangle will be drawn as a stroke with the `color` and `width` specified. The `rect` is specified in local space. See also `draw_texture_rect`.
				If `width` is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
				If `antialiased` is `true`, half transparent "feathers" will be attached to the boundary, making outlines smooth.
				**Note:** `width` is only effective if `filled` is `false`.
				**Note:** Unfilled rectangles drawn with a negative `width` may not display perfectly. For example, corners may be missing or brighter due to overlapping lines (for a translucent `color`).
			'''

    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(filled, bool), 'filled must be bool'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(antialiased, bool), 'antialiased must be bool'











    self._ptr.call_with_return(212,tuple([rect._ptr, color._ptr, filled, width, antialiased]))

  @functools.native_method
  def draw_circle(self, position:'Vector2'   , radius:'float'   , color:'Color'   , filled:'bool' =True  , width:'float' =-1.0  , antialiased:'bool' =False  ) -> None:
    r'''
				Draws a circle, with `position` defined in local space. See also `draw_ellipse`, `draw_arc`, `draw_polyline`, and `draw_polygon`.
				If `filled` is `true`, the circle will be filled with the `color` specified. If `filled` is `false`, the circle will be drawn as a stroke with the `color` and `width` specified.
				If `width` is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive `width` like `1.0`.
				If `antialiased` is `true`, half transparent "feathers" will be attached to the boundary, making outlines smooth.
				**Note:** `width` is only effective if `filled` is `false`.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'
    assert isinstance(radius, (int, float)), 'radius must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(filled, bool), 'filled must be bool'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(antialiased, bool), 'antialiased must be bool'












    self._ptr.call_with_return(213,tuple([position._ptr, radius, color._ptr, filled, width, antialiased]))

  @functools.native_method
  def draw_texture(self, texture:'py4godot_texture2d.Texture2D'   , position:'Vector2'   , modulate:'Color' = None  ) -> None:
    r'''
				Draws a texture at a given position. The `position` is defined in local space.
				**Note:** Styleboxes, textures, and meshes stored only inside local variables should **not** be used with this method in GDScript, because the drawing operation doesn't begin immediately once this method is called. In GDScript, when the function with the local variables ends, the local variables get destroyed before the rendering takes place.
			'''
    if modulate is None:
      modulate = Color.new0()

    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'









    self._ptr.call_with_return(214,tuple([texture._ptr, position._ptr, modulate._ptr]))

  @functools.native_method
  def draw_texture_rect(self, texture:'py4godot_texture2d.Texture2D'   , rect:'Rect2'   , tile:'bool'   , modulate:'Color' = None  , transpose:'bool' =False  ) -> None:
    r'''
				Draws a textured rectangle at a given position, optionally modulated by a color. The `rect` is defined in local space. If `transpose` is `true`, the texture will have its X and Y coordinates swapped. See also `draw_rect` and `draw_texture_rect_region`.
				**Note:** Styleboxes, textures, and meshes stored only inside local variables should **not** be used with this method in GDScript, because the drawing operation doesn't begin immediately once this method is called. In GDScript, when the function with the local variables ends, the local variables get destroyed before the rendering takes place.
			'''
    if modulate is None:
      modulate = Color.new0()

    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'
    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'
    assert isinstance(tile, bool), 'tile must be bool'
    assert isinstance(transpose, bool), 'transpose must be bool'











    self._ptr.call_with_return(215,tuple([texture._ptr, rect._ptr, tile, modulate._ptr, transpose]))

  @functools.native_method
  def draw_texture_rect_region(self, texture:'py4godot_texture2d.Texture2D'   , rect:'Rect2'   , src_rect:'Rect2'   , modulate:'Color' = None  , transpose:'bool' =False  , clip_uv:'bool' =True  ) -> None:
    r'''
				Draws a textured rectangle from a texture's region (specified by `src_rect`) at a given position in local space, optionally modulated by a color. If `transpose` is `true`, the texture will have its X and Y coordinates swapped. See also `draw_texture_rect`.
				**Note:** Styleboxes, textures, and meshes stored only inside local variables should **not** be used with this method in GDScript, because the drawing operation doesn't begin immediately once this method is called. In GDScript, when the function with the local variables ends, the local variables get destroyed before the rendering takes place.
			'''
    if modulate is None:
      modulate = Color.new0()

    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'
    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'
    assert(not src_rect is None)
    assert isinstance(src_rect, Rect2), 'src_rect must be Rect2'
    assert isinstance(transpose, bool), 'transpose must be bool'
    assert isinstance(clip_uv, bool), 'clip_uv must be bool'












    self._ptr.call_with_return(216,tuple([texture._ptr, rect._ptr, src_rect._ptr, modulate._ptr, transpose, clip_uv]))

  @functools.native_method
  def draw_msdf_texture_rect_region(self, texture:'py4godot_texture2d.Texture2D'   , rect:'Rect2'   , src_rect:'Rect2'   , modulate:'Color' = None  , outline:'float' =0.0  , pixel_range:'float' =4.0  , scale:'float' =1.0  ) -> None:
    r'''
				Draws a textured rectangle region of the multichannel signed distance field texture at a given position, optionally modulated by a color. The `rect` is defined in local space. See `FontFile.multichannel_signed_distance_field` for more information and caveats about MSDF font rendering.
				If `outline` is positive, each alpha channel value of pixel in region is set to maximum value of true distance in the `outline` radius.
				Value of the `pixel_range` should the same that was used during distance field texture generation.
				**Note:** Styleboxes, textures, and meshes stored only inside local variables should **not** be used with this method in GDScript, because the drawing operation doesn't begin immediately once this method is called. In GDScript, when the function with the local variables ends, the local variables get destroyed before the rendering takes place.
			'''
    if modulate is None:
      modulate = Color.new0()

    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'
    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'
    assert(not src_rect is None)
    assert isinstance(src_rect, Rect2), 'src_rect must be Rect2'
    assert isinstance(outline, (int, float)), 'outline must be int or float'
    assert isinstance(pixel_range, (int, float)), 'pixel_range must be int or float'
    assert isinstance(scale, (int, float)), 'scale must be int or float'













    self._ptr.call_with_return(217,tuple([texture._ptr, rect._ptr, src_rect._ptr, modulate._ptr, outline, pixel_range, scale]))

  @functools.native_method
  def draw_lcd_texture_rect_region(self, texture:'py4godot_texture2d.Texture2D'   , rect:'Rect2'   , src_rect:'Rect2'   , modulate:'Color' = None  ) -> None:
    r'''
				Draws a textured rectangle region of the font texture with LCD subpixel anti-aliasing at a given position, optionally modulated by a color. The `rect` is defined in local space.
				Texture is drawn using the following blend operation, blend mode of the `CanvasItemMaterial` is ignored:
				```gdscript
				dst.r = texture.r * modulate.r * modulate.a + dst.r * (1.0 - texture.r * modulate.a);
				dst.g = texture.g * modulate.g * modulate.a + dst.g * (1.0 - texture.g * modulate.a);
				dst.b = texture.b * modulate.b * modulate.a + dst.b * (1.0 - texture.b * modulate.a);
				dst.a = modulate.a + dst.a * (1.0 - modulate.a);
				```
				**Note:** Styleboxes, textures, and meshes stored only inside local variables should **not** be used with this method in GDScript, because the drawing operation doesn't begin immediately once this method is called. In GDScript, when the function with the local variables ends, the local variables get destroyed before the rendering takes place.
			'''
    if modulate is None:
      modulate = Color.new0()

    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'
    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'
    assert(not src_rect is None)
    assert isinstance(src_rect, Rect2), 'src_rect must be Rect2'










    self._ptr.call_with_return(218,tuple([texture._ptr, rect._ptr, src_rect._ptr, modulate._ptr]))

  @functools.native_method
  def draw_style_box(self, style_box:'py4godot_stylebox.StyleBox'   , rect:'Rect2'   ) -> None:
    r'''
				Draws a styled rectangle. The `rect` is defined in local space.
				**Note:** Styleboxes, textures, and meshes stored only inside local variables should **not** be used with this method in GDScript, because the drawing operation doesn't begin immediately once this method is called. In GDScript, when the function with the local variables ends, the local variables get destroyed before the rendering takes place.
			'''

    assert(not style_box is None)
    assert isinstance(style_box, get_class('StyleBox')), 'style_box must be StyleBox'
    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'








    self._ptr.call_with_return(219,tuple([style_box._ptr, rect._ptr]))

  @functools.native_method
  def draw_primitive(self, points:'PackedVector2Array'   , colors:'PackedColorArray'   , uvs:'PackedVector2Array'   , texture:'py4godot_texture2d.Texture2D' = None  ) -> None:
    r'''
				Draws a custom primitive. 1 point for a point, 2 points for a line, 3 points for a triangle, and 4 points for a quad. If 0 points or more than 4 points are specified, nothing will be drawn and an error message will be printed. The `points` array is defined in local space. See also `draw_line`, `draw_polyline`, `draw_polygon`, and `draw_rect`.
				**Note:** Styleboxes, textures, and meshes stored only inside local variables should **not** be used with this method in GDScript, because the drawing operation doesn't begin immediately once this method is called. In GDScript, when the function with the local variables ends, the local variables get destroyed before the rendering takes place.
			'''
    if texture is None:
      texture = c_utils.empty_object

    assert(not points is None)
    assert isinstance(points, PackedVector2Array), 'points must be PackedVector2Array'
    assert(not colors is None)
    assert isinstance(colors, PackedColorArray), 'colors must be PackedColorArray'
    assert(not uvs is None)
    assert isinstance(uvs, PackedVector2Array), 'uvs must be PackedVector2Array'










    self._ptr.call_with_return(220,tuple([points._ptr, colors._ptr, uvs._ptr, texture._ptr]))

  @functools.native_method
  def draw_polygon(self, points:'PackedVector2Array'   , colors:'PackedColorArray'   , uvs:'PackedVector2Array' = None  , texture:'py4godot_texture2d.Texture2D' = None  ) -> None:
    r'''
				Draws a solid polygon of any number of points, convex or concave. Unlike `draw_colored_polygon`, each point's color can be changed individually. The `points` array is defined in local space. See also `draw_polyline` and `draw_polyline_colors`. If you need more flexibility (such as being able to use bones), use `RenderingServer.canvas_item_add_triangle_array` instead.
				**Note:** If you frequently redraw the same polygon with a large number of vertices, consider pre-calculating the triangulation with `Geometry2D.triangulate_polygon` and using `draw_mesh`, `draw_multimesh`, or `RenderingServer.canvas_item_add_triangle_array`.
				**Note:** Styleboxes, textures, and meshes stored only inside local variables should **not** be used with this method in GDScript, because the drawing operation doesn't begin immediately once this method is called. In GDScript, when the function with the local variables ends, the local variables get destroyed before the rendering takes place.
			'''
    if uvs is None:
      uvs = PackedVector2Array.new0()
    if texture is None:
      texture = c_utils.empty_object

    assert(not points is None)
    assert isinstance(points, PackedVector2Array), 'points must be PackedVector2Array'
    assert(not colors is None)
    assert isinstance(colors, PackedColorArray), 'colors must be PackedColorArray'










    self._ptr.call_with_return(221,tuple([points._ptr, colors._ptr, uvs._ptr, texture._ptr]))

  @functools.native_method
  def draw_colored_polygon(self, points:'PackedVector2Array'   , color:'Color'   , uvs:'PackedVector2Array' = None  , texture:'py4godot_texture2d.Texture2D' = None  ) -> None:
    r'''
				Draws a colored polygon of any number of points, convex or concave. The points in the `points` array are defined in local space. Unlike `draw_polygon`, a single color must be specified for the whole polygon.
				**Note:** If you frequently redraw the same polygon with a large number of vertices, consider pre-calculating the triangulation with `Geometry2D.triangulate_polygon` and using `draw_mesh`, `draw_multimesh`, or `RenderingServer.canvas_item_add_triangle_array`.
				**Note:** Styleboxes, textures, and meshes stored only inside local variables should **not** be used with this method in GDScript, because the drawing operation doesn't begin immediately once this method is called. In GDScript, when the function with the local variables ends, the local variables get destroyed before the rendering takes place.
			'''
    if uvs is None:
      uvs = PackedVector2Array.new0()
    if texture is None:
      texture = c_utils.empty_object

    assert(not points is None)
    assert isinstance(points, PackedVector2Array), 'points must be PackedVector2Array'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'










    self._ptr.call_with_return(222,tuple([points._ptr, color._ptr, uvs._ptr, texture._ptr]))

  @functools.native_method
  def draw_string(self, font:'py4godot_font.Font'   , pos:'Vector2'   , text:'str'   , alignment:'int'  =0, width:'float' =-1  , font_size:'int' =16  , modulate:'Color' = None  , justification_flags:'int' =3  , direction:'int'  =0, orientation:'int'  =0, oversampling:'float' =0.0  ) -> None:
    r'''
				Draws `text` using the specified `font` at the `pos` in local space (bottom-left corner using the baseline of the font). The text will have its color multiplied by `modulate`. If `width` is greater than or equal to 0, the text will be clipped if it exceeds the specified width. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
				**Example:** Draw "Hello world", using the project's default font:
				
				```gdscript
				draw_string(ThemeDB.fallback_font, Vector2(64, 64), "Hello world", HORIZONTAL_ALIGNMENT_LEFT, -1, ThemeDB.fallback_font_size)
				```
				
				
				See also `Font.draw_string`.
			'''

    if modulate is None:
      modulate = Color.new0()




    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(alignment, (int, float)), 'alignment must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'
    assert isinstance(direction, (int, float)), 'direction must be int or float'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'







    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)









    self._ptr.call_with_return(223,tuple([font._ptr, pos._ptr, py_string_text._ptr, alignment, width, font_size, modulate._ptr, justification_flags, direction, orientation, oversampling]))

  @functools.native_method
  def draw_multiline_string(self, font:'py4godot_font.Font'   , pos:'Vector2'   , text:'str'   , alignment:'int'  =0, width:'float' =-1  , font_size:'int' =16  , max_lines:'int' =-1  , modulate:'Color' = None  , brk_flags:'int' =3  , justification_flags:'int' =3  , direction:'int'  =0, orientation:'int'  =0, oversampling:'float' =0.0  ) -> None:
    r'''
				Breaks `text` into lines and draws it using the specified `font` at the `pos` in local space (top-left corner). The text will have its color multiplied by `modulate`. If `width` is greater than or equal to 0, the text will be clipped if it exceeds the specified width. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''

    if modulate is None:
      modulate = Color.new0()





    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(alignment, (int, float)), 'alignment must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    assert isinstance(max_lines, (int, float)), 'max_lines must be int or float'
    assert isinstance(brk_flags, (int, float)), 'brk_flags must be int or float'
    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'
    assert isinstance(direction, (int, float)), 'direction must be int or float'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'







    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)











    self._ptr.call_with_return(224,tuple([font._ptr, pos._ptr, py_string_text._ptr, alignment, width, font_size, max_lines, modulate._ptr, brk_flags, justification_flags, direction, orientation, oversampling]))

  @functools.native_method
  def draw_string_outline(self, font:'py4godot_font.Font'   , pos:'Vector2'   , text:'str'   , alignment:'int'  =0, width:'float' =-1  , font_size:'int' =16  , size:'int' =1  , modulate:'Color' = None  , justification_flags:'int' =3  , direction:'int'  =0, orientation:'int'  =0, oversampling:'float' =0.0  ) -> None:
    r'''
				Draws `text` outline using the specified `font` at the `pos` in local space (bottom-left corner using the baseline of the font). The text will have its color multiplied by `modulate`. If `width` is greater than or equal to 0, the text will be clipped if it exceeds the specified width. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''

    if modulate is None:
      modulate = Color.new0()




    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(alignment, (int, float)), 'alignment must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'
    assert isinstance(direction, (int, float)), 'direction must be int or float'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'







    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)










    self._ptr.call_with_return(225,tuple([font._ptr, pos._ptr, py_string_text._ptr, alignment, width, font_size, size, modulate._ptr, justification_flags, direction, orientation, oversampling]))

  @functools.native_method
  def draw_multiline_string_outline(self, font:'py4godot_font.Font'   , pos:'Vector2'   , text:'str'   , alignment:'int'  =0, width:'float' =-1  , font_size:'int' =16  , max_lines:'int' =-1  , size:'int' =1  , modulate:'Color' = None  , brk_flags:'int' =3  , justification_flags:'int' =3  , direction:'int'  =0, orientation:'int'  =0, oversampling:'float' =0.0  ) -> None:
    r'''
				Breaks `text` to the lines and draws text outline using the specified `font` at the `pos` in local space (top-left corner). The text will have its color multiplied by `modulate`. If `width` is greater than or equal to 0, the text will be clipped if it exceeds the specified width. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''

    if modulate is None:
      modulate = Color.new0()





    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(alignment, (int, float)), 'alignment must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    assert isinstance(max_lines, (int, float)), 'max_lines must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(brk_flags, (int, float)), 'brk_flags must be int or float'
    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'
    assert isinstance(direction, (int, float)), 'direction must be int or float'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'







    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)












    self._ptr.call_with_return(226,tuple([font._ptr, pos._ptr, py_string_text._ptr, alignment, width, font_size, max_lines, size, modulate._ptr, brk_flags, justification_flags, direction, orientation, oversampling]))

  @functools.native_method
  def draw_char(self, font:'py4godot_font.Font'   , pos:'Vector2'   , char:'str'   , font_size:'int' =16  , modulate:'Color' = None  , oversampling:'float' =0.0  ) -> None:
    r'''
				Draws a string first character using a custom font. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used. `pos` is defined in local space.
			'''
    if modulate is None:
      modulate = Color.new0()

    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert(not char is None)
    assert isinstance(char, (str, String)), 'char must be str or String'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'







    assert(isinstance(char, (str, String)))
    py_string_char = char if isinstance(char, StringName) else c_utils.py_string_to_string(char)




    self._ptr.call_with_return(227,tuple([font._ptr, pos._ptr, py_string_char._ptr, font_size, modulate._ptr, oversampling]))

  @functools.native_method
  def draw_char_outline(self, font:'py4godot_font.Font'   , pos:'Vector2'   , char:'str'   , font_size:'int' =16  , size:'int' =-1  , modulate:'Color' = None  , oversampling:'float' =0.0  ) -> None:
    r'''
				Draws a string first character outline using a custom font. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used. `pos` is defined in local space.
			'''
    if modulate is None:
      modulate = Color.new0()

    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert(not char is None)
    assert isinstance(char, (str, String)), 'char must be str or String'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'







    assert(isinstance(char, (str, String)))
    py_string_char = char if isinstance(char, StringName) else c_utils.py_string_to_string(char)





    self._ptr.call_with_return(228,tuple([font._ptr, pos._ptr, py_string_char._ptr, font_size, size, modulate._ptr, oversampling]))

  @functools.native_method
  def draw_mesh(self, mesh:'py4godot_mesh.Mesh'   , texture:'py4godot_texture2d.Texture2D'   , transform:'Transform2D' = None  , modulate:'Color' = None  ) -> None:
    r'''
				Draws a `Mesh` in 2D, using the provided texture. See `MeshInstance2D` for related documentation. The `transform` is defined in local space.
				**Note:** Styleboxes, textures, and meshes stored only inside local variables should **not** be used with this method in GDScript, because the drawing operation doesn't begin immediately once this method is called. In GDScript, when the function with the local variables ends, the local variables get destroyed before the rendering takes place.
			'''
    if transform is None:
      transform = Transform2D.new0()
    if modulate is None:
      modulate = Color.new0()

    assert(not mesh is None)
    assert isinstance(mesh, get_class('Mesh')), 'mesh must be Mesh'
    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'










    self._ptr.call_with_return(229,tuple([mesh._ptr, texture._ptr, transform._ptr, modulate._ptr]))

  @functools.native_method
  def draw_multimesh(self, multimesh:'py4godot_multimesh.MultiMesh'   , texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Draws a `MultiMesh` in 2D with the provided texture. See `MultiMeshInstance2D` for related documentation.
				**Note:** Styleboxes, textures, and meshes stored only inside local variables should **not** be used with this method in GDScript, because the drawing operation doesn't begin immediately once this method is called. In GDScript, when the function with the local variables ends, the local variables get destroyed before the rendering takes place.
			'''

    assert(not multimesh is None)
    assert isinstance(multimesh, get_class('MultiMesh')), 'multimesh must be MultiMesh'
    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'








    self._ptr.call_with_return(230,tuple([multimesh._ptr, texture._ptr]))

  @functools.native_method
  def draw_set_transform(self, position:'Vector2'   , rotation:'float' =0.0  , scale:'Vector2' = None  ) -> None:
    r'''
				Sets a custom local transform for drawing via components. Anything drawn afterwards will be transformed by this.
				**Note:** `FontFile.oversampling` does _not_ take `scale` into account. This means that scaling up/down will cause bitmap fonts and rasterized (non-MSDF) dynamic fonts to appear blurry or pixelated. To ensure text remains crisp regardless of scale, you can enable MSDF font rendering by enabling `ProjectSettings.gui/theme/default_font_multichannel_signed_distance_field` (applies to the default project font only), or enabling **Multichannel Signed Distance Field** in the import options of a DynamicFont for custom fonts. On system fonts, `SystemFont.multichannel_signed_distance_field` can be enabled in the inspector.
			'''
    if scale is None:
      scale = Vector2.new0()

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'
    assert isinstance(rotation, (int, float)), 'rotation must be int or float'









    self._ptr.call_with_return(231,tuple([position._ptr, rotation, scale._ptr]))

  @functools.native_method
  def draw_set_transform_matrix(self, xform:'Transform2D'   ) -> None:
    r'''
				Sets a custom local transform for drawing via matrix. Anything drawn afterwards will be transformed by this.
			'''

    assert(not xform is None)
    assert isinstance(xform, Transform2D), 'xform must be Transform2D'







    self._ptr.call_with_return(232,tuple([xform._ptr]))

  @functools.native_method
  def draw_animation_slice(self, animation_length:'float'   , slice_begin:'float'   , slice_end:'float'   , offset:'float' =0.0  ) -> None:
    r'''
				Subsequent drawing commands will be ignored unless they fall within the specified animation slice. This is a faster way to implement animations that loop on background rather than redrawing constantly.
			'''

    assert isinstance(animation_length, (int, float)), 'animation_length must be int or float'
    assert isinstance(slice_begin, (int, float)), 'slice_begin must be int or float'
    assert isinstance(slice_end, (int, float)), 'slice_end must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'










    self._ptr.call_with_return(233,tuple([animation_length, slice_begin, slice_end, offset]))

  @functools.native_method
  def draw_end_animation(self) -> None:
    r'''
				After submitting all animations slices via `draw_animation_slice`, this function can be used to revert drawing to its default state (all subsequent drawing commands will be visible). If you don't care about this particular use case, usage of this function after submitting the slices is not required.
			'''




    self._ptr.call_with_return(234,tuple([]))

  @functools.native_method
  def get_transform(self) -> typing.Union['Transform2D']:
    r'''
				Returns the transform matrix of this `CanvasItem`.
			'''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(235,tuple([]))
    return _ret


  @functools.native_method
  def get_global_transform(self) -> typing.Union['Transform2D']:
    r'''
				Returns the global transform matrix of this item, i.e. the combined transform up to the topmost `CanvasItem` node. The topmost item is a `CanvasItem` that either has no parent, has non-`CanvasItem` parent or it has `top_level` enabled.
			'''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(236,tuple([]))
    return _ret


  @functools.native_method
  def get_global_transform_with_canvas(self) -> typing.Union['Transform2D']:
    r'''
				Returns the transform from the local coordinate system of this `CanvasItem` to the `Viewport`s coordinate system.
			'''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(237,tuple([]))
    return _ret


  @functools.native_method
  def get_viewport_transform(self) -> typing.Union['Transform2D']:
    r'''
				Returns the transform of this node, converted from its registered canvas's coordinate system to its viewport embedder's coordinate system. See also `Viewport.get_final_transform` and `Node.get_viewport`.
			'''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(238,tuple([]))
    return _ret


  @functools.native_method
  def get_viewport_rect(self) -> typing.Union['Rect2']:
    r'''
				Returns this node's viewport boundaries as a `Rect2`. See also `Node.get_viewport`.
			'''




    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(239,tuple([]))
    return _ret


  @functools.native_method
  def get_canvas_transform(self) -> typing.Union['Transform2D']:
    r'''
				Returns the transform of this node, converted from its registered canvas's coordinate system to its viewport's coordinate system. See also `Node.get_viewport`.
			'''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(240,tuple([]))
    return _ret


  @functools.native_method
  def get_screen_transform(self) -> typing.Union['Transform2D']:
    r'''
				Returns the transform of this `CanvasItem` in global screen coordinates (i.e. taking window position into account). Mostly useful for editor plugins.
				Equivalent to `get_global_transform_with_canvas` if the window is embedded (see `Viewport.gui_embed_subwindows`).
			'''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(241,tuple([]))
    return _ret


  @functools.native_method
  def get_local_mouse_position(self) -> typing.Union['Vector2']:
    r'''
				Returns the mouse's position in this `CanvasItem` using the local coordinate system of this `CanvasItem`.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(242,tuple([]))
    return _ret


  @functools.native_method
  def get_global_mouse_position(self) -> typing.Union['Vector2']:
    r'''
				Returns mouse cursor's global position relative to the `CanvasLayer` that contains this node.
				**Note:** For screen-space coordinates (e.g. when using a non-embedded `Popup`), you can use `DisplayServer.mouse_get_position`.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(243,tuple([]))
    return _ret


  @functools.native_method
  def get_canvas(self) -> typing.Union['RID']:
    r'''
				Returns the `RID` of the `World2D` canvas where this node is registered to, used by the `RenderingServer`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(244,tuple([]))
    return _ret


  @functools.native_method
  def get_canvas_layer_node(self) -> typing.Union['py4godot_canvaslayer.CanvasLayer','py4godot_parallaxbackground.ParallaxBackground']:
    r'''
				Returns the `CanvasLayer` that contains this node, or `null` if the node is not in any `CanvasLayer`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: CanvasLayer
    _ret._ptr = self._ptr.call_with_return(245,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_world_2d(self) -> typing.Union['py4godot_world2d.World2D']:
    r'''
				Returns the `World2D` this node is registered to.
				Usually, this is the same as this node's viewport (see `Node.get_viewport` and `Viewport.find_world_2d`).
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: World2D
    _ret._ptr = self._ptr.call_with_return(246,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_material(self, material:'py4godot_material.Material'   ) -> None:
    r''''''

    assert(not material is None)
    assert isinstance(material, get_class('Material')), 'material must be Material'


    self.py__material = material






    self._ptr.call_with_return(247,tuple([material._ptr]))

  @functools.native_method
  def get_material(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Material
    _ret._ptr = self._ptr.call_with_return(248,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_instance_shader_parameter(self, name:'object'   , value:'object'   ) -> None:
    r'''
				Set the value of a shader uniform for this instance only (`url=$DOCS_URL/tutorials/shaders/shader_reference/shading_language.html#per-instance-uniforms`per-instance uniform`/url`). See also `ShaderMaterial.set_shader_parameter` to assign a uniform on all instances using the same `ShaderMaterial`.
				**Note:** For a shader uniform to be assignable on a per-instance basis, it _must_ be defined with `instance uniform ...` rather than `uniform ...` in the shader code.
				**Note:** `name` is case-sensitive and must match the name of the uniform in the code exactly (not the capitalized name in the inspector).
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(249,tuple([py_stringname_name._ptr, value]))

  @functools.native_method
  def get_instance_shader_parameter(self, name:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Get the value of a shader parameter as set on this instance.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = None
    _ret = self._ptr.call_with_return(250,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def set_use_parent_material(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__use_parent_material = enable






    self._ptr.call_with_return(251,tuple([enable]))

  @functools.native_method
  def get_use_parent_material(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(252,tuple([]))

    return _ret


  @functools.native_method
  def set_notify_local_transform(self, enable:'bool'   ) -> None:
    r'''
				If `true`, the node will receive `constant NOTIFICATION_LOCAL_TRANSFORM_CHANGED` whenever its local transform changes.
				**Note:** Many canvas items such as `Bone2D` or `CollisionShape2D` automatically enable this in order to function correctly.
			'''

    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(253,tuple([enable]))

  @functools.native_method
  def is_local_transform_notification_enabled(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the node receives `constant NOTIFICATION_LOCAL_TRANSFORM_CHANGED` whenever its local transform changes. This is enabled with `set_notify_local_transform`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(254,tuple([]))
    return _ret


  @functools.native_method
  def set_notify_transform(self, enable:'bool'   ) -> None:
    r'''
				If `true`, the node will receive `constant NOTIFICATION_TRANSFORM_CHANGED` whenever its global transform changes.
				**Note:** Many canvas items such as `Camera2D` or `Light2D` automatically enable this in order to function correctly.
			'''

    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(255,tuple([enable]))

  @functools.native_method
  def is_transform_notification_enabled(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the node receives `constant NOTIFICATION_TRANSFORM_CHANGED` whenever its global transform changes. This is enabled with `set_notify_transform`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(256,tuple([]))
    return _ret


  @functools.native_method
  def force_update_transform(self) -> None:
    r'''
				Forces the node's transform to update. Fails if the node is not inside the tree. See also `get_transform`.
				**Note:** For performance reasons, transform changes are usually accumulated and applied _once_ at the end of the frame. The update propagates through `CanvasItem` children, as well. Therefore, use this method only when you need an up-to-date transform (such as during physics operations).
			'''




    self._ptr.call_with_return(257,tuple([]))

  @functools.native_method
  def make_canvas_position_local(self, viewport_point:'Vector2'   ) -> typing.Union['Vector2']:
    r'''
				Transforms `viewport_point` from the viewport's coordinates to this node's local coordinates.
				For the opposite operation, use `get_global_transform_with_canvas`.
				```gdscript
				var viewport_point = get_global_transform_with_canvas() * local_point
				```
			'''

    assert(not viewport_point is None)
    assert isinstance(viewport_point, Vector2), 'viewport_point must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(258,tuple([viewport_point._ptr]))
    return _ret


  @functools.native_method
  def make_input_local(self, event:'py4godot_inputevent.InputEvent'   ) -> typing.Any:
    r'''
				Returns a copy of the given `event` with its coordinates converted from global space to this `CanvasItem`'s local space. If not possible, returns the same `InputEvent` unchanged.
			'''

    assert(not event is None)
    assert isinstance(event, get_class('InputEvent')), 'event must be InputEvent'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: InputEvent
    _ret._ptr = self._ptr.call_with_return(259,tuple([event._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_visibility_layer(self, layer:'int'   ) -> None:
    r''''''

    assert isinstance(layer, (int, float)), 'layer must be int or float'


    self.py__visibility_layer = layer






    self._ptr.call_with_return(260,tuple([layer]))

  @functools.native_method
  def get_visibility_layer(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(261,tuple([]))

    return _ret


  @functools.native_method
  def set_visibility_layer_bit(self, layer:'int'   , enabled:'bool'   ) -> None:
    r'''
				Set/clear individual bits on the rendering visibility layer. This simplifies editing this `CanvasItem`'s visibility layer.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(262,tuple([layer, enabled]))

  @functools.native_method
  def get_visibility_layer_bit(self, layer:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the layer at the given index is set in `visibility_layer`.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(263,tuple([layer]))
    return _ret


  @functools.native_method
  def set_texture_filter(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__texture_filter = mode






    self._ptr.call_with_return(264,tuple([mode]))

  @functools.native_method
  def get_texture_filter(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(265,tuple([]))

    return _ret


  @functools.native_method
  def set_texture_repeat(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__texture_repeat = mode






    self._ptr.call_with_return(266,tuple([mode]))

  @functools.native_method
  def get_texture_repeat(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(267,tuple([]))

    return _ret


  @functools.native_method
  def set_clip_children_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__clip_children = mode






    self._ptr.call_with_return(268,tuple([mode]))

  @functools.native_method
  def get_clip_children_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(269,tuple([]))

    return _ret



register_cast_function('CanvasItem', CanvasItem.cast)
register_class('CanvasItem', CanvasItem)
