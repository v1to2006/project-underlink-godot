# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.OpenXRInterface as py4godot_openxrinterface 
  import py4godot.classes.WebXRInterface as py4godot_webxrinterface 
  import py4godot.classes.MobileVRInterface as py4godot_mobilevrinterface 
import py4godot.classes.XRInterface as py4godot_xrinterface 
from py4godot.wrappers.wrappers import CPPXRInterfaceExtensionWrapper


class XRInterfaceExtension(py4godot_xrinterface.XRInterface):
  r'''
		External XR interface plugins should inherit from this class.
	'''

  @staticmethod
  def constructor():
    class_ = XRInterfaceExtension.construct_without_init()
    class_._ptr = constructor(1022,0, ())
    return class_
  @staticmethod
  def new():
    class_ = XRInterfaceExtension.construct_without_init()
    class_._ptr = constructor(1022,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPXRInterfaceExtensionWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(1022,0, ())


  def generate_wrapper(self):
    return CPPXRInterfaceExtensionWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = XRInterfaceExtension.__new__(XRInterfaceExtension)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'XRInterfaceExtension'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(118, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = XRInterfaceExtension.construct_without_init()
    cls._ptr = CPPXRInterfaceExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = XRInterfaceExtension.construct_without_init()
    cls._ptr = CPPXRInterfaceExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _get_name(self) -> typing.Union['StringName']:
    r'''
				Returns the name of this interface.
			'''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([]))
    return str(_ret)


  @functools.native_method
  def _get_capabilities(self) -> typing.Union[int]:
    r'''
				Returns the capabilities of this interface.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([]))
    return _ret


  @functools.native_method
  def _is_initialized(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this interface has been initialized.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(83,tuple([]))
    return _ret


  @functools.native_method
  def _initialize(self) -> typing.Union[bool]:
    r'''
				Initializes the interface, returns `true` on success.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([]))
    return _ret


  @functools.native_method
  def _uninitialize(self) -> None:
    r'''
				Uninitialize the interface.
			'''




    self._ptr.call_with_return(85,tuple([]))

  @functools.native_method
  def _get_system_info(self) -> typing.Union['Dictionary']:
    r'''
				Returns a `Dictionary` with system information related to this interface.
			'''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def _supports_play_area_mode(self, mode:'int'  ) -> typing.Union[bool]:
    r'''
				Returns `true` if this interface supports this play area mode.
			'''

    assert isinstance(mode, (int, float)), 'mode must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(87,tuple([mode]))
    return _ret


  @functools.native_method
  def _get_play_area_mode(self) -> typing.Union[int]:
    r'''
				Returns the play area mode that sets up our play area.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(88,tuple([]))
    return _ret


  @functools.native_method
  def _set_play_area_mode(self, mode:'int'  ) -> typing.Union[bool]:
    r'''
				Set the play area mode for this interface.
			'''

    assert isinstance(mode, (int, float)), 'mode must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([mode]))
    return _ret


  @functools.native_method
  def _get_play_area(self) -> typing.Union['PackedVector3Array']:
    r'''
				Returns a `PackedVector3Array` that represents the play areas boundaries (if applicable).
			'''




    _ret = PackedVector3Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(90,tuple([]))
    return _ret


  @functools.native_method
  def _get_render_target_size(self) -> typing.Union['Vector2']:
    r'''
				Returns the size of our render target for this interface, this overrides the size of the `Viewport` marked as the xr viewport.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([]))
    return _ret


  @functools.native_method
  def _get_view_count(self) -> typing.Union[int]:
    r'''
				Returns the number of views this interface requires, 1 for mono, 2 for stereoscopic.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([]))
    return _ret


  @functools.native_method
  def _get_camera_transform(self) -> typing.Union['Transform3D']:
    r'''
				Returns the `Transform3D` that positions the `XRCamera3D` in the world.
			'''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(93,tuple([]))
    return _ret


  @functools.native_method
  def _get_transform_for_view(self, view:'int'   , cam_transform:'Transform3D'   ) -> typing.Union['Transform3D']:
    r'''
				Returns a `Transform3D` for a given view.
			'''

    assert isinstance(view, (int, float)), 'view must be int or float'
    assert(not cam_transform is None)
    assert isinstance(cam_transform, Transform3D), 'cam_transform must be Transform3D'








    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(94,tuple([view, cam_transform._ptr]))
    return _ret


  @functools.native_method
  def _get_projection_for_view(self, view:'int'   , aspect:'float'   , z_near:'float'   , z_far:'float'   ) -> typing.Union['PackedFloat64Array']:
    r'''
				Returns the projection matrix for the given view as a `PackedFloat64Array`.
			'''

    assert isinstance(view, (int, float)), 'view must be int or float'
    assert isinstance(aspect, (int, float)), 'aspect must be int or float'
    assert isinstance(z_near, (int, float)), 'z_near must be int or float'
    assert isinstance(z_far, (int, float)), 'z_far must be int or float'










    _ret = PackedFloat64Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(95,tuple([view, aspect, z_near, z_far]))
    return _ret


  @functools.native_method
  def _get_vrs_texture(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([]))
    return _ret


  @functools.native_method
  def _get_vrs_texture_format(self) -> typing.Union[int]:
    r'''
				Returns the format of the texture returned by `_get_vrs_texture`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(97,tuple([]))
    return _ret


  @functools.native_method
  def _process(self) -> None:
    r'''
				Called if this `XRInterfaceExtension` is active before our physics and game process is called. Most XR interfaces will update its `XRPositionalTracker`s at this point in time.
			'''




    self._ptr.call_with_return(98,tuple([]))

  @functools.native_method
  def _pre_render(self) -> None:
    r'''
				Called if this `XRInterfaceExtension` is active before rendering starts. Most XR interfaces will sync tracking at this point in time.
			'''




    self._ptr.call_with_return(99,tuple([]))

  @functools.native_method
  def _pre_draw_viewport(self, render_target:'RID'   ) -> typing.Union[bool]:
    r'''
				Called if this is our primary `XRInterfaceExtension` before we start processing a `Viewport` for every active XR `Viewport`, returns `true` if that viewport should be rendered. An XR interface may return `false` if the user has taken off their headset and we can pause rendering.
			'''

    assert(not render_target is None)
    assert isinstance(render_target, RID), 'render_target must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([render_target._ptr]))
    return _ret


  @functools.native_method
  def _post_draw_viewport(self, render_target:'RID'   , screen_rect:'Rect2'   ) -> None:
    r'''
				Called after the XR `Viewport` draw logic has completed.
			'''

    assert(not render_target is None)
    assert isinstance(render_target, RID), 'render_target must be RID'
    assert(not screen_rect is None)
    assert isinstance(screen_rect, Rect2), 'screen_rect must be Rect2'








    self._ptr.call_with_return(101,tuple([render_target._ptr, screen_rect._ptr]))

  @functools.native_method
  def _end_frame(self) -> None:
    r'''
				Called if interface is active and queues have been submitted.
			'''




    self._ptr.call_with_return(102,tuple([]))

  @functools.native_method
  def _get_suggested_tracker_names(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns a `PackedStringArray` with tracker names configured by this interface. Note that user configuration can override this list.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(103,tuple([]))
    return _ret


  @functools.native_method
  def _get_suggested_pose_names(self, tracker_name:'object'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns a `PackedStringArray` with pose names configured by this interface. Note that user configuration can override this list.
			'''

    assert(not tracker_name is None)
    assert isinstance(tracker_name, (str, StringName)), 'tracker_name must be str or StringName'





    assert(isinstance(tracker_name, (str, StringName)))
    py_stringname_tracker_name = tracker_name if isinstance(tracker_name, StringName) else c_utils.py_string_to_string_name(tracker_name)

    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(104,tuple([py_stringname_tracker_name._ptr]))
    return _ret


  @functools.native_method
  def _get_tracking_status(self) -> typing.Union[int]:
    r'''
				Returns the current status of our tracking.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(105,tuple([]))
    return _ret


  @functools.native_method
  def _trigger_haptic_pulse(self, action_name:'str'   , tracker_name:'object'   , frequency:'float'   , amplitude:'float'   , duration_sec:'float'   , delay_sec:'float'   ) -> None:
    r'''
				Triggers a haptic pulse to be emitted on the specified tracker.
			'''

    assert(not action_name is None)
    assert isinstance(action_name, (str, String)), 'action_name must be str or String'
    assert(not tracker_name is None)
    assert isinstance(tracker_name, (str, StringName)), 'tracker_name must be str or StringName'
    assert isinstance(frequency, (int, float)), 'frequency must be int or float'
    assert isinstance(amplitude, (int, float)), 'amplitude must be int or float'
    assert isinstance(duration_sec, (int, float)), 'duration_sec must be int or float'
    assert isinstance(delay_sec, (int, float)), 'delay_sec must be int or float'





    assert(isinstance(action_name, (str, String)))
    py_string_action_name = action_name if isinstance(action_name, StringName) else c_utils.py_string_to_string(action_name)
    assert(isinstance(tracker_name, (str, StringName)))
    py_stringname_tracker_name = tracker_name if isinstance(tracker_name, StringName) else c_utils.py_string_to_string_name(tracker_name)





    self._ptr.call_with_return(106,tuple([py_string_action_name._ptr, py_stringname_tracker_name._ptr, frequency, amplitude, duration_sec, delay_sec]))

  @functools.native_method
  def _get_anchor_detection_is_enabled(self) -> typing.Union[bool]:
    r'''
				Return `true` if anchor detection is enabled for this interface.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(107,tuple([]))
    return _ret


  @functools.native_method
  def _set_anchor_detection_is_enabled(self, enabled:'bool'   ) -> None:
    r'''
				Enables anchor detection on this interface if supported.
			'''

    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(108,tuple([enabled]))

  @functools.native_method
  def _get_camera_feed_id(self) -> typing.Union[int]:
    r'''
				Returns the camera feed ID for the `CameraFeed` registered with the `CameraServer` that should be presented as the background on an AR capable device (if applicable).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(109,tuple([]))
    return _ret


  @functools.native_method
  def _get_color_texture(self) -> typing.Union['RID']:
    r'''
				Return color texture into which to render (if applicable).
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(110,tuple([]))
    return _ret


  @functools.native_method
  def _get_depth_texture(self) -> typing.Union['RID']:
    r'''
				Return depth texture into which to render (if applicable).
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(111,tuple([]))
    return _ret


  @functools.native_method
  def _get_velocity_texture(self) -> typing.Union['RID']:
    r'''
				Return velocity texture into which to render (if applicable).
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(112,tuple([]))
    return _ret


  @functools.native_method
  def get_color_texture(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(113,tuple([]))
    return _ret


  @functools.native_method
  def get_depth_texture(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(114,tuple([]))
    return _ret


  @functools.native_method
  def get_velocity_texture(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(115,tuple([]))
    return _ret


  @functools.native_method
  def add_blit(self, render_target:'RID'   , src_rect:'Rect2'   , dst_rect:'Rect2i'   , use_layer:'bool'   , layer:'int'   , apply_lens_distortion:'bool'   , eye_center:'Vector2'   , k1:'float'   , k2:'float'   , upscale:'float'   , aspect_ratio:'float'   ) -> None:
    r'''
				Blits our render results to screen optionally applying lens distortion. This can only be called while processing `_commit_views`.
			'''

    assert(not render_target is None)
    assert isinstance(render_target, RID), 'render_target must be RID'
    assert(not src_rect is None)
    assert isinstance(src_rect, Rect2), 'src_rect must be Rect2'
    assert(not dst_rect is None)
    assert isinstance(dst_rect, Rect2i), 'dst_rect must be Rect2i'
    assert isinstance(use_layer, bool), 'use_layer must be bool'
    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(apply_lens_distortion, bool), 'apply_lens_distortion must be bool'
    assert(not eye_center is None)
    assert isinstance(eye_center, Vector2), 'eye_center must be Vector2'
    assert isinstance(k1, (int, float)), 'k1 must be int or float'
    assert isinstance(k2, (int, float)), 'k2 must be int or float'
    assert isinstance(upscale, (int, float)), 'upscale must be int or float'
    assert isinstance(aspect_ratio, (int, float)), 'aspect_ratio must be int or float'

















    self._ptr.call_with_return(116,tuple([render_target._ptr, src_rect._ptr, dst_rect._ptr, use_layer, layer, apply_lens_distortion, eye_center._ptr, k1, k2, upscale, aspect_ratio]))

  @functools.native_method
  def get_render_target_texture(self, render_target:'RID'   ) -> typing.Union['RID']:
    r'''
				Returns a valid `RID` for a texture to which we should render the current frame if supported by the interface.
			'''

    assert(not render_target is None)
    assert isinstance(render_target, RID), 'render_target must be RID'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(117,tuple([render_target._ptr]))
    return _ret



register_cast_function('XRInterfaceExtension', XRInterfaceExtension.cast)
register_class('XRInterfaceExtension', XRInterfaceExtension)
