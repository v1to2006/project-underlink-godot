# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.LabelSettings as py4godot_labelsettings 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.VisualShaderNodeIntParameter as py4godot_visualshadernodeintparameter 
  import py4godot.classes.BoxShape3D as py4godot_boxshape3d 
  import py4godot.classes.VisualShaderNodeParameterRef as py4godot_visualshadernodeparameterref 
  import py4godot.classes.VisualShaderNodeFloatFunc as py4godot_visualshadernodefloatfunc 
  import py4godot.classes.AudioEffectFilter as py4godot_audioeffectfilter 
  import py4godot.classes.AnimationNode as py4godot_animationnode 
  import py4godot.classes.AudioEffectBandLimitFilter as py4godot_audioeffectbandlimitfilter 
  import py4godot.classes.AudioStreamPlaylist as py4godot_audiostreamplaylist 
  import py4godot.classes.AudioStream as py4godot_audiostream 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.CryptoKey as py4godot_cryptokey 
  import py4godot.classes.CameraAttributes as py4godot_cameraattributes 
  import py4godot.classes.Compositor as py4godot_compositor 
  import py4godot.classes.FontFile as py4godot_fontfile 
  import py4godot.classes.VisualShaderNodeRandomRange as py4godot_visualshadernoderandomrange 
  import py4godot.classes.BaseMaterial3D as py4godot_basematerial3d 
  import py4godot.classes.GLTFLight as py4godot_gltflight 
  import py4godot.classes.ColorPalette as py4godot_colorpalette 
  import py4godot.classes.AnimationNodeStateMachine as py4godot_animationnodestatemachine 
  import py4godot.classes.GLTFTextureSampler as py4godot_gltftexturesampler 
  import py4godot.classes.ORMMaterial3D as py4godot_ormmaterial3d 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.InputEventFromWindow as py4godot_inputeventfromwindow 
  import py4godot.classes.BitMap as py4godot_bitmap 
  import py4godot.classes.StyleBoxLine as py4godot_styleboxline 
  import py4godot.classes.VisualShaderNodeFrame as py4godot_visualshadernodeframe 
  import py4godot.classes.PhysicsMaterial as py4godot_physicsmaterial 
  import py4godot.classes.VisualShaderNodeConstant as py4godot_visualshadernodeconstant 
  import py4godot.classes.VisualShaderNodeParticleEmitter as py4godot_visualshadernodeparticleemitter 
  import py4godot.classes.Mesh as py4godot_mesh 
  import py4godot.classes.VisualShaderNodeCompare as py4godot_visualshadernodecompare 
  import py4godot.classes.AnimationNodeOutput as py4godot_animationnodeoutput 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.VisualShaderNodeMix as py4godot_visualshadernodemix 
  import py4godot.classes.GLTFDocumentExtension as py4godot_gltfdocumentextension 
  import py4godot.classes.AudioStreamSynchronized as py4godot_audiostreamsynchronized 
  import py4godot.classes.EditorNode3DGizmoPlugin as py4godot_editornode3dgizmoplugin 
  import py4godot.classes.TextureLayeredRD as py4godot_texturelayeredrd 
  import py4godot.classes.VisualShaderNodeVectorCompose as py4godot_visualshadernodevectorcompose 
  import py4godot.classes.Script as py4godot_script 
  import py4godot.classes.Translation as py4godot_translation 
  import py4godot.classes.FogMaterial as py4godot_fogmaterial 
  import py4godot.classes.Noise as py4godot_noise 
  import py4godot.classes.Curve2D as py4godot_curve2d 
  import py4godot.classes.BoxMesh as py4godot_boxmesh 
  import py4godot.classes.VisualShaderNodeCubemap as py4godot_visualshadernodecubemap 
  import py4godot.classes.InputEventMouseMotion as py4godot_inputeventmousemotion 
  import py4godot.classes.VisualShaderNodeVectorDecompose as py4godot_visualshadernodevectordecompose 
  import py4godot.classes.PointMesh as py4godot_pointmesh 
  import py4godot.classes.VisualShaderNodeTexture2DArray as py4godot_visualshadernodetexture2darray 
  import py4godot.classes.VisualShaderNodeDotProduct as py4godot_visualshadernodedotproduct 
  import py4godot.classes.OpenXRDpadBindingModifier as py4godot_openxrdpadbindingmodifier 
  import py4godot.classes.VisualShaderNodeExpression as py4godot_visualshadernodeexpression 
  import py4godot.classes.NavigationPolygon as py4godot_navigationpolygon 
  import py4godot.classes.SceneReplicationConfig as py4godot_scenereplicationconfig 
  import py4godot.classes.VisualShaderNodeTransformConstant as py4godot_visualshadernodetransformconstant 
  import py4godot.classes.StyleBoxEmpty as py4godot_styleboxempty 
  import py4godot.classes.CameraAttributesPractical as py4godot_cameraattributespractical 
  import py4godot.classes.ScriptExtension as py4godot_scriptextension 
  import py4godot.classes.VisualShaderNodeCustom as py4godot_visualshadernodecustom 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.TextureLayered as py4godot_texturelayered 
  import py4godot.classes.VisualShaderNodeTextureParameter as py4godot_visualshadernodetextureparameter 
  import py4godot.classes.VisualShaderNodeIntConstant as py4godot_visualshadernodeintconstant 
  import py4godot.classes.AnimationLibrary as py4godot_animationlibrary 
  import py4godot.classes.GLTFBufferView as py4godot_gltfbufferview 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.CompressedTexture2DArray as py4godot_compressedtexture2darray 
  import py4godot.classes.PrimitiveMesh as py4godot_primitivemesh 
  import py4godot.classes.Theme as py4godot_theme 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.VisualShaderNodeFloatParameter as py4godot_visualshadernodefloatparameter 
  import py4godot.classes.VisualShaderNodeParameter as py4godot_visualshadernodeparameter 
  import py4godot.classes.InputEventScreenTouch as py4godot_inputeventscreentouch 
  import py4godot.classes.VisualShaderNodeVectorLen as py4godot_visualshadernodevectorlen 
  import py4godot.classes.Curve3D as py4godot_curve3d 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.World3D as py4godot_world3d 
  import py4godot.classes.GLTFDocumentExtensionConvertImporterMesh as py4godot_gltfdocumentextensionconvertimportermesh 
  import py4godot.classes.ImageTextureLayered as py4godot_imagetexturelayered 
  import py4godot.classes.VisualShaderNodeDistanceFade as py4godot_visualshadernodedistancefade 
  import py4godot.classes.AnimationNodeStateMachinePlayback as py4godot_animationnodestatemachineplayback 
  import py4godot.classes.VisualShaderNodeOutput as py4godot_visualshadernodeoutput 
  import py4godot.classes.GLTFNode as py4godot_gltfnode 
  import py4godot.classes.Image as py4godot_image 
  import py4godot.classes.VideoStreamPlayback as py4godot_videostreamplayback 
  import py4godot.classes.VisualShaderNodeUIntOp as py4godot_visualshadernodeuintop 
  import py4godot.classes.InputEventJoypadMotion as py4godot_inputeventjoypadmotion 
  import py4godot.classes.AudioEffectReverb as py4godot_audioeffectreverb 
  import py4godot.classes.VisualShaderNodeSwitch as py4godot_visualshadernodeswitch 
  import py4godot.classes.TileSetAtlasSource as py4godot_tilesetatlassource 
  import py4godot.classes.AnimationNodeBlend2 as py4godot_animationnodeblend2 
  import py4godot.classes.AudioEffectLowPassFilter as py4godot_audioeffectlowpassfilter 
  import py4godot.classes.VisualShaderNodeFaceForward as py4godot_visualshadernodefaceforward 
  import py4godot.classes.AudioEffect as py4godot_audioeffect 
  import py4godot.classes.VisualShaderNodeTexture as py4godot_visualshadernodetexture 
  import py4godot.classes.AnimationNodeBlendSpace1D as py4godot_animationnodeblendspace1d 
  import py4godot.classes.InputEvent as py4godot_inputevent 
  import py4godot.classes.SkeletonModification2DStackHolder as py4godot_skeletonmodification2dstackholder 
  import py4godot.classes.TextMesh as py4godot_textmesh 
  import py4godot.classes.EditorSettings as py4godot_editorsettings 
  import py4godot.classes.TileSet as py4godot_tileset 
  import py4godot.classes.AnimationNodeBlendSpace2D as py4godot_animationnodeblendspace2d 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.Texture2DArrayRD as py4godot_texture2darrayrd 
  import py4godot.classes.CubemapArray as py4godot_cubemaparray 
  import py4godot.classes.AudioStreamWAV as py4godot_audiostreamwav 
  import py4godot.classes.AudioEffectSpectrumAnalyzer as py4godot_audioeffectspectrumanalyzer 
  import py4godot.classes.Texture as py4godot_texture 
  import py4godot.classes.AudioEffectChorus as py4godot_audioeffectchorus 
  import py4godot.classes.VisualShaderNodeColorConstant as py4godot_visualshadernodecolorconstant 
  import py4godot.classes.VoxelGIData as py4godot_voxelgidata 
  import py4godot.classes.GLTFState as py4godot_gltfstate 
  import py4godot.classes.OpenXRActionSet as py4godot_openxractionset 
  import py4godot.classes.FontVariation as py4godot_fontvariation 
  import py4godot.classes.ImporterMesh as py4godot_importermesh 
  import py4godot.classes.VisualShaderNodeResizableBase as py4godot_visualshadernoderesizablebase 
  import py4godot.classes.SkeletonModification2D as py4godot_skeletonmodification2d 
  import py4godot.classes.TileMapPattern as py4godot_tilemappattern 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.AudioEffectHighPassFilter as py4godot_audioeffecthighpassfilter 
  import py4godot.classes.VisualShaderNodeParticleAccelerator as py4godot_visualshadernodeparticleaccelerator 
  import py4godot.classes.SeparationRayShape2D as py4godot_separationrayshape2d 
  import py4godot.classes.VisualShaderNodeFloatOp as py4godot_visualshadernodefloatop 
  import py4godot.classes.AudioEffectDelay as py4godot_audioeffectdelay 
  import py4godot.classes.InputEventMIDI as py4godot_inputeventmidi 
  import py4godot.classes.PrismMesh as py4godot_prismmesh 
  import py4godot.classes.InputEventWithModifiers as py4godot_inputeventwithmodifiers 
  import py4godot.classes.VisualShaderNodeVec3Constant as py4godot_visualshadernodevec3constant 
  import py4godot.classes.ArrayMesh as py4godot_arraymesh 
  import py4godot.classes.OpenXRAnalogThresholdModifier as py4godot_openxranalogthresholdmodifier 
  import py4godot.classes.VisualShaderNodeTextureSDF as py4godot_visualshadernodetexturesdf 
  import py4godot.classes.CompressedTextureLayered as py4godot_compressedtexturelayered 
  import py4godot.classes.InputEventGesture as py4godot_inputeventgesture 
  import py4godot.classes.VisualShaderNodeColorFunc as py4godot_visualshadernodecolorfunc 
  import py4godot.classes.VisualShaderNodeParticleConeVelocity as py4godot_visualshadernodeparticleconevelocity 
  import py4godot.classes.VisualShaderNodeDeterminant as py4godot_visualshadernodedeterminant 
  import py4godot.classes.PolygonOccluder3D as py4godot_polygonoccluder3d 
  import py4godot.classes.InputEventScreenDrag as py4godot_inputeventscreendrag 
  import py4godot.classes.AnimationNodeTimeScale as py4godot_animationnodetimescale 
  import py4godot.classes.VisualShaderNode as py4godot_visualshadernode 
  import py4godot.classes.OccluderPolygon2D as py4godot_occluderpolygon2d 
  import py4godot.classes.X509Certificate as py4godot_x509certificate 
  import py4godot.classes.VisualShaderNodeTransformParameter as py4godot_visualshadernodetransformparameter 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.VisualShaderNodeParticleMeshEmitter as py4godot_visualshadernodeparticlemeshemitter 
  import py4godot.classes.Environment as py4godot_environment 
  import py4godot.classes.LightmapGIData as py4godot_lightmapgidata 
  import py4godot.classes.AudioEffectPanner as py4godot_audioeffectpanner 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.PlaceholderCubemapArray as py4godot_placeholdercubemaparray 
  import py4godot.classes.SpriteFrames as py4godot_spriteframes 
  import py4godot.classes.AudioEffectLimiter as py4godot_audioeffectlimiter 
  import py4godot.classes.PlaceholderMaterial as py4godot_placeholdermaterial 
  import py4godot.classes.TorusMesh as py4godot_torusmesh 
  import py4godot.classes.MissingResource as py4godot_missingresource 
  import py4godot.classes.HeightMapShape3D as py4godot_heightmapshape3d 
  import py4godot.classes.VisualShaderNodeBillboard as py4godot_visualshadernodebillboard 
  import py4godot.classes.SeparationRayShape3D as py4godot_separationrayshape3d 
  import py4godot.classes.VisualShaderNodeTextureParameterTriplanar as py4godot_visualshadernodetextureparametertriplanar 
  import py4godot.classes.TubeTrailMesh as py4godot_tubetrailmesh 
  import py4godot.classes.FBXDocument as py4godot_fbxdocument 
  import py4godot.classes.OpenXRBindingModifier as py4godot_openxrbindingmodifier 
  import py4godot.classes.VisualShaderNodeTexture2DArrayParameter as py4godot_visualshadernodetexture2darrayparameter 
  import py4godot.classes.AnimationNodeAnimation as py4godot_animationnodeanimation 
  import py4godot.classes.VisualShaderNodeGroupBase as py4godot_visualshadernodegroupbase 
  import py4godot.classes.VisualShaderNodeTransformFunc as py4godot_visualshadernodetransformfunc 
  import py4godot.classes.NoiseTexture3D as py4godot_noisetexture3d 
  import py4godot.classes.AnimationNodeBlend3 as py4godot_animationnodeblend3 
  import py4godot.classes.VisualShaderNodeMultiplyAdd as py4godot_visualshadernodemultiplyadd 
  import py4godot.classes.InputEventMouse as py4godot_inputeventmouse 
  import py4godot.classes.ParticleProcessMaterial as py4godot_particleprocessmaterial 
  import py4godot.classes.VisualShaderNodeTexture3DParameter as py4godot_visualshadernodetexture3dparameter 
  import py4godot.classes.VisualShaderNodeVectorRefract as py4godot_visualshadernodevectorrefract 
  import py4godot.classes.NavigationMesh as py4godot_navigationmesh 
  import py4godot.classes.VisualShaderNodeParticleBoxEmitter as py4godot_visualshadernodeparticleboxemitter 
  import py4godot.classes.VisualShaderNodeParticleRingEmitter as py4godot_visualshadernodeparticleringemitter 
  import py4godot.classes.AnimationNodeTimeSeek as py4godot_animationnodetimeseek 
  import py4godot.classes.SphereMesh as py4godot_spheremesh 
  import py4godot.classes.AudioEffectNotchFilter as py4godot_audioeffectnotchfilter 
  import py4godot.classes.VisualShaderNodeClamp as py4godot_visualshadernodeclamp 
  import py4godot.classes.GLTFMesh as py4godot_gltfmesh 
  import py4godot.classes.OpenXRHapticBase as py4godot_openxrhapticbase 
  import py4godot.classes.NavigationMeshSourceGeometryData3D as py4godot_navigationmeshsourcegeometrydata3d 
  import py4godot.classes.WorldBoundaryShape3D as py4godot_worldboundaryshape3d 
  import py4godot.classes.AudioStreamGenerator as py4godot_audiostreamgenerator 
  import py4godot.classes.CapsuleMesh as py4godot_capsulemesh 
  import py4godot.classes.OpenXRHapticVibration as py4godot_openxrhapticvibration 
  import py4godot.classes.CanvasItemMaterial as py4godot_canvasitemmaterial 
  import py4godot.classes.RDShaderSPIRV as py4godot_rdshaderspirv 
  import py4godot.classes.AnimationNodeAdd3 as py4godot_animationnodeadd3 
  import py4godot.classes.CodeHighlighter as py4godot_codehighlighter 
  import py4godot.classes.VisualShaderNodeDerivativeFunc as py4godot_visualshadernodederivativefunc 
  import py4godot.classes.VisualShaderNodeParticleMultiplyByAxisAngle as py4godot_visualshadernodeparticlemultiplybyaxisangle 
  import py4godot.classes.VisualShaderNodeVec3Parameter as py4godot_visualshadernodevec3parameter 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.OpenXRInteractionProfile as py4godot_openxrinteractionprofile 
  import py4godot.classes.ConcavePolygonShape2D as py4godot_concavepolygonshape2d 
  import py4godot.classes.ImmediateMesh as py4godot_immediatemesh 
  import py4godot.classes.GLTFAccessor as py4godot_gltfaccessor 
  import py4godot.classes.StyleBoxTexture as py4godot_styleboxtexture 
  import py4godot.classes.PolygonPathFinder as py4godot_polygonpathfinder 
  import py4godot.classes.VisualShaderNodeUIntParameter as py4godot_visualshadernodeuintparameter 
  import py4godot.classes.InputEventShortcut as py4godot_inputeventshortcut 
  import py4godot.classes.FastNoiseLite as py4godot_fastnoiselite 
  import py4godot.classes.PackedDataContainer as py4godot_packeddatacontainer 
  import py4godot.classes.SegmentShape2D as py4godot_segmentshape2d 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.VisualShaderNodeInput as py4godot_visualshadernodeinput 
  import py4godot.classes.AnimationNodeExtension as py4godot_animationnodeextension 
  import py4godot.classes.PlaneMesh as py4godot_planemesh 
  import py4godot.classes.RectangleShape2D as py4godot_rectangleshape2d 
  import py4godot.classes.ArrayOccluder3D as py4godot_arrayoccluder3d 
  import py4godot.classes.VisualShaderNodeWorldPositionFromDepth as py4godot_visualshadernodeworldpositionfromdepth 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.VisualShaderNodeVarying as py4godot_visualshadernodevarying 
  import py4godot.classes.VisualShaderNodeVaryingGetter as py4godot_visualshadernodevaryinggetter 
  import py4godot.classes.VisualShaderNodeScreenUVToSDF as py4godot_visualshadernodescreenuvtosdf 
  import py4godot.classes.VisualShaderNodeGlobalExpression as py4godot_visualshadernodeglobalexpression 
  import py4godot.classes.AnimationNodeBlendTree as py4godot_animationnodeblendtree 
  import py4godot.classes.PlaceholderMesh as py4godot_placeholdermesh 
  import py4godot.classes.SkeletonModification2DLookAt as py4godot_skeletonmodification2dlookat 
  import py4godot.classes.ShaderMaterial as py4godot_shadermaterial 
  import py4godot.classes.RichTextEffect as py4godot_richtexteffect 
  import py4godot.classes.VisualShaderNodeProximityFade as py4godot_visualshadernodeproximityfade 
  import py4godot.classes.VisualShaderNodeVectorFunc as py4godot_visualshadernodevectorfunc 
  import py4godot.classes.AudioStreamRandomizer as py4godot_audiostreamrandomizer 
  import py4godot.classes.VisualShaderNodeTexture2DParameter as py4godot_visualshadernodetexture2dparameter 
  import py4godot.classes.GDExtension as py4godot_gdextension 
  import py4godot.classes.QuadOccluder3D as py4godot_quadoccluder3d 
  import py4godot.classes.PanoramaSkyMaterial as py4godot_panoramaskymaterial 
  import py4godot.classes.CircleShape2D as py4godot_circleshape2d 
  import py4godot.classes.CompressedCubemapArray as py4godot_compressedcubemaparray 
  import py4godot.classes.VisualShaderNodeStep as py4godot_visualshadernodestep 
  import py4godot.classes.Shortcut as py4godot_shortcut 
  import py4godot.classes.VisualShaderNodeComment as py4godot_visualshadernodecomment 
  import py4godot.classes.VisualShaderNodeVectorDistance as py4godot_visualshadernodevectordistance 
  import py4godot.classes.GLTFSkeleton as py4godot_gltfskeleton 
  import py4godot.classes.QuadMesh as py4godot_quadmesh 
  import py4godot.classes.InputEventKey as py4godot_inputeventkey 
  import py4godot.classes.OpenXRIPBinding as py4godot_openxripbinding 
  import py4godot.classes.AudioEffectHighShelfFilter as py4godot_audioeffecthighshelffilter 
  import py4godot.classes.GDScript as py4godot_gdscript 
  import py4godot.classes.StyleBoxFlat as py4godot_styleboxflat 
  import py4godot.classes.VisualShaderNodeScreenNormalWorldSpace as py4godot_visualshadernodescreennormalworldspace 
  import py4godot.classes.VisualShaderNodeVaryingSetter as py4godot_visualshadernodevaryingsetter 
  import py4godot.classes.VisualShaderNodeUIntConstant as py4godot_visualshadernodeuintconstant 
  import py4godot.classes.PlaceholderTextureLayered as py4godot_placeholdertexturelayered 
  import py4godot.classes.AudioEffectCompressor as py4godot_audioeffectcompressor 
  import py4godot.classes.VisualShaderNodeVectorBase as py4godot_visualshadernodevectorbase 
  import py4godot.classes.VisualShaderNodeParticleEmit as py4godot_visualshadernodeparticleemit 
  import py4godot.classes.VisualShaderNodeIntOp as py4godot_visualshadernodeintop 
  import py4godot.classes.VisualShaderNodeCurveXYZTexture as py4godot_visualshadernodecurvexyztexture 
  import py4godot.classes.PackedScene as py4godot_packedscene 
  import py4godot.classes.VisualShaderNodeRemap as py4godot_visualshadernoderemap 
  import py4godot.classes.InputEventMouseButton as py4godot_inputeventmousebutton 
  import py4godot.classes.SphereOccluder3D as py4godot_sphereoccluder3d 
  import py4godot.classes.MultiMesh as py4godot_multimesh 
  import py4godot.classes.OggPacketSequence as py4godot_oggpacketsequence 
  import py4godot.classes.AudioBusLayout as py4godot_audiobuslayout 
  import py4godot.classes.ConcavePolygonShape3D as py4godot_concavepolygonshape3d 
  import py4godot.classes.SyntaxHighlighter as py4godot_syntaxhighlighter 
  import py4godot.classes.SkeletonModification2DCCDIK as py4godot_skeletonmodification2dccdik 
  import py4godot.classes.Skin as py4godot_skin 
  import py4godot.classes.AudioStreamOggVorbis as py4godot_audiostreamoggvorbis 
  import py4godot.classes.AudioEffectPitchShift as py4godot_audioeffectpitchshift 
  import py4godot.classes.SphereShape3D as py4godot_sphereshape3d 
  import py4godot.classes.TextureCubemapArrayRD as py4godot_texturecubemaparrayrd 
  import py4godot.classes.VisualShaderNodeIf as py4godot_visualshadernodeif 
  import py4godot.classes.CompositorEffect as py4godot_compositoreffect 
  import py4godot.classes.SkeletonModification2DJiggle as py4godot_skeletonmodification2djiggle 
  import py4godot.classes.GLTFSkin as py4godot_gltfskin 
  import py4godot.classes.EditorSyntaxHighlighter as py4godot_editorsyntaxhighlighter 
  import py4godot.classes.CapsuleShape3D as py4godot_capsuleshape3d 
  import py4godot.classes.AnimationRootNode as py4godot_animationrootnode 
  import py4godot.classes.VisualShaderNodeRotationByAxis as py4godot_visualshadernoderotationbyaxis 
  import py4godot.classes.VisualShaderNodeVec2Parameter as py4godot_visualshadernodevec2parameter 
  import py4godot.classes.VideoStream as py4godot_videostream 
  import py4godot.classes.AnimationNodeOneShot as py4godot_animationnodeoneshot 
  import py4godot.classes.SystemFont as py4godot_systemfont 
  import py4godot.classes.VisualShaderNodeCubemapParameter as py4godot_visualshadernodecubemapparameter 
  import py4godot.classes.MeshLibrary as py4godot_meshlibrary 
  import py4godot.classes.VisualShaderNodeCurveTexture as py4godot_visualshadernodecurvetexture 
  import py4godot.classes.VisualShaderNodeSample3D as py4godot_visualshadernodesample3d 
  import py4godot.classes.AudioEffectStereoEnhance as py4godot_audioeffectstereoenhance 
  import py4godot.classes.GLTFTexture as py4godot_gltftexture 
  import py4godot.classes.AudioEffectLowShelfFilter as py4godot_audioeffectlowshelffilter 
  import py4godot.classes.ShaderInclude as py4godot_shaderinclude 
  import py4godot.classes.SkeletonModification2DPhysicalBones as py4godot_skeletonmodification2dphysicalbones 
  import py4godot.classes.VisualShaderNodeUVPolarCoord as py4godot_visualshadernodeuvpolarcoord 
  import py4godot.classes.AnimationNodeSub2 as py4godot_animationnodesub2 
  import py4godot.classes.PhysicalSkyMaterial as py4godot_physicalskymaterial 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.VisualShaderNodeBooleanParameter as py4godot_visualshadernodebooleanparameter 
  import py4godot.classes.GLTFAnimation as py4godot_gltfanimation 
  import py4godot.classes.AudioStreamMP3 as py4godot_audiostreammp3 
  import py4godot.classes.Shader as py4godot_shader 
  import py4godot.classes.SkeletonProfileHumanoid as py4godot_skeletonprofilehumanoid 
  import py4godot.classes.VisualShaderNodeBooleanConstant as py4godot_visualshadernodebooleanconstant 
  import py4godot.classes.OpenXRActionBindingModifier as py4godot_openxractionbindingmodifier 
  import py4godot.classes.PlaceholderTexture3D as py4godot_placeholdertexture3d 
  import py4godot.classes.SkeletonModification2DTwoBoneIK as py4godot_skeletonmodification2dtwoboneik 
  import py4godot.classes.AudioEffectEQ6 as py4godot_audioeffecteq6 
  import py4godot.classes.ImageTexture3D as py4godot_imagetexture3d 
  import py4godot.classes.WorldBoundaryShape2D as py4godot_worldboundaryshape2d 
  import py4godot.classes.FoldableGroup as py4godot_foldablegroup 
  import py4godot.classes.TextureCubemapRD as py4godot_texturecubemaprd 
  import py4godot.classes.Texture3D as py4godot_texture3d 
  import py4godot.classes.Texture2DArray as py4godot_texture2darray 
  import py4godot.classes.CapsuleShape2D as py4godot_capsuleshape2d 
  import py4godot.classes.VisualShaderNodeIs as py4godot_visualshadernodeis 
  import py4godot.classes.ConvexPolygonShape3D as py4godot_convexpolygonshape3d 
  import py4godot.classes.VisualShaderNodeSmoothStep as py4godot_visualshadernodesmoothstep 
  import py4godot.classes.Gradient as py4godot_gradient 
  import py4godot.classes.AudioEffectPhaser as py4godot_audioeffectphaser 
  import py4godot.classes.VisualShaderNodeParticleSphereEmitter as py4godot_visualshadernodeparticlesphereemitter 
  import py4godot.classes.AudioEffectEQ21 as py4godot_audioeffecteq21 
  import py4godot.classes.OpenXRAction as py4godot_openxraction 
  import py4godot.classes.ProceduralSkyMaterial as py4godot_proceduralskymaterial 
  import py4godot.classes.AudioEffectDistortion as py4godot_audioeffectdistortion 
  import py4godot.classes.BoneMap as py4godot_bonemap 
  import py4godot.classes.VisualShaderNodeParticleOutput as py4godot_visualshadernodeparticleoutput 
  import py4godot.classes.AudioEffectHardLimiter as py4godot_audioeffecthardlimiter 
  import py4godot.classes.VisualShaderNodeVec2Constant as py4godot_visualshadernodevec2constant 
  import py4godot.classes.GDScriptSyntaxHighlighter as py4godot_gdscriptsyntaxhighlighter 
  import py4godot.classes.AudioEffectRecord as py4godot_audioeffectrecord 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.VisualShaderNodeReroute as py4godot_visualshadernodereroute 
  import py4godot.classes.VisualShaderNodeSDFRaymarch as py4godot_visualshadernodesdfraymarch 
  import py4godot.classes.PlaceholderTexture2DArray as py4godot_placeholdertexture2darray 
  import py4godot.classes.AnimationNodeTransition as py4godot_animationnodetransition 
  import py4godot.classes.Font as py4godot_font 
  import py4godot.classes.Cubemap as py4godot_cubemap 
  import py4godot.classes.StyleBox as py4godot_stylebox 
  import py4godot.classes.OpenXRActionMap as py4godot_openxractionmap 
  import py4godot.classes.OpenXRIPBindingModifier as py4godot_openxripbindingmodifier 
  import py4godot.classes.AudioStreamPolyphonic as py4godot_audiostreampolyphonic 
  import py4godot.classes.VisualShaderNodeUVFunc as py4godot_visualshadernodeuvfunc 
  import py4godot.classes.CameraAttributesPhysical as py4godot_cameraattributesphysical 
  import py4godot.classes.VisualShaderNodeVectorOp as py4godot_visualshadernodevectorop 
  import py4godot.classes.Sky as py4godot_sky 
  import py4godot.classes.VisualShaderNodeFloatConstant as py4godot_visualshadernodefloatconstant 
  import py4godot.classes.CompressedCubemap as py4godot_compressedcubemap 
  import py4godot.classes.World2D as py4godot_world2d 
  import py4godot.classes.CylinderMesh as py4godot_cylindermesh 
  import py4godot.classes.BoxOccluder3D as py4godot_boxoccluder3d 
  import py4godot.classes.VisualShaderNodeVec4Constant as py4godot_visualshadernodevec4constant 
  import py4godot.classes.CompressedTexture3D as py4godot_compressedtexture3d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.TileSetScenesCollectionSource as py4godot_tilesetscenescollectionsource 
  import py4godot.classes.PlaceholderCubemap as py4godot_placeholdercubemap 
  import py4godot.classes.AudioEffectAmplify as py4godot_audioeffectamplify 
  import py4godot.classes.RDShaderFile as py4godot_rdshaderfile 
  import py4godot.classes.AudioEffectEQ10 as py4godot_audioeffecteq10 
  import py4godot.classes.VisualShaderNodeUIntFunc as py4godot_visualshadernodeuintfunc 
  import py4godot.classes.VisualShader as py4godot_visualshader 
  import py4godot.classes.AnimationNodeAdd2 as py4godot_animationnodeadd2 
  import py4godot.classes.VisualShaderNodeFresnel as py4godot_visualshadernodefresnel 
  import py4godot.classes.VideoStreamTheora as py4godot_videostreamtheora 
  import py4godot.classes.Occluder3D as py4godot_occluder3d 
  import py4godot.classes.VisualShaderNodeIntFunc as py4godot_visualshadernodeintfunc 
  import py4godot.classes.AnimationNodeSync as py4godot_animationnodesync 
  import py4godot.classes.InputEventPanGesture as py4godot_inputeventpangesture 
  import py4godot.classes.FBXState as py4godot_fbxstate 
  import py4godot.classes.AudioStreamInteractive as py4godot_audiostreaminteractive 
  import py4godot.classes.Material as py4godot_material 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.Texture3DRD as py4godot_texture3drd 
  import py4godot.classes.ButtonGroup as py4godot_buttongroup 
  import py4godot.classes.AudioStreamMicrophone as py4godot_audiostreammicrophone 
  import py4godot.classes.VisualShaderNodeParticleRandomness as py4godot_visualshadernodeparticlerandomness 
  import py4godot.classes.VisualShaderNodeTransformDecompose as py4godot_visualshadernodetransformdecompose 
  import py4godot.classes.RibbonTrailMesh as py4godot_ribbontrailmesh 
  import py4godot.classes.StandardMaterial3D as py4godot_standardmaterial3d 
  import py4godot.classes.ConvexPolygonShape2D as py4godot_convexpolygonshape2d 
  import py4godot.classes.GLTFCamera as py4godot_gltfcamera 
  import py4godot.classes.InputEventAction as py4godot_inputeventaction 
  import py4godot.classes.VisualShaderNodeTransformOp as py4godot_visualshadernodetransformop 
  import py4godot.classes.InputEventJoypadButton as py4godot_inputeventjoypadbutton 
  import py4godot.classes.VisualShaderNodeSDFToScreenUV as py4godot_visualshadernodesdftoscreenuv 
  import py4godot.classes.GLTFDocument as py4godot_gltfdocument 
  import py4godot.classes.GLTFPhysicsShape as py4godot_gltfphysicsshape 
  import py4godot.classes.Curve as py4godot_curve 
  import py4godot.classes.VisualShaderNodeColorOp as py4godot_visualshadernodecolorop 
  import py4godot.classes.SkeletonModification2DFABRIK as py4godot_skeletonmodification2dfabrik 
  import py4godot.classes.VisualShaderNodeOuterProduct as py4godot_visualshadernodeouterproduct 
  import py4godot.classes.TileSetSource as py4godot_tilesetsource 
  import py4godot.classes.SkeletonModificationStack2D as py4godot_skeletonmodificationstack2d 
  import py4godot.classes.NavigationMeshSourceGeometryData2D as py4godot_navigationmeshsourcegeometrydata2d 
  import py4godot.classes.VisualShaderNodeTransformVecMult as py4godot_visualshadernodetransformvecmult 
  import py4godot.classes.AnimationNodeStateMachineTransition as py4godot_animationnodestatemachinetransition 
  import py4godot.classes.Shape3D as py4godot_shape3d 
  import py4godot.classes.VisualShaderNodeLinearSceneDepth as py4godot_visualshadernodelinearscenedepth 
  import py4godot.classes.SkeletonProfile as py4godot_skeletonprofile 
  import py4godot.classes.CylinderShape3D as py4godot_cylindershape3d 
  import py4godot.classes.VisualShaderNodeColorParameter as py4godot_visualshadernodecolorparameter 
  import py4godot.classes.InputEventMagnifyGesture as py4godot_inputeventmagnifygesture 
  import py4godot.classes.GLTFPhysicsBody as py4godot_gltfphysicsbody 
  import py4godot.classes.AudioEffectBandPassFilter as py4godot_audioeffectbandpassfilter 
  import py4godot.classes.Shape2D as py4godot_shape2d 
  import py4godot.classes.OptimizedTranslation as py4godot_optimizedtranslation 
  import py4godot.classes.AudioEffectCapture as py4godot_audioeffectcapture 
  import py4godot.classes.AudioEffectEQ as py4godot_audioeffecteq 
  import py4godot.classes.GLTFSpecGloss as py4godot_gltfspecgloss 
  import py4godot.classes.JSON as py4godot_json 
  import py4godot.classes.VisualShaderNodeTextureSDFNormal as py4godot_visualshadernodetexturesdfnormal 
  import py4godot.classes.VisualShaderNodeTransformCompose as py4godot_visualshadernodetransformcompose 
  import py4godot.classes.VisualShaderNodeTexture3D as py4godot_visualshadernodetexture3d 
  import py4godot.classes.VisualShaderNodeVec4Parameter as py4godot_visualshadernodevec4parameter 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPAnimationWrapper

class TrackType:
  TYPE_VALUE = 0
  TYPE_POSITION_3D = 1
  TYPE_ROTATION_3D = 2
  TYPE_SCALE_3D = 3
  TYPE_BLEND_SHAPE = 4
  TYPE_METHOD = 5
  TYPE_BEZIER = 6
  TYPE_AUDIO = 7
  TYPE_ANIMATION = 8
class InterpolationType:
  INTERPOLATION_NEAREST = 0
  INTERPOLATION_LINEAR = 1
  INTERPOLATION_CUBIC = 2
  INTERPOLATION_LINEAR_ANGLE = 3
  INTERPOLATION_CUBIC_ANGLE = 4
class UpdateMode:
  UPDATE_CONTINUOUS = 0
  UPDATE_DISCRETE = 1
  UPDATE_CAPTURE = 2
class LoopMode:
  LOOP_NONE = 0
  LOOP_LINEAR = 1
  LOOP_PINGPONG = 2
class LoopedFlag:
  LOOPED_FLAG_NONE = 0
  LOOPED_FLAG_END = 1
  LOOPED_FLAG_START = 2
class FindMode:
  FIND_MODE_NEAREST = 0
  FIND_MODE_APPROX = 1
  FIND_MODE_EXACT = 2


class Animation(py4godot_resource.Resource):
  r'''
		This resource holds data that can be used to animate anything in the engine. Animations are divided into tracks and each track must be linked to a node. The state of that node can be changed through time, by adding timed keys (events) to the track.
		
		```gdscript
		# This creates an animation that makes the node "Enemy" move to the right by
		# 100 pixels in 2.0 seconds.
		var animation = Animation.new()
		var track_index = animation.add_track(Animation.TYPE_VALUE)
		animation.track_set_path(track_index, "Enemy:position:x")
		animation.track_insert_key(track_index, 0.0, 0)
		animation.track_insert_key(track_index, 2.0, 100)
		animation.length = 2.0
		```
		
		
		Animations are just data containers, and must be added to nodes such as an `AnimationPlayer` to be played back. Animation tracks have different types, each with its own set of dedicated methods. Check `enum TrackType` to see available types.
		**Note:** For 3D position/rotation/scale, using the dedicated `constant TYPE_POSITION_3D`, `constant TYPE_ROTATION_3D` and `constant TYPE_SCALE_3D` track types instead of `constant TYPE_VALUE` is recommended for performance reasons.
	'''

  @staticmethod
  def constructor():
    class_ = Animation.construct_without_init()
    class_._ptr = constructor(72,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Animation.construct_without_init()
    class_._ptr = constructor(72,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAnimationWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(72,0, ())


  def generate_wrapper(self):
    return CPPAnimationWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Animation.__new__(Animation)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Animation'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(162, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Animation.construct_without_init()
    cls._ptr = CPPAnimationWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Animation.construct_without_init()
    cls._ptr = CPPAnimationWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def length(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_length()
    return _ret
  @length.setter
  def length(self,  value:'float'):
    self.set_length(value)
  @property
  def loop_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_loop_mode()
    return _ret
  @loop_mode.setter
  def loop_mode(self,  value:'int'):
    self.set_loop_mode(value)
  @property
  def step(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_step()
    return _ret
  @step.setter
  def step(self,  value:'float'):
    self.set_step(value)
  @property
  def capture_included(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_capture_included()
    return _ret
  @functools.native_method
  def add_track(self, type:'int'  , at_position:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a track to the Animation.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(at_position, (int, float)), 'at_position must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(77,tuple([type, at_position]))
    return _ret


  @functools.native_method
  def remove_track(self, track_idx:'int'   ) -> None:
    r'''
				Removes a track by specifying the track index.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'







    self._ptr.call_with_return(78,tuple([track_idx]))

  @functools.native_method
  def get_track_count(self) -> typing.Union[int]:
    r'''
				Returns the amount of tracks in the animation.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(79,tuple([]))
    return _ret


  @functools.native_method
  def track_get_type(self, track_idx:'int'   ) -> typing.Union[int]:
    r'''
				Gets the type of a track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(80,tuple([track_idx]))
    return _ret


  @functools.native_method
  def track_get_path(self, track_idx:'int'   ) -> typing.Union['NodePath']:
    r'''
				Gets the path of a track. For more information on the path format, see `track_set_path`.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'







    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([track_idx]))
    return _ret


  @functools.native_method
  def track_set_path(self, track_idx:'int'   , path:'object'   ) -> None:
    r'''
				Sets the path of a track. Paths must be valid scene-tree paths to a node and must be specified starting from the `AnimationMixer.root_node` that will reproduce the animation. Tracks that control properties or bones must append their name after the path, separated by `":"`.
				For example, `"character/skeleton:ankle"` or `"character/mesh:transform/local"`.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert(not path is None)
    assert isinstance(path, (str, NodePath)), 'path must be str or NodePath'






    assert(isinstance(path, (str, NodePath)))
    py_nodepath_path = path if isinstance(path,NodePath) else NodePath.new2(path)

    self._ptr.call_with_return(82,tuple([track_idx, py_nodepath_path._ptr]))

  @functools.native_method
  def find_track(self, path:'object'   , type:'int'  ) -> typing.Union[int]:
    r'''
				Returns the index of the specified track. If the track is not found, return -1.
			'''

    assert(not path is None)
    assert isinstance(path, (str, NodePath)), 'path must be str or NodePath'
    assert isinstance(type, (int, float)), 'type must be int or float'





    assert(isinstance(path, (str, NodePath)))
    py_nodepath_path = path if isinstance(path,NodePath) else NodePath.new2(path)


    _ret = 0
    _ret = self._ptr.call_with_return(83,tuple([py_nodepath_path._ptr, type]))
    return _ret


  @functools.native_method
  def track_move_up(self, track_idx:'int'   ) -> None:
    r'''
				Moves a track up.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'







    self._ptr.call_with_return(84,tuple([track_idx]))

  @functools.native_method
  def track_move_down(self, track_idx:'int'   ) -> None:
    r'''
				Moves a track down.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'







    self._ptr.call_with_return(85,tuple([track_idx]))

  @functools.native_method
  def track_move_to(self, track_idx:'int'   , to_idx:'int'   ) -> None:
    r'''
				Changes the index position of track `track_idx` to the one defined in `to_idx`.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(to_idx, (int, float)), 'to_idx must be int or float'








    self._ptr.call_with_return(86,tuple([track_idx, to_idx]))

  @functools.native_method
  def track_swap(self, track_idx:'int'   , with_idx:'int'   ) -> None:
    r'''
				Swaps the track `track_idx`'s index position with the track `with_idx`.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(with_idx, (int, float)), 'with_idx must be int or float'








    self._ptr.call_with_return(87,tuple([track_idx, with_idx]))

  @functools.native_method
  def track_set_imported(self, track_idx:'int'   , imported:'bool'   ) -> None:
    r'''
				Sets the given track as imported or not.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(imported, bool), 'imported must be bool'








    self._ptr.call_with_return(88,tuple([track_idx, imported]))

  @functools.native_method
  def track_is_imported(self, track_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given track is imported. Else, return `false`.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([track_idx]))
    return _ret


  @functools.native_method
  def track_set_enabled(self, track_idx:'int'   , enabled:'bool'   ) -> None:
    r'''
				Enables/disables the given track. Tracks are enabled by default.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(90,tuple([track_idx, enabled]))

  @functools.native_method
  def track_is_enabled(self, track_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the track at index `track_idx` is enabled.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(91,tuple([track_idx]))
    return _ret


  @functools.native_method
  def position_track_insert_key(self, track_idx:'int'   , time:'float'   , position:'Vector3'   ) -> typing.Union[int]:
    r'''
				Inserts a key in a given 3D position track. Returns the key index.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time, (int, float)), 'time must be int or float'
    assert(not position is None)
    assert isinstance(position, Vector3), 'position must be Vector3'









    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([track_idx, time, position._ptr]))
    return _ret


  @functools.native_method
  def rotation_track_insert_key(self, track_idx:'int'   , time:'float'   , rotation:'Quaternion'   ) -> typing.Union[int]:
    r'''
				Inserts a key in a given 3D rotation track. Returns the key index.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time, (int, float)), 'time must be int or float'
    assert(not rotation is None)
    assert isinstance(rotation, Quaternion), 'rotation must be Quaternion'









    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([track_idx, time, rotation._ptr]))
    return _ret


  @functools.native_method
  def scale_track_insert_key(self, track_idx:'int'   , time:'float'   , scale:'Vector3'   ) -> typing.Union[int]:
    r'''
				Inserts a key in a given 3D scale track. Returns the key index.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time, (int, float)), 'time must be int or float'
    assert(not scale is None)
    assert isinstance(scale, Vector3), 'scale must be Vector3'









    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([track_idx, time, scale._ptr]))
    return _ret


  @functools.native_method
  def blend_shape_track_insert_key(self, track_idx:'int'   , time:'float'   , amount:'float'   ) -> typing.Union[int]:
    r'''
				Inserts a key in a given blend shape track. Returns the key index.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time, (int, float)), 'time must be int or float'
    assert isinstance(amount, (int, float)), 'amount must be int or float'









    _ret = 0
    _ret = self._ptr.call_with_return(95,tuple([track_idx, time, amount]))
    return _ret


  @functools.native_method
  def position_track_interpolate(self, track_idx:'int'   , time_sec:'float'   , backward:'bool' =False  ) -> typing.Union['Vector3']:
    r'''
				Returns the interpolated position value at the given time (in seconds). The `track_idx` must be the index of a 3D position track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time_sec, (int, float)), 'time_sec must be int or float'
    assert isinstance(backward, bool), 'backward must be bool'









    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([track_idx, time_sec, backward]))
    return _ret


  @functools.native_method
  def rotation_track_interpolate(self, track_idx:'int'   , time_sec:'float'   , backward:'bool' =False  ) -> typing.Union['Quaternion']:
    r'''
				Returns the interpolated rotation value at the given time (in seconds). The `track_idx` must be the index of a 3D rotation track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time_sec, (int, float)), 'time_sec must be int or float'
    assert isinstance(backward, bool), 'backward must be bool'









    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(97,tuple([track_idx, time_sec, backward]))
    return _ret


  @functools.native_method
  def scale_track_interpolate(self, track_idx:'int'   , time_sec:'float'   , backward:'bool' =False  ) -> typing.Union['Vector3']:
    r'''
				Returns the interpolated scale value at the given time (in seconds). The `track_idx` must be the index of a 3D scale track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time_sec, (int, float)), 'time_sec must be int or float'
    assert isinstance(backward, bool), 'backward must be bool'









    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(98,tuple([track_idx, time_sec, backward]))
    return _ret


  @functools.native_method
  def blend_shape_track_interpolate(self, track_idx:'int'   , time_sec:'float'   , backward:'bool' =False  ) -> typing.Union[float]:
    r'''
				Returns the interpolated blend shape value at the given time (in seconds). The `track_idx` must be the index of a blend shape track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time_sec, (int, float)), 'time_sec must be int or float'
    assert isinstance(backward, bool), 'backward must be bool'









    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([track_idx, time_sec, backward]))
    return _ret


  @functools.native_method
  def track_insert_key(self, track_idx:'int'   , time:'float'   , key:'object'   , transition:'float' =1  ) -> typing.Union[int]:
    r'''
				Inserts a generic key in a given track. Returns the key index.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time, (int, float)), 'time must be int or float'
    
    assert isinstance(transition, (int, float)), 'transition must be int or float'

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )









    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([track_idx, time, key, transition]))
    return _ret


  @functools.native_method
  def track_remove_key(self, track_idx:'int'   , key_idx:'int'   ) -> None:
    r'''
				Removes a key by index in a given track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'








    self._ptr.call_with_return(101,tuple([track_idx, key_idx]))

  @functools.native_method
  def track_remove_key_at_time(self, track_idx:'int'   , time:'float'   ) -> None:
    r'''
				Removes a key at `time` in a given track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time, (int, float)), 'time must be int or float'








    self._ptr.call_with_return(102,tuple([track_idx, time]))

  @functools.native_method
  def track_set_key_value(self, track_idx:'int'   , key:'int'   , value:'object'   ) -> None:
    r'''
				Sets the value of an existing key.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key, (int, float)), 'key must be int or float'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    self._ptr.call_with_return(103,tuple([track_idx, key, value]))

  @functools.native_method
  def track_set_key_transition(self, track_idx:'int'   , key_idx:'int'   , transition:'float'   ) -> None:
    r'''
				Sets the transition curve (easing) for a specific key (see the built-in math function `@GlobalScope.ease`).
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'
    assert isinstance(transition, (int, float)), 'transition must be int or float'









    self._ptr.call_with_return(104,tuple([track_idx, key_idx, transition]))

  @functools.native_method
  def track_set_key_time(self, track_idx:'int'   , key_idx:'int'   , time:'float'   ) -> None:
    r'''
				Sets the time of an existing key.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'
    assert isinstance(time, (int, float)), 'time must be int or float'









    self._ptr.call_with_return(105,tuple([track_idx, key_idx, time]))

  @functools.native_method
  def track_get_key_transition(self, track_idx:'int'   , key_idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the transition curve (easing) for a specific key (see the built-in math function `@GlobalScope.ease`).
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(106,tuple([track_idx, key_idx]))
    return _ret


  @functools.native_method
  def track_get_key_count(self, track_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the number of keys in a given track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(107,tuple([track_idx]))
    return _ret


  @functools.native_method
  def track_get_key_value(self, track_idx:'int'   , key_idx:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the value of a given key in a given track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(108,tuple([track_idx, key_idx]))
    return _ret


  @functools.native_method
  def track_get_key_time(self, track_idx:'int'   , key_idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the time at which the key is located.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(109,tuple([track_idx, key_idx]))
    return _ret


  @functools.native_method
  def track_find_key(self, track_idx:'int'   , time:'float'   , find_mode:'int'  =0, limit:'bool' =False  , backward:'bool' =False  ) -> typing.Union[int]:
    r'''
				Finds the key index by time in a given track. Optionally, only find it if the approx/exact time is given.
				If `limit` is `true`, it does not return keys outside the animation range.
				If `backward` is `true`, the direction is reversed in methods that rely on one directional processing.
				For example, in case `find_mode` is `constant FIND_MODE_NEAREST`, if there is no key in the current position just after seeked, the first key found is retrieved by searching before the position, but if `backward` is `true`, the first key found is retrieved after the position.
			'''


    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time, (int, float)), 'time must be int or float'
    assert isinstance(find_mode, (int, float)), 'find_mode must be int or float'
    assert isinstance(limit, bool), 'limit must be bool'
    assert isinstance(backward, bool), 'backward must be bool'











    _ret = 0
    _ret = self._ptr.call_with_return(110,tuple([track_idx, time, find_mode, limit, backward]))
    return _ret


  @functools.native_method
  def track_set_interpolation_type(self, track_idx:'int'   , interpolation:'int'  ) -> None:
    r'''
				Sets the interpolation type of a given track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(interpolation, (int, float)), 'interpolation must be int or float'








    self._ptr.call_with_return(111,tuple([track_idx, interpolation]))

  @functools.native_method
  def track_get_interpolation_type(self, track_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the interpolation type of a given track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(112,tuple([track_idx]))
    return _ret


  @functools.native_method
  def track_set_interpolation_loop_wrap(self, track_idx:'int'   , interpolation:'bool'   ) -> None:
    r'''
				If `true`, the track at `track_idx` wraps the interpolation loop.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(interpolation, bool), 'interpolation must be bool'








    self._ptr.call_with_return(113,tuple([track_idx, interpolation]))

  @functools.native_method
  def track_get_interpolation_loop_wrap(self, track_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the track at `track_idx` wraps the interpolation loop. New tracks wrap the interpolation loop by default.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(114,tuple([track_idx]))
    return _ret


  @functools.native_method
  def track_is_compressed(self, track_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the track is compressed, `false` otherwise. See also `compress`.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(115,tuple([track_idx]))
    return _ret


  @functools.native_method
  def value_track_set_update_mode(self, track_idx:'int'   , mode:'int'  ) -> None:
    r'''
				Sets the update mode of a value track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(mode, (int, float)), 'mode must be int or float'








    self._ptr.call_with_return(116,tuple([track_idx, mode]))

  @functools.native_method
  def value_track_get_update_mode(self, track_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the update mode of a value track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(117,tuple([track_idx]))
    return _ret


  @functools.native_method
  def value_track_interpolate(self, track_idx:'int'   , time_sec:'float'   , backward:'bool' =False  ) -> typing.Union[typing.Any]:
    r'''
				Returns the interpolated value at the given time (in seconds). The `track_idx` must be the index of a value track.
				A `backward` mainly affects the direction of key retrieval of the track with `constant UPDATE_DISCRETE` converted by `constant AnimationMixer.ANIMATION_CALLBACK_MODE_DISCRETE_FORCE_CONTINUOUS` to match the result with `track_find_key`.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time_sec, (int, float)), 'time_sec must be int or float'
    assert isinstance(backward, bool), 'backward must be bool'









    _ret = None
    _ret = self._ptr.call_with_return(118,tuple([track_idx, time_sec, backward]))
    return _ret


  @functools.native_method
  def method_track_get_name(self, track_idx:'int'   , key_idx:'int'   ) -> typing.Union['StringName']:
    r'''
				Returns the method name of a method track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'








    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(119,tuple([track_idx, key_idx]))
    return str(_ret)


  @functools.native_method
  def method_track_get_params(self, track_idx:'int'   , key_idx:'int'   ) -> typing.Union['Array']:
    r'''
				Returns the arguments values to be called on a method track for a given key in a given track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'








    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(120,tuple([track_idx, key_idx]))
    return _ret


  @functools.native_method
  def bezier_track_insert_key(self, track_idx:'int'   , time:'float'   , value:'float'   , in_handle:'Vector2' = None  , out_handle:'Vector2' = None  ) -> typing.Union[int]:
    r'''
				Inserts a Bezier Track key at the given `time` in seconds. The `track_idx` must be the index of a Bezier Track.
				`in_handle` is the left-side weight of the added Bezier curve point, `out_handle` is the right-side one, while `value` is the actual value at this point.
			'''
    if in_handle is None:
      in_handle = Vector2.new0()
    if out_handle is None:
      out_handle = Vector2.new0()

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time, (int, float)), 'time must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'











    _ret = 0
    _ret = self._ptr.call_with_return(121,tuple([track_idx, time, value, in_handle._ptr, out_handle._ptr]))
    return _ret


  @functools.native_method
  def bezier_track_set_key_value(self, track_idx:'int'   , key_idx:'int'   , value:'float'   ) -> None:
    r'''
				Sets the value of the key identified by `key_idx` to the given value. The `track_idx` must be the index of a Bezier Track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'









    self._ptr.call_with_return(122,tuple([track_idx, key_idx, value]))

  @functools.native_method
  def bezier_track_set_key_in_handle(self, track_idx:'int'   , key_idx:'int'   , in_handle:'Vector2'   , balanced_value_time_ratio:'float' =1.0  ) -> None:
    r'''
				Sets the in handle of the key identified by `key_idx` to value `in_handle`. The `track_idx` must be the index of a Bezier Track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'
    assert(not in_handle is None)
    assert isinstance(in_handle, Vector2), 'in_handle must be Vector2'
    assert isinstance(balanced_value_time_ratio, (int, float)), 'balanced_value_time_ratio must be int or float'










    self._ptr.call_with_return(123,tuple([track_idx, key_idx, in_handle._ptr, balanced_value_time_ratio]))

  @functools.native_method
  def bezier_track_set_key_out_handle(self, track_idx:'int'   , key_idx:'int'   , out_handle:'Vector2'   , balanced_value_time_ratio:'float' =1.0  ) -> None:
    r'''
				Sets the out handle of the key identified by `key_idx` to value `out_handle`. The `track_idx` must be the index of a Bezier Track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'
    assert(not out_handle is None)
    assert isinstance(out_handle, Vector2), 'out_handle must be Vector2'
    assert isinstance(balanced_value_time_ratio, (int, float)), 'balanced_value_time_ratio must be int or float'










    self._ptr.call_with_return(124,tuple([track_idx, key_idx, out_handle._ptr, balanced_value_time_ratio]))

  @functools.native_method
  def bezier_track_get_key_value(self, track_idx:'int'   , key_idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the value of the key identified by `key_idx`. The `track_idx` must be the index of a Bezier Track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(125,tuple([track_idx, key_idx]))
    return _ret


  @functools.native_method
  def bezier_track_get_key_in_handle(self, track_idx:'int'   , key_idx:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the in handle of the key identified by `key_idx`. The `track_idx` must be the index of a Bezier Track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(126,tuple([track_idx, key_idx]))
    return _ret


  @functools.native_method
  def bezier_track_get_key_out_handle(self, track_idx:'int'   , key_idx:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the out handle of the key identified by `key_idx`. The `track_idx` must be the index of a Bezier Track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(127,tuple([track_idx, key_idx]))
    return _ret


  @functools.native_method
  def bezier_track_interpolate(self, track_idx:'int'   , time:'float'   ) -> typing.Union[float]:
    r'''
				Returns the interpolated value at the given `time` (in seconds). The `track_idx` must be the index of a Bezier Track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time, (int, float)), 'time must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(128,tuple([track_idx, time]))
    return _ret


  @functools.native_method
  def audio_track_insert_key(self, track_idx:'int'   , time:'float'   , stream:'py4godot_resource.Resource'   , start_offset:'float' =0  , end_offset:'float' =0  ) -> typing.Union[int]:
    r'''
				Inserts an Audio Track key at the given `time` in seconds. The `track_idx` must be the index of an Audio Track.
				`stream` is the `AudioStream` resource to play. `start_offset` is the number of seconds cut off at the beginning of the audio stream, while `end_offset` is at the ending.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time, (int, float)), 'time must be int or float'
    assert(not stream is None)
    assert isinstance(stream, get_class('Resource')), 'stream must be Resource'
    assert isinstance(start_offset, (int, float)), 'start_offset must be int or float'
    assert isinstance(end_offset, (int, float)), 'end_offset must be int or float'











    _ret = 0
    _ret = self._ptr.call_with_return(129,tuple([track_idx, time, stream._ptr, start_offset, end_offset]))
    return _ret


  @functools.native_method
  def audio_track_set_key_stream(self, track_idx:'int'   , key_idx:'int'   , stream:'py4godot_resource.Resource'   ) -> None:
    r'''
				Sets the stream of the key identified by `key_idx` to value `stream`. The `track_idx` must be the index of an Audio Track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'
    assert(not stream is None)
    assert isinstance(stream, get_class('Resource')), 'stream must be Resource'









    self._ptr.call_with_return(130,tuple([track_idx, key_idx, stream._ptr]))

  @functools.native_method
  def audio_track_set_key_start_offset(self, track_idx:'int'   , key_idx:'int'   , offset:'float'   ) -> None:
    r'''
				Sets the start offset of the key identified by `key_idx` to value `offset`. The `track_idx` must be the index of an Audio Track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'









    self._ptr.call_with_return(131,tuple([track_idx, key_idx, offset]))

  @functools.native_method
  def audio_track_set_key_end_offset(self, track_idx:'int'   , key_idx:'int'   , offset:'float'   ) -> None:
    r'''
				Sets the end offset of the key identified by `key_idx` to value `offset`. The `track_idx` must be the index of an Audio Track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'









    self._ptr.call_with_return(132,tuple([track_idx, key_idx, offset]))

  @functools.native_method
  def audio_track_get_key_stream(self, track_idx:'int'   , key_idx:'int'   ) -> typing.Any:
    r'''
				Returns the audio stream of the key identified by `key_idx`. The `track_idx` must be the index of an Audio Track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'








    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Resource
    _ret._ptr = self._ptr.call_with_return(133,tuple([track_idx, key_idx]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def audio_track_get_key_start_offset(self, track_idx:'int'   , key_idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the start offset of the key identified by `key_idx`. The `track_idx` must be the index of an Audio Track.
				Start offset is the number of seconds cut off at the beginning of the audio stream.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(134,tuple([track_idx, key_idx]))
    return _ret


  @functools.native_method
  def audio_track_get_key_end_offset(self, track_idx:'int'   , key_idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the end offset of the key identified by `key_idx`. The `track_idx` must be the index of an Audio Track.
				End offset is the number of seconds cut off at the ending of the audio stream.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(135,tuple([track_idx, key_idx]))
    return _ret


  @functools.native_method
  def audio_track_set_use_blend(self, track_idx:'int'   , enable:'bool'   ) -> None:
    r'''
				Sets whether the track will be blended with other animations. If `true`, the audio playback volume changes depending on the blend value.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'








    self._ptr.call_with_return(136,tuple([track_idx, enable]))

  @functools.native_method
  def audio_track_is_use_blend(self, track_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the track at `track_idx` will be blended with other animations.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(137,tuple([track_idx]))
    return _ret


  @functools.native_method
  def animation_track_insert_key(self, track_idx:'int'   , time:'float'   , animation:'object'   ) -> typing.Union[int]:
    r'''
				Inserts a key with value `animation` at the given `time` (in seconds). The `track_idx` must be the index of an Animation Track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(time, (int, float)), 'time must be int or float'
    assert(not animation is None)
    assert isinstance(animation, (str, StringName)), 'animation must be str or StringName'







    assert(isinstance(animation, (str, StringName)))
    py_stringname_animation = animation if isinstance(animation, StringName) else c_utils.py_string_to_string_name(animation)

    _ret = 0
    _ret = self._ptr.call_with_return(138,tuple([track_idx, time, py_stringname_animation._ptr]))
    return _ret


  @functools.native_method
  def animation_track_set_key_animation(self, track_idx:'int'   , key_idx:'int'   , animation:'object'   ) -> None:
    r'''
				Sets the key identified by `key_idx` to value `animation`. The `track_idx` must be the index of an Animation Track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'
    assert(not animation is None)
    assert isinstance(animation, (str, StringName)), 'animation must be str or StringName'







    assert(isinstance(animation, (str, StringName)))
    py_stringname_animation = animation if isinstance(animation, StringName) else c_utils.py_string_to_string_name(animation)

    self._ptr.call_with_return(139,tuple([track_idx, key_idx, py_stringname_animation._ptr]))

  @functools.native_method
  def animation_track_get_key_animation(self, track_idx:'int'   , key_idx:'int'   ) -> typing.Union['StringName']:
    r'''
				Returns the animation name at the key identified by `key_idx`. The `track_idx` must be the index of an Animation Track.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert isinstance(key_idx, (int, float)), 'key_idx must be int or float'








    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(140,tuple([track_idx, key_idx]))
    return str(_ret)


  @functools.native_method
  def add_marker(self, name:'object'   , time:'float'   ) -> None:
    r'''
				Adds a marker to this Animation.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(time, (int, float)), 'time must be int or float'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(141,tuple([py_stringname_name._ptr, time]))

  @functools.native_method
  def remove_marker(self, name:'object'   ) -> None:
    r'''
				Removes the marker with the given name from this Animation.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(142,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def has_marker(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if this Animation contains a marker with the given name.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(143,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def get_marker_at_time(self, time:'float'   ) -> typing.Union['StringName']:
    r'''
				Returns the name of the marker located at the given time.
			'''

    assert isinstance(time, (int, float)), 'time must be int or float'







    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(144,tuple([time]))
    return str(_ret)


  @functools.native_method
  def get_next_marker(self, time:'float'   ) -> typing.Union['StringName']:
    r'''
				Returns the closest marker that comes after the given time. If no such marker exists, an empty string is returned.
			'''

    assert isinstance(time, (int, float)), 'time must be int or float'







    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(145,tuple([time]))
    return str(_ret)


  @functools.native_method
  def get_prev_marker(self, time:'float'   ) -> typing.Union['StringName']:
    r'''
				Returns the closest marker that comes before the given time. If no such marker exists, an empty string is returned.
			'''

    assert isinstance(time, (int, float)), 'time must be int or float'







    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(146,tuple([time]))
    return str(_ret)


  @functools.native_method
  def get_marker_time(self, name:'object'   ) -> typing.Union[float]:
    r'''
				Returns the given marker's time.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(147,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def get_marker_names(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns every marker in this Animation, sorted ascending by time.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(148,tuple([]))
    return _ret


  @functools.native_method
  def get_marker_color(self, name:'object'   ) -> typing.Union['Color']:
    r'''
				Returns the given marker's color.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(149,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def set_marker_color(self, name:'object'   , color:'Color'   ) -> None:
    r'''
				Sets the given marker's color.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(150,tuple([py_stringname_name._ptr, color._ptr]))

  @functools.native_method
  def set_length(self, time_sec:'float'   ) -> None:
    r''''''

    assert isinstance(time_sec, (int, float)), 'time_sec must be int or float'


    self.py__length = time_sec






    self._ptr.call_with_return(151,tuple([time_sec]))

  @functools.native_method
  def get_length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(152,tuple([]))

    return _ret


  @functools.native_method
  def set_loop_mode(self, loop_mode:'int'  ) -> None:
    r''''''

    assert isinstance(loop_mode, (int, float)), 'loop_mode must be int or float'


    self.py__loop_mode = loop_mode






    self._ptr.call_with_return(153,tuple([loop_mode]))

  @functools.native_method
  def get_loop_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(154,tuple([]))

    return _ret


  @functools.native_method
  def set_step(self, size_sec:'float'   ) -> None:
    r''''''

    assert isinstance(size_sec, (int, float)), 'size_sec must be int or float'


    self.py__step = size_sec






    self._ptr.call_with_return(155,tuple([size_sec]))

  @functools.native_method
  def get_step(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(156,tuple([]))

    return _ret


  @functools.native_method
  def clear(self) -> None:
    r'''
				Clear the animation (clear all tracks and reset all).
			'''




    self._ptr.call_with_return(157,tuple([]))

  @functools.native_method
  def copy_track(self, track_idx:'int'   , to_animation:'Animation'   ) -> None:
    r'''
				Adds a new track to `to_animation` that is a copy of the given track from this animation.
			'''

    assert isinstance(track_idx, (int, float)), 'track_idx must be int or float'
    assert(not to_animation is None)
    assert isinstance(to_animation, get_class('Animation')), 'to_animation must be Animation'








    self._ptr.call_with_return(158,tuple([track_idx, to_animation._ptr]))

  @functools.native_method
  def optimize(self, allowed_velocity_err:'float' =0.01  , allowed_angular_err:'float' =0.01  , precision:'int' =3  ) -> None:
    r'''
				Optimize the animation and all its tracks in-place. This will preserve only as many keys as are necessary to keep the animation within the specified bounds.
			'''

    assert isinstance(allowed_velocity_err, (int, float)), 'allowed_velocity_err must be int or float'
    assert isinstance(allowed_angular_err, (int, float)), 'allowed_angular_err must be int or float'
    assert isinstance(precision, (int, float)), 'precision must be int or float'









    self._ptr.call_with_return(159,tuple([allowed_velocity_err, allowed_angular_err, precision]))

  @functools.native_method
  def compress(self, page_size:'int' =8192  , fps:'int' =120  , split_tolerance:'float' =4.0  ) -> None:
    r'''
				Compress the animation and all its tracks in-place. This will make `track_is_compressed` return `true` once called on this `Animation`. Compressed tracks require less memory to be played, and are designed to be used for complex 3D animations (such as cutscenes) imported from external 3D software. Compression is lossy, but the difference is usually not noticeable in real world conditions.
				**Note:** Compressed tracks have various limitations (such as not being editable from the editor), so only use compressed animations if you actually need them.
			'''

    assert isinstance(page_size, (int, float)), 'page_size must be int or float'
    assert isinstance(fps, (int, float)), 'fps must be int or float'
    assert isinstance(split_tolerance, (int, float)), 'split_tolerance must be int or float'









    self._ptr.call_with_return(160,tuple([page_size, fps, split_tolerance]))

  @functools.native_method
  def is_capture_included(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(161,tuple([]))

    return _ret



register_cast_function('Animation', Animation.cast)
register_class('Animation', Animation)
