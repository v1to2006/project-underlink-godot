# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.SkeletonModificationStack2D as py4godot_skeletonmodificationstack2d 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPSkeletonModification2DWrapper


class SkeletonModification2D(py4godot_resource.Resource):
  r'''
		This resource provides an interface that can be expanded so code that operates on `Bone2D` nodes in a `Skeleton2D` can be mixed and matched together to create complex interactions.
		This is used to provide Godot with a flexible and powerful Inverse Kinematics solution that can be adapted for many different uses.
	'''

  @staticmethod
  def constructor():
    class_ = SkeletonModification2D.construct_without_init()
    class_._ptr = constructor(749,0, ())
    return class_
  @staticmethod
  def new():
    class_ = SkeletonModification2D.construct_without_init()
    class_._ptr = constructor(749,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPSkeletonModification2DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(749,0, ())


  def generate_wrapper(self):
    return CPPSkeletonModification2DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = SkeletonModification2D.__new__(SkeletonModification2D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'SkeletonModification2D'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(90, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = SkeletonModification2D.construct_without_init()
    cls._ptr = CPPSkeletonModification2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = SkeletonModification2D.construct_without_init()
    cls._ptr = CPPSkeletonModification2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_enabled()
    return _ret
  @enabled.setter
  def enabled(self,  value:'bool'):
    self.set_enabled(value)
  @property
  def execution_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_execution_mode()
    return _ret
  @execution_mode.setter
  def execution_mode(self,  value:'int'):
    self.set_execution_mode(value)
  @functools.native_method
  def _execute(self, delta:'float'   ) -> None:
    r'''
				Executes the given modification. This is where the modification performs whatever function it is designed to do.
			'''

    assert isinstance(delta, (int, float)), 'delta must be int or float'







    self._ptr.call_with_return(77,tuple([delta]))

  @functools.native_method
  def _setup_modification(self, modification_stack:'py4godot_skeletonmodificationstack2d.SkeletonModificationStack2D'   ) -> None:
    r'''
				Called when the modification is setup. This is where the modification performs initialization.
			'''

    assert(not modification_stack is None)
    assert isinstance(modification_stack, get_class('SkeletonModificationStack2D')), 'modification_stack must be SkeletonModificationStack2D'







    self._ptr.call_with_return(78,tuple([modification_stack._ptr]))

  @functools.native_method
  def _draw_editor_gizmo(self) -> None:
    r'''
				Used for drawing **editor-only** modification gizmos. This function will only be called in the Godot editor and can be overridden to draw custom gizmos.
				**Note:** You will need to use the Skeleton2D from `SkeletonModificationStack2D.get_skeleton` and it's draw functions, as the `SkeletonModification2D` resource cannot draw on its own.
			'''




    self._ptr.call_with_return(79,tuple([]))

  @functools.native_method
  def set_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__enabled = enabled






    self._ptr.call_with_return(80,tuple([enabled]))

  @functools.native_method
  def get_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(81,tuple([]))

    return _ret


  @functools.native_method
  def get_modification_stack(self) -> typing.Union['py4godot_skeletonmodificationstack2d.SkeletonModificationStack2D']:
    r'''
				Returns the `SkeletonModificationStack2D` that this modification is bound to. Through the modification stack, you can access the Skeleton2D the modification is operating on.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: SkeletonModificationStack2D
    _ret._ptr = self._ptr.call_with_return(82,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_is_setup(self, is_setup:'bool'   ) -> None:
    r'''
				Manually allows you to set the setup state of the modification. This function should only rarely be used, as the `SkeletonModificationStack2D` the modification is bound to should handle setting the modification up.
			'''

    assert isinstance(is_setup, bool), 'is_setup must be bool'







    self._ptr.call_with_return(83,tuple([is_setup]))

  @functools.native_method
  def get_is_setup(self) -> typing.Union[bool]:
    r'''
				Returns whether this modification has been successfully setup or not.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([]))
    return _ret


  @functools.native_method
  def set_execution_mode(self, execution_mode:'int'   ) -> None:
    r''''''

    assert isinstance(execution_mode, (int, float)), 'execution_mode must be int or float'


    self.py__execution_mode = execution_mode






    self._ptr.call_with_return(85,tuple([execution_mode]))

  @functools.native_method
  def get_execution_mode(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([]))

    return _ret


  @functools.native_method
  def clamp_angle(self, angle:'float'   , min:'float'   , max:'float'   , invert:'bool'   ) -> typing.Union[float]:
    r'''
				Takes an angle and clamps it so it is within the passed-in `min` and `max` range. `invert` will inversely clamp the angle, clamping it to the range outside of the given bounds.
			'''

    assert isinstance(angle, (int, float)), 'angle must be int or float'
    assert isinstance(min, (int, float)), 'min must be int or float'
    assert isinstance(max, (int, float)), 'max must be int or float'
    assert isinstance(invert, bool), 'invert must be bool'










    _ret = 0
    _ret = self._ptr.call_with_return(87,tuple([angle, min, max, invert]))
    return _ret


  @functools.native_method
  def set_editor_draw_gizmo(self, draw_gizmo:'bool'   ) -> None:
    r'''
				Sets whether this modification will call `_draw_editor_gizmo` in the Godot editor to draw modification-specific gizmos.
			'''

    assert isinstance(draw_gizmo, bool), 'draw_gizmo must be bool'







    self._ptr.call_with_return(88,tuple([draw_gizmo]))

  @functools.native_method
  def get_editor_draw_gizmo(self) -> typing.Union[bool]:
    r'''
				Returns whether this modification will call `_draw_editor_gizmo` in the Godot editor to draw modification-specific gizmos.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([]))
    return _ret



register_cast_function('SkeletonModification2D', SkeletonModification2D.cast)
register_class('SkeletonModification2D', SkeletonModification2D)
