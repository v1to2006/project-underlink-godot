# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.SliderJoint3D as py4godot_sliderjoint3d 
  import py4godot.classes.CharacterBody3D as py4godot_characterbody3d 
  import py4godot.classes.AimModifier3D as py4godot_aimmodifier3d 
  import py4godot.classes.CSGShape3D as py4godot_csgshape3d 
  import py4godot.classes.XRController3D as py4godot_xrcontroller3d 
  import py4godot.classes.CSGCombiner3D as py4godot_csgcombiner3d 
  import py4godot.classes.XRBodyModifier3D as py4godot_xrbodymodifier3d 
  import py4godot.classes.OmniLight3D as py4godot_omnilight3d 
  import py4godot.classes.BoneAttachment3D as py4godot_boneattachment3d 
  import py4godot.classes.ReflectionProbe as py4godot_reflectionprobe 
  import py4godot.classes.LookAtModifier3D as py4godot_lookatmodifier3d 
  import py4godot.classes.XRAnchor3D as py4godot_xranchor3d 
  import py4godot.classes.HingeJoint3D as py4godot_hingejoint3d 
  import py4godot.classes.NavigationLink3D as py4godot_navigationlink3d 
  import py4godot.classes.GPUParticlesCollisionSphere3D as py4godot_gpuparticlescollisionsphere3d 
  import py4godot.classes.CSGPrimitive3D as py4godot_csgprimitive3d 
  import py4godot.classes.VisibleOnScreenNotifier3D as py4godot_visibleonscreennotifier3d 
  import py4godot.classes.SkeletonModifier3D as py4godot_skeletonmodifier3d 
  import py4godot.classes.Joint3D as py4godot_joint3d 
  import py4godot.classes.AnimatedSprite3D as py4godot_animatedsprite3d 
  import py4godot.classes.SpotLight3D as py4godot_spotlight3d 
  import py4godot.classes.SpriteBase3D as py4godot_spritebase3d 
  import py4godot.classes.Skeleton3D as py4godot_skeleton3d 
  import py4godot.classes.ModifierBoneTarget3D as py4godot_modifierbonetarget3d 
  import py4godot.classes.SpringBoneCollisionPlane3D as py4godot_springbonecollisionplane3d 
  import py4godot.classes.PhysicalBone3D as py4godot_physicalbone3d 
  import py4godot.classes.Generic6DOFJoint3D as py4godot_generic6dofjoint3d 
  import py4godot.classes.SpringBoneCollisionCapsule3D as py4godot_springbonecollisioncapsule3d 
  import py4godot.classes.OpenXRCompositionLayer as py4godot_openxrcompositionlayer 
  import py4godot.classes.GPUParticles3D as py4godot_gpuparticles3d 
  import py4godot.classes.ConeTwistJoint3D as py4godot_conetwistjoint3d 
  import py4godot.classes.VisibleOnScreenEnabler3D as py4godot_visibleonscreenenabler3d 
  import py4godot.classes.PhysicalBoneSimulator3D as py4godot_physicalbonesimulator3d 
  import py4godot.classes.OpenXRRenderModel as py4godot_openxrrendermodel 
  import py4godot.classes.XROrigin3D as py4godot_xrorigin3d 
  import py4godot.classes.CPUParticles3D as py4godot_cpuparticles3d 
  import py4godot.classes.ImporterMeshInstance3D as py4godot_importermeshinstance3d 
  import py4godot.classes.AudioListener3D as py4godot_audiolistener3d 
  import py4godot.classes.CollisionObject3D as py4godot_collisionobject3d 
  import py4godot.classes.LightmapProbe as py4godot_lightmapprobe 
  import py4godot.classes.XRCamera3D as py4godot_xrcamera3d 
  import py4godot.classes.RemoteTransform3D as py4godot_remotetransform3d 
  import py4godot.classes.NavigationRegion3D as py4godot_navigationregion3d 
  import py4godot.classes.AudioStreamPlayer3D as py4godot_audiostreamplayer3d 
  import py4godot.classes.GPUParticlesAttractorBox3D as py4godot_gpuparticlesattractorbox3d 
  import py4godot.classes.SpringBoneSimulator3D as py4godot_springbonesimulator3d 
  import py4godot.classes.MeshInstance3D as py4godot_meshinstance3d 
  import py4godot.classes.AnimatableBody3D as py4godot_animatablebody3d 
  import py4godot.classes.SkeletonIK3D as py4godot_skeletonik3d 
  import py4godot.classes.CSGSphere3D as py4godot_csgsphere3d 
  import py4godot.classes.Camera3D as py4godot_camera3d 
  import py4godot.classes.BoneConstraint3D as py4godot_boneconstraint3d 
  import py4godot.classes.CollisionShape3D as py4godot_collisionshape3d 
  import py4godot.classes.SpringBoneCollision3D as py4godot_springbonecollision3d 
  import py4godot.classes.CSGPolygon3D as py4godot_csgpolygon3d 
  import py4godot.classes.VoxelGI as py4godot_voxelgi 
  import py4godot.classes.MultiMeshInstance3D as py4godot_multimeshinstance3d 
  import py4godot.classes.Decal as py4godot_decal 
  import py4godot.classes.GridMap as py4godot_gridmap 
  import py4godot.classes.ConvertTransformModifier3D as py4godot_converttransformmodifier3d 
  import py4godot.classes.OpenXRHand as py4godot_openxrhand 
  import py4godot.classes.RayCast3D as py4godot_raycast3d 
  import py4godot.classes.GeometryInstance3D as py4godot_geometryinstance3d 
  import py4godot.classes.GPUParticlesCollisionBox3D as py4godot_gpuparticlescollisionbox3d 
  import py4godot.classes.OpenXRRenderModelManager as py4godot_openxrrendermodelmanager 
  import py4godot.classes.SpringArm3D as py4godot_springarm3d 
  import py4godot.classes.LightmapGI as py4godot_lightmapgi 
  import py4godot.classes.OpenXRVisibilityMask as py4godot_openxrvisibilitymask 
  import py4godot.classes.GPUParticlesAttractorVectorField3D as py4godot_gpuparticlesattractorvectorfield3d 
  import py4godot.classes.CSGBox3D as py4godot_csgbox3d 
  import py4godot.classes.XRHandModifier3D as py4godot_xrhandmodifier3d 
  import py4godot.classes.Label3D as py4godot_label3d 
  import py4godot.classes.VisualInstance3D as py4godot_visualinstance3d 
  import py4godot.classes.GPUParticlesCollision3D as py4godot_gpuparticlescollision3d 
  import py4godot.classes.RigidBody3D as py4godot_rigidbody3d 
  import py4godot.classes.SpringBoneCollisionSphere3D as py4godot_springbonecollisionsphere3d 
  import py4godot.classes.Light3D as py4godot_light3d 
  import py4godot.classes.ShapeCast3D as py4godot_shapecast3d 
  import py4godot.classes.FogVolume as py4godot_fogvolume 
  import py4godot.classes.CollisionPolygon3D as py4godot_collisionpolygon3d 
  import py4godot.classes.PathFollow3D as py4godot_pathfollow3d 
  import py4godot.classes.PinJoint3D as py4godot_pinjoint3d 
  import py4godot.classes.Sprite3D as py4godot_sprite3d 
  import py4godot.classes.SoftBody3D as py4godot_softbody3d 
  import py4godot.classes.PhysicsBody3D as py4godot_physicsbody3d 
  import py4godot.classes.CSGCylinder3D as py4godot_csgcylinder3d 
  import py4godot.classes.StaticBody3D as py4godot_staticbody3d 
  import py4godot.classes.NavigationObstacle3D as py4godot_navigationobstacle3d 
  import py4godot.classes.GPUParticlesCollisionSDF3D as py4godot_gpuparticlescollisionsdf3d 
  import py4godot.classes.OpenXRCompositionLayerEquirect as py4godot_openxrcompositionlayerequirect 
  import py4godot.classes.CSGMesh3D as py4godot_csgmesh3d 
  import py4godot.classes.GPUParticlesCollisionHeightField3D as py4godot_gpuparticlescollisionheightfield3d 
  import py4godot.classes.XRNode3D as py4godot_xrnode3d 
  import py4godot.classes.DirectionalLight3D as py4godot_directionallight3d 
  import py4godot.classes.Area3D as py4godot_area3d 
  import py4godot.classes.OpenXRCompositionLayerQuad as py4godot_openxrcompositionlayerquad 
  import py4godot.classes.OpenXRCompositionLayerCylinder as py4godot_openxrcompositionlayercylinder 
  import py4godot.classes.GPUParticlesAttractor3D as py4godot_gpuparticlesattractor3d 
  import py4godot.classes.RootMotionView as py4godot_rootmotionview 
  import py4godot.classes.CopyTransformModifier3D as py4godot_copytransformmodifier3d 
  import py4godot.classes.Path3D as py4godot_path3d 
  import py4godot.classes.XRFaceModifier3D as py4godot_xrfacemodifier3d 
  import py4godot.classes.OccluderInstance3D as py4godot_occluderinstance3d 
  import py4godot.classes.CSGTorus3D as py4godot_csgtorus3d 
  import py4godot.classes.RetargetModifier3D as py4godot_retargetmodifier3d 
  import py4godot.classes.GPUParticlesAttractorSphere3D as py4godot_gpuparticlesattractorsphere3d 
  import py4godot.classes.Marker3D as py4godot_marker3d 
  import py4godot.classes.VehicleBody3D as py4godot_vehiclebody3d 
import py4godot.classes.Node3D as py4godot_node3d 
from py4godot.wrappers.wrappers import CPPVehicleWheel3DWrapper


class VehicleWheel3D(py4godot_node3d.Node3D):
  r'''
		A node used as a child of a `VehicleBody3D` parent to simulate the behavior of one of its wheels. This node also acts as a collider to detect if the wheel is touching a surface.
		**Note:** This class has known issues and isn't designed to provide realistic 3D vehicle physics. If you want advanced vehicle physics, you may need to write your own physics integration using another `PhysicsBody3D` class.
	'''

  @staticmethod
  def constructor():
    class_ = VehicleWheel3D.construct_without_init()
    class_._ptr = constructor(867,0, ())
    return class_
  @staticmethod
  def new():
    class_ = VehicleWheel3D.construct_without_init()
    class_._ptr = constructor(867,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPVehicleWheel3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(867,0, ())


  def generate_wrapper(self):
    return CPPVehicleWheel3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = VehicleWheel3D.__new__(VehicleWheel3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'VehicleWheel3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = VehicleWheel3D.construct_without_init()
    cls._ptr = CPPVehicleWheel3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = VehicleWheel3D.construct_without_init()
    cls._ptr = CPPVehicleWheel3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def engine_force(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_engine_force()
    return _ret
  @engine_force.setter
  def engine_force(self,  value:'float'):
    self.set_engine_force(value)
  @property
  def brake(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_brake()
    return _ret
  @brake.setter
  def brake(self,  value:'float'):
    self.set_brake(value)
  @property
  def steering(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_steering()
    return _ret
  @steering.setter
  def steering(self,  value:'float'):
    self.set_steering(value)
  @property
  def use_as_traction(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_used_as_traction()
    return _ret
  @use_as_traction.setter
  def use_as_traction(self,  value:'bool'):
    self.set_use_as_traction(value)
  @property
  def use_as_steering(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_used_as_steering()
    return _ret
  @use_as_steering.setter
  def use_as_steering(self,  value:'bool'):
    self.set_use_as_steering(value)
  @property
  def wheel_roll_influence(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_roll_influence()
    return _ret
  @wheel_roll_influence.setter
  def wheel_roll_influence(self,  value:'float'):
    self.set_roll_influence(value)
  @property
  def wheel_radius(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_radius()
    return _ret
  @wheel_radius.setter
  def wheel_radius(self,  value:'float'):
    self.set_radius(value)
  @property
  def wheel_rest_length(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_suspension_rest_length()
    return _ret
  @wheel_rest_length.setter
  def wheel_rest_length(self,  value:'float'):
    self.set_suspension_rest_length(value)
  @property
  def wheel_friction_slip(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_friction_slip()
    return _ret
  @wheel_friction_slip.setter
  def wheel_friction_slip(self,  value:'float'):
    self.set_friction_slip(value)
  @property
  def suspension_travel(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_suspension_travel()
    return _ret
  @suspension_travel.setter
  def suspension_travel(self,  value:'float'):
    self.set_suspension_travel(value)
  @property
  def suspension_stiffness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_suspension_stiffness()
    return _ret
  @suspension_stiffness.setter
  def suspension_stiffness(self,  value:'float'):
    self.set_suspension_stiffness(value)
  @property
  def suspension_max_force(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_suspension_max_force()
    return _ret
  @suspension_max_force.setter
  def suspension_max_force(self,  value:'float'):
    self.set_suspension_max_force(value)
  @property
  def damping_compression(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_damping_compression()
    return _ret
  @damping_compression.setter
  def damping_compression(self,  value:'float'):
    self.set_damping_compression(value)
  @property
  def damping_relaxation(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_damping_relaxation()
    return _ret
  @damping_relaxation.setter
  def damping_relaxation(self,  value:'float'):
    self.set_damping_relaxation(value)
  @functools.native_method
  def set_radius(self, length:'float'   ) -> None:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'


    self.py__wheel_radius = length






    self._ptr.call_with_return(251,tuple([length]))

  @functools.native_method
  def get_radius(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(252,tuple([]))

    return _ret


  @functools.native_method
  def set_suspension_rest_length(self, length:'float'   ) -> None:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'


    self.py__wheel_rest_length = length






    self._ptr.call_with_return(253,tuple([length]))

  @functools.native_method
  def get_suspension_rest_length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(254,tuple([]))

    return _ret


  @functools.native_method
  def set_suspension_travel(self, length:'float'   ) -> None:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'


    self.py__suspension_travel = length






    self._ptr.call_with_return(255,tuple([length]))

  @functools.native_method
  def get_suspension_travel(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(256,tuple([]))

    return _ret


  @functools.native_method
  def set_suspension_stiffness(self, length:'float'   ) -> None:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'


    self.py__suspension_stiffness = length






    self._ptr.call_with_return(257,tuple([length]))

  @functools.native_method
  def get_suspension_stiffness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(258,tuple([]))

    return _ret


  @functools.native_method
  def set_suspension_max_force(self, length:'float'   ) -> None:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'


    self.py__suspension_max_force = length






    self._ptr.call_with_return(259,tuple([length]))

  @functools.native_method
  def get_suspension_max_force(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(260,tuple([]))

    return _ret


  @functools.native_method
  def set_damping_compression(self, length:'float'   ) -> None:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'


    self.py__damping_compression = length






    self._ptr.call_with_return(261,tuple([length]))

  @functools.native_method
  def get_damping_compression(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(262,tuple([]))

    return _ret


  @functools.native_method
  def set_damping_relaxation(self, length:'float'   ) -> None:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'


    self.py__damping_relaxation = length






    self._ptr.call_with_return(263,tuple([length]))

  @functools.native_method
  def get_damping_relaxation(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(264,tuple([]))

    return _ret


  @functools.native_method
  def set_use_as_traction(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__use_as_traction = enable






    self._ptr.call_with_return(265,tuple([enable]))

  @functools.native_method
  def is_used_as_traction(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(266,tuple([]))

    return _ret


  @functools.native_method
  def set_use_as_steering(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__use_as_steering = enable






    self._ptr.call_with_return(267,tuple([enable]))

  @functools.native_method
  def is_used_as_steering(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(268,tuple([]))

    return _ret


  @functools.native_method
  def set_friction_slip(self, length:'float'   ) -> None:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'


    self.py__wheel_friction_slip = length






    self._ptr.call_with_return(269,tuple([length]))

  @functools.native_method
  def get_friction_slip(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(270,tuple([]))

    return _ret


  @functools.native_method
  def is_in_contact(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this wheel is in contact with a surface.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(271,tuple([]))
    return _ret


  @functools.native_method
  def get_contact_body(self) -> typing.Any:
    r'''
				Returns the contacting body node if valid in the tree, as `Node3D`. At the moment, `GridMap` is not supported so the node will be always of type `PhysicsBody3D`.
				Returns `null` if the wheel is not in contact with a surface, or the contact body is not a `PhysicsBody3D`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Node3D
    _ret._ptr = self._ptr.call_with_return(272,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_contact_point(self) -> typing.Union['Vector3']:
    r'''
				Returns the point of the suspension's collision in world space if the wheel is in contact. If the wheel isn't in contact with anything, returns the maximum point of the wheel's ray cast in world space, which is defined by `wheel_rest_length + wheel_radius`.
			'''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(273,tuple([]))
    return _ret


  @functools.native_method
  def get_contact_normal(self) -> typing.Union['Vector3']:
    r'''
				Returns the normal of the suspension's collision in world space if the wheel is in contact. If the wheel isn't in contact with anything, returns a vector pointing directly along the suspension axis toward the vehicle in world space.
			'''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(274,tuple([]))
    return _ret


  @functools.native_method
  def set_roll_influence(self, roll_influence:'float'   ) -> None:
    r''''''

    assert isinstance(roll_influence, (int, float)), 'roll_influence must be int or float'


    self.py__wheel_roll_influence = roll_influence






    self._ptr.call_with_return(275,tuple([roll_influence]))

  @functools.native_method
  def get_roll_influence(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(276,tuple([]))

    return _ret


  @functools.native_method
  def get_skidinfo(self) -> typing.Union[float]:
    r'''
				Returns a value between 0.0 and 1.0 that indicates whether this wheel is skidding. 0.0 is skidding (the wheel has lost grip, e.g. icy terrain), 1.0 means not skidding (the wheel has full grip, e.g. dry asphalt road).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(277,tuple([]))
    return _ret


  @functools.native_method
  def get_rpm(self) -> typing.Union[float]:
    r'''
				Returns the rotational speed of the wheel in revolutions per minute.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(278,tuple([]))
    return _ret


  @functools.native_method
  def set_engine_force(self, engine_force:'float'   ) -> None:
    r''''''

    assert isinstance(engine_force, (int, float)), 'engine_force must be int or float'


    self.py__engine_force = engine_force






    self._ptr.call_with_return(279,tuple([engine_force]))

  @functools.native_method
  def get_engine_force(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(280,tuple([]))

    return _ret


  @functools.native_method
  def set_brake(self, brake:'float'   ) -> None:
    r''''''

    assert isinstance(brake, (int, float)), 'brake must be int or float'


    self.py__brake = brake






    self._ptr.call_with_return(281,tuple([brake]))

  @functools.native_method
  def get_brake(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(282,tuple([]))

    return _ret


  @functools.native_method
  def set_steering(self, steering:'float'   ) -> None:
    r''''''

    assert isinstance(steering, (int, float)), 'steering must be int or float'


    self.py__steering = steering






    self._ptr.call_with_return(283,tuple([steering]))

  @functools.native_method
  def get_steering(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(284,tuple([]))

    return _ret



register_cast_function('VehicleWheel3D', VehicleWheel3D.cast)
register_class('VehicleWheel3D', VehicleWheel3D)
