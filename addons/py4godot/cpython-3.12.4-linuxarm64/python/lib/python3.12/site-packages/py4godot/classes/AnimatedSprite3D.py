# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.SpriteFrames as py4godot_spriteframes 
import py4godot.classes.SpriteBase3D as py4godot_spritebase3d 
from py4godot.wrappers.wrappers import CPPAnimatedSprite3DWrapper


class AnimatedSprite3D(py4godot_spritebase3d.SpriteBase3D):
  r'''
		`AnimatedSprite3D` is similar to the `Sprite3D` node, except it carries multiple textures as animation `sprite_frames`. Animations are created using a `SpriteFrames` resource, which allows you to import image files (or a folder containing said files) to provide the animation frames for the sprite. The `SpriteFrames` resource can be configured in the editor via the SpriteFrames bottom panel.
	'''

  @staticmethod
  def constructor():
    class_ = AnimatedSprite3D.construct_without_init()
    class_._ptr = constructor(70,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AnimatedSprite3D.construct_without_init()
    class_._ptr = constructor(70,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAnimatedSprite3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(70,0, ())


  def generate_wrapper(self):
    return CPPAnimatedSprite3DWrapper()
  def init_signals(self):
    super().init_signals()
    sprite_frames_changed_name = utils.py_string_to_string_name("sprite_frames_changed")
    self.sprite_frames_changed = signals.BuiltinSignal(self, sprite_frames_changed_name)
    animation_changed_name = utils.py_string_to_string_name("animation_changed")
    self.animation_changed = signals.BuiltinSignal(self, animation_changed_name)
    frame_changed_name = utils.py_string_to_string_name("frame_changed")
    self.frame_changed = signals.BuiltinSignal(self, frame_changed_name)
    animation_looped_name = utils.py_string_to_string_name("animation_looped")
    self.animation_looped = signals.BuiltinSignal(self, animation_looped_name)
    animation_finished_name = utils.py_string_to_string_name("animation_finished")
    self.animation_finished = signals.BuiltinSignal(self, animation_finished_name)

  @staticmethod
  def construct_without_init():
    cls = AnimatedSprite3D.__new__(AnimatedSprite3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AnimatedSprite3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimatedSprite3D.construct_without_init()
    cls._ptr = CPPAnimatedSprite3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimatedSprite3D.construct_without_init()
    cls._ptr = CPPAnimatedSprite3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def sprite_frames(self) -> typing.Union['py4godot_spriteframes.SpriteFrames']:
    r''''''
    _ret = self. get_sprite_frames()
    return _ret
  @sprite_frames.setter
  def sprite_frames(self,  value:'py4godot_object.Object'):
    self.set_sprite_frames(value)
  @property
  def animation(self) -> typing.Union['StringName']:
    r''''''
    _ret = self. get_animation()
    return _ret
  @animation.setter
  def animation(self,  value:'object'):
    self.set_animation(value)
  @property
  def autoplay(self) -> typing.Union['StringName']:
    r''''''
    _ret = self. get_autoplay()
    return _ret
  @autoplay.setter
  def autoplay(self,  value:'object'):
    self.set_autoplay(value)
  @property
  def frame(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_frame()
    return _ret
  @frame.setter
  def frame(self,  value:'int'):
    self.set_frame(value)
  @property
  def frame_progress(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_frame_progress()
    return _ret
  @frame_progress.setter
  def frame_progress(self,  value:'float'):
    self.set_frame_progress(value)
  @property
  def speed_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_speed_scale()
    return _ret
  @speed_scale.setter
  def speed_scale(self,  value:'float'):
    self.set_speed_scale(value)
  @functools.native_method
  def set_sprite_frames(self, sprite_frames:'py4godot_spriteframes.SpriteFrames'   ) -> None:
    r''''''

    assert(not sprite_frames is None)
    assert isinstance(sprite_frames, get_class('SpriteFrames')), 'sprite_frames must be SpriteFrames'


    self.py__sprite_frames = sprite_frames






    self._ptr.call_with_return(332,tuple([sprite_frames._ptr]))

  @functools.native_method
  def get_sprite_frames(self) -> typing.Union['py4godot_spriteframes.SpriteFrames']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: SpriteFrames
    _ret._ptr = self._ptr.call_with_return(333,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_animation(self, name:'object'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'


    self.py__animation = name



    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(334,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def get_animation(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(335,tuple([]))

    return str(_ret)


  @functools.native_method
  def set_autoplay(self, name:'str'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'


    self.py__autoplay = name



    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    py__string_name = utils.py_string_to_string(name)
    py__string_name.shouldBeDeleted = False


    self._ptr.call_with_return(336,tuple([py__string_name._ptr]))

  @functools.native_method
  def get_autoplay(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(337,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def is_playing(self) -> typing.Union[bool]:
    r'''
				Returns `true` if an animation is currently playing (even if `speed_scale` and/or `custom_speed` are `0`).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(338,tuple([]))
    return _ret


  @functools.native_method
  def play(self, name:'object' = None  , custom_speed:'float' =1.0  , from_end:'bool' =False  ) -> None:
    r'''
				Plays the animation with key `name`. If `custom_speed` is negative and `from_end` is `true`, the animation will play backwards (which is equivalent to calling `play_backwards`).
				If this method is called with that same animation `name`, or with no `name` parameter, the assigned animation will resume playing if it was paused.
			'''
    if name is None:
      name = StringName.new0()

    assert isinstance(custom_speed, (int, float)), 'custom_speed must be int or float'
    assert isinstance(from_end, bool), 'from_end must be bool'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)



    self._ptr.call_with_return(339,tuple([py_stringname_name._ptr, custom_speed, from_end]))

  @functools.native_method
  def play_backwards(self, name:'object' = None  ) -> None:
    r'''
				Plays the animation with key `name` in reverse.
				This method is a shorthand for `play` with `custom_speed = -1.0` and `from_end = true`, so see its description for more information.
			'''
    if name is None:
      name = StringName.new0()






    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(340,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def pause(self) -> None:
    r'''
				Pauses the currently playing animation. The `frame` and `frame_progress` will be kept and calling `play` or `play_backwards` without arguments will resume the animation from the current playback position.
				See also `stop`.
			'''




    self._ptr.call_with_return(341,tuple([]))

  @functools.native_method
  def stop(self) -> None:
    r'''
				Stops the currently playing animation. The animation position is reset to `0` and the `custom_speed` is reset to `1.0`. See also `pause`.
			'''




    self._ptr.call_with_return(342,tuple([]))

  @functools.native_method
  def set_frame(self, frame:'int'   ) -> None:
    r''''''

    assert isinstance(frame, (int, float)), 'frame must be int or float'


    self.py__frame = frame






    self._ptr.call_with_return(343,tuple([frame]))

  @functools.native_method
  def get_frame(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(344,tuple([]))

    return _ret


  @functools.native_method
  def set_frame_progress(self, progress:'float'   ) -> None:
    r''''''

    assert isinstance(progress, (int, float)), 'progress must be int or float'


    self.py__frame_progress = progress






    self._ptr.call_with_return(345,tuple([progress]))

  @functools.native_method
  def get_frame_progress(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(346,tuple([]))

    return _ret


  @functools.native_method
  def set_frame_and_progress(self, frame:'int'   , progress:'float'   ) -> None:
    r'''
				Sets `frame` and `frame_progress` to the given values. Unlike setting `frame`, this method does not reset the `frame_progress` to `0.0` implicitly.
				**Example:** Change the animation while keeping the same `frame` and `frame_progress`:
				
				```gdscript
				var current_frame = animated_sprite.get_frame()
				var current_progress = animated_sprite.get_frame_progress()
				animated_sprite.play("walk_another_skin")
				animated_sprite.set_frame_and_progress(current_frame, current_progress)
				```
				
			'''

    assert isinstance(frame, (int, float)), 'frame must be int or float'
    assert isinstance(progress, (int, float)), 'progress must be int or float'








    self._ptr.call_with_return(347,tuple([frame, progress]))

  @functools.native_method
  def set_speed_scale(self, speed_scale:'float'   ) -> None:
    r''''''

    assert isinstance(speed_scale, (int, float)), 'speed_scale must be int or float'


    self.py__speed_scale = speed_scale






    self._ptr.call_with_return(348,tuple([speed_scale]))

  @functools.native_method
  def get_speed_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(349,tuple([]))

    return _ret


  @functools.native_method
  def get_playing_speed(self) -> typing.Union[float]:
    r'''
				Returns the actual playing speed of current animation or `0` if not playing. This speed is the `speed_scale` property multiplied by `custom_speed` argument specified when calling the `play` method.
				Returns a negative value if the current animation is playing backwards.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(350,tuple([]))
    return _ret



register_cast_function('AnimatedSprite3D', AnimatedSprite3D.cast)
register_class('AnimatedSprite3D', AnimatedSprite3D)
