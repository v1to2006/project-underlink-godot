# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.Tree as py4godot_tree 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.TextEdit as py4godot_textedit 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.GraphElement as py4godot_graphelement 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.RichTextLabel as py4godot_richtextlabel 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.TabBar as py4godot_tabbar 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.GraphNode as py4godot_graphnode 
  import py4godot.classes.TextServerExtension as py4godot_textserverextension 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.TextServer as py4godot_textserver 
  import py4godot.classes.TextServerAdvanced as py4godot_textserveradvanced 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.TextServerDummy as py4godot_textserverdummy 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.Control as py4godot_control 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.TabContainer as py4godot_tabcontainer 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.FoldableGroup as py4godot_foldablegroup 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
import py4godot.classes.Container as py4godot_container 
from py4godot.wrappers.wrappers import CPPFoldableContainerWrapper

class TitlePosition:
  POSITION_TOP = 0
  POSITION_BOTTOM = 1


class FoldableContainer(py4godot_container.Container):
  r'''
		A container that can be expanded/collapsed, with a title that can be filled with controls, such as buttons. This is also called an accordion.
		The title can be positioned at the top or bottom of the container. The container can be expanded or collapsed by clicking the title or by pressing `ui_accept` when focused. Child control nodes are hidden when the container is collapsed. Ignores non-control children.
		A FoldableContainer can be grouped with other FoldableContainers so that only one of them can be opened at a time; see `foldable_group` and `FoldableGroup`.
	'''

  @staticmethod
  def constructor():
    class_ = FoldableContainer.construct_without_init()
    class_._ptr = constructor(335,0, ())
    return class_
  @staticmethod
  def new():
    class_ = FoldableContainer.construct_without_init()
    class_._ptr = constructor(335,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPFoldableContainerWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(335,0, ())


  def generate_wrapper(self):
    return CPPFoldableContainerWrapper()
  def init_signals(self):
    super().init_signals()
    folding_changed_name = utils.py_string_to_string_name("folding_changed")
    self.folding_changed = signals.BuiltinSignal(self, folding_changed_name)

  @staticmethod
  def construct_without_init():
    cls = FoldableContainer.__new__(FoldableContainer)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'FoldableContainer'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = FoldableContainer.construct_without_init()
    cls._ptr = CPPFoldableContainerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = FoldableContainer.construct_without_init()
    cls._ptr = CPPFoldableContainerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def folded(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_folded()
    return _ret
  @folded.setter
  def folded(self,  value:'bool'):
    self.set_folded(value)
  @property
  def title(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_title()
    return _ret
  @title.setter
  def title(self,  value:'str'):
    self.set_title(value)
  @property
  def title_alignment(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_title_alignment()
    return _ret
  @title_alignment.setter
  def title_alignment(self,  value:'int'):
    self.set_title_alignment(value)
  @property
  def title_position(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_title_position()
    return _ret
  @title_position.setter
  def title_position(self,  value:'int'):
    self.set_title_position(value)
  @property
  def title_text_overrun_behavior(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_title_text_overrun_behavior()
    return _ret
  @title_text_overrun_behavior.setter
  def title_text_overrun_behavior(self,  value:'int'):
    self.set_title_text_overrun_behavior(value)
  @property
  def foldable_group(self) -> typing.Union['py4godot_foldablegroup.FoldableGroup']:
    r''''''
    _ret = self. get_foldable_group()
    return _ret
  @foldable_group.setter
  def foldable_group(self,  value:'py4godot_object.Object'):
    self.set_foldable_group(value)
  @property
  def title_text_direction(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_title_text_direction()
    return _ret
  @title_text_direction.setter
  def title_text_direction(self,  value:'int'):
    self.set_title_text_direction(value)
  @property
  def language(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_language()
    return _ret
  @language.setter
  def language(self,  value:'str'):
    self.set_language(value)
  @functools.native_method
  def fold(self) -> None:
    r'''
				Folds the container and emits `signal folding_changed`.
			'''




    self._ptr.call_with_return(437,tuple([]))

  @functools.native_method
  def expand(self) -> None:
    r'''
				Expands the container and emits `signal folding_changed`.
			'''




    self._ptr.call_with_return(438,tuple([]))

  @functools.native_method
  def set_folded(self, folded:'bool'   ) -> None:
    r''''''

    assert isinstance(folded, bool), 'folded must be bool'


    self.py__folded = folded






    self._ptr.call_with_return(439,tuple([folded]))

  @functools.native_method
  def is_folded(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(440,tuple([]))

    return _ret


  @functools.native_method
  def set_foldable_group(self, button_group:'py4godot_foldablegroup.FoldableGroup'   ) -> None:
    r''''''

    assert(not button_group is None)
    assert isinstance(button_group, get_class('FoldableGroup')), 'button_group must be FoldableGroup'


    self.py__foldable_group = button_group






    self._ptr.call_with_return(441,tuple([button_group._ptr]))

  @functools.native_method
  def get_foldable_group(self) -> typing.Union['py4godot_foldablegroup.FoldableGroup']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: FoldableGroup
    _ret._ptr = self._ptr.call_with_return(442,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_title(self, text:'str'   ) -> None:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'


    self.py__title = text



    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    py__string_text = utils.py_string_to_string(text)
    py__string_text.shouldBeDeleted = False


    self._ptr.call_with_return(443,tuple([py__string_text._ptr]))

  @functools.native_method
  def get_title(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(444,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_title_alignment(self, alignment:'int'  ) -> None:
    r''''''

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'


    self.py__title_alignment = alignment






    self._ptr.call_with_return(445,tuple([alignment]))

  @functools.native_method
  def get_title_alignment(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(446,tuple([]))

    return _ret


  @functools.native_method
  def set_language(self, language:'str'   ) -> None:
    r''''''

    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'


    self.py__language = language



    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    py__string_language = utils.py_string_to_string(language)
    py__string_language.shouldBeDeleted = False


    self._ptr.call_with_return(447,tuple([py__string_language._ptr]))

  @functools.native_method
  def get_language(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(448,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_title_text_direction(self, text_direction:'int'  ) -> None:
    r''''''

    assert isinstance(text_direction, (int, float)), 'text_direction must be int or float'


    self.py__title_text_direction = text_direction






    self._ptr.call_with_return(449,tuple([text_direction]))

  @functools.native_method
  def get_title_text_direction(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(450,tuple([]))

    return _ret


  @functools.native_method
  def set_title_text_overrun_behavior(self, overrun_behavior:'int'  ) -> None:
    r''''''

    assert isinstance(overrun_behavior, (int, float)), 'overrun_behavior must be int or float'


    self.py__title_text_overrun_behavior = overrun_behavior






    self._ptr.call_with_return(451,tuple([overrun_behavior]))

  @functools.native_method
  def get_title_text_overrun_behavior(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(452,tuple([]))

    return _ret


  @functools.native_method
  def set_title_position(self, title_position:'int'  ) -> None:
    r''''''

    assert isinstance(title_position, (int, float)), 'title_position must be int or float'


    self.py__title_position = title_position






    self._ptr.call_with_return(453,tuple([title_position]))

  @functools.native_method
  def get_title_position(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(454,tuple([]))

    return _ret


  @functools.native_method
  def add_title_bar_control(self, control:'py4godot_control.Control'   ) -> None:
    r'''
				Adds a `Control` that will be placed next to the container's title, obscuring the clickable area. Prime usage is adding `Button` nodes, but it can be any `Control`.
				The control will be added as a child of this container and removed from previous parent if necessary. The controls will be placed aligned to the right, with the first added control being the leftmost one.
			'''

    assert(not control is None)
    assert isinstance(control, get_class('Control')), 'control must be Control'







    self._ptr.call_with_return(455,tuple([control._ptr]))

  @functools.native_method
  def remove_title_bar_control(self, control:'py4godot_control.Control'   ) -> None:
    r'''
				Removes a `Control` added with `add_title_bar_control`. The node is not freed automatically, you need to use `Node.queue_free`.
			'''

    assert(not control is None)
    assert isinstance(control, get_class('Control')), 'control must be Control'







    self._ptr.call_with_return(456,tuple([control._ptr]))


register_cast_function('FoldableContainer', FoldableContainer.cast)
register_class('FoldableContainer', FoldableContainer)
