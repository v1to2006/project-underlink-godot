# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PackedVector2ArrayTypedArray as py4godot_packedvector2arraytypedarray 
import py4godot.classes.Resource as py4godot_resource 
import py4godot.classes.PackedVector2ArrayTypedArray as py4godot_packedvector2arraytypedarray 
from py4godot.wrappers.wrappers import CPPNavigationMeshSourceGeometryData2DWrapper


class NavigationMeshSourceGeometryData2D(py4godot_resource.Resource):
  r'''
		Container for parsed source geometry data used in navigation mesh baking.
	'''

  @staticmethod
  def constructor():
    class_ = NavigationMeshSourceGeometryData2D.construct_without_init()
    class_._ptr = constructor(500,0, ())
    return class_
  @staticmethod
  def new():
    class_ = NavigationMeshSourceGeometryData2D.construct_without_init()
    class_._ptr = constructor(500,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPNavigationMeshSourceGeometryData2DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(500,0, ())


  def generate_wrapper(self):
    return CPPNavigationMeshSourceGeometryData2DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = NavigationMeshSourceGeometryData2D.__new__(NavigationMeshSourceGeometryData2D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'NavigationMeshSourceGeometryData2D'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(93, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = NavigationMeshSourceGeometryData2D.construct_without_init()
    cls._ptr = CPPNavigationMeshSourceGeometryData2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = NavigationMeshSourceGeometryData2D.construct_without_init()
    cls._ptr = CPPNavigationMeshSourceGeometryData2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def traversable_outlines(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_traversable_outlines()
    return _ret
  @traversable_outlines.setter
  def traversable_outlines(self,  value:'Array'):
    self.set_traversable_outlines(value)
  @property
  def obstruction_outlines(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_obstruction_outlines()
    return _ret
  @obstruction_outlines.setter
  def obstruction_outlines(self,  value:'Array'):
    self.set_obstruction_outlines(value)
  @property
  def projected_obstructions(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_projected_obstructions()
    return _ret
  @projected_obstructions.setter
  def projected_obstructions(self,  value:'Array'):
    self.set_projected_obstructions(value)
  @functools.native_method
  def clear(self) -> None:
    r'''
				Clears the internal data.
			'''




    self._ptr.call_with_return(77,tuple([]))

  @functools.native_method
  def has_data(self) -> typing.Union[bool]:
    r'''
				Returns `true` when parsed source geometry data exists.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([]))
    return _ret


  @functools.native_method
  def set_traversable_outlines(self, traversable_outlines:'py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray'   ) -> None:
    r'''
				Sets all the traversable area outlines arrays.
			'''

    assert isinstance(traversable_outlines, Array), 'traversable_outlines must be Array'


    self.py__traversable_outlines = traversable_outlines






    self._ptr.call_with_return(79,tuple([traversable_outlines._ptr]))

  @functools.native_method
  def get_traversable_outlines(self) -> typing.Union['py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray']:
    r'''
				Returns all the traversable area outlines arrays.
			'''




    _ret = py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))

    return _ret


  @functools.native_method
  def set_obstruction_outlines(self, obstruction_outlines:'py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray'   ) -> None:
    r'''
				Sets all the obstructed area outlines arrays.
			'''

    assert isinstance(obstruction_outlines, Array), 'obstruction_outlines must be Array'


    self.py__obstruction_outlines = obstruction_outlines






    self._ptr.call_with_return(81,tuple([obstruction_outlines._ptr]))

  @functools.native_method
  def get_obstruction_outlines(self) -> typing.Union['py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray']:
    r'''
				Returns all the obstructed area outlines arrays.
			'''




    _ret = py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(82,tuple([]))

    return _ret


  @functools.native_method
  def append_traversable_outlines(self, traversable_outlines:'py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray'   ) -> None:
    r'''
				Appends another array of `traversable_outlines` at the end of the existing traversable outlines array.
			'''

    assert isinstance(traversable_outlines, Array), 'traversable_outlines must be Array'







    self._ptr.call_with_return(83,tuple([traversable_outlines._ptr]))

  @functools.native_method
  def append_obstruction_outlines(self, obstruction_outlines:'py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray'   ) -> None:
    r'''
				Appends another array of `obstruction_outlines` at the end of the existing obstruction outlines array.
			'''

    assert isinstance(obstruction_outlines, Array), 'obstruction_outlines must be Array'







    self._ptr.call_with_return(84,tuple([obstruction_outlines._ptr]))

  @functools.native_method
  def add_traversable_outline(self, shape_outline:'PackedVector2Array'   ) -> None:
    r'''
				Adds the outline points of a shape as traversable area.
			'''

    assert(not shape_outline is None)
    assert isinstance(shape_outline, PackedVector2Array), 'shape_outline must be PackedVector2Array'







    self._ptr.call_with_return(85,tuple([shape_outline._ptr]))

  @functools.native_method
  def add_obstruction_outline(self, shape_outline:'PackedVector2Array'   ) -> None:
    r'''
				Adds the outline points of a shape as obstructed area.
			'''

    assert(not shape_outline is None)
    assert isinstance(shape_outline, PackedVector2Array), 'shape_outline must be PackedVector2Array'







    self._ptr.call_with_return(86,tuple([shape_outline._ptr]))

  @functools.native_method
  def merge(self, other_geometry:'NavigationMeshSourceGeometryData2D'   ) -> None:
    r'''
				Adds the geometry data of another `NavigationMeshSourceGeometryData2D` to the navigation mesh baking data.
			'''

    assert(not other_geometry is None)
    assert isinstance(other_geometry, get_class('NavigationMeshSourceGeometryData2D')), 'other_geometry must be NavigationMeshSourceGeometryData2D'







    self._ptr.call_with_return(87,tuple([other_geometry._ptr]))

  @functools.native_method
  def add_projected_obstruction(self, vertices:'PackedVector2Array'   , carve:'bool'   ) -> None:
    r'''
				Adds a projected obstruction shape to the source geometry. If `carve` is `true` the carved shape will not be affected by additional offsets (e.g. agent radius) of the navigation mesh baking process.
			'''

    assert(not vertices is None)
    assert isinstance(vertices, PackedVector2Array), 'vertices must be PackedVector2Array'
    assert isinstance(carve, bool), 'carve must be bool'








    self._ptr.call_with_return(88,tuple([vertices._ptr, carve]))

  @functools.native_method
  def clear_projected_obstructions(self) -> None:
    r'''
				Clears all projected obstructions.
			'''




    self._ptr.call_with_return(89,tuple([]))

  @functools.native_method
  def set_projected_obstructions(self, projected_obstructions:'Array'   ) -> None:
    r'''
				Sets the projected obstructions with an Array of Dictionaries with the following key value pairs:
				
				```gdscript
				"vertices" : PackedFloat32Array
				"carve" : bool
				```
				
			'''

    assert(not projected_obstructions is None)
    assert isinstance(projected_obstructions, Array), 'projected_obstructions must be Array'


    self.py__projected_obstructions = projected_obstructions






    self._ptr.call_with_return(90,tuple([projected_obstructions._ptr]))

  @functools.native_method
  def get_projected_obstructions(self) -> typing.Union['Array']:
    r'''
				Returns the projected obstructions as an `Array` of dictionaries. Each `Dictionary` contains the following entries:
				- `vertices` - A `PackedFloat32Array` that defines the outline points of the projected shape.
				- `carve` - A `bool` that defines how the projected shape affects the navigation mesh baking. If `true` the projected shape will not be affected by addition offsets, e.g. agent radius.
			'''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([]))

    return _ret


  @functools.native_method
  def get_bounds(self) -> typing.Union['Rect2']:
    r'''
				Returns an axis-aligned bounding box that covers all the stored geometry data. The bounds are calculated when calling this function with the result cached until further geometry changes are made.
			'''




    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(92,tuple([]))
    return _ret



register_cast_function('NavigationMeshSourceGeometryData2D', NavigationMeshSourceGeometryData2D.cast)
register_class('NavigationMeshSourceGeometryData2D', NavigationMeshSourceGeometryData2D)
