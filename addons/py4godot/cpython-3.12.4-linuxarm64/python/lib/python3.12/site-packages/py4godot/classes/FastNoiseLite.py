# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Noise as py4godot_noise 
from py4godot.wrappers.wrappers import CPPFastNoiseLiteWrapper

class NoiseType:
  TYPE_VALUE = 5
  TYPE_VALUE_CUBIC = 4
  TYPE_PERLIN = 3
  TYPE_CELLULAR = 2
  TYPE_SIMPLEX = 0
  TYPE_SIMPLEX_SMOOTH = 1
class FractalType:
  FRACTAL_NONE = 0
  FRACTAL_FBM = 1
  FRACTAL_RIDGED = 2
  FRACTAL_PING_PONG = 3
class CellularDistanceFunction:
  DISTANCE_EUCLIDEAN = 0
  DISTANCE_EUCLIDEAN_SQUARED = 1
  DISTANCE_MANHATTAN = 2
  DISTANCE_HYBRID = 3
class CellularReturnType:
  RETURN_CELL_VALUE = 0
  RETURN_DISTANCE = 1
  RETURN_DISTANCE2 = 2
  RETURN_DISTANCE2_ADD = 3
  RETURN_DISTANCE2_SUB = 4
  RETURN_DISTANCE2_MUL = 5
  RETURN_DISTANCE2_DIV = 6
class DomainWarpType:
  DOMAIN_WARP_SIMPLEX = 0
  DOMAIN_WARP_SIMPLEX_REDUCED = 1
  DOMAIN_WARP_BASIC_GRID = 2
class DomainWarpFractalType:
  DOMAIN_WARP_FRACTAL_NONE = 0
  DOMAIN_WARP_FRACTAL_PROGRESSIVE = 1
  DOMAIN_WARP_FRACTAL_INDEPENDENT = 2


class FastNoiseLite(py4godot_noise.Noise):
  r''''''

  @staticmethod
  def constructor():
    class_ = FastNoiseLite.construct_without_init()
    class_._ptr = constructor(328,0, ())
    return class_
  @staticmethod
  def new():
    class_ = FastNoiseLite.construct_without_init()
    class_._ptr = constructor(328,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPFastNoiseLiteWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(328,0, ())


  def generate_wrapper(self):
    return CPPFastNoiseLiteWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = FastNoiseLite.__new__(FastNoiseLite)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'FastNoiseLite'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(128, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = FastNoiseLite.construct_without_init()
    cls._ptr = CPPFastNoiseLiteWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = FastNoiseLite.construct_without_init()
    cls._ptr = CPPFastNoiseLiteWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def noise_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_noise_type()
    return _ret
  @noise_type.setter
  def noise_type(self,  value:'int'):
    self.set_noise_type(value)
  @property
  def seed(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_seed()
    return _ret
  @seed.setter
  def seed(self,  value:'int'):
    self.set_seed(value)
  @property
  def frequency(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_frequency()
    return _ret
  @frequency.setter
  def frequency(self,  value:'float'):
    self.set_frequency(value)
  @property
  def offset(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_offset()
    return _ret
  @offset.setter
  def offset(self,  value:'Vector3'):
    self.set_offset(value)
  @property
  def fractal_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_fractal_type()
    return _ret
  @fractal_type.setter
  def fractal_type(self,  value:'int'):
    self.set_fractal_type(value)
  @property
  def fractal_octaves(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_fractal_octaves()
    return _ret
  @fractal_octaves.setter
  def fractal_octaves(self,  value:'int'):
    self.set_fractal_octaves(value)
  @property
  def fractal_lacunarity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fractal_lacunarity()
    return _ret
  @fractal_lacunarity.setter
  def fractal_lacunarity(self,  value:'float'):
    self.set_fractal_lacunarity(value)
  @property
  def fractal_gain(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fractal_gain()
    return _ret
  @fractal_gain.setter
  def fractal_gain(self,  value:'float'):
    self.set_fractal_gain(value)
  @property
  def fractal_weighted_strength(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fractal_weighted_strength()
    return _ret
  @fractal_weighted_strength.setter
  def fractal_weighted_strength(self,  value:'float'):
    self.set_fractal_weighted_strength(value)
  @property
  def fractal_ping_pong_strength(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fractal_ping_pong_strength()
    return _ret
  @fractal_ping_pong_strength.setter
  def fractal_ping_pong_strength(self,  value:'float'):
    self.set_fractal_ping_pong_strength(value)
  @property
  def cellular_distance_function(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_cellular_distance_function()
    return _ret
  @cellular_distance_function.setter
  def cellular_distance_function(self,  value:'int'):
    self.set_cellular_distance_function(value)
  @property
  def cellular_jitter(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_cellular_jitter()
    return _ret
  @cellular_jitter.setter
  def cellular_jitter(self,  value:'float'):
    self.set_cellular_jitter(value)
  @property
  def cellular_return_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_cellular_return_type()
    return _ret
  @cellular_return_type.setter
  def cellular_return_type(self,  value:'int'):
    self.set_cellular_return_type(value)
  @property
  def domain_warp_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_domain_warp_enabled()
    return _ret
  @domain_warp_enabled.setter
  def domain_warp_enabled(self,  value:'bool'):
    self.set_domain_warp_enabled(value)
  @property
  def domain_warp_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_domain_warp_type()
    return _ret
  @domain_warp_type.setter
  def domain_warp_type(self,  value:'int'):
    self.set_domain_warp_type(value)
  @property
  def domain_warp_amplitude(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_domain_warp_amplitude()
    return _ret
  @domain_warp_amplitude.setter
  def domain_warp_amplitude(self,  value:'float'):
    self.set_domain_warp_amplitude(value)
  @property
  def domain_warp_frequency(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_domain_warp_frequency()
    return _ret
  @domain_warp_frequency.setter
  def domain_warp_frequency(self,  value:'float'):
    self.set_domain_warp_frequency(value)
  @property
  def domain_warp_fractal_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_domain_warp_fractal_type()
    return _ret
  @domain_warp_fractal_type.setter
  def domain_warp_fractal_type(self,  value:'int'):
    self.set_domain_warp_fractal_type(value)
  @property
  def domain_warp_fractal_octaves(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_domain_warp_fractal_octaves()
    return _ret
  @domain_warp_fractal_octaves.setter
  def domain_warp_fractal_octaves(self,  value:'int'):
    self.set_domain_warp_fractal_octaves(value)
  @property
  def domain_warp_fractal_lacunarity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_domain_warp_fractal_lacunarity()
    return _ret
  @domain_warp_fractal_lacunarity.setter
  def domain_warp_fractal_lacunarity(self,  value:'float'):
    self.set_domain_warp_fractal_lacunarity(value)
  @property
  def domain_warp_fractal_gain(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_domain_warp_fractal_gain()
    return _ret
  @domain_warp_fractal_gain.setter
  def domain_warp_fractal_gain(self,  value:'float'):
    self.set_domain_warp_fractal_gain(value)
  @functools.native_method
  def set_noise_type(self, type:'int'  ) -> None:
    r''''''

    assert isinstance(type, (int, float)), 'type must be int or float'


    self.py__noise_type = type






    self._ptr.call_with_return(86,tuple([type]))

  @functools.native_method
  def get_noise_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(87,tuple([]))

    return _ret


  @functools.native_method
  def set_seed(self, seed:'int'   ) -> None:
    r''''''

    assert isinstance(seed, (int, float)), 'seed must be int or float'


    self.py__seed = seed






    self._ptr.call_with_return(88,tuple([seed]))

  @functools.native_method
  def get_seed(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([]))

    return _ret


  @functools.native_method
  def set_frequency(self, freq:'float'   ) -> None:
    r''''''

    assert isinstance(freq, (int, float)), 'freq must be int or float'


    self.py__frequency = freq






    self._ptr.call_with_return(90,tuple([freq]))

  @functools.native_method
  def get_frequency(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(91,tuple([]))

    return _ret


  @functools.native_method
  def set_offset(self, offset:'Vector3'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector3), 'offset must be Vector3'


    self.py__offset = offset






    self._ptr.call_with_return(92,tuple([offset._ptr]))

  @functools.native_method
  def get_offset(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(93,tuple([]))

    return _ret


  @functools.native_method
  def set_fractal_type(self, type:'int'  ) -> None:
    r''''''

    assert isinstance(type, (int, float)), 'type must be int or float'


    self.py__fractal_type = type






    self._ptr.call_with_return(94,tuple([type]))

  @functools.native_method
  def get_fractal_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(95,tuple([]))

    return _ret


  @functools.native_method
  def set_fractal_octaves(self, octave_count:'int'   ) -> None:
    r''''''

    assert isinstance(octave_count, (int, float)), 'octave_count must be int or float'


    self.py__fractal_octaves = octave_count






    self._ptr.call_with_return(96,tuple([octave_count]))

  @functools.native_method
  def get_fractal_octaves(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([]))

    return _ret


  @functools.native_method
  def set_fractal_lacunarity(self, lacunarity:'float'   ) -> None:
    r''''''

    assert isinstance(lacunarity, (int, float)), 'lacunarity must be int or float'


    self.py__fractal_lacunarity = lacunarity






    self._ptr.call_with_return(98,tuple([lacunarity]))

  @functools.native_method
  def get_fractal_lacunarity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([]))

    return _ret


  @functools.native_method
  def set_fractal_gain(self, gain:'float'   ) -> None:
    r''''''

    assert isinstance(gain, (int, float)), 'gain must be int or float'


    self.py__fractal_gain = gain






    self._ptr.call_with_return(100,tuple([gain]))

  @functools.native_method
  def get_fractal_gain(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(101,tuple([]))

    return _ret


  @functools.native_method
  def set_fractal_weighted_strength(self, weighted_strength:'float'   ) -> None:
    r''''''

    assert isinstance(weighted_strength, (int, float)), 'weighted_strength must be int or float'


    self.py__fractal_weighted_strength = weighted_strength






    self._ptr.call_with_return(102,tuple([weighted_strength]))

  @functools.native_method
  def get_fractal_weighted_strength(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([]))

    return _ret


  @functools.native_method
  def set_fractal_ping_pong_strength(self, ping_pong_strength:'float'   ) -> None:
    r''''''

    assert isinstance(ping_pong_strength, (int, float)), 'ping_pong_strength must be int or float'


    self.py__fractal_ping_pong_strength = ping_pong_strength






    self._ptr.call_with_return(104,tuple([ping_pong_strength]))

  @functools.native_method
  def get_fractal_ping_pong_strength(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(105,tuple([]))

    return _ret


  @functools.native_method
  def set_cellular_distance_function(self, func:'int'  ) -> None:
    r''''''

    assert isinstance(func, (int, float)), 'func must be int or float'


    self.py__cellular_distance_function = func






    self._ptr.call_with_return(106,tuple([func]))

  @functools.native_method
  def get_cellular_distance_function(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(107,tuple([]))

    return _ret


  @functools.native_method
  def set_cellular_jitter(self, jitter:'float'   ) -> None:
    r''''''

    assert isinstance(jitter, (int, float)), 'jitter must be int or float'


    self.py__cellular_jitter = jitter






    self._ptr.call_with_return(108,tuple([jitter]))

  @functools.native_method
  def get_cellular_jitter(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(109,tuple([]))

    return _ret


  @functools.native_method
  def set_cellular_return_type(self, ret:'int'  ) -> None:
    r''''''

    assert isinstance(ret, (int, float)), 'ret must be int or float'


    self.py__cellular_return_type = ret






    self._ptr.call_with_return(110,tuple([ret]))

  @functools.native_method
  def get_cellular_return_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(111,tuple([]))

    return _ret


  @functools.native_method
  def set_domain_warp_enabled(self, domain_warp_enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(domain_warp_enabled, bool), 'domain_warp_enabled must be bool'


    self.py__domain_warp_enabled = domain_warp_enabled






    self._ptr.call_with_return(112,tuple([domain_warp_enabled]))

  @functools.native_method
  def is_domain_warp_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(113,tuple([]))

    return _ret


  @functools.native_method
  def set_domain_warp_type(self, domain_warp_type:'int'  ) -> None:
    r''''''

    assert isinstance(domain_warp_type, (int, float)), 'domain_warp_type must be int or float'


    self.py__domain_warp_type = domain_warp_type






    self._ptr.call_with_return(114,tuple([domain_warp_type]))

  @functools.native_method
  def get_domain_warp_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(115,tuple([]))

    return _ret


  @functools.native_method
  def set_domain_warp_amplitude(self, domain_warp_amplitude:'float'   ) -> None:
    r''''''

    assert isinstance(domain_warp_amplitude, (int, float)), 'domain_warp_amplitude must be int or float'


    self.py__domain_warp_amplitude = domain_warp_amplitude






    self._ptr.call_with_return(116,tuple([domain_warp_amplitude]))

  @functools.native_method
  def get_domain_warp_amplitude(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(117,tuple([]))

    return _ret


  @functools.native_method
  def set_domain_warp_frequency(self, domain_warp_frequency:'float'   ) -> None:
    r''''''

    assert isinstance(domain_warp_frequency, (int, float)), 'domain_warp_frequency must be int or float'


    self.py__domain_warp_frequency = domain_warp_frequency






    self._ptr.call_with_return(118,tuple([domain_warp_frequency]))

  @functools.native_method
  def get_domain_warp_frequency(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(119,tuple([]))

    return _ret


  @functools.native_method
  def set_domain_warp_fractal_type(self, domain_warp_fractal_type:'int'  ) -> None:
    r''''''

    assert isinstance(domain_warp_fractal_type, (int, float)), 'domain_warp_fractal_type must be int or float'


    self.py__domain_warp_fractal_type = domain_warp_fractal_type






    self._ptr.call_with_return(120,tuple([domain_warp_fractal_type]))

  @functools.native_method
  def get_domain_warp_fractal_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(121,tuple([]))

    return _ret


  @functools.native_method
  def set_domain_warp_fractal_octaves(self, domain_warp_octave_count:'int'   ) -> None:
    r''''''

    assert isinstance(domain_warp_octave_count, (int, float)), 'domain_warp_octave_count must be int or float'


    self.py__domain_warp_fractal_octaves = domain_warp_octave_count






    self._ptr.call_with_return(122,tuple([domain_warp_octave_count]))

  @functools.native_method
  def get_domain_warp_fractal_octaves(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(123,tuple([]))

    return _ret


  @functools.native_method
  def set_domain_warp_fractal_lacunarity(self, domain_warp_lacunarity:'float'   ) -> None:
    r''''''

    assert isinstance(domain_warp_lacunarity, (int, float)), 'domain_warp_lacunarity must be int or float'


    self.py__domain_warp_fractal_lacunarity = domain_warp_lacunarity






    self._ptr.call_with_return(124,tuple([domain_warp_lacunarity]))

  @functools.native_method
  def get_domain_warp_fractal_lacunarity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(125,tuple([]))

    return _ret


  @functools.native_method
  def set_domain_warp_fractal_gain(self, domain_warp_gain:'float'   ) -> None:
    r''''''

    assert isinstance(domain_warp_gain, (int, float)), 'domain_warp_gain must be int or float'


    self.py__domain_warp_fractal_gain = domain_warp_gain






    self._ptr.call_with_return(126,tuple([domain_warp_gain]))

  @functools.native_method
  def get_domain_warp_fractal_gain(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(127,tuple([]))

    return _ret



register_cast_function('FastNoiseLite', FastNoiseLite.cast)
register_class('FastNoiseLite', FastNoiseLite)
