# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.GrooveJoint2D as py4godot_groovejoint2d 
  import py4godot.classes.Marker2D as py4godot_marker2d 
  import py4godot.classes.Tree as py4godot_tree 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.WorldEnvironment as py4godot_worldenvironment 
  import py4godot.classes.ShapeCast2D as py4godot_shapecast2d 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.SpriteBase3D as py4godot_spritebase3d 
  import py4godot.classes.AnimationMixer as py4godot_animationmixer 
  import py4godot.classes.EditorPlugin as py4godot_editorplugin 
  import py4godot.classes.GPUParticles3D as py4godot_gpuparticles3d 
  import py4godot.classes.OpenXRCompositionLayer as py4godot_openxrcompositionlayer 
  import py4godot.classes.Texture2DTypedArray as py4godot_texture2dtypedarray 
  import py4godot.classes.RichTextLabel as py4godot_richtextlabel 
  import py4godot.classes.CollisionObject3D as py4godot_collisionobject3d 
  import py4godot.classes.LightmapProbe as py4godot_lightmapprobe 
  import py4godot.classes.ParallaxBackground as py4godot_parallaxbackground 
  import py4godot.classes.RemoteTransform3D as py4godot_remotetransform3d 
  import py4godot.classes.EditorFileSystem as py4godot_editorfilesystem 
  import py4godot.classes.GPUParticles2D as py4godot_gpuparticles2d 
  import py4godot.classes.MultiplayerSynchronizer as py4godot_multiplayersynchronizer 
  import py4godot.classes.MeshInstance3D as py4godot_meshinstance3d 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.Window as py4godot_window 
  import py4godot.classes.NavigationLink2D as py4godot_navigationlink2d 
  import py4godot.classes.LightOccluder2D as py4godot_lightoccluder2d 
  import py4godot.classes.Script as py4godot_script 
  import py4godot.classes.CSGPolygon3D as py4godot_csgpolygon3d 
  import py4godot.classes.StaticBody2D as py4godot_staticbody2d 
  import py4godot.classes.FileDialog as py4godot_filedialog 
  import py4godot.classes.RayCast3D as py4godot_raycast3d 
  import py4godot.classes.AudioListener2D as py4godot_audiolistener2d 
  import py4godot.classes.AnimationPlayer as py4godot_animationplayer 
  import py4godot.classes.Container as py4godot_container 
  import py4godot.classes.PinJoint3D as py4godot_pinjoint3d 
  import py4godot.classes.ConfirmationDialog as py4godot_confirmationdialog 
  import py4godot.classes.CollisionPolygon2D as py4godot_collisionpolygon2d 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.Theme as py4godot_theme 
  import py4godot.classes.CSGCylinder3D as py4godot_csgcylinder3d 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.AudioStreamPlayer2D as py4godot_audiostreamplayer2d 
  import py4godot.classes.MeshInstance2D as py4godot_meshinstance2d 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.OpenXRCompositionLayerEquirect as py4godot_openxrcompositionlayerequirect 
  import py4godot.classes.CSGMesh3D as py4godot_csgmesh3d 
  import py4godot.classes.Light2D as py4godot_light2d 
  import py4godot.classes.OpenXRCompositionLayerCylinder as py4godot_openxrcompositionlayercylinder 
  import py4godot.classes.MeshTypedArray as py4godot_meshtypedarray 
  import py4godot.classes.RetargetModifier3D as py4godot_retargetmodifier3d 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.GPUParticlesAttractorSphere3D as py4godot_gpuparticlesattractorsphere3d 
  import py4godot.classes.CanvasModulate as py4godot_canvasmodulate 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.AimModifier3D as py4godot_aimmodifier3d 
  import py4godot.classes.ResourcePreloader as py4godot_resourcepreloader 
  import py4godot.classes.XRController3D as py4godot_xrcontroller3d 
  import py4godot.classes.CSGCombiner3D as py4godot_csgcombiner3d 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.PinJoint2D as py4godot_pinjoint2d 
  import py4godot.classes.ReflectionProbe as py4godot_reflectionprobe 
  import py4godot.classes.PointLight2D as py4godot_pointlight2d 
  import py4godot.classes.XRAnchor3D as py4godot_xranchor3d 
  import py4godot.classes.EditorSettings as py4godot_editorsettings 
  import py4godot.classes.HingeJoint3D as py4godot_hingejoint3d 
  import py4godot.classes.SpringBoneCollisionPlane3D as py4godot_springbonecollisionplane3d 
  import py4godot.classes.AnimatableBody2D as py4godot_animatablebody2d 
  import py4godot.classes.CharacterBody2D as py4godot_characterbody2d 
  import py4godot.classes.Generic6DOFJoint3D as py4godot_generic6dofjoint3d 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.XROrigin3D as py4godot_xrorigin3d 
  import py4godot.classes.ImporterMeshInstance3D as py4godot_importermeshinstance3d 
  import py4godot.classes.AudioListener3D as py4godot_audiolistener3d 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.GPUParticlesAttractorBox3D as py4godot_gpuparticlesattractorbox3d 
  import py4godot.classes.Bone2D as py4godot_bone2d 
  import py4godot.classes.AnimatableBody3D as py4godot_animatablebody3d 
  import py4godot.classes.SkeletonIK3D as py4godot_skeletonik3d 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.Camera3D as py4godot_camera3d 
  import py4godot.classes.BoneConstraint3D as py4godot_boneconstraint3d 
  import py4godot.classes.VisibleOnScreenNotifier2D as py4godot_visibleonscreennotifier2d 
  import py4godot.classes.VoxelGI as py4godot_voxelgi 
  import py4godot.classes.EditorResourcePreview as py4godot_editorresourcepreview 
  import py4godot.classes.Decal as py4godot_decal 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.GridMap as py4godot_gridmap 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.RayCast2D as py4godot_raycast2d 
  import py4godot.classes.EditorUndoRedoManager as py4godot_editorundoredomanager 
  import py4godot.classes.OpenXRVisibilityMask as py4godot_openxrvisibilitymask 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.VisualInstance3D as py4godot_visualinstance3d 
  import py4godot.classes.ScriptCreateDialog as py4godot_scriptcreatedialog 
  import py4godot.classes.SpringBoneCollisionSphere3D as py4godot_springbonecollisionsphere3d 
  import py4godot.classes.HTTPRequest as py4godot_httprequest 
  import py4godot.classes.Area2D as py4godot_area2d 
  import py4godot.classes.InstancePlaceholder as py4godot_instanceplaceholder 
  import py4godot.classes.FogVolume as py4godot_fogvolume 
  import py4godot.classes.PathFollow3D as py4godot_pathfollow3d 
  import py4godot.classes.Timer as py4godot_timer 
  import py4godot.classes.ShaderGlobalsOverride as py4godot_shaderglobalsoverride 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.PhysicsBody3D as py4godot_physicsbody3d 
  import py4godot.classes.Control as py4godot_control 
  import py4godot.classes.StaticBody3D as py4godot_staticbody3d 
  import py4godot.classes.PathFollow2D as py4godot_pathfollow2d 
  import py4godot.classes.BackBufferCopy as py4godot_backbuffercopy 
  import py4godot.classes.AnimationTree as py4godot_animationtree 
  import py4godot.classes.PhysicsBody2D as py4godot_physicsbody2d 
  import py4godot.classes.NavigationObstacle3D as py4godot_navigationobstacle3d 
  import py4godot.classes.RigidBody2D as py4godot_rigidbody2d 
  import py4godot.classes.GPUParticlesCollisionSDF3D as py4godot_gpuparticlescollisionsdf3d 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.XRFaceModifier3D as py4godot_xrfacemodifier3d 
  import py4godot.classes.CanvasLayer as py4godot_canvaslayer 
  import py4godot.classes.Polygon2D as py4godot_polygon2d 
  import py4godot.classes.OccluderInstance3D as py4godot_occluderinstance3d 
  import py4godot.classes.CSGTorus3D as py4godot_csgtorus3d 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.EditorFileDialog as py4godot_editorfiledialog 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.CharacterBody3D as py4godot_characterbody3d 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.StatusIndicator as py4godot_statusindicator 
  import py4godot.classes.CanvasGroup as py4godot_canvasgroup 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.MissingNode as py4godot_missingnode 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.BoneAttachment3D as py4godot_boneattachment3d 
  import py4godot.classes.LookAtModifier3D as py4godot_lookatmodifier3d 
  import py4godot.classes.TouchScreenButton as py4godot_touchscreenbutton 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.NavigationLink3D as py4godot_navigationlink3d 
  import py4godot.classes.GPUParticlesCollisionSphere3D as py4godot_gpuparticlescollisionsphere3d 
  import py4godot.classes.VisibleOnScreenNotifier3D as py4godot_visibleonscreennotifier3d 
  import py4godot.classes.Skeleton2D as py4godot_skeleton2d 
  import py4godot.classes.Joint3D as py4godot_joint3d 
  import py4godot.classes.Viewport as py4godot_viewport 
  import py4godot.classes.SubViewport as py4godot_subviewport 
  import py4godot.classes.SpotLight3D as py4godot_spotlight3d 
  import py4godot.classes.PopupPanel as py4godot_popuppanel 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.ModifierBoneTarget3D as py4godot_modifierbonetarget3d 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.SpringBoneCollisionCapsule3D as py4godot_springbonecollisioncapsule3d 
  import py4godot.classes.GridMapEditorPlugin as py4godot_gridmapeditorplugin 
  import py4godot.classes.ConeTwistJoint3D as py4godot_conetwistjoint3d 
  import py4godot.classes.PhysicalBoneSimulator3D as py4godot_physicalbonesimulator3d 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.NavigationRegion2D as py4godot_navigationregion2d 
  import py4godot.classes.OpenXRRenderModel as py4godot_openxrrendermodel 
  import py4godot.classes.TabBar as py4godot_tabbar 
  import py4godot.classes.CPUParticles3D as py4godot_cpuparticles3d 
  import py4godot.classes.Popup as py4godot_popup 
  import py4godot.classes.Resource as py4godot_resource 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.VisibleOnScreenEnabler2D as py4godot_visibleonscreenenabler2d 
  import py4godot.classes.XRCamera3D as py4godot_xrcamera3d 
  import py4godot.classes.NavigationRegion3D as py4godot_navigationregion3d 
  import py4godot.classes.AcceptDialog as py4godot_acceptdialog 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.AudioStreamPlayer3D as py4godot_audiostreamplayer3d 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.Node2D as py4godot_node2d 
  import py4godot.classes.AnimatedSprite2D as py4godot_animatedsprite2d 
  import py4godot.classes.Path2D as py4godot_path2d 
  import py4godot.classes.Parallax2D as py4godot_parallax2d 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.MultiMeshInstance3D as py4godot_multimeshinstance3d 
  import py4godot.classes.ConvertTransformModifier3D as py4godot_converttransformmodifier3d 
  import py4godot.classes.GeometryInstance3D as py4godot_geometryinstance3d 
  import py4godot.classes.SpringArm3D as py4godot_springarm3d 
  import py4godot.classes.LightmapGI as py4godot_lightmapgi 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.CSGBox3D as py4godot_csgbox3d 
  import py4godot.classes.RigidBody3D as py4godot_rigidbody3d 
  import py4godot.classes.ShapeCast3D as py4godot_shapecast3d 
  import py4godot.classes.TileMapLayer as py4godot_tilemaplayer 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.CollisionObject2D as py4godot_collisionobject2d 
  import py4godot.classes.Sprite3D as py4godot_sprite3d 
  import py4godot.classes.SoftBody3D as py4godot_softbody3d 
  import py4godot.classes.PopupMenu as py4godot_popupmenu 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.NavigationAgent3D as py4godot_navigationagent3d 
  import py4godot.classes.NavigationObstacle2D as py4godot_navigationobstacle2d 
  import py4godot.classes.OpenXRCompositionLayerQuad as py4godot_openxrcompositionlayerquad 
  import py4godot.classes.GPUParticlesAttractor3D as py4godot_gpuparticlesattractor3d 
  import py4godot.classes.CopyTransformModifier3D as py4godot_copytransformmodifier3d 
  import py4godot.classes.Path3D as py4godot_path3d 
  import py4godot.classes.Marker3D as py4godot_marker3d 
  import py4godot.classes.TabContainer as py4godot_tabcontainer 
  import py4godot.classes.DirectionalLight2D as py4godot_directionallight2d 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.VehicleBody3D as py4godot_vehiclebody3d 
  import py4godot.classes.SliderJoint3D as py4godot_sliderjoint3d 
  import py4godot.classes.CSGShape3D as py4godot_csgshape3d 
  import py4godot.classes.CPUParticles2D as py4godot_cpuparticles2d 
  import py4godot.classes.XRBodyModifier3D as py4godot_xrbodymodifier3d 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.OmniLight3D as py4godot_omnilight3d 
  import py4godot.classes.NodeTypedArray as py4godot_nodetypedarray 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.RemoteTransform2D as py4godot_remotetransform2d 
  import py4godot.classes.Node as py4godot_node 
  import py4godot.classes.TileMap as py4godot_tilemap 
  import py4godot.classes.Sprite2D as py4godot_sprite2d 
  import py4godot.classes.CSGPrimitive3D as py4godot_csgprimitive3d 
  import py4godot.classes.TextEdit as py4godot_textedit 
  import py4godot.classes.SkeletonModifier3D as py4godot_skeletonmodifier3d 
  import py4godot.classes.AnimatedSprite3D as py4godot_animatedsprite3d 
  import py4godot.classes.Line2D as py4godot_line2d 
  import py4godot.classes.Skeleton3D as py4godot_skeleton3d 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.VehicleWheel3D as py4godot_vehiclewheel3d 
  import py4godot.classes.PhysicalBone3D as py4godot_physicalbone3d 
  import py4godot.classes.Node3D as py4godot_node3d 
  import py4godot.classes.GraphElement as py4godot_graphelement 
  import py4godot.classes.VisibleOnScreenEnabler3D as py4godot_visibleonscreenenabler3d 
  import py4godot.classes.CollisionShape2D as py4godot_collisionshape2d 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.EditorPaths as py4godot_editorpaths 
  import py4godot.classes.SpringBoneSimulator3D as py4godot_springbonesimulator3d 
  import py4godot.classes.CanvasItem as py4godot_canvasitem 
  import py4godot.classes.CSGSphere3D as py4godot_csgsphere3d 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.CollisionShape3D as py4godot_collisionshape3d 
  import py4godot.classes.SpringBoneCollision3D as py4godot_springbonecollision3d 
  import py4godot.classes.GraphNode as py4godot_graphnode 
  import py4godot.classes.EditorCommandPalette as py4godot_editorcommandpalette 
  import py4godot.classes.OpenXRHand as py4godot_openxrhand 
  import py4godot.classes.GPUParticlesCollisionBox3D as py4godot_gpuparticlescollisionbox3d 
  import py4godot.classes.OpenXRRenderModelManager as py4godot_openxrrendermodelmanager 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.GPUParticlesAttractorVectorField3D as py4godot_gpuparticlesattractorvectorfield3d 
  import py4godot.classes.XRHandModifier3D as py4godot_xrhandmodifier3d 
  import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
  import py4godot.classes.Label3D as py4godot_label3d 
  import py4godot.classes.DampedSpringJoint2D as py4godot_dampedspringjoint2d 
  import py4godot.classes.GPUParticlesCollision3D as py4godot_gpuparticlescollision3d 
  import py4godot.classes.Light3D as py4godot_light3d 
  import py4godot.classes.CollisionPolygon3D as py4godot_collisionpolygon3d 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.PhysicalBone2D as py4godot_physicalbone2d 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.MultiplayerSpawner as py4godot_multiplayerspawner 
  import py4godot.classes.Joint2D as py4godot_joint2d 
  import py4godot.classes.NavigationAgent2D as py4godot_navigationagent2d 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.FoldableContainer as py4godot_foldablecontainer 
  import py4godot.classes.MultiMeshInstance2D as py4godot_multimeshinstance2d 
  import py4godot.classes.GPUParticlesCollisionHeightField3D as py4godot_gpuparticlescollisionheightfield3d 
  import py4godot.classes.XRNode3D as py4godot_xrnode3d 
  import py4godot.classes.ParallaxLayer as py4godot_parallaxlayer 
  import py4godot.classes.DirectionalLight3D as py4godot_directionallight3d 
  import py4godot.classes.Area3D as py4godot_area3d 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.RootMotionView as py4godot_rootmotionview 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.EditorSelection as py4godot_editorselection 
  import py4godot.classes.Camera2D as py4godot_camera2d 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.AudioStreamPlayer as py4godot_audiostreamplayer 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
import py4godot.classes.Texture2DTypedArray as py4godot_texture2dtypedarray 
import py4godot.classes.MeshTypedArray as py4godot_meshtypedarray 
import py4godot.classes.NodeTypedArray as py4godot_nodetypedarray 
import py4godot.classes.Object as py4godot_object 
import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
from py4godot.wrappers.wrappers import CPPEditorInterfaceWrapper

_EditorInterface_singleton_instance = None

class EditorInterface(py4godot_object.Object):
  r'''
		`EditorInterface` gives you control over Godot editor's window. It allows customizing the window, saving and (re-)loading scenes, rendering mesh previews, inspecting and editing resources and objects, and provides access to `EditorSettings`, `EditorFileSystem`, `EditorResourcePreview`, `ScriptEditor`, the editor viewport, and information about scenes.
		**Note:** This class shouldn't be instantiated directly. Instead, access the singleton directly by its name.
		
		```gdscript
		var editor_settings = EditorInterface.get_editor_settings()
		```
		
		
	'''


  def generate_wrapper(self):
    return CPPEditorInterfaceWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = EditorInterface.__new__(EditorInterface)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorInterface'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorInterface.construct_without_init()
    cls._ptr = CPPEditorInterfaceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorInterface.construct_without_init()
    cls._ptr = CPPEditorInterfaceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _EditorInterface_singleton_instance
    if _EditorInterface_singleton_instance is None:
      singleton = EditorInterface()
      singleton._ptr = constructor(291,0, ())
      _EditorInterface_singleton_instance = singleton
    return _EditorInterface_singleton_instance

  @property
  def distraction_free_mode(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_distraction_free_mode_enabled()
    return _ret
  @distraction_free_mode.setter
  def distraction_free_mode(self,  value:'bool'):
    self.set_distraction_free_mode(value)
  @property
  def movie_maker_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_movie_maker_enabled()
    return _ret
  @movie_maker_enabled.setter
  def movie_maker_enabled(self,  value:'bool'):
    self.set_movie_maker_enabled(value)
  @functools.native_method
  def restart_editor(self, save:'bool' =True  ) -> None:
    r'''
				Restarts the editor. This closes the editor and then opens the same project. If `save` is `true`, the project will be saved before restarting.
			'''

    assert isinstance(save, bool), 'save must be bool'







    self._ptr.call_with_return(49,tuple([save]))

  @functools.native_method
  def get_command_palette(self) -> typing.Union['py4godot_editorcommandpalette.EditorCommandPalette']:
    r'''
				Returns the editor's `EditorCommandPalette` instance.
				**Warning:** Removing and freeing this node will render a part of the editor useless and may cause a crash.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: EditorCommandPalette
    _ret._ptr = self._ptr.call_with_return(50,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_resource_filesystem(self) -> typing.Union['py4godot_editorfilesystem.EditorFileSystem']:
    r'''
				Returns the editor's `EditorFileSystem` instance.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: EditorFileSystem
    _ret._ptr = self._ptr.call_with_return(51,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_editor_paths(self) -> typing.Union['py4godot_editorpaths.EditorPaths']:
    r'''
				Returns the `EditorPaths` singleton.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: EditorPaths
    _ret._ptr = self._ptr.call_with_return(52,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_resource_previewer(self) -> typing.Union['py4godot_editorresourcepreview.EditorResourcePreview']:
    r'''
				Returns the editor's `EditorResourcePreview` instance.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: EditorResourcePreview
    _ret._ptr = self._ptr.call_with_return(53,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_selection(self) -> typing.Union['py4godot_editorselection.EditorSelection']:
    r'''
				Returns the editor's `EditorSelection` instance.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: EditorSelection
    _ret._ptr = self._ptr.call_with_return(54,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_editor_settings(self) -> typing.Union['py4godot_editorsettings.EditorSettings']:
    r'''
				Returns the editor's `EditorSettings` instance.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: EditorSettings
    _ret._ptr = self._ptr.call_with_return(55,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_editor_toaster(self) -> typing.Union['py4godot_editortoaster.EditorToaster']:
    r'''
				Returns the editor's `EditorToaster`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: EditorToaster
    _ret._ptr = self._ptr.call_with_return(56,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_editor_undo_redo(self) -> typing.Union['py4godot_editorundoredomanager.EditorUndoRedoManager']:
    r'''
				Returns the editor's `EditorUndoRedoManager`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: EditorUndoRedoManager
    _ret._ptr = self._ptr.call_with_return(57,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def make_mesh_previews(self, meshes:'py4godot_meshtypedarray.MeshTypedArray'   , preview_size:'int'   ) -> typing.Union['py4godot_texture2dtypedarray.Texture2DTypedArray']:
    r'''
				Returns mesh previews rendered at the given size as an `Array` of `Texture2D`s.
			'''

    assert isinstance(meshes, Array), 'meshes must be Array'
    assert isinstance(preview_size, (int, float)), 'preview_size must be int or float'








    _ret = py4godot_texture2dtypedarray.Texture2DTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([meshes._ptr, preview_size]))
    return _ret


  @functools.native_method
  def set_plugin_enabled(self, plugin:'str'   , enabled:'bool'   ) -> None:
    r'''
				Sets the enabled status of a plugin. The plugin name is the same as its directory name.
			'''

    assert(not plugin is None)
    assert isinstance(plugin, (str, String)), 'plugin must be str or String'
    assert isinstance(enabled, bool), 'enabled must be bool'





    assert(isinstance(plugin, (str, String)))
    py_string_plugin = plugin if isinstance(plugin, StringName) else c_utils.py_string_to_string(plugin)


    self._ptr.call_with_return(59,tuple([py_string_plugin._ptr, enabled]))

  @functools.native_method
  def is_plugin_enabled(self, plugin:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified `plugin` is enabled. The plugin name is the same as its directory name.
			'''

    assert(not plugin is None)
    assert isinstance(plugin, (str, String)), 'plugin must be str or String'





    assert(isinstance(plugin, (str, String)))
    py_string_plugin = plugin if isinstance(plugin, StringName) else c_utils.py_string_to_string(plugin)

    _ret = 0
    _ret = self._ptr.call_with_return(60,tuple([py_string_plugin._ptr]))
    return _ret


  @functools.native_method
  def get_editor_theme(self) -> typing.Union['py4godot_theme.Theme']:
    r'''
				Returns the editor's `Theme`.
				**Note:** When creating custom editor UI, prefer accessing theme items directly from your GUI nodes using the `get_theme_*` methods.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Theme
    _ret._ptr = self._ptr.call_with_return(61,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_base_control(self) -> typing.Any:
    r'''
				Returns the main container of Godot editor's window. For example, you can use it to retrieve the size of the container and place your controls accordingly.
				**Warning:** Removing and freeing this node will render the editor useless and may cause a crash.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Control
    _ret._ptr = self._ptr.call_with_return(62,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_editor_main_screen(self) -> typing.Union['py4godot_vboxcontainer.VBoxContainer','py4godot_colorpicker.ColorPicker','py4godot_filesystemdock.FileSystemDock','py4godot_scripteditorbase.ScriptEditorBase']:
    r'''
				Returns the editor control responsible for main screen plugins and tools. Use it with plugins that implement `EditorPlugin._has_main_screen`.
				**Note:** This node is a `VBoxContainer`, which means that if you add a `Control` child to it, you need to set the child's `Control.size_flags_vertical` to `constant Control.SIZE_EXPAND_FILL` to make it use the full available space.
				**Warning:** Removing and freeing this node will render a part of the editor useless and may cause a crash.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: VBoxContainer
    _ret._ptr = self._ptr.call_with_return(63,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_script_editor(self) -> typing.Union['py4godot_scripteditor.ScriptEditor']:
    r'''
				Returns the editor's `ScriptEditor` instance.
				**Warning:** Removing and freeing this node will render a part of the editor useless and may cause a crash.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: ScriptEditor
    _ret._ptr = self._ptr.call_with_return(64,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_editor_viewport_2d(self) -> typing.Union['py4godot_subviewport.SubViewport']:
    r'''
				Returns the 2D editor `SubViewport`. It does not have a camera. Instead, the view transforms are done directly and can be accessed with `Viewport.global_canvas_transform`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: SubViewport
    _ret._ptr = self._ptr.call_with_return(65,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_editor_viewport_3d(self, idx:'int' =0  ) -> typing.Union['py4godot_subviewport.SubViewport']:
    r'''
				Returns the specified 3D editor `SubViewport`, from `0` to `3`. The viewport can be used to access the active editor cameras with `Viewport.get_camera_3d`.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: SubViewport
    _ret._ptr = self._ptr.call_with_return(66,tuple([idx]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_main_screen_editor(self, name:'str'   ) -> None:
    r'''
				Sets the editor's current main screen to the one specified in `name`. `name` must match the title of the tab in question exactly (e.g. `2D`, `3D`, `code skip-lint`Script`, `Game`, or `AssetLib` for default tabs).
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(67,tuple([py_string_name._ptr]))

  @functools.native_method
  def set_distraction_free_mode(self, enter:'bool'   ) -> None:
    r''''''

    assert isinstance(enter, bool), 'enter must be bool'


    self.py__distraction_free_mode = enter






    self._ptr.call_with_return(68,tuple([enter]))

  @functools.native_method
  def is_distraction_free_mode_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(69,tuple([]))

    return _ret


  @functools.native_method
  def is_multi_window_enabled(self) -> typing.Union[bool]:
    r'''
				Returns `true` if multiple window support is enabled in the editor. Multiple window support is enabled if _all_ of these statements are true:
				- `EditorSettings.interface/multi_window/enable` is `true`.
				- `EditorSettings.interface/editor/single_window_mode` is `false`.
				- `Viewport.gui_embed_subwindows` is `false`. This is forced to `true` on platforms that don't support multiple windows such as Web, or when the `--single-window` `url=$DOCS_URL/tutorials/editor/command_line_tutorial.html`command line argument`/url` is used.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(70,tuple([]))
    return _ret


  @functools.native_method
  def get_editor_scale(self) -> typing.Union[float]:
    r'''
				Returns the actual scale of the editor UI (`1.0` being 100% scale). This can be used to adjust position and dimensions of the UI added by plugins.
				**Note:** This value is set via the `EditorSettings.interface/editor/display_scale` and `EditorSettings.interface/editor/custom_display_scale` settings. The editor must be restarted for changes to be properly applied.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(71,tuple([]))
    return _ret


  @functools.native_method
  def popup_dialog(self, dialog:'py4godot_window.Window'   , rect:'Rect2i' = None  ) -> None:
    r'''
				Pops up the `dialog` in the editor UI with `Window.popup_exclusive`. The dialog must have no current parent, otherwise the method fails.
				See also `Window.set_unparent_when_invisible`.
			'''
    if rect is None:
      rect = Rect2i.new0()

    assert(not dialog is None)
    assert isinstance(dialog, get_class('Window')), 'dialog must be Window'








    self._ptr.call_with_return(72,tuple([dialog._ptr, rect._ptr]))

  @functools.native_method
  def popup_dialog_centered(self, dialog:'py4godot_window.Window'   , minsize:'Vector2i' = None  ) -> None:
    r'''
				Pops up the `dialog` in the editor UI with `Window.popup_exclusive_centered`. The dialog must have no current parent, otherwise the method fails.
				See also `Window.set_unparent_when_invisible`.
			'''
    if minsize is None:
      minsize = Vector2i.new0()

    assert(not dialog is None)
    assert isinstance(dialog, get_class('Window')), 'dialog must be Window'








    self._ptr.call_with_return(73,tuple([dialog._ptr, minsize._ptr]))

  @functools.native_method
  def popup_dialog_centered_ratio(self, dialog:'py4godot_window.Window'   , ratio:'float' =0.8  ) -> None:
    r'''
				Pops up the `dialog` in the editor UI with `Window.popup_exclusive_centered_ratio`. The dialog must have no current parent, otherwise the method fails.
				See also `Window.set_unparent_when_invisible`.
			'''

    assert(not dialog is None)
    assert isinstance(dialog, get_class('Window')), 'dialog must be Window'
    assert isinstance(ratio, (int, float)), 'ratio must be int or float'








    self._ptr.call_with_return(74,tuple([dialog._ptr, ratio]))

  @functools.native_method
  def popup_dialog_centered_clamped(self, dialog:'py4godot_window.Window'   , minsize:'Vector2i' = None  , fallback_ratio:'float' =0.75  ) -> None:
    r'''
				Pops up the `dialog` in the editor UI with `Window.popup_exclusive_centered_clamped`. The dialog must have no current parent, otherwise the method fails.
				See also `Window.set_unparent_when_invisible`.
			'''
    if minsize is None:
      minsize = Vector2i.new0()

    assert(not dialog is None)
    assert isinstance(dialog, get_class('Window')), 'dialog must be Window'
    assert isinstance(fallback_ratio, (int, float)), 'fallback_ratio must be int or float'









    self._ptr.call_with_return(75,tuple([dialog._ptr, minsize._ptr, fallback_ratio]))

  @functools.native_method
  def get_current_feature_profile(self) -> typing.Union[str]:
    r'''
				Returns the name of the currently activated feature profile. If the default profile is currently active, an empty string is returned instead.
				In order to get a reference to the `EditorFeatureProfile`, you must load the feature profile using `EditorFeatureProfile.load_from_file`.
				**Note:** Feature profiles created via the user interface are loaded from the `feature_profiles` directory, as a file with the `.profile` extension. The editor configuration folder can be found by using `EditorPaths.get_config_dir`.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(76,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_current_feature_profile(self, profile_name:'str'   ) -> None:
    r'''
				Selects and activates the specified feature profile with the given `profile_name`. Set `profile_name` to an empty string to reset to the default feature profile.
				A feature profile can be created programmatically using the `EditorFeatureProfile` class.
				**Note:** The feature profile that gets activated must be located in the `feature_profiles` directory, as a file with the `.profile` extension. If a profile could not be found, an error occurs. The editor configuration folder can be found by using `EditorPaths.get_config_dir`.
			'''

    assert(not profile_name is None)
    assert isinstance(profile_name, (str, String)), 'profile_name must be str or String'





    assert(isinstance(profile_name, (str, String)))
    py_string_profile_name = profile_name if isinstance(profile_name, StringName) else c_utils.py_string_to_string(profile_name)

    self._ptr.call_with_return(77,tuple([py_string_profile_name._ptr]))

  @functools.native_method
  def popup_node_selector(self, callback:'Callable'   , valid_types:'py4godot_stringnametypedarray.StringNameTypedArray' = None  , current_value:'py4godot_node.Node' = None  ) -> None:
    r'''
				Pops up an editor dialog for selecting a `Node` from the edited scene. The `callback` must take a single argument of type `NodePath`. It is called on the selected `NodePath` or the empty path `^""` if the dialog is canceled. If `valid_types` is provided, the dialog will only show Nodes that match one of the listed Node types. If `current_value` is provided, the Node will be automatically selected in the tree, if it exists.
				**Example:** Display the node selection dialog as soon as this node is added to the tree for the first time:
				```gdscript
				func _ready():
					if Engine.is_editor_hint():
						EditorInterface.popup_node_selector(_on_node_selected, `"Button"`)

				func _on_node_selected(node_path):
					if node_path.is_empty():
						print("node selection canceled")
					else:
						print("selected ", node_path)
				```
			'''

    if current_value is None:
      current_value = c_utils.empty_object

    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'
    assert isinstance(valid_types, Array), 'valid_types must be Array'









    self._ptr.call_with_return(78,tuple([callback._ptr, valid_types._ptr, current_value._ptr]))

  @functools.native_method
  def popup_property_selector(self, object_:'py4godot_object.Object'   , callback:'Callable'   , type_filter:'PackedInt32Array' = None  , current_value:'str' =""  ) -> None:
    r'''
				Pops up an editor dialog for selecting properties from `object`. The `callback` must take a single argument of type `NodePath`. It is called on the selected property path (see `NodePath.get_as_property_path`) or the empty path `^""` if the dialog is canceled. If `type_filter` is provided, the dialog will only show properties that match one of the listed `enum Variant.Type` values. If `current_value` is provided, the property will be selected automatically in the property list, if it exists.
				```gdscript
				func _ready():
					if Engine.is_editor_hint():
						EditorInterface.popup_property_selector(this, _on_property_selected, `TYPE_INT`)

				func _on_property_selected(property_path):
					if property_path.is_empty():
						print("property selection canceled")
					else:
						print("selected ", property_path)
				```
			'''
    if type_filter is None:
      type_filter = PackedInt32Array.new0()
    if current_value is None:
      current_value = String.new0()

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'








    assert(isinstance(current_value, (str, String)))
    py_string_current_value = current_value if isinstance(current_value, StringName) else c_utils.py_string_to_string(current_value)

    self._ptr.call_with_return(79,tuple([object_._ptr, callback._ptr, type_filter._ptr, py_string_current_value._ptr]))

  @functools.native_method
  def popup_method_selector(self, object_:'py4godot_object.Object'   , callback:'Callable'   , current_value:'str' =""  ) -> None:
    r'''
				Pops up an editor dialog for selecting a method from `object`. The `callback` must take a single argument of type `String` which will contain the name of the selected method or be empty if the dialog is canceled. If `current_value` is provided, the method will be selected automatically in the method list, if it exists.
			'''
    if current_value is None:
      current_value = String.new0()

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'







    assert(isinstance(current_value, (str, String)))
    py_string_current_value = current_value if isinstance(current_value, StringName) else c_utils.py_string_to_string(current_value)

    self._ptr.call_with_return(80,tuple([object_._ptr, callback._ptr, py_string_current_value._ptr]))

  @functools.native_method
  def popup_quick_open(self, callback:'Callable'   , base_types:'py4godot_stringnametypedarray.StringNameTypedArray' = None  ) -> None:
    r'''
				Pops up an editor dialog for quick selecting a resource file. The `callback` must take a single argument of type `String` which will contain the path of the selected resource or be empty if the dialog is canceled. If `base_types` is provided, the dialog will only show resources that match these types. Only types deriving from `Resource` are supported.
			'''


    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'
    assert isinstance(base_types, Array), 'base_types must be Array'








    self._ptr.call_with_return(81,tuple([callback._ptr, base_types._ptr]))

  @functools.native_method
  def popup_create_dialog(self, callback:'Callable'   , base_type:'object' = None  , current_type:'str' =""  , dialog_title:'str' =""  , type_blocklist:'py4godot_stringnametypedarray.StringNameTypedArray' = None  ) -> None:
    r'''
				Pops up an editor dialog for creating an object.
				The `callback` must take a single argument of type `String`, which will contain the type name of the selected object (or the script path of the type, if the type is created from a script), or be an empty string if no item is selected.
				The `base_type` specifies the base type of objects to display. For example, if you set this to "Resource", all types derived from `Resource` will display in the create dialog.
				The `current_type` will be passed in the search box of the create dialog, and the specified type can be immediately selected when the dialog pops up. If the `current_type` is not derived from `base_type`, there will be no result of the type in the dialog.
				The `dialog_title` allows you to define a custom title for the dialog. This is useful if you want to accurately hint the usage of the dialog. If the `dialog_title` is an empty string, the dialog will use "Create New 'Base Type'" as the default title.
				The `type_blocklist` contains a list of type names, and the types in the blocklist will be hidden from the create dialog.
				**Note:** Trying to list the base type in the `type_blocklist` will hide all types derived from the base type from the create dialog.
			'''
    if base_type is None:
      base_type = StringName.new0()
    if current_type is None:
      current_type = String.new0()
    if dialog_title is None:
      dialog_title = String.new0()


    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'
    assert isinstance(type_blocklist, Array), 'type_blocklist must be Array'






    assert(isinstance(base_type, (str, StringName)))
    py_stringname_base_type = base_type if isinstance(base_type, StringName) else c_utils.py_string_to_string_name(base_type)
    assert(isinstance(current_type, (str, String)))
    py_string_current_type = current_type if isinstance(current_type, StringName) else c_utils.py_string_to_string(current_type)
    assert(isinstance(dialog_title, (str, String)))
    py_string_dialog_title = dialog_title if isinstance(dialog_title, StringName) else c_utils.py_string_to_string(dialog_title)


    self._ptr.call_with_return(82,tuple([callback._ptr, py_stringname_base_type._ptr, py_string_current_type._ptr, py_string_dialog_title._ptr, type_blocklist._ptr]))

  @functools.native_method
  def get_file_system_dock(self) -> typing.Union['py4godot_filesystemdock.FileSystemDock']:
    r'''
				Returns the editor's `FileSystemDock` instance.
				**Warning:** Removing and freeing this node will render a part of the editor useless and may cause a crash.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: FileSystemDock
    _ret._ptr = self._ptr.call_with_return(83,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def select_file(self, file:'str'   ) -> None:
    r'''
				Selects the file, with the path provided by `file`, in the FileSystem dock.
			'''

    assert(not file is None)
    assert isinstance(file, (str, String)), 'file must be str or String'





    assert(isinstance(file, (str, String)))
    py_string_file = file if isinstance(file, StringName) else c_utils.py_string_to_string(file)

    self._ptr.call_with_return(84,tuple([py_string_file._ptr]))

  @functools.native_method
  def get_selected_paths(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns an array containing the paths of the currently selected files (and directories) in the `FileSystemDock`.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(85,tuple([]))
    return _ret


  @functools.native_method
  def get_current_path(self) -> typing.Union[str]:
    r'''
				Returns the current path being viewed in the `FileSystemDock`.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_current_directory(self) -> typing.Union[str]:
    r'''
				Returns the current directory being viewed in the `FileSystemDock`. If a file is selected, its base directory will be returned using `String.get_base_dir` instead.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_inspector(self) -> typing.Union['py4godot_editorinspector.EditorInspector']:
    r'''
				Returns the editor's `EditorInspector` instance.
				**Warning:** Removing and freeing this node will render a part of the editor useless and may cause a crash.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: EditorInspector
    _ret._ptr = self._ptr.call_with_return(88,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def inspect_object(self, object_:'py4godot_object.Object'   , for_property:'str' =""  , inspector_only:'bool' =False  ) -> None:
    r'''
				Shows the given property on the given `object` in the editor's Inspector dock. If `inspector_only` is `true`, plugins will not attempt to edit `object`.
			'''
    if for_property is None:
      for_property = String.new0()

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert isinstance(inspector_only, bool), 'inspector_only must be bool'






    assert(isinstance(for_property, (str, String)))
    py_string_for_property = for_property if isinstance(for_property, StringName) else c_utils.py_string_to_string(for_property)


    self._ptr.call_with_return(89,tuple([object_._ptr, py_string_for_property._ptr, inspector_only]))

  @functools.native_method
  def edit_resource(self, resource:'py4godot_resource.Resource'   ) -> None:
    r'''
				Edits the given `Resource`. If the resource is a `Script` you can also edit it with `edit_script` to specify the line and column position.
			'''

    assert(not resource is None)
    assert isinstance(resource, get_class('Resource')), 'resource must be Resource'







    self._ptr.call_with_return(90,tuple([resource._ptr]))

  @functools.native_method
  def edit_node(self, node:'py4godot_node.Node'   ) -> None:
    r'''
				Edits the given `Node`. The node will be also selected if it's inside the scene tree.
			'''

    assert(not node is None)
    assert isinstance(node, get_class('Node')), 'node must be Node'







    self._ptr.call_with_return(91,tuple([node._ptr]))

  @functools.native_method
  def edit_script(self, script:'py4godot_script.Script'   , line:'int' =-1  , column:'int' =0  , grab_focus:'bool' =True  ) -> None:
    r'''
				Edits the given `Script`. The line and column on which to open the script can also be specified. The script will be open with the user-configured editor for the script's language which may be an external editor.
			'''

    assert(not script is None)
    assert isinstance(script, get_class('Script')), 'script must be Script'
    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(grab_focus, bool), 'grab_focus must be bool'










    self._ptr.call_with_return(92,tuple([script._ptr, line, column, grab_focus]))

  @functools.native_method
  def open_scene_from_path(self, scene_filepath:'str'   , set_inherited:'bool' =False  ) -> None:
    r'''
				Opens the scene at the given path. If `set_inherited` is `true`, creates a new inherited scene.
			'''

    assert(not scene_filepath is None)
    assert isinstance(scene_filepath, (str, String)), 'scene_filepath must be str or String'
    assert isinstance(set_inherited, bool), 'set_inherited must be bool'





    assert(isinstance(scene_filepath, (str, String)))
    py_string_scene_filepath = scene_filepath if isinstance(scene_filepath, StringName) else c_utils.py_string_to_string(scene_filepath)


    self._ptr.call_with_return(93,tuple([py_string_scene_filepath._ptr, set_inherited]))

  @functools.native_method
  def reload_scene_from_path(self, scene_filepath:'str'   ) -> None:
    r'''
				Reloads the scene at the given path.
			'''

    assert(not scene_filepath is None)
    assert isinstance(scene_filepath, (str, String)), 'scene_filepath must be str or String'





    assert(isinstance(scene_filepath, (str, String)))
    py_string_scene_filepath = scene_filepath if isinstance(scene_filepath, StringName) else c_utils.py_string_to_string(scene_filepath)

    self._ptr.call_with_return(94,tuple([py_string_scene_filepath._ptr]))

  @functools.native_method
  def get_open_scenes(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns an array with the file paths of the currently opened scenes.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(95,tuple([]))
    return _ret


  @functools.native_method
  def get_open_scene_roots(self) -> typing.Union['py4godot_nodetypedarray.NodeTypedArray']:
    r'''
				Returns an array with references to the root nodes of the currently opened scenes.
			'''




    _ret = py4godot_nodetypedarray.NodeTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([]))
    return _ret


  @functools.native_method
  def get_edited_scene_root(self) -> typing.Any:
    r'''
				Returns the edited (current) scene's root `Node`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Node
    _ret._ptr = self._ptr.call_with_return(97,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def save_scene(self) -> typing.Union[int]:
    r'''
				Saves the currently active scene. Returns either `constant OK` or `constant ERR_CANT_CREATE`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(98,tuple([]))
    return _ret


  @functools.native_method
  def save_scene_as(self, path:'str'   , with_preview:'bool' =True  ) -> None:
    r'''
				Saves the currently active scene as a file at `path`.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(with_preview, bool), 'with_preview must be bool'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)


    self._ptr.call_with_return(99,tuple([py_string_path._ptr, with_preview]))

  @functools.native_method
  def save_all_scenes(self) -> None:
    r'''
				Saves all opened scenes in the editor.
			'''




    self._ptr.call_with_return(100,tuple([]))

  @functools.native_method
  def close_scene(self) -> typing.Union[int]:
    r'''
				Closes the currently active scene, discarding any pending changes in the process. Returns `constant OK` on success or `constant ERR_DOES_NOT_EXIST` if there is no scene to close.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(101,tuple([]))
    return _ret


  @functools.native_method
  def mark_scene_as_unsaved(self) -> None:
    r'''
				Marks the current scene tab as unsaved.
			'''




    self._ptr.call_with_return(102,tuple([]))

  @functools.native_method
  def play_main_scene(self) -> None:
    r'''
				Plays the main scene.
			'''




    self._ptr.call_with_return(103,tuple([]))

  @functools.native_method
  def play_current_scene(self) -> None:
    r'''
				Plays the currently active scene.
			'''




    self._ptr.call_with_return(104,tuple([]))

  @functools.native_method
  def play_custom_scene(self, scene_filepath:'str'   ) -> None:
    r'''
				Plays the scene specified by its filepath.
			'''

    assert(not scene_filepath is None)
    assert isinstance(scene_filepath, (str, String)), 'scene_filepath must be str or String'





    assert(isinstance(scene_filepath, (str, String)))
    py_string_scene_filepath = scene_filepath if isinstance(scene_filepath, StringName) else c_utils.py_string_to_string(scene_filepath)

    self._ptr.call_with_return(105,tuple([py_string_scene_filepath._ptr]))

  @functools.native_method
  def stop_playing_scene(self) -> None:
    r'''
				Stops the scene that is currently playing.
			'''




    self._ptr.call_with_return(106,tuple([]))

  @functools.native_method
  def is_playing_scene(self) -> typing.Union[bool]:
    r'''
				Returns `true` if a scene is currently being played, `false` otherwise. Paused scenes are considered as being played.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(107,tuple([]))
    return _ret


  @functools.native_method
  def get_playing_scene(self) -> typing.Union[str]:
    r'''
				Returns the name of the scene that is being played. If no scene is currently being played, returns an empty string.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(108,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_movie_maker_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__movie_maker_enabled = enabled






    self._ptr.call_with_return(109,tuple([enabled]))

  @functools.native_method
  def is_movie_maker_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(110,tuple([]))

    return _ret



register_cast_function('EditorInterface', EditorInterface.cast)
register_class('EditorInterface', EditorInterface)
