# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.SubtweenTweener as py4godot_subtweentweener 
  import py4godot.classes.Node as py4godot_node 
  import py4godot.classes.CallbackTweener as py4godot_callbacktweener 
  import py4godot.classes.Object as py4godot_object 
  import py4godot.classes.IntervalTweener as py4godot_intervaltweener 
  import py4godot.classes.PropertyTweener as py4godot_propertytweener 
  import py4godot.classes.MethodTweener as py4godot_methodtweener 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPTweenWrapper

class TweenProcessMode:
  TWEEN_PROCESS_PHYSICS = 0
  TWEEN_PROCESS_IDLE = 1
class TweenPauseMode:
  TWEEN_PAUSE_BOUND = 0
  TWEEN_PAUSE_STOP = 1
  TWEEN_PAUSE_PROCESS = 2
class TransitionType:
  TRANS_LINEAR = 0
  TRANS_SINE = 1
  TRANS_QUINT = 2
  TRANS_QUART = 3
  TRANS_QUAD = 4
  TRANS_EXPO = 5
  TRANS_ELASTIC = 6
  TRANS_CUBIC = 7
  TRANS_CIRC = 8
  TRANS_BOUNCE = 9
  TRANS_BACK = 10
  TRANS_SPRING = 11
class EaseType:
  EASE_IN = 0
  EASE_OUT = 1
  EASE_IN_OUT = 2
  EASE_OUT_IN = 3


class Tween(py4godot_refcounted.RefCounted):
  r'''
		Tweens are mostly useful for animations requiring a numerical property to be interpolated over a range of values. The name _tween_ comes from _in-betweening_, an animation technique where you specify _keyframes_ and the computer interpolates the frames that appear between them. Animating something with a `Tween` is called tweening.
		`Tween` is more suited than `AnimationPlayer` for animations where you don't know the final values in advance. For example, interpolating a dynamically-chosen camera zoom value is best done with a `Tween`; it would be difficult to do the same thing with an `AnimationPlayer` node. Tweens are also more light-weight than `AnimationPlayer`, so they are very much suited for simple animations or general tasks that don't require visual tweaking provided by the editor. They can be used in a "fire-and-forget" manner for some logic that normally would be done by code. You can e.g. make something shoot periodically by using a looped `CallbackTweener` with a delay.
		A `Tween` can be created by using either `SceneTree.create_tween` or `Node.create_tween`. `Tween`s created manually (i.e. by using `Tween.new()`) are invalid and can't be used for tweening values.
		A tween animation is created by adding `Tweener`s to the `Tween` object, using `tween_property`, `tween_interval`, `tween_callback` or `tween_method`:
		
		```gdscript
		var tween = get_tree().create_tween()
		tween.tween_property($Sprite, "modulate", Color.RED, 1.0)
		tween.tween_property($Sprite, "scale", Vector2(), 1.0)
		tween.tween_callback($Sprite.queue_free)
		```
		
		
		This sequence will make the `$Sprite` node turn red, then shrink, before finally calling `Node.queue_free` to free the sprite. `Tweener`s are executed one after another by default. This behavior can be changed using `parallel` and `set_parallel`.
		When a `Tweener` is created with one of the `tween_*` methods, a chained method call can be used to tweak the properties of this `Tweener`. For example, if you want to set a different transition type in the above example, you can use `set_trans`:
		
		```gdscript
		var tween = get_tree().create_tween()
		tween.tween_property($Sprite, "modulate", Color.RED, 1.0).set_trans(Tween.TRANS_SINE)
		tween.tween_property($Sprite, "scale", Vector2(), 1.0).set_trans(Tween.TRANS_BOUNCE)
		tween.tween_callback($Sprite.queue_free)
		```
		
		
		Most of the `Tween` methods can be chained this way too. In the following example the `Tween` is bound to the running script's node and a default transition is set for its `Tweener`s:
		
		```gdscript
		var tween = get_tree().create_tween().bind_node(self).set_trans(Tween.TRANS_ELASTIC)
		tween.tween_property($Sprite, "modulate", Color.RED, 1.0)
		tween.tween_property($Sprite, "scale", Vector2(), 1.0)
		tween.tween_callback($Sprite.queue_free)
		```
		
		
		Another interesting use for `Tween`s is animating arbitrary sets of objects:
		
		```gdscript
		var tween = create_tween()
		for sprite in get_children():
			tween.tween_property(sprite, "position", Vector2(0, 0), 1.0)
		```
		
		
		In the example above, all children of a node are moved one after another to position `(0, 0)`.
		You should avoid using more than one `Tween` per object's property. If two or more tweens animate one property at the same time, the last one created will take priority and assign the final value. If you want to interrupt and restart an animation, consider assigning the `Tween` to a variable:
		
		```gdscript
		var tween
		func animate():
			if tween:
				tween.kill() # Abort the previous animation.
			tween = create_tween()
		```
		
		
		Some `Tweener`s use transitions and eases. The first accepts a `enum TransitionType` constant, and refers to the way the timing of the animation is handled (see `url=https://easings.net/`easings.net`/url` for some examples). The second accepts an `enum EaseType` constant, and controls where the `trans_type` is applied to the interpolation (in the beginning, the end, or both). If you don't know which transition and easing to pick, you can try different `enum TransitionType` constants with `constant EASE_IN_OUT`, and use the one that looks best.
		`url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/tween_cheatsheet.webp`Tween easing and transition types cheatsheet`/url`
		**Note:** Tweens are not designed to be reused and trying to do so results in an undefined behavior. Create a new Tween for each animation and every time you replay an animation from start. Keep in mind that Tweens start immediately, so only create a Tween when you want to start animating.
		**Note:** The tween is processed after all of the nodes in the current frame, i.e. node's `Node._process` method would be called before the tween (or `Node._physics_process` depending on the value passed to `set_process_mode`).
	'''

  @staticmethod
  def constructor():
    class_ = Tween.construct_without_init()
    class_._ptr = constructor(853,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Tween.construct_without_init()
    class_._ptr = constructor(853,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTweenWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(853,0, ())


  def generate_wrapper(self):
    return CPPTweenWrapper()
  def init_signals(self):
    super().init_signals()
    step_finished_name = utils.py_string_to_string_name("step_finished")
    self.step_finished = signals.BuiltinSignal(self, step_finished_name)
    loop_finished_name = utils.py_string_to_string_name("loop_finished")
    self.loop_finished = signals.BuiltinSignal(self, loop_finished_name)
    finished_name = utils.py_string_to_string_name("finished")
    self.finished = signals.BuiltinSignal(self, finished_name)

  @staticmethod
  def construct_without_init():
    cls = Tween.__new__(Tween)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Tween'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(78, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Tween.construct_without_init()
    cls._ptr = CPPTweenWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Tween.construct_without_init()
    cls._ptr = CPPTweenWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def tween_property(self, object_:'py4godot_object.Object'   , property:'object'   , final_val:'object'   , duration:'float'   ) -> typing.Union['py4godot_propertytweener.PropertyTweener']:
    r'''
				Creates and appends a `PropertyTweener`. This method tweens a `property` of an `object` between an initial value and `final_val` in a span of time equal to `duration`, in seconds. The initial value by default is the property's value at the time the tweening of the `PropertyTweener` starts.
				
				```gdscript
				var tween = create_tween()
				tween.tween_property($Sprite, "position", Vector2(100, 200), 1.0)
				tween.tween_property($Sprite, "position", Vector2(200, 300), 1.0)
				```
				
				
				will move the sprite to position (100, 200) and then to (200, 300). If you use `PropertyTweener.from` or `PropertyTweener.from_current`, the starting position will be overwritten by the given value instead. See other methods in `PropertyTweener` to see how the tweening can be tweaked further.
				**Note:** You can find the correct property name by hovering over the property in the Inspector. You can also provide the components of a property directly by using `"property:component"` (eg. `position:x`), where it would only apply to that particular component.
				**Example:** Moving an object twice from the same position, with different transition types:
				
				```gdscript
				var tween = create_tween()
				tween.tween_property($Sprite, "position", Vector2.RIGHT * 300, 1.0).as_relative().set_trans(Tween.TRANS_SINE)
				tween.tween_property($Sprite, "position", Vector2.RIGHT * 300, 1.0).as_relative().from_current().set_trans(Tween.TRANS_EXPO)
				```
				
				
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not property is None)
    assert isinstance(property, (str, NodePath)), 'property must be str or NodePath'
    
    assert isinstance(duration, (int, float)), 'duration must be int or float'

    if not (type(final_val).__name__ in py4godot.variant_types.core_types or isinstance(final_val, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'final_val': "
                f"{type(final_val).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(property, (str, NodePath)))
    py_nodepath_property = property if isinstance(property,NodePath) else NodePath.new2(property)



    _ret = classes.Object.Object.construct_without_init() #Smart casted to: PropertyTweener
    _ret._ptr = self._ptr.call_with_return(53,tuple([object_._ptr, py_nodepath_property._ptr, final_val, duration]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def tween_interval(self, time:'float'   ) -> typing.Union['py4godot_intervaltweener.IntervalTweener']:
    r'''
				Creates and appends an `IntervalTweener`. This method can be used to create delays in the tween animation, as an alternative to using the delay in other `Tweener`s, or when there's no animation (in which case the `Tween` acts as a timer). `time` is the length of the interval, in seconds.
				**Example:** Creating an interval in code execution:
				
				```gdscript
				# ... some code
				await create_tween().tween_interval(2).finished
				# ... more code
				```
				
				
				**Example:** Creating an object that moves back and forth and jumps every few seconds:
				
				```gdscript
				var tween = create_tween().set_loops()
				tween.tween_property($Sprite, "position:x", 200.0, 1.0).as_relative()
				tween.tween_callback(jump)
				tween.tween_interval(2)
				tween.tween_property($Sprite, "position:x", -200.0, 1.0).as_relative()
				tween.tween_callback(jump)
				tween.tween_interval(2)
				```
				
				
			'''

    assert isinstance(time, (int, float)), 'time must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: IntervalTweener
    _ret._ptr = self._ptr.call_with_return(54,tuple([time]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def tween_callback(self, callback:'Callable'   ) -> typing.Union['py4godot_callbacktweener.CallbackTweener']:
    r'''
				Creates and appends a `CallbackTweener`. This method can be used to call an arbitrary method in any object. Use `Callable.bind` to bind additional arguments for the call.
				**Example:** Object that keeps shooting every 1 second:
				
				```gdscript
				var tween = get_tree().create_tween().set_loops()
				tween.tween_callback(shoot).set_delay(1.0)
				```
				
				
				**Example:** Turning a sprite red and then blue, with 2 second delay:
				
				```gdscript
				var tween = get_tree().create_tween()
				tween.tween_callback($Sprite.set_modulate.bind(Color.RED)).set_delay(2)
				tween.tween_callback($Sprite.set_modulate.bind(Color.BLUE)).set_delay(2)
				```
				
				
			'''

    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: CallbackTweener
    _ret._ptr = self._ptr.call_with_return(55,tuple([callback._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def tween_method(self, method:'Callable'   , from_:'object'   , to:'object'   , duration:'float'   ) -> typing.Union['py4godot_methodtweener.MethodTweener']:
    r'''
				Creates and appends a `MethodTweener`. This method is similar to a combination of `tween_callback` and `tween_property`. It calls a method over time with a tweened value provided as an argument. The value is tweened between `from` and `to` over the time specified by `duration`, in seconds. Use `Callable.bind` to bind additional arguments for the call. You can use `MethodTweener.set_ease` and `MethodTweener.set_trans` to tweak the easing and transition of the value or `MethodTweener.set_delay` to delay the tweening.
				**Example:** Making a 3D object look from one point to another point:
				
				```gdscript
				var tween = create_tween()
				tween.tween_method(look_at.bind(Vector3.UP), Vector3(-1, 0, -1), Vector3(1, 0, -1), 1.0) # The look_at() method takes up vector as second argument.
				```
				
				
				**Example:** Setting the text of a `Label`, using an intermediate method and after a delay:
				
				```gdscript
				func _ready():
					var tween = create_tween()
					tween.tween_method(set_label_text, 0, 10, 1.0).set_delay(1.0)

				func set_label_text(value: int):
					$Label.text = "Counting " + str(value)
				```
				
				
			'''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'
    
    
    assert isinstance(duration, (int, float)), 'duration must be int or float'

    if not (type(from_).__name__ in py4godot.variant_types.core_types or isinstance(from_, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'from_': "
                f"{type(from_).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )
    if not (type(to).__name__ in py4godot.variant_types.core_types or isinstance(to, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'to': "
                f"{type(to).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )









    _ret = classes.Object.Object.construct_without_init() #Smart casted to: MethodTweener
    _ret._ptr = self._ptr.call_with_return(56,tuple([method._ptr, from_, to, duration]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def tween_subtween(self, subtween:'Tween'   ) -> typing.Union['py4godot_subtweentweener.SubtweenTweener']:
    r'''
				Creates and appends a `SubtweenTweener`. This method can be used to nest `subtween` within this `Tween`, allowing for the creation of more complex and composable sequences.
				```gdscript
				# Subtween will rotate the object.
				var subtween = create_tween()
				subtween.tween_property(self, "rotation_degrees", 45.0, 1.0)
				subtween.tween_property(self, "rotation_degrees", 0.0, 1.0)

				# Parent tween will execute the subtween as one of its steps.
				var tween = create_tween()
				tween.tween_property(self, "position:x", 500, 3.0)
				tween.tween_subtween(subtween)
				tween.tween_property(self, "position:x", 300, 2.0)
				```
				**Note:** The methods `pause`, `stop`, and `set_loops` can cause the parent `Tween` to get stuck on the subtween step; see the documentation for those methods for more information.
				**Note:** The pause and process modes set by `set_pause_mode` and `set_process_mode` on `subtween` will be overridden by the parent `Tween`'s settings.
			'''

    assert(not subtween is None)
    assert isinstance(subtween, get_class('Tween')), 'subtween must be Tween'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: SubtweenTweener
    _ret._ptr = self._ptr.call_with_return(57,tuple([subtween._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def custom_step(self, delta:'float'   ) -> typing.Union[bool]:
    r'''
				Processes the `Tween` by the given `delta` value, in seconds. This is mostly useful for manual control when the `Tween` is paused. It can also be used to end the `Tween` animation immediately, by setting `delta` longer than the whole duration of the `Tween` animation.
				Returns `true` if the `Tween` still has `Tweener`s that haven't finished.
			'''

    assert isinstance(delta, (int, float)), 'delta must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(58,tuple([delta]))
    return _ret


  @functools.native_method
  def stop(self) -> None:
    r'''
				Stops the tweening and resets the `Tween` to its initial state. This will not remove any appended `Tweener`s.
				**Note:** This does _not_ reset targets of `PropertyTweener`s to their values when the `Tween` first started.
				```gdscript
				var tween = create_tween()

				# Will move from 0 to 500 over 1 second.
				position.x = 0.0
				tween.tween_property(self, "position:x", 500, 1.0)

				# Will be at (about) 250 when the timer finishes.
				await get_tree().create_timer(0.5).timeout

				# Will now move from (about) 250 to 500 over 1 second,
				# thus at half the speed as before.
				tween.stop()
				tween.play()
				```
				**Note:** If a Tween is stopped and not bound to any node, it will exist indefinitely until manually started or invalidated. If you lose a reference to such Tween, you can retrieve it using `SceneTree.get_processed_tweens`.
			'''




    self._ptr.call_with_return(59,tuple([]))

  @functools.native_method
  def pause(self) -> None:
    r'''
				Pauses the tweening. The animation can be resumed by using `play`.
				**Note:** If a Tween is paused and not bound to any node, it will exist indefinitely until manually started or invalidated. If you lose a reference to such Tween, you can retrieve it using `SceneTree.get_processed_tweens`.
			'''




    self._ptr.call_with_return(60,tuple([]))

  @functools.native_method
  def play(self) -> None:
    r'''
				Resumes a paused or stopped `Tween`.
			'''




    self._ptr.call_with_return(61,tuple([]))

  @functools.native_method
  def kill(self) -> None:
    r'''
				Aborts all tweening operations and invalidates the `Tween`.
			'''




    self._ptr.call_with_return(62,tuple([]))

  @functools.native_method
  def get_total_elapsed_time(self) -> typing.Union[float]:
    r'''
				Returns the total time in seconds the `Tween` has been animating (i.e. the time since it started, not counting pauses etc.). The time is affected by `set_speed_scale`, and `stop` will reset it to `0`.
				**Note:** As it results from accumulating frame deltas, the time returned after the `Tween` has finished animating will be slightly greater than the actual `Tween` duration.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(63,tuple([]))
    return _ret


  @functools.native_method
  def is_running(self) -> typing.Union[bool]:
    r'''
				Returns whether the `Tween` is currently running, i.e. it wasn't paused and it's not finished.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(64,tuple([]))
    return _ret


  @functools.native_method
  def is_valid(self) -> typing.Union[bool]:
    r'''
				Returns whether the `Tween` is valid. A valid `Tween` is a `Tween` contained by the scene tree (i.e. the array from `SceneTree.get_processed_tweens` will contain this `Tween`). A `Tween` might become invalid when it has finished tweening, is killed, or when created with `Tween.new()`. Invalid `Tween`s can't have `Tweener`s appended.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(65,tuple([]))
    return _ret


  @functools.native_method
  def bind_node(self, node:'py4godot_node.Node'   ) -> typing.Union['typing.Self']:
    r'''
				Binds this `Tween` with the given `node`. `Tween`s are processed directly by the `SceneTree`, so they run independently of the animated nodes. When you bind a `Node` with the `Tween`, the `Tween` will halt the animation when the object is not inside tree and the `Tween` will be automatically killed when the bound object is freed. Also `constant TWEEN_PAUSE_BOUND` will make the pausing behavior dependent on the bound node.
				For a shorter way to create and bind a `Tween`, you can use `Node.create_tween`.
			'''

    assert(not node is None)
    assert isinstance(node, get_class('Node')), 'node must be Node'







    _ret = Tween.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(66,tuple([node._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_process_mode(self, mode:'int'  ) -> typing.Union['typing.Self']:
    r'''
				Determines whether the `Tween` should run after process frames (see `Node._process`) or physics frames (see `Node._physics_process`).
				Default value is `constant TWEEN_PROCESS_IDLE`.
			'''

    assert isinstance(mode, (int, float)), 'mode must be int or float'







    _ret = Tween.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(67,tuple([mode]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_pause_mode(self, mode:'int'  ) -> typing.Union['typing.Self']:
    r'''
				Determines the behavior of the `Tween` when the `SceneTree` is paused.
				Default value is `constant TWEEN_PAUSE_BOUND`.
			'''

    assert isinstance(mode, (int, float)), 'mode must be int or float'







    _ret = Tween.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(68,tuple([mode]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_ignore_time_scale(self, ignore:'bool' =True  ) -> typing.Union['typing.Self']:
    r'''
				If `ignore` is `true`, the tween will ignore `Engine.time_scale` and update with the real, elapsed time. This affects all `Tweener`s and their delays. Default value is `false`.
			'''

    assert isinstance(ignore, bool), 'ignore must be bool'







    _ret = Tween.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(69,tuple([ignore]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_parallel(self, parallel:'bool' =True  ) -> typing.Union['typing.Self']:
    r'''
				If `parallel` is `true`, the `Tweener`s appended after this method will by default run simultaneously, as opposed to sequentially.
				**Note:** Just like with `parallel`, the tweener added right before this method will also be part of the parallel step.
				```gdscript
				tween.tween_property(self, "position", Vector2(300, 0), 0.5)
				tween.set_parallel()
				tween.tween_property(self, "modulate", Color.GREEN, 0.5) # Runs together with the position tweener.
				```
			'''

    assert isinstance(parallel, bool), 'parallel must be bool'







    _ret = Tween.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(70,tuple([parallel]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_loops(self, loops:'int' =0  ) -> typing.Union['typing.Self']:
    r'''
				Sets the number of times the tweening sequence will be repeated, i.e. `set_loops(2)` will run the animation twice.
				Calling this method without arguments will make the `Tween` run infinitely, until either it is killed with `kill`, the `Tween`'s bound node is freed, or all the animated objects have been freed (which makes further animation impossible).
				**Warning:** Make sure to always add some duration/delay when using infinite loops. To prevent the game freezing, 0-duration looped animations (e.g. a single `CallbackTweener` with no delay) are stopped after a small number of loops, which may produce unexpected results. If a `Tween`'s lifetime depends on some node, always use `bind_node`.
			'''

    assert isinstance(loops, (int, float)), 'loops must be int or float'







    _ret = Tween.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(71,tuple([loops]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_loops_left(self) -> typing.Union[int]:
    r'''
				Returns the number of remaining loops for this `Tween` (see `set_loops`). A return value of `-1` indicates an infinitely looping `Tween`, and a return value of `0` indicates that the `Tween` has already finished.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(72,tuple([]))
    return _ret


  @functools.native_method
  def set_speed_scale(self, speed:'float'   ) -> typing.Union['typing.Self']:
    r'''
				Scales the speed of tweening. This affects all `Tweener`s and their delays.
			'''

    assert isinstance(speed, (int, float)), 'speed must be int or float'







    _ret = Tween.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(73,tuple([speed]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_trans(self, trans:'int'  ) -> typing.Union['typing.Self']:
    r'''
				Sets the default transition type for `PropertyTweener`s and `MethodTweener`s appended after this method.
				Before this method is called, the default transition type is `constant TRANS_LINEAR`.
				```gdscript
				var tween = create_tween()
				tween.tween_property(self, "position", Vector2(300, 0), 0.5) # Uses TRANS_LINEAR.
				tween.set_trans(Tween.TRANS_SINE)
				tween.tween_property(self, "rotation_degrees", 45.0, 0.5) # Uses TRANS_SINE.
				```
			'''

    assert isinstance(trans, (int, float)), 'trans must be int or float'







    _ret = Tween.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(74,tuple([trans]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_ease(self, ease:'int'  ) -> typing.Union['typing.Self']:
    r'''
				Sets the default ease type for `PropertyTweener`s and `MethodTweener`s appended after this method.
				Before this method is called, the default ease type is `constant EASE_IN_OUT`.
				```gdscript
				var tween = create_tween()
				tween.tween_property(self, "position", Vector2(300, 0), 0.5) # Uses EASE_IN_OUT.
				tween.set_ease(Tween.EASE_IN)
				tween.tween_property(self, "rotation_degrees", 45.0, 0.5) # Uses EASE_IN.
				```
			'''

    assert isinstance(ease, (int, float)), 'ease must be int or float'







    _ret = Tween.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(75,tuple([ease]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def parallel(self) -> typing.Union['typing.Self']:
    r'''
				Makes the next `Tweener` run parallelly to the previous one.
				
				```gdscript
				var tween = create_tween()
				tween.tween_property(...)
				tween.parallel().tween_property(...)
				tween.parallel().tween_property(...)
				```
				
				
				All `Tweener`s in the example will run at the same time.
				You can make the `Tween` parallel by default by using `set_parallel`.
			'''




    _ret = Tween.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(76,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def chain(self) -> typing.Union['typing.Self']:
    r'''
				Used to chain two `Tweener`s after `set_parallel` is called with `true`.
				
				```gdscript
				var tween = create_tween().set_parallel(true)
				tween.tween_property(...)
				tween.tween_property(...) # Will run parallelly with above.
				tween.chain().tween_property(...) # Will run after two above are finished.
				```
				
				
			'''




    _ret = Tween.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(77,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @staticmethod
  def interpolate_value(initial_value:'object'   , delta_value:'object'   , elapsed_time:'float'   , duration:'float'   , trans_type:'int'  , ease_type:'int'  ) -> typing.Union[typing.Any]:
    r'''
				This method can be used for manual interpolation of a value, when you don't want `Tween` to do animating for you. It's similar to `@GlobalScope.lerp`, but with support for custom transition and easing.
				`initial_value` is the starting value of the interpolation.
				`delta_value` is the change of the value in the interpolation, i.e. it's equal to `final_value - initial_value`.
				`elapsed_time` is the time in seconds that passed after the interpolation started and it's used to control the position of the interpolation. E.g. when it's equal to half of the `duration`, the interpolated value will be halfway between initial and final values. This value can also be greater than `duration` or lower than 0, which will extrapolate the value.
				`duration` is the total time of the interpolation.
				**Note:** If `duration` is equal to `0`, the method will always return the final value, regardless of `elapsed_time` provided.
			'''

    
    
    assert isinstance(elapsed_time, (int, float)), 'elapsed_time must be int or float'
    assert isinstance(duration, (int, float)), 'duration must be int or float'
    assert isinstance(trans_type, (int, float)), 'trans_type must be int or float'
    assert isinstance(ease_type, (int, float)), 'ease_type must be int or float'

    if not (type(initial_value).__name__ in py4godot.variant_types.core_types or isinstance(initial_value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'initial_value': "
                f"{type(initial_value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )
    if not (type(delta_value).__name__ in py4godot.variant_types.core_types or isinstance(delta_value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'delta_value': "
                f"{type(delta_value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )











    _ret = None
    _ret = static_method(853,0,tuple([initial_value, delta_value, elapsed_time, duration, trans_type, ease_type]))
    return _ret



register_cast_function('Tween', Tween.cast)
register_class('Tween', Tween)
