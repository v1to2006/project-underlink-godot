# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.NavigationMesh as py4godot_navigationmesh 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPNavigationPolygonWrapper

class SamplePartitionType:
  SAMPLE_PARTITION_CONVEX_PARTITION = 0
  SAMPLE_PARTITION_TRIANGULATE = 1
  SAMPLE_PARTITION_MAX = 2
class ParsedGeometryType:
  PARSED_GEOMETRY_MESH_INSTANCES = 0
  PARSED_GEOMETRY_STATIC_COLLIDERS = 1
  PARSED_GEOMETRY_BOTH = 2
  PARSED_GEOMETRY_MAX = 3
class SourceGeometryMode:
  SOURCE_GEOMETRY_ROOT_NODE_CHILDREN = 0
  SOURCE_GEOMETRY_GROUPS_WITH_CHILDREN = 1
  SOURCE_GEOMETRY_GROUPS_EXPLICIT = 2
  SOURCE_GEOMETRY_MAX = 3


class NavigationPolygon(py4godot_resource.Resource):
  r'''
		A navigation mesh can be created either by baking it with the help of the `NavigationServer2D`, or by adding vertices and convex polygon indices arrays manually.
		To bake a navigation mesh at least one outline needs to be added that defines the outer bounds of the baked area.
		
		```gdscript
		var new_navigation_mesh = NavigationPolygon.new()
		var bounding_outline = PackedVector2Array(`Vector2(0, 0), Vector2(0, 50), Vector2(50, 50), Vector2(50, 0)`)
		new_navigation_mesh.add_outline(bounding_outline)
		NavigationServer2D.bake_from_source_geometry_data(new_navigation_mesh, NavigationMeshSourceGeometryData2D.new());
		$NavigationRegion2D.navigation_polygon = new_navigation_mesh
		```
		
		
		Adding vertices and polygon indices manually.
		
		```gdscript
		var new_navigation_mesh = NavigationPolygon.new()
		var new_vertices = PackedVector2Array(`Vector2(0, 0), Vector2(0, 50), Vector2(50, 50), Vector2(50, 0)`)
		new_navigation_mesh.vertices = new_vertices
		var new_polygon_indices = PackedInt32Array(`0, 1, 2, 3`)
		new_navigation_mesh.add_polygon(new_polygon_indices)
		$NavigationRegion2D.navigation_polygon = new_navigation_mesh
		```
		
		
	'''

  @staticmethod
  def constructor():
    class_ = NavigationPolygon.construct_without_init()
    class_._ptr = constructor(508,0, ())
    return class_
  @staticmethod
  def new():
    class_ = NavigationPolygon.construct_without_init()
    class_._ptr = constructor(508,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPNavigationPolygonWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(508,0, ())


  def generate_wrapper(self):
    return CPPNavigationPolygonWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = NavigationPolygon.__new__(NavigationPolygon)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'NavigationPolygon'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(115, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = NavigationPolygon.construct_without_init()
    cls._ptr = CPPNavigationPolygonWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = NavigationPolygon.construct_without_init()
    cls._ptr = CPPNavigationPolygonWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def vertices(self) -> typing.Union['PackedVector2Array']:
    r''''''
    _ret = self. get_vertices()
    return _ret
  @vertices.setter
  def vertices(self,  value:'PackedVector2Array'):
    self.set_vertices(value)
  @property
  def polygons(self) -> typing.Union['Array']:
    r''''''
    _ret = self. _get_polygons()
    return _ret
  @polygons.setter
  def polygons(self,  value:'Array'):
    self._set_polygons(value)
  @property
  def outlines(self) -> typing.Union['Array']:
    r''''''
    _ret = self. _get_outlines()
    return _ret
  @outlines.setter
  def outlines(self,  value:'Array'):
    self._set_outlines(value)
  @property
  def sample_partition_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_sample_partition_type()
    return _ret
  @sample_partition_type.setter
  def sample_partition_type(self,  value:'int'):
    self.set_sample_partition_type(value)
  @property
  def parsed_geometry_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_parsed_geometry_type()
    return _ret
  @parsed_geometry_type.setter
  def parsed_geometry_type(self,  value:'int'):
    self.set_parsed_geometry_type(value)
  @property
  def parsed_collision_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_parsed_collision_mask()
    return _ret
  @parsed_collision_mask.setter
  def parsed_collision_mask(self,  value:'int'):
    self.set_parsed_collision_mask(value)
  @property
  def source_geometry_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_source_geometry_mode()
    return _ret
  @source_geometry_mode.setter
  def source_geometry_mode(self,  value:'int'):
    self.set_source_geometry_mode(value)
  @property
  def source_geometry_group_name(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_source_geometry_group_name()
    return _ret
  @source_geometry_group_name.setter
  def source_geometry_group_name(self,  value:'str'):
    self.set_source_geometry_group_name(value)
  @property
  def cell_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_cell_size()
    return _ret
  @cell_size.setter
  def cell_size(self,  value:'float'):
    self.set_cell_size(value)
  @property
  def border_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_border_size()
    return _ret
  @border_size.setter
  def border_size(self,  value:'float'):
    self.set_border_size(value)
  @property
  def agent_radius(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_agent_radius()
    return _ret
  @agent_radius.setter
  def agent_radius(self,  value:'float'):
    self.set_agent_radius(value)
  @property
  def baking_rect(self) -> typing.Union['Rect2']:
    r''''''
    _ret = self. get_baking_rect()
    return _ret
  @baking_rect.setter
  def baking_rect(self,  value:'Rect2'):
    self.set_baking_rect(value)
  @property
  def baking_rect_offset(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_baking_rect_offset()
    return _ret
  @baking_rect_offset.setter
  def baking_rect_offset(self,  value:'Vector2'):
    self.set_baking_rect_offset(value)
  @functools.native_method
  def set_vertices(self, vertices:'PackedVector2Array'   ) -> None:
    r'''
				Sets the vertices that can be then indexed to create polygons with the `add_polygon` method.
			'''

    assert(not vertices is None)
    assert isinstance(vertices, PackedVector2Array), 'vertices must be PackedVector2Array'


    self.py__vertices = vertices






    self._ptr.call_with_return(77,tuple([vertices._ptr]))

  @functools.native_method
  def get_vertices(self) -> typing.Union['PackedVector2Array']:
    r'''
				Returns a `PackedVector2Array` containing all the vertices being used to create the polygons.
			'''




    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([]))

    return _ret


  @functools.native_method
  def add_polygon(self, polygon:'PackedInt32Array'   ) -> None:
    r'''
				Adds a polygon using the indices of the vertices you get when calling `get_vertices`.
			'''

    assert(not polygon is None)
    assert isinstance(polygon, PackedInt32Array), 'polygon must be PackedInt32Array'







    self._ptr.call_with_return(79,tuple([polygon._ptr]))

  @functools.native_method
  def get_polygon_count(self) -> typing.Union[int]:
    r'''
				Returns the count of all polygons.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(80,tuple([]))
    return _ret


  @functools.native_method
  def get_polygon(self, idx:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns a `PackedInt32Array` containing the indices of the vertices of a created polygon.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([idx]))
    return _ret


  @functools.native_method
  def clear_polygons(self) -> None:
    r'''
				Clears the array of polygons, but it doesn't clear the array of outlines and vertices.
			'''




    self._ptr.call_with_return(82,tuple([]))

  @functools.native_method
  def get_navigation_mesh(self) -> typing.Union['py4godot_navigationmesh.NavigationMesh']:
    r'''
				Returns the `NavigationMesh` resulting from this navigation polygon. This navigation mesh can be used to update the navigation mesh of a region with the `NavigationServer3D.region_set_navigation_mesh` API directly.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: NavigationMesh
    _ret._ptr = self._ptr.call_with_return(83,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def add_outline(self, outline:'PackedVector2Array'   ) -> None:
    r'''
				Appends a `PackedVector2Array` that contains the vertices of an outline to the internal array that contains all the outlines.
			'''

    assert(not outline is None)
    assert isinstance(outline, PackedVector2Array), 'outline must be PackedVector2Array'







    self._ptr.call_with_return(84,tuple([outline._ptr]))

  @functools.native_method
  def add_outline_at_index(self, outline:'PackedVector2Array'   , index:'int'   ) -> None:
    r'''
				Adds a `PackedVector2Array` that contains the vertices of an outline to the internal array that contains all the outlines at a fixed position.
			'''

    assert(not outline is None)
    assert isinstance(outline, PackedVector2Array), 'outline must be PackedVector2Array'
    assert isinstance(index, (int, float)), 'index must be int or float'








    self._ptr.call_with_return(85,tuple([outline._ptr, index]))

  @functools.native_method
  def get_outline_count(self) -> typing.Union[int]:
    r'''
				Returns the number of outlines that were created in the editor or by script.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def set_outline(self, idx:'int'   , outline:'PackedVector2Array'   ) -> None:
    r'''
				Changes an outline created in the editor or by script. You have to call `make_polygons_from_outlines` for the polygons to update.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not outline is None)
    assert isinstance(outline, PackedVector2Array), 'outline must be PackedVector2Array'








    self._ptr.call_with_return(87,tuple([idx, outline._ptr]))

  @functools.native_method
  def get_outline(self, idx:'int'   ) -> typing.Union['PackedVector2Array']:
    r'''
				Returns a `PackedVector2Array` containing the vertices of an outline that was created in the editor or by script.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([idx]))
    return _ret


  @functools.native_method
  def remove_outline(self, idx:'int'   ) -> None:
    r'''
				Removes an outline created in the editor or by script. You have to call `make_polygons_from_outlines` for the polygons to update.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    self._ptr.call_with_return(89,tuple([idx]))

  @functools.native_method
  def clear_outlines(self) -> None:
    r'''
				Clears the array of the outlines, but it doesn't clear the vertices and the polygons that were created by them.
			'''




    self._ptr.call_with_return(90,tuple([]))

  @functools.native_method
  def make_polygons_from_outlines(self) -> None:
    r'''
				Creates polygons from the outlines added in the editor or by script.
			'''




    self._ptr.call_with_return(91,tuple([]))

  @functools.native_method
  def set_cell_size(self, cell_size:'float'   ) -> None:
    r''''''

    assert isinstance(cell_size, (int, float)), 'cell_size must be int or float'


    self.py__cell_size = cell_size






    self._ptr.call_with_return(92,tuple([cell_size]))

  @functools.native_method
  def get_cell_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([]))

    return _ret


  @functools.native_method
  def set_border_size(self, border_size:'float'   ) -> None:
    r''''''

    assert isinstance(border_size, (int, float)), 'border_size must be int or float'


    self.py__border_size = border_size






    self._ptr.call_with_return(94,tuple([border_size]))

  @functools.native_method
  def get_border_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(95,tuple([]))

    return _ret


  @functools.native_method
  def set_sample_partition_type(self, sample_partition_type:'int'  ) -> None:
    r''''''

    assert isinstance(sample_partition_type, (int, float)), 'sample_partition_type must be int or float'


    self.py__sample_partition_type = sample_partition_type






    self._ptr.call_with_return(96,tuple([sample_partition_type]))

  @functools.native_method
  def get_sample_partition_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(97,tuple([]))

    return _ret


  @functools.native_method
  def set_parsed_geometry_type(self, geometry_type:'int'  ) -> None:
    r''''''

    assert isinstance(geometry_type, (int, float)), 'geometry_type must be int or float'


    self.py__parsed_geometry_type = geometry_type






    self._ptr.call_with_return(98,tuple([geometry_type]))

  @functools.native_method
  def get_parsed_geometry_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(99,tuple([]))

    return _ret


  @functools.native_method
  def set_parsed_collision_mask(self, mask:'int'   ) -> None:
    r''''''

    assert isinstance(mask, (int, float)), 'mask must be int or float'


    self.py__parsed_collision_mask = mask






    self._ptr.call_with_return(100,tuple([mask]))

  @functools.native_method
  def get_parsed_collision_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(101,tuple([]))

    return _ret


  @functools.native_method
  def set_parsed_collision_mask_value(self, layer_number:'int'   , value:'bool'   ) -> None:
    r'''
				Based on `value`, enables or disables the specified layer in the `parsed_collision_mask`, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'








    self._ptr.call_with_return(102,tuple([layer_number, value]))

  @functools.native_method
  def get_parsed_collision_mask_value(self, layer_number:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether or not the specified layer of the `parsed_collision_mask` is enabled, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([layer_number]))
    return _ret


  @functools.native_method
  def set_source_geometry_mode(self, geometry_mode:'int'  ) -> None:
    r''''''

    assert isinstance(geometry_mode, (int, float)), 'geometry_mode must be int or float'


    self.py__source_geometry_mode = geometry_mode






    self._ptr.call_with_return(104,tuple([geometry_mode]))

  @functools.native_method
  def get_source_geometry_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(105,tuple([]))

    return _ret


  @functools.native_method
  def set_source_geometry_group_name(self, group_name:'object'   ) -> None:
    r''''''

    assert(not group_name is None)
    assert isinstance(group_name, (str, StringName)), 'group_name must be str or StringName'


    self.py__source_geometry_group_name = group_name



    assert(isinstance(group_name, (str, StringName)))
    py_stringname_group_name = group_name if isinstance(group_name, StringName) else c_utils.py_string_to_string_name(group_name)


    self._ptr.call_with_return(106,tuple([py_stringname_group_name._ptr]))

  @functools.native_method
  def get_source_geometry_group_name(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(107,tuple([]))

    return str(_ret)


  @functools.native_method
  def set_agent_radius(self, agent_radius:'float'   ) -> None:
    r''''''

    assert isinstance(agent_radius, (int, float)), 'agent_radius must be int or float'


    self.py__agent_radius = agent_radius






    self._ptr.call_with_return(108,tuple([agent_radius]))

  @functools.native_method
  def get_agent_radius(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(109,tuple([]))

    return _ret


  @functools.native_method
  def set_baking_rect(self, rect:'Rect2'   ) -> None:
    r''''''

    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'


    self.py__baking_rect = rect






    self._ptr.call_with_return(110,tuple([rect._ptr]))

  @functools.native_method
  def get_baking_rect(self) -> typing.Union['Rect2']:
    r''''''




    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(111,tuple([]))

    return _ret


  @functools.native_method
  def set_baking_rect_offset(self, rect_offset:'Vector2'   ) -> None:
    r''''''

    assert(not rect_offset is None)
    assert isinstance(rect_offset, Vector2), 'rect_offset must be Vector2'


    self.py__baking_rect_offset = rect_offset






    self._ptr.call_with_return(112,tuple([rect_offset._ptr]))

  @functools.native_method
  def get_baking_rect_offset(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(113,tuple([]))

    return _ret


  @functools.native_method
  def clear(self) -> None:
    r'''
				Clears the internal arrays for vertices and polygon indices.
			'''




    self._ptr.call_with_return(114,tuple([]))


register_cast_function('NavigationPolygon', NavigationPolygon.cast)
register_class('NavigationPolygon', NavigationPolygon)
