# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ImageTextureLayered as py4godot_imagetexturelayered 
  import py4godot.classes.CompressedCubemap as py4godot_compressedcubemap 
  import py4godot.classes.CompressedCubemapArray as py4godot_compressedcubemaparray 
  import py4godot.classes.PlaceholderCubemapArray as py4godot_placeholdercubemaparray 
  import py4godot.classes.Image as py4godot_image 
  import py4godot.classes.Texture2DArrayRD as py4godot_texture2darrayrd 
  import py4godot.classes.PlaceholderTexture2DArray as py4godot_placeholdertexture2darray 
  import py4godot.classes.TextureCubemapArrayRD as py4godot_texturecubemaparrayrd 
  import py4godot.classes.CubemapArray as py4godot_cubemaparray 
  import py4godot.classes.PlaceholderCubemap as py4godot_placeholdercubemap 
  import py4godot.classes.TextureLayeredRD as py4godot_texturelayeredrd 
  import py4godot.classes.Cubemap as py4godot_cubemap 
  import py4godot.classes.CompressedTexture2DArray as py4godot_compressedtexture2darray 
  import py4godot.classes.TextureCubemapRD as py4godot_texturecubemaprd 
  import py4godot.classes.PlaceholderTextureLayered as py4godot_placeholdertexturelayered 
  import py4godot.classes.Texture2DArray as py4godot_texture2darray 
  import py4godot.classes.CompressedTextureLayered as py4godot_compressedtexturelayered 
import py4godot.classes.Texture as py4godot_texture 
from py4godot.wrappers.wrappers import CPPTextureLayeredWrapper

class LayeredType:
  LAYERED_TYPE_2D_ARRAY = 0
  LAYERED_TYPE_CUBEMAP = 1
  LAYERED_TYPE_CUBEMAP_ARRAY = 2


class TextureLayered(py4godot_texture.Texture):
  r'''
		Base class for `ImageTextureLayered` and `CompressedTextureLayered`. Cannot be used directly, but contains all the functions necessary for accessing the derived resource types. See also `Texture3D`.
		Data is set on a per-layer basis. For `Texture2DArray`s, the layer specifies the array layer.
		All images need to have the same width, height and number of mipmap levels.
		A `TextureLayered` can be loaded with `ResourceLoader.load`.
		Internally, Godot maps these files to their respective counterparts in the target rendering driver (Vulkan, OpenGL3).
	'''

  @staticmethod
  def constructor():
    class_ = TextureLayered.construct_without_init()
    class_._ptr = constructor(827,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TextureLayered.construct_without_init()
    class_._ptr = constructor(827,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTextureLayeredWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(827,0, ())


  def generate_wrapper(self):
    return CPPTextureLayeredWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = TextureLayered.__new__(TextureLayered)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TextureLayered'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(91, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TextureLayered.construct_without_init()
    cls._ptr = CPPTextureLayeredWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TextureLayered.construct_without_init()
    cls._ptr = CPPTextureLayeredWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _get_format(self) -> typing.Union[int]:
    r'''
				Called when the `TextureLayered`'s format is queried.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(77,tuple([]))
    return _ret


  @functools.native_method
  def _get_layered_type(self) -> typing.Union[int]:
    r'''
				Called when the layers' type in the `TextureLayered` is queried.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([]))
    return _ret


  @functools.native_method
  def _get_width(self) -> typing.Union[int]:
    r'''
				Called when the `TextureLayered`'s width queried.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(79,tuple([]))
    return _ret


  @functools.native_method
  def _get_height(self) -> typing.Union[int]:
    r'''
				Called when the `TextureLayered`'s height is queried.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(80,tuple([]))
    return _ret


  @functools.native_method
  def _get_layers(self) -> typing.Union[int]:
    r'''
				Called when the number of layers in the `TextureLayered` is queried.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(81,tuple([]))
    return _ret


  @functools.native_method
  def _has_mipmaps(self) -> typing.Union[bool]:
    r'''
				Called when the presence of mipmaps in the `TextureLayered` is queried.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([]))
    return _ret


  @functools.native_method
  def _get_layer_data(self, layer_index:'int'   ) -> typing.Union['py4godot_image.Image']:
    r'''
				Called when the data for a layer in the `TextureLayered` is queried.
			'''

    assert isinstance(layer_index, (int, float)), 'layer_index must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Image
    _ret._ptr = self._ptr.call_with_return(83,tuple([layer_index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_format(self) -> typing.Union[int]:
    r'''
				Returns the current format being used by this texture.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(84,tuple([]))
    return _ret


  @functools.native_method
  def get_layered_type(self) -> typing.Union[int]:
    r'''
				Returns the `TextureLayered`'s type. The type determines how the data is accessed, with cubemaps having special types.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(85,tuple([]))
    return _ret


  @functools.native_method
  def get_width(self) -> typing.Union[int]:
    r'''
				Returns the width of the texture in pixels. Width is typically represented by the X axis.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def get_height(self) -> typing.Union[int]:
    r'''
				Returns the height of the texture in pixels. Height is typically represented by the Y axis.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(87,tuple([]))
    return _ret


  @functools.native_method
  def get_layers(self) -> typing.Union[int]:
    r'''
				Returns the number of referenced `Image`s.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([]))
    return _ret


  @functools.native_method
  def has_mipmaps(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the layers have generated mipmaps.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([]))
    return _ret


  @functools.native_method
  def get_layer_data(self, layer:'int'   ) -> typing.Union['py4godot_image.Image']:
    r'''
				Returns an `Image` resource with the data from specified `layer`.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Image
    _ret._ptr = self._ptr.call_with_return(90,tuple([layer]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('TextureLayered', TextureLayered.cast)
register_class('TextureLayered', TextureLayered)
