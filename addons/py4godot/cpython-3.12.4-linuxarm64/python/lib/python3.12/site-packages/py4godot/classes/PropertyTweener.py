# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Tween as py4godot_tween 
import py4godot.classes.Tweener as py4godot_tweener 
from py4godot.wrappers.wrappers import CPPPropertyTweenerWrapper


class PropertyTweener(py4godot_tweener.Tweener):
  r'''
		`PropertyTweener` is used to interpolate a property in an object. See `Tween.tween_property` for more usage information.
		The tweener will finish automatically if the target object is freed.
		**Note:** `Tween.tween_property` is the only correct way to create `PropertyTweener`. Any `PropertyTweener` created manually will not function correctly.
	'''

  @staticmethod
  def constructor():
    class_ = PropertyTweener.construct_without_init()
    class_._ptr = constructor(642,0, ())
    return class_
  @staticmethod
  def new():
    class_ = PropertyTweener.construct_without_init()
    class_._ptr = constructor(642,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPPropertyTweenerWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(642,0, ())


  def generate_wrapper(self):
    return CPPPropertyTweenerWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = PropertyTweener.__new__(PropertyTweener)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PropertyTweener'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(60, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = PropertyTweener.construct_without_init()
    cls._ptr = CPPPropertyTweenerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = PropertyTweener.construct_without_init()
    cls._ptr = CPPPropertyTweenerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def from_(self, value:'object'   ) -> typing.Union['typing.Self']:
    r'''
				Sets a custom initial value to the `PropertyTweener`.
				**Example:** Move the node from position `(100, 100)` to `(200, 100)`.
				
				```gdscript
				var tween = get_tree().create_tween()
				tween.tween_property(self, "position", Vector2(200, 100), 1).from(Vector2(100, 100))
				```
				
				
			'''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    _ret = PropertyTweener.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([value]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def from_current(self) -> typing.Union['typing.Self']:
    r'''
				Makes the `PropertyTweener` use the current property value (i.e. at the time of creating this `PropertyTweener`) as a starting point. This is equivalent of using `from` with the current value. These two calls will do the same:
				
				```gdscript
				tween.tween_property(self, "position", Vector2(200, 100), 1).from(position)
				tween.tween_property(self, "position", Vector2(200, 100), 1).from_current()
				```
				
				
			'''




    _ret = PropertyTweener.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def as_relative(self) -> typing.Union['typing.Self']:
    r'''
				When called, the final value will be used as a relative value instead.
				**Example:** Move the node by `100` pixels to the right.
				
				```gdscript
				var tween = get_tree().create_tween()
				tween.tween_property(self, "position", Vector2.RIGHT * 100, 1).as_relative()
				```
				
				
			'''




    _ret = PropertyTweener.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(55,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_trans(self, trans:'int'  ) -> typing.Union['typing.Self']:
    r'''
				Sets the type of used transition from `enum Tween.TransitionType`. If not set, the default transition is used from the `Tween` that contains this Tweener.
			'''

    assert isinstance(trans, (int, float)), 'trans must be int or float'







    _ret = PropertyTweener.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(56,tuple([trans]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_ease(self, ease:'int'  ) -> typing.Union['typing.Self']:
    r'''
				Sets the type of used easing from `enum Tween.EaseType`. If not set, the default easing is used from the `Tween` that contains this Tweener.
			'''

    assert isinstance(ease, (int, float)), 'ease must be int or float'







    _ret = PropertyTweener.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(57,tuple([ease]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_custom_interpolator(self, interpolator_method:'Callable'   ) -> typing.Union['typing.Self']:
    r'''
				Allows interpolating the value with a custom easing function. The provided `interpolator_method` will be called with a value ranging from `0.0` to `1.0` and is expected to return a value within the same range (values outside the range can be used for overshoot). The return value of the method is then used for interpolation between initial and final value. Note that the parameter passed to the method is still subject to the tweener's own easing.
				
				```gdscript
				@export var curve: Curve

				func _ready():
					var tween = create_tween()
					# Interpolate the value using a custom curve.
					tween.tween_property(self, "position:x", 300, 1).as_relative().set_custom_interpolator(tween_curve)

				func tween_curve(v):
					return curve.sample_baked(v)
				```
				
				
			'''

    assert(not interpolator_method is None)
    assert isinstance(interpolator_method, Callable), 'interpolator_method must be Callable'







    _ret = PropertyTweener.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([interpolator_method._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_delay(self, delay:'float'   ) -> typing.Union['typing.Self']:
    r'''
				Sets the time in seconds after which the `PropertyTweener` will start interpolating. By default there's no delay.
			'''

    assert isinstance(delay, (int, float)), 'delay must be int or float'







    _ret = PropertyTweener.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(59,tuple([delay]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('PropertyTweener', PropertyTweener.cast)
register_class('PropertyTweener', PropertyTweener)
