# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.CameraAttributes as py4godot_cameraattributes 
  import py4godot.classes.CameraAttributesPractical as py4godot_cameraattributespractical 
  import py4godot.classes.LightmapGIData as py4godot_lightmapgidata 
  import py4godot.classes.CameraAttributesPhysical as py4godot_cameraattributesphysical 
  import py4godot.classes.Sky as py4godot_sky 
import py4godot.classes.VisualInstance3D as py4godot_visualinstance3d 
from py4godot.wrappers.wrappers import CPPLightmapGIWrapper

class BakeQuality:
  BAKE_QUALITY_LOW = 0
  BAKE_QUALITY_MEDIUM = 1
  BAKE_QUALITY_HIGH = 2
  BAKE_QUALITY_ULTRA = 3
class GenerateProbes:
  GENERATE_PROBES_DISABLED = 0
  GENERATE_PROBES_SUBDIV_4 = 1
  GENERATE_PROBES_SUBDIV_8 = 2
  GENERATE_PROBES_SUBDIV_16 = 3
  GENERATE_PROBES_SUBDIV_32 = 4
class BakeError:
  BAKE_ERROR_OK = 0
  BAKE_ERROR_NO_SCENE_ROOT = 1
  BAKE_ERROR_FOREIGN_DATA = 2
  BAKE_ERROR_NO_LIGHTMAPPER = 3
  BAKE_ERROR_NO_SAVE_PATH = 4
  BAKE_ERROR_NO_MESHES = 5
  BAKE_ERROR_MESHES_INVALID = 6
  BAKE_ERROR_CANT_CREATE_IMAGE = 7
  BAKE_ERROR_USER_ABORTED = 8
  BAKE_ERROR_TEXTURE_SIZE_TOO_SMALL = 9
  BAKE_ERROR_LIGHTMAP_TOO_SMALL = 10
  BAKE_ERROR_ATLAS_TOO_SMALL = 11
class EnvironmentMode:
  ENVIRONMENT_MODE_DISABLED = 0
  ENVIRONMENT_MODE_SCENE = 1
  ENVIRONMENT_MODE_CUSTOM_SKY = 2
  ENVIRONMENT_MODE_CUSTOM_COLOR = 3


class LightmapGI(py4godot_visualinstance3d.VisualInstance3D):
  r'''
		The `LightmapGI` node is used to compute and store baked lightmaps. Lightmaps are used to provide high-quality indirect lighting with very little light leaking. `LightmapGI` can also provide rough reflections using spherical harmonics if `directional` is enabled. Dynamic objects can receive indirect lighting thanks to _light probes_, which can be automatically placed by setting `generate_probes_subdiv` to a value other than `constant GENERATE_PROBES_DISABLED`. Additional lightmap probes can also be added by creating `LightmapProbe` nodes. The downside is that lightmaps are fully static and cannot be baked in an exported project. Baking a `LightmapGI` node is also slower compared to `VoxelGI`.
		**Procedural generation:** Lightmap baking functionality is only available in the editor. This means `LightmapGI` is not suited to procedurally generated or user-built levels. For procedurally generated or user-built levels, use `VoxelGI` or SDFGI instead (see `Environment.sdfgi_enabled`).
		**Performance:** `LightmapGI` provides the best possible run-time performance for global illumination. It is suitable for low-end hardware including integrated graphics and mobile devices.
		**Note:** Due to how lightmaps work, most properties only have a visible effect once lightmaps are baked again.
		**Note:** Lightmap baking on `CSGShape3D`s and `PrimitiveMesh`es is not supported, as these cannot store UV2 data required for baking.
		**Note:** If no custom lightmappers are installed, `LightmapGI` can only be baked from devices that support the Forward+ or Mobile renderers.
		**Note:** The `LightmapGI` node only bakes light data for child nodes of its parent. Nodes further up the hierarchy of the scene will not be baked.
	'''

  @staticmethod
  def constructor():
    class_ = LightmapGI.construct_without_init()
    class_._ptr = constructor(452,0, ())
    return class_
  @staticmethod
  def new():
    class_ = LightmapGI.construct_without_init()
    class_._ptr = constructor(452,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPLightmapGIWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(452,0, ())


  def generate_wrapper(self):
    return CPPLightmapGIWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = LightmapGI.__new__(LightmapGI)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'LightmapGI'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = LightmapGI.construct_without_init()
    cls._ptr = CPPLightmapGIWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = LightmapGI.construct_without_init()
    cls._ptr = CPPLightmapGIWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def quality(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_bake_quality()
    return _ret
  @quality.setter
  def quality(self,  value:'int'):
    self.set_bake_quality(value)
  @property
  def supersampling(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_supersampling_enabled()
    return _ret
  @supersampling.setter
  def supersampling(self,  value:'bool'):
    self.set_supersampling_enabled(value)
  @property
  def supersampling_factor(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_supersampling_factor()
    return _ret
  @supersampling_factor.setter
  def supersampling_factor(self,  value:'float'):
    self.set_supersampling_factor(value)
  @property
  def bounces(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_bounces()
    return _ret
  @bounces.setter
  def bounces(self,  value:'int'):
    self.set_bounces(value)
  @property
  def bounce_indirect_energy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_bounce_indirect_energy()
    return _ret
  @bounce_indirect_energy.setter
  def bounce_indirect_energy(self,  value:'float'):
    self.set_bounce_indirect_energy(value)
  @property
  def directional(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_directional()
    return _ret
  @directional.setter
  def directional(self,  value:'bool'):
    self.set_directional(value)
  @property
  def shadowmask_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_shadowmask_mode()
    return _ret
  @shadowmask_mode.setter
  def shadowmask_mode(self,  value:'int'):
    self.set_shadowmask_mode(value)
  @property
  def use_texture_for_bounces(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_texture_for_bounces()
    return _ret
  @use_texture_for_bounces.setter
  def use_texture_for_bounces(self,  value:'bool'):
    self.set_use_texture_for_bounces(value)
  @property
  def interior(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_interior()
    return _ret
  @interior.setter
  def interior(self,  value:'bool'):
    self.set_interior(value)
  @property
  def use_denoiser(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_denoiser()
    return _ret
  @use_denoiser.setter
  def use_denoiser(self,  value:'bool'):
    self.set_use_denoiser(value)
  @property
  def denoiser_strength(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_denoiser_strength()
    return _ret
  @denoiser_strength.setter
  def denoiser_strength(self,  value:'float'):
    self.set_denoiser_strength(value)
  @property
  def denoiser_range(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_denoiser_range()
    return _ret
  @denoiser_range.setter
  def denoiser_range(self,  value:'int'):
    self.set_denoiser_range(value)
  @property
  def bias(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_bias()
    return _ret
  @bias.setter
  def bias(self,  value:'float'):
    self.set_bias(value)
  @property
  def texel_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_texel_scale()
    return _ret
  @texel_scale.setter
  def texel_scale(self,  value:'float'):
    self.set_texel_scale(value)
  @property
  def max_texture_size(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_texture_size()
    return _ret
  @max_texture_size.setter
  def max_texture_size(self,  value:'int'):
    self.set_max_texture_size(value)
  @property
  def environment_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_environment_mode()
    return _ret
  @environment_mode.setter
  def environment_mode(self,  value:'int'):
    self.set_environment_mode(value)
  @property
  def environment_custom_sky(self) -> typing.Union['py4godot_sky.Sky']:
    r''''''
    _ret = self. get_environment_custom_sky()
    return _ret
  @environment_custom_sky.setter
  def environment_custom_sky(self,  value:'py4godot_object.Object'):
    self.set_environment_custom_sky(value)
  @property
  def environment_custom_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_environment_custom_color()
    return _ret
  @environment_custom_color.setter
  def environment_custom_color(self,  value:'Color'):
    self.set_environment_custom_color(value)
  @property
  def environment_custom_energy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_environment_custom_energy()
    return _ret
  @environment_custom_energy.setter
  def environment_custom_energy(self,  value:'float'):
    self.set_environment_custom_energy(value)
  @property
  def camera_attributes(self) -> typing.Union['py4godot_cameraattributespractical.CameraAttributesPractical']:
    r''''''
    _ret = self. get_camera_attributes()
    return _ret
  @camera_attributes.setter
  def camera_attributes(self,  value:'py4godot_object.Object'):
    self.set_camera_attributes(value)
  @property
  def generate_probes_subdiv(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_generate_probes()
    return _ret
  @generate_probes_subdiv.setter
  def generate_probes_subdiv(self,  value:'int'):
    self.set_generate_probes(value)
  @property
  def light_data(self) -> typing.Union['py4godot_lightmapgidata.LightmapGIData']:
    r''''''
    _ret = self. get_light_data()
    return _ret
  @light_data.setter
  def light_data(self,  value:'py4godot_object.Object'):
    self.set_light_data(value)
  @functools.native_method
  def set_light_data(self, data:'py4godot_lightmapgidata.LightmapGIData'   ) -> None:
    r''''''

    assert(not data is None)
    assert isinstance(data, get_class('LightmapGIData')), 'data must be LightmapGIData'


    self.py__light_data = data






    self._ptr.call_with_return(264,tuple([data._ptr]))

  @functools.native_method
  def get_light_data(self) -> typing.Union['py4godot_lightmapgidata.LightmapGIData']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: LightmapGIData
    _ret._ptr = self._ptr.call_with_return(265,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_bake_quality(self, bake_quality:'int'  ) -> None:
    r''''''

    assert isinstance(bake_quality, (int, float)), 'bake_quality must be int or float'


    self.py__quality = bake_quality






    self._ptr.call_with_return(266,tuple([bake_quality]))

  @functools.native_method
  def get_bake_quality(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(267,tuple([]))

    return _ret


  @functools.native_method
  def set_bounces(self, bounces:'int'   ) -> None:
    r''''''

    assert isinstance(bounces, (int, float)), 'bounces must be int or float'


    self.py__bounces = bounces






    self._ptr.call_with_return(268,tuple([bounces]))

  @functools.native_method
  def get_bounces(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(269,tuple([]))

    return _ret


  @functools.native_method
  def set_bounce_indirect_energy(self, bounce_indirect_energy:'float'   ) -> None:
    r''''''

    assert isinstance(bounce_indirect_energy, (int, float)), 'bounce_indirect_energy must be int or float'


    self.py__bounce_indirect_energy = bounce_indirect_energy






    self._ptr.call_with_return(270,tuple([bounce_indirect_energy]))

  @functools.native_method
  def get_bounce_indirect_energy(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(271,tuple([]))

    return _ret


  @functools.native_method
  def set_generate_probes(self, subdivision:'int'  ) -> None:
    r''''''

    assert isinstance(subdivision, (int, float)), 'subdivision must be int or float'


    self.py__generate_probes_subdiv = subdivision






    self._ptr.call_with_return(272,tuple([subdivision]))

  @functools.native_method
  def get_generate_probes(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(273,tuple([]))

    return _ret


  @functools.native_method
  def set_bias(self, bias:'float'   ) -> None:
    r''''''

    assert isinstance(bias, (int, float)), 'bias must be int or float'


    self.py__bias = bias






    self._ptr.call_with_return(274,tuple([bias]))

  @functools.native_method
  def get_bias(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(275,tuple([]))

    return _ret


  @functools.native_method
  def set_environment_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__environment_mode = mode






    self._ptr.call_with_return(276,tuple([mode]))

  @functools.native_method
  def get_environment_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(277,tuple([]))

    return _ret


  @functools.native_method
  def set_environment_custom_sky(self, sky:'py4godot_sky.Sky'   ) -> None:
    r''''''

    assert(not sky is None)
    assert isinstance(sky, get_class('Sky')), 'sky must be Sky'


    self.py__environment_custom_sky = sky






    self._ptr.call_with_return(278,tuple([sky._ptr]))

  @functools.native_method
  def get_environment_custom_sky(self) -> typing.Union['py4godot_sky.Sky']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Sky
    _ret._ptr = self._ptr.call_with_return(279,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_environment_custom_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__environment_custom_color = color






    self._ptr.call_with_return(280,tuple([color._ptr]))

  @functools.native_method
  def get_environment_custom_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(281,tuple([]))

    return _ret


  @functools.native_method
  def set_environment_custom_energy(self, energy:'float'   ) -> None:
    r''''''

    assert isinstance(energy, (int, float)), 'energy must be int or float'


    self.py__environment_custom_energy = energy






    self._ptr.call_with_return(282,tuple([energy]))

  @functools.native_method
  def get_environment_custom_energy(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(283,tuple([]))

    return _ret


  @functools.native_method
  def set_texel_scale(self, texel_scale:'float'   ) -> None:
    r''''''

    assert isinstance(texel_scale, (int, float)), 'texel_scale must be int or float'


    self.py__texel_scale = texel_scale






    self._ptr.call_with_return(284,tuple([texel_scale]))

  @functools.native_method
  def get_texel_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(285,tuple([]))

    return _ret


  @functools.native_method
  def set_max_texture_size(self, max_texture_size:'int'   ) -> None:
    r''''''

    assert isinstance(max_texture_size, (int, float)), 'max_texture_size must be int or float'


    self.py__max_texture_size = max_texture_size






    self._ptr.call_with_return(286,tuple([max_texture_size]))

  @functools.native_method
  def get_max_texture_size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(287,tuple([]))

    return _ret


  @functools.native_method
  def set_supersampling_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__supersampling = enable






    self._ptr.call_with_return(288,tuple([enable]))

  @functools.native_method
  def is_supersampling_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(289,tuple([]))

    return _ret


  @functools.native_method
  def set_supersampling_factor(self, factor:'float'   ) -> None:
    r''''''

    assert isinstance(factor, (int, float)), 'factor must be int or float'


    self.py__supersampling_factor = factor






    self._ptr.call_with_return(290,tuple([factor]))

  @functools.native_method
  def get_supersampling_factor(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(291,tuple([]))

    return _ret


  @functools.native_method
  def set_use_denoiser(self, use_denoiser:'bool'   ) -> None:
    r''''''

    assert isinstance(use_denoiser, bool), 'use_denoiser must be bool'


    self.py__use_denoiser = use_denoiser






    self._ptr.call_with_return(292,tuple([use_denoiser]))

  @functools.native_method
  def is_using_denoiser(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(293,tuple([]))

    return _ret


  @functools.native_method
  def set_denoiser_strength(self, denoiser_strength:'float'   ) -> None:
    r''''''

    assert isinstance(denoiser_strength, (int, float)), 'denoiser_strength must be int or float'


    self.py__denoiser_strength = denoiser_strength






    self._ptr.call_with_return(294,tuple([denoiser_strength]))

  @functools.native_method
  def get_denoiser_strength(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(295,tuple([]))

    return _ret


  @functools.native_method
  def set_denoiser_range(self, denoiser_range:'int'   ) -> None:
    r''''''

    assert isinstance(denoiser_range, (int, float)), 'denoiser_range must be int or float'


    self.py__denoiser_range = denoiser_range






    self._ptr.call_with_return(296,tuple([denoiser_range]))

  @functools.native_method
  def get_denoiser_range(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(297,tuple([]))

    return _ret


  @functools.native_method
  def set_interior(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__interior = enable






    self._ptr.call_with_return(298,tuple([enable]))

  @functools.native_method
  def is_interior(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(299,tuple([]))

    return _ret


  @functools.native_method
  def set_directional(self, directional:'bool'   ) -> None:
    r''''''

    assert isinstance(directional, bool), 'directional must be bool'


    self.py__directional = directional






    self._ptr.call_with_return(300,tuple([directional]))

  @functools.native_method
  def is_directional(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(301,tuple([]))

    return _ret


  @functools.native_method
  def set_shadowmask_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__shadowmask_mode = mode






    self._ptr.call_with_return(302,tuple([mode]))

  @functools.native_method
  def get_shadowmask_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(303,tuple([]))

    return _ret


  @functools.native_method
  def set_use_texture_for_bounces(self, use_texture_for_bounces:'bool'   ) -> None:
    r''''''

    assert isinstance(use_texture_for_bounces, bool), 'use_texture_for_bounces must be bool'


    self.py__use_texture_for_bounces = use_texture_for_bounces






    self._ptr.call_with_return(304,tuple([use_texture_for_bounces]))

  @functools.native_method
  def is_using_texture_for_bounces(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(305,tuple([]))

    return _ret


  @functools.native_method
  def set_camera_attributes(self, camera_attributes:'py4godot_cameraattributes.CameraAttributes'   ) -> None:
    r''''''

    assert(not camera_attributes is None)
    assert isinstance(camera_attributes, get_class('CameraAttributes')), 'camera_attributes must be CameraAttributes'


    self.py__camera_attributes = camera_attributes






    self._ptr.call_with_return(306,tuple([camera_attributes._ptr]))

  @functools.native_method
  def get_camera_attributes(self) -> typing.Union['py4godot_cameraattributes.CameraAttributes','py4godot_cameraattributespractical.CameraAttributesPractical','py4godot_cameraattributesphysical.CameraAttributesPhysical']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: CameraAttributes
    _ret._ptr = self._ptr.call_with_return(307,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('LightmapGI', LightmapGI.cast)
register_class('LightmapGI', LightmapGI)
