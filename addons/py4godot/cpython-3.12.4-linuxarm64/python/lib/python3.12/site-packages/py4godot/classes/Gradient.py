# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPGradientWrapper

class InterpolationMode:
  GRADIENT_INTERPOLATE_LINEAR = 0
  GRADIENT_INTERPOLATE_CONSTANT = 1
  GRADIENT_INTERPOLATE_CUBIC = 2
class ColorSpace:
  GRADIENT_COLOR_SPACE_SRGB = 0
  GRADIENT_COLOR_SPACE_LINEAR_SRGB = 1
  GRADIENT_COLOR_SPACE_OKLAB = 2


class Gradient(py4godot_resource.Resource):
  r'''
		This resource describes a color transition by defining a set of colored points and how to interpolate between them.
		See also `Curve` which supports more complex easing methods, but does not support colors.
	'''

  @staticmethod
  def constructor():
    class_ = Gradient.construct_without_init()
    class_._ptr = constructor(379,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Gradient.construct_without_init()
    class_._ptr = constructor(379,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPGradientWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(379,0, ())


  def generate_wrapper(self):
    return CPPGradientWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Gradient.__new__(Gradient)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Gradient'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(94, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Gradient.construct_without_init()
    cls._ptr = CPPGradientWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Gradient.construct_without_init()
    cls._ptr = CPPGradientWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def interpolation_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_interpolation_mode()
    return _ret
  @interpolation_mode.setter
  def interpolation_mode(self,  value:'int'):
    self.set_interpolation_mode(value)
  @property
  def interpolation_color_space(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_interpolation_color_space()
    return _ret
  @interpolation_color_space.setter
  def interpolation_color_space(self,  value:'int'):
    self.set_interpolation_color_space(value)
  @property
  def offsets(self) -> typing.Union['PackedFloat32Array']:
    r''''''
    _ret = self. get_offsets()
    return _ret
  @offsets.setter
  def offsets(self,  value:'PackedFloat32Array'):
    self.set_offsets(value)
  @property
  def colors(self) -> typing.Union['PackedColorArray']:
    r''''''
    _ret = self. get_colors()
    return _ret
  @colors.setter
  def colors(self,  value:'PackedColorArray'):
    self.set_colors(value)
  @functools.native_method
  def add_point(self, offset:'float'   , color:'Color'   ) -> None:
    r'''
				Adds the specified color to the gradient, with the specified offset.
			'''

    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'








    self._ptr.call_with_return(77,tuple([offset, color._ptr]))

  @functools.native_method
  def remove_point(self, point:'int'   ) -> None:
    r'''
				Removes the color at index `point`.
			'''

    assert isinstance(point, (int, float)), 'point must be int or float'







    self._ptr.call_with_return(78,tuple([point]))

  @functools.native_method
  def set_offset(self, point:'int'   , offset:'float'   ) -> None:
    r'''
				Sets the offset for the gradient color at index `point`.
			'''

    assert isinstance(point, (int, float)), 'point must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'








    self._ptr.call_with_return(79,tuple([point, offset]))

  @functools.native_method
  def get_offset(self, point:'int'   ) -> typing.Union[float]:
    r'''
				Returns the offset of the gradient color at index `point`.
			'''

    assert isinstance(point, (int, float)), 'point must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(80,tuple([point]))
    return _ret


  @functools.native_method
  def reverse(self) -> None:
    r'''
				Reverses/mirrors the gradient.
				**Note:** This method mirrors all points around the middle of the gradient, which may produce unexpected results when `interpolation_mode` is set to `constant GRADIENT_INTERPOLATE_CONSTANT`.
			'''




    self._ptr.call_with_return(81,tuple([]))

  @functools.native_method
  def set_color(self, point:'int'   , color:'Color'   ) -> None:
    r'''
				Sets the color of the gradient color at index `point`.
			'''

    assert isinstance(point, (int, float)), 'point must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'








    self._ptr.call_with_return(82,tuple([point, color._ptr]))

  @functools.native_method
  def get_color(self, point:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the color of the gradient color at index `point`.
			'''

    assert isinstance(point, (int, float)), 'point must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(83,tuple([point]))
    return _ret


  @functools.native_method
  def sample(self, offset:'float'   ) -> typing.Union['Color']:
    r'''
				Returns the interpolated color specified by `offset`. `offset` should be between `0.0` and `1.0` (inclusive). Using a value lower than `0.0` will return the same color as `0.0`, and using a value higher than `1.0` will return the same color as `1.0`. If your input value is not within this range, consider using `@GlobalScope.remap` on the input value with output values set to `0.0` and `1.0`.
			'''

    assert isinstance(offset, (int, float)), 'offset must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(84,tuple([offset]))
    return _ret


  @functools.native_method
  def get_point_count(self) -> typing.Union[int]:
    r'''
				Returns the number of colors in the gradient.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([]))
    return _ret


  @functools.native_method
  def set_offsets(self, offsets:'PackedFloat32Array'   ) -> None:
    r''''''

    assert(not offsets is None)
    assert isinstance(offsets, PackedFloat32Array), 'offsets must be PackedFloat32Array'


    self.py__offsets = offsets






    self._ptr.call_with_return(86,tuple([offsets._ptr]))

  @functools.native_method
  def get_offsets(self) -> typing.Union['PackedFloat32Array']:
    r''''''




    _ret = PackedFloat32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([]))

    return _ret


  @functools.native_method
  def set_colors(self, colors:'PackedColorArray'   ) -> None:
    r''''''

    assert(not colors is None)
    assert isinstance(colors, PackedColorArray), 'colors must be PackedColorArray'


    self.py__colors = colors






    self._ptr.call_with_return(88,tuple([colors._ptr]))

  @functools.native_method
  def get_colors(self) -> typing.Union['PackedColorArray']:
    r''''''




    _ret = PackedColorArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(89,tuple([]))

    return _ret


  @functools.native_method
  def set_interpolation_mode(self, interpolation_mode:'int'  ) -> None:
    r''''''

    assert isinstance(interpolation_mode, (int, float)), 'interpolation_mode must be int or float'


    self.py__interpolation_mode = interpolation_mode






    self._ptr.call_with_return(90,tuple([interpolation_mode]))

  @functools.native_method
  def get_interpolation_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(91,tuple([]))

    return _ret


  @functools.native_method
  def set_interpolation_color_space(self, interpolation_color_space:'int'  ) -> None:
    r''''''

    assert isinstance(interpolation_color_space, (int, float)), 'interpolation_color_space must be int or float'


    self.py__interpolation_color_space = interpolation_color_space






    self._ptr.call_with_return(92,tuple([interpolation_color_space]))

  @functools.native_method
  def get_interpolation_color_space(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(93,tuple([]))

    return _ret



register_cast_function('Gradient', Gradient.cast)
register_class('Gradient', Gradient)
