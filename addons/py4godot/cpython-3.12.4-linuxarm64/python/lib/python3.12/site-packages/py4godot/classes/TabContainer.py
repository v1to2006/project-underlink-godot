# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.Tree as py4godot_tree 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.PopupPanel as py4godot_popuppanel 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.RichTextLabel as py4godot_richtextlabel 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.TabBar as py4godot_tabbar 
  import py4godot.classes.Popup as py4godot_popup 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.PopupMenu as py4godot_popupmenu 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.Node as py4godot_node 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.TextEdit as py4godot_textedit 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.GraphElement as py4godot_graphelement 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.GraphNode as py4godot_graphnode 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.Control as py4godot_control 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.FoldableContainer as py4godot_foldablecontainer 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
import py4godot.classes.Container as py4godot_container 
from py4godot.wrappers.wrappers import CPPTabContainerWrapper

class TabPosition:
  POSITION_TOP = 0
  POSITION_BOTTOM = 1
  POSITION_MAX = 2


class TabContainer(py4godot_container.Container):
  r'''
		Arranges child controls into a tabbed view, creating a tab for each one. The active tab's corresponding control is made visible, while all other child controls are hidden. Ignores non-control children.
		**Note:** The drawing of the clickable tabs is handled by this node; `TabBar` is not needed.
	'''

  @staticmethod
  def constructor():
    class_ = TabContainer.construct_without_init()
    class_._ptr = constructor(807,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TabContainer.construct_without_init()
    class_._ptr = constructor(807,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTabContainerWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(807,0, ())


  def generate_wrapper(self):
    return CPPTabContainerWrapper()
  def init_signals(self):
    super().init_signals()
    active_tab_rearranged_name = utils.py_string_to_string_name("active_tab_rearranged")
    self.active_tab_rearranged = signals.BuiltinSignal(self, active_tab_rearranged_name)
    tab_changed_name = utils.py_string_to_string_name("tab_changed")
    self.tab_changed = signals.BuiltinSignal(self, tab_changed_name)
    tab_clicked_name = utils.py_string_to_string_name("tab_clicked")
    self.tab_clicked = signals.BuiltinSignal(self, tab_clicked_name)
    tab_hovered_name = utils.py_string_to_string_name("tab_hovered")
    self.tab_hovered = signals.BuiltinSignal(self, tab_hovered_name)
    tab_selected_name = utils.py_string_to_string_name("tab_selected")
    self.tab_selected = signals.BuiltinSignal(self, tab_selected_name)
    tab_button_pressed_name = utils.py_string_to_string_name("tab_button_pressed")
    self.tab_button_pressed = signals.BuiltinSignal(self, tab_button_pressed_name)
    pre_popup_pressed_name = utils.py_string_to_string_name("pre_popup_pressed")
    self.pre_popup_pressed = signals.BuiltinSignal(self, pre_popup_pressed_name)

  @staticmethod
  def construct_without_init():
    cls = TabContainer.__new__(TabContainer)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TabContainer'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TabContainer.construct_without_init()
    cls._ptr = CPPTabContainerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TabContainer.construct_without_init()
    cls._ptr = CPPTabContainerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def tab_alignment(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tab_alignment()
    return _ret
  @tab_alignment.setter
  def tab_alignment(self,  value:'int'):
    self.set_tab_alignment(value)
  @property
  def current_tab(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_current_tab()
    return _ret
  @current_tab.setter
  def current_tab(self,  value:'int'):
    self.set_current_tab(value)
  @property
  def tabs_position(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tabs_position()
    return _ret
  @tabs_position.setter
  def tabs_position(self,  value:'int'):
    self.set_tabs_position(value)
  @property
  def clip_tabs(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_clip_tabs()
    return _ret
  @clip_tabs.setter
  def clip_tabs(self,  value:'bool'):
    self.set_clip_tabs(value)
  @property
  def tabs_visible(self) -> typing.Union[bool]:
    r''''''
    _ret = self. are_tabs_visible()
    return _ret
  @tabs_visible.setter
  def tabs_visible(self,  value:'bool'):
    self.set_tabs_visible(value)
  @property
  def all_tabs_in_front(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_all_tabs_in_front()
    return _ret
  @all_tabs_in_front.setter
  def all_tabs_in_front(self,  value:'bool'):
    self.set_all_tabs_in_front(value)
  @property
  def drag_to_rearrange_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_drag_to_rearrange_enabled()
    return _ret
  @drag_to_rearrange_enabled.setter
  def drag_to_rearrange_enabled(self,  value:'bool'):
    self.set_drag_to_rearrange_enabled(value)
  @property
  def tabs_rearrange_group(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tabs_rearrange_group()
    return _ret
  @tabs_rearrange_group.setter
  def tabs_rearrange_group(self,  value:'int'):
    self.set_tabs_rearrange_group(value)
  @property
  def use_hidden_tabs_for_min_size(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_use_hidden_tabs_for_min_size()
    return _ret
  @use_hidden_tabs_for_min_size.setter
  def use_hidden_tabs_for_min_size(self,  value:'bool'):
    self.set_use_hidden_tabs_for_min_size(value)
  @property
  def tab_focus_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tab_focus_mode()
    return _ret
  @tab_focus_mode.setter
  def tab_focus_mode(self,  value:'int'):
    self.set_tab_focus_mode(value)
  @property
  def deselect_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_deselect_enabled()
    return _ret
  @deselect_enabled.setter
  def deselect_enabled(self,  value:'bool'):
    self.set_deselect_enabled(value)
  @functools.native_method
  def get_tab_count(self) -> typing.Union[int]:
    r'''
				Returns the number of tabs.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(437,tuple([]))
    return _ret


  @functools.native_method
  def set_current_tab(self, tab_idx:'int'   ) -> None:
    r''''''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'


    self.py__current_tab = tab_idx






    self._ptr.call_with_return(438,tuple([tab_idx]))

  @functools.native_method
  def get_current_tab(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(439,tuple([]))

    return _ret


  @functools.native_method
  def get_previous_tab(self) -> typing.Union[int]:
    r'''
				Returns the previously active tab index.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(440,tuple([]))
    return _ret


  @functools.native_method
  def select_previous_available(self) -> typing.Union[bool]:
    r'''
				Selects the first available tab with lower index than the currently selected. Returns `true` if tab selection changed.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(441,tuple([]))
    return _ret


  @functools.native_method
  def select_next_available(self) -> typing.Union[bool]:
    r'''
				Selects the first available tab with greater index than the currently selected. Returns `true` if tab selection changed.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(442,tuple([]))
    return _ret


  @functools.native_method
  def get_current_tab_control(self) -> typing.Any:
    r'''
				Returns the child `Control` node located at the active tab index.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Control
    _ret._ptr = self._ptr.call_with_return(443,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_tab_bar(self) -> typing.Union['py4godot_tabbar.TabBar']:
    r'''
				Returns the `TabBar` contained in this container.
				**Warning:** This is a required internal node, removing and freeing it or editing its tabs may cause a crash. If you wish to edit the tabs, use the methods provided in `TabContainer`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TabBar
    _ret._ptr = self._ptr.call_with_return(444,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_tab_control(self, tab_idx:'int'   ) -> typing.Any:
    r'''
				Returns the `Control` node from the tab at index `tab_idx`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Control
    _ret._ptr = self._ptr.call_with_return(445,tuple([tab_idx]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_tab_alignment(self, alignment:'int'  ) -> None:
    r''''''

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'


    self.py__tab_alignment = alignment






    self._ptr.call_with_return(446,tuple([alignment]))

  @functools.native_method
  def get_tab_alignment(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(447,tuple([]))

    return _ret


  @functools.native_method
  def set_tabs_position(self, tabs_position:'int'  ) -> None:
    r''''''

    assert isinstance(tabs_position, (int, float)), 'tabs_position must be int or float'


    self.py__tabs_position = tabs_position






    self._ptr.call_with_return(448,tuple([tabs_position]))

  @functools.native_method
  def get_tabs_position(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(449,tuple([]))

    return _ret


  @functools.native_method
  def set_clip_tabs(self, clip_tabs:'bool'   ) -> None:
    r''''''

    assert isinstance(clip_tabs, bool), 'clip_tabs must be bool'


    self.py__clip_tabs = clip_tabs






    self._ptr.call_with_return(450,tuple([clip_tabs]))

  @functools.native_method
  def get_clip_tabs(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(451,tuple([]))

    return _ret


  @functools.native_method
  def set_tabs_visible(self, visible:'bool'   ) -> None:
    r''''''

    assert isinstance(visible, bool), 'visible must be bool'


    self.py__tabs_visible = visible






    self._ptr.call_with_return(452,tuple([visible]))

  @functools.native_method
  def are_tabs_visible(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(453,tuple([]))

    return _ret


  @functools.native_method
  def set_all_tabs_in_front(self, is_front:'bool'   ) -> None:
    r''''''

    assert isinstance(is_front, bool), 'is_front must be bool'


    self.py__all_tabs_in_front = is_front






    self._ptr.call_with_return(454,tuple([is_front]))

  @functools.native_method
  def is_all_tabs_in_front(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(455,tuple([]))

    return _ret


  @functools.native_method
  def set_tab_title(self, tab_idx:'int'   , title:'str'   ) -> None:
    r'''
				Sets a custom title for the tab at index `tab_idx` (tab titles default to the name of the indexed child node). Set it back to the child's name to make the tab default to it again.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert(not title is None)
    assert isinstance(title, (str, String)), 'title must be str or String'






    assert(isinstance(title, (str, String)))
    py_string_title = title if isinstance(title, StringName) else c_utils.py_string_to_string(title)

    self._ptr.call_with_return(456,tuple([tab_idx, py_string_title._ptr]))

  @functools.native_method
  def get_tab_title(self, tab_idx:'int'   ) -> typing.Union[str]:
    r'''
				Returns the title of the tab at index `tab_idx`. Tab titles default to the name of the indexed child node, but this can be overridden with `set_tab_title`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(457,tuple([tab_idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_tab_tooltip(self, tab_idx:'int'   , tooltip:'str'   ) -> None:
    r'''
				Sets a custom tooltip text for tab at index `tab_idx`.
				**Note:** By default, if the `tooltip` is empty and the tab text is truncated (not all characters fit into the tab), the title will be displayed as a tooltip. To hide the tooltip, assign `" "` as the `tooltip` text.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert(not tooltip is None)
    assert isinstance(tooltip, (str, String)), 'tooltip must be str or String'






    assert(isinstance(tooltip, (str, String)))
    py_string_tooltip = tooltip if isinstance(tooltip, StringName) else c_utils.py_string_to_string(tooltip)

    self._ptr.call_with_return(458,tuple([tab_idx, py_string_tooltip._ptr]))

  @functools.native_method
  def get_tab_tooltip(self, tab_idx:'int'   ) -> typing.Union[str]:
    r'''
				Returns the tooltip text of the tab at index `tab_idx`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(459,tuple([tab_idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_tab_icon(self, tab_idx:'int'   , icon:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets an icon for the tab at index `tab_idx`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'








    self._ptr.call_with_return(460,tuple([tab_idx, icon._ptr]))

  @functools.native_method
  def get_tab_icon(self, tab_idx:'int'   ) -> typing.Any:
    r'''
				Returns the `Texture2D` for the tab at index `tab_idx` or `null` if the tab has no `Texture2D`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(461,tuple([tab_idx]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_tab_icon_max_width(self, tab_idx:'int'   , width:'int'   ) -> None:
    r'''
				Sets the maximum allowed width of the icon for the tab at index `tab_idx`. This limit is applied on top of the default size of the icon and on top of `theme_item icon_max_width`. The height is adjusted according to the icon's ratio.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'








    self._ptr.call_with_return(462,tuple([tab_idx, width]))

  @functools.native_method
  def get_tab_icon_max_width(self, tab_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the maximum allowed width of the icon for the tab at index `tab_idx`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(463,tuple([tab_idx]))
    return _ret


  @functools.native_method
  def set_tab_disabled(self, tab_idx:'int'   , disabled:'bool'   ) -> None:
    r'''
				If `disabled` is `true`, disables the tab at index `tab_idx`, making it non-interactable.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert isinstance(disabled, bool), 'disabled must be bool'








    self._ptr.call_with_return(464,tuple([tab_idx, disabled]))

  @functools.native_method
  def is_tab_disabled(self, tab_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the tab at index `tab_idx` is disabled.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(465,tuple([tab_idx]))
    return _ret


  @functools.native_method
  def set_tab_hidden(self, tab_idx:'int'   , hidden:'bool'   ) -> None:
    r'''
				If `hidden` is `true`, hides the tab at index `tab_idx`, making it disappear from the tab area.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert isinstance(hidden, bool), 'hidden must be bool'








    self._ptr.call_with_return(466,tuple([tab_idx, hidden]))

  @functools.native_method
  def is_tab_hidden(self, tab_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the tab at index `tab_idx` is hidden.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(467,tuple([tab_idx]))
    return _ret


  @functools.native_method
  def set_tab_metadata(self, tab_idx:'int'   , metadata:'object'   ) -> None:
    r'''
				Sets the metadata value for the tab at index `tab_idx`, which can be retrieved later using `get_tab_metadata`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    

    if not (type(metadata).__name__ in py4godot.variant_types.core_types or isinstance(metadata, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'metadata': "
                f"{type(metadata).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    self._ptr.call_with_return(468,tuple([tab_idx, metadata]))

  @functools.native_method
  def get_tab_metadata(self, tab_idx:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the metadata value set to the tab at index `tab_idx` using `set_tab_metadata`. If no metadata was previously set, returns `null` by default.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = None
    _ret = self._ptr.call_with_return(469,tuple([tab_idx]))
    return _ret


  @functools.native_method
  def set_tab_button_icon(self, tab_idx:'int'   , icon:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets the button icon from the tab at index `tab_idx`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'








    self._ptr.call_with_return(470,tuple([tab_idx, icon._ptr]))

  @functools.native_method
  def get_tab_button_icon(self, tab_idx:'int'   ) -> typing.Any:
    r'''
				Returns the button icon from the tab at index `tab_idx`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(471,tuple([tab_idx]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_tab_idx_at_point(self, point:'Vector2'   ) -> typing.Union[int]:
    r'''
				Returns the index of the tab at local coordinates `point`. Returns `-1` if the point is outside the control boundaries or if there's no tab at the queried position.
			'''

    assert(not point is None)
    assert isinstance(point, Vector2), 'point must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(472,tuple([point._ptr]))
    return _ret


  @functools.native_method
  def get_tab_idx_from_control(self, control:'py4godot_control.Control'   ) -> typing.Union[int]:
    r'''
				Returns the index of the tab tied to the given `control`. The control must be a child of the `TabContainer`.
			'''

    assert(not control is None)
    assert isinstance(control, get_class('Control')), 'control must be Control'







    _ret = 0
    _ret = self._ptr.call_with_return(473,tuple([control._ptr]))
    return _ret


  @functools.native_method
  def set_popup(self, popup:'py4godot_node.Node'   ) -> None:
    r'''
				If set on a `Popup` node instance, a popup menu icon appears in the top-right corner of the `TabContainer` (setting it to `null` will make it go away). Clicking it will expand the `Popup` node.
			'''

    assert(not popup is None)
    assert isinstance(popup, get_class('Node')), 'popup must be Node'







    self._ptr.call_with_return(474,tuple([popup._ptr]))

  @functools.native_method
  def get_popup(self) -> typing.Union['py4godot_popuppanel.PopupPanel','py4godot_popupmenu.PopupMenu','py4godot_popup.Popup']:
    r'''
				Returns the `Popup` node instance if one has been set already with `set_popup`.
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their `Window.visible` property.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Popup
    _ret._ptr = self._ptr.call_with_return(475,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_drag_to_rearrange_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__drag_to_rearrange_enabled = enabled






    self._ptr.call_with_return(476,tuple([enabled]))

  @functools.native_method
  def get_drag_to_rearrange_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(477,tuple([]))

    return _ret


  @functools.native_method
  def set_tabs_rearrange_group(self, group_id:'int'   ) -> None:
    r''''''

    assert isinstance(group_id, (int, float)), 'group_id must be int or float'


    self.py__tabs_rearrange_group = group_id






    self._ptr.call_with_return(478,tuple([group_id]))

  @functools.native_method
  def get_tabs_rearrange_group(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(479,tuple([]))

    return _ret


  @functools.native_method
  def set_use_hidden_tabs_for_min_size(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__use_hidden_tabs_for_min_size = enabled






    self._ptr.call_with_return(480,tuple([enabled]))

  @functools.native_method
  def get_use_hidden_tabs_for_min_size(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(481,tuple([]))

    return _ret


  @functools.native_method
  def set_tab_focus_mode(self, focus_mode:'int'  ) -> None:
    r''''''

    assert isinstance(focus_mode, (int, float)), 'focus_mode must be int or float'


    self.py__tab_focus_mode = focus_mode






    self._ptr.call_with_return(482,tuple([focus_mode]))

  @functools.native_method
  def get_tab_focus_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(483,tuple([]))

    return _ret


  @functools.native_method
  def set_deselect_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__deselect_enabled = enabled






    self._ptr.call_with_return(484,tuple([enabled]))

  @functools.native_method
  def get_deselect_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(485,tuple([]))

    return _ret



register_cast_function('TabContainer', TabContainer.cast)
register_class('TabContainer', TabContainer)
