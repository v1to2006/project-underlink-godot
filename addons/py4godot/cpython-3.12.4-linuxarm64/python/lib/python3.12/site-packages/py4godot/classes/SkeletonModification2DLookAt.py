# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.SkeletonModification2D as py4godot_skeletonmodification2d 
from py4godot.wrappers.wrappers import CPPSkeletonModification2DLookAtWrapper


class SkeletonModification2DLookAt(py4godot_skeletonmodification2d.SkeletonModification2D):
  r'''
		This `SkeletonModification2D` rotates a bone to look a target. This is extremely helpful for moving character's head to look at the player, rotating a turret to look at a target, or any other case where you want to make a bone rotate towards something quickly and easily.
	'''

  @staticmethod
  def constructor():
    class_ = SkeletonModification2DLookAt.construct_without_init()
    class_._ptr = constructor(753,0, ())
    return class_
  @staticmethod
  def new():
    class_ = SkeletonModification2DLookAt.construct_without_init()
    class_._ptr = constructor(753,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPSkeletonModification2DLookAtWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(753,0, ())


  def generate_wrapper(self):
    return CPPSkeletonModification2DLookAtWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = SkeletonModification2DLookAt.__new__(SkeletonModification2DLookAt)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'SkeletonModification2DLookAt'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(106, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = SkeletonModification2DLookAt.construct_without_init()
    cls._ptr = CPPSkeletonModification2DLookAtWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = SkeletonModification2DLookAt.construct_without_init()
    cls._ptr = CPPSkeletonModification2DLookAtWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def bone_index(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_bone_index()
    return _ret
  @bone_index.setter
  def bone_index(self,  value:'int'):
    self.set_bone_index(value)
  @property
  def bone2d_node(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_bone2d_node()
    return _ret
  @bone2d_node.setter
  def bone2d_node(self,  value:'object'):
    self.set_bone2d_node(value)
  @property
  def target_nodepath(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_target_node()
    return _ret
  @target_nodepath.setter
  def target_nodepath(self,  value:'object'):
    self.set_target_node(value)
  @functools.native_method
  def set_bone2d_node(self, bone2d_nodepath:'object'   ) -> None:
    r''''''

    assert(not bone2d_nodepath is None)
    assert isinstance(bone2d_nodepath, (str, NodePath)), 'bone2d_nodepath must be str or NodePath'


    self.py__bone2d_node = bone2d_nodepath



    assert(isinstance(bone2d_nodepath, (str, NodePath)))
    py_nodepath_bone2d_nodepath = bone2d_nodepath if isinstance(bone2d_nodepath,NodePath) else NodePath.new2(bone2d_nodepath)


    self._ptr.call_with_return(90,tuple([py_nodepath_bone2d_nodepath._ptr]))

  @functools.native_method
  def get_bone2d_node(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([]))

    return _ret


  @functools.native_method
  def set_bone_index(self, bone_idx:'int'   ) -> None:
    r''''''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'


    self.py__bone_index = bone_idx






    self._ptr.call_with_return(92,tuple([bone_idx]))

  @functools.native_method
  def get_bone_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([]))

    return _ret


  @functools.native_method
  def set_target_node(self, target_nodepath:'object'   ) -> None:
    r''''''

    assert(not target_nodepath is None)
    assert isinstance(target_nodepath, (str, NodePath)), 'target_nodepath must be str or NodePath'


    self.py__target_nodepath = target_nodepath



    assert(isinstance(target_nodepath, (str, NodePath)))
    py_nodepath_target_nodepath = target_nodepath if isinstance(target_nodepath,NodePath) else NodePath.new2(target_nodepath)


    self._ptr.call_with_return(94,tuple([py_nodepath_target_nodepath._ptr]))

  @functools.native_method
  def get_target_node(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(95,tuple([]))

    return _ret


  @functools.native_method
  def set_additional_rotation(self, rotation:'float'   ) -> None:
    r'''
				Sets the amount of additional rotation that is to be applied after executing the modification. This allows for offsetting the results by the inputted rotation amount.
			'''

    assert isinstance(rotation, (int, float)), 'rotation must be int or float'







    self._ptr.call_with_return(96,tuple([rotation]))

  @functools.native_method
  def get_additional_rotation(self) -> typing.Union[float]:
    r'''
				Returns the amount of additional rotation that is applied after the LookAt modification executes.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([]))
    return _ret


  @functools.native_method
  def set_enable_constraint(self, enable_constraint:'bool'   ) -> None:
    r'''
				Sets whether this modification will use constraints or not. When `true`, constraints will be applied when solving the LookAt modification.
			'''

    assert isinstance(enable_constraint, bool), 'enable_constraint must be bool'







    self._ptr.call_with_return(98,tuple([enable_constraint]))

  @functools.native_method
  def get_enable_constraint(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the LookAt modification is using constraints.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([]))
    return _ret


  @functools.native_method
  def set_constraint_angle_min(self, angle_min:'float'   ) -> None:
    r'''
				Sets the constraint's minimum allowed angle.
			'''

    assert isinstance(angle_min, (int, float)), 'angle_min must be int or float'







    self._ptr.call_with_return(100,tuple([angle_min]))

  @functools.native_method
  def get_constraint_angle_min(self) -> typing.Union[float]:
    r'''
				Returns the constraint's minimum allowed angle.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(101,tuple([]))
    return _ret


  @functools.native_method
  def set_constraint_angle_max(self, angle_max:'float'   ) -> None:
    r'''
				Sets the constraint's maximum allowed angle.
			'''

    assert isinstance(angle_max, (int, float)), 'angle_max must be int or float'







    self._ptr.call_with_return(102,tuple([angle_max]))

  @functools.native_method
  def get_constraint_angle_max(self) -> typing.Union[float]:
    r'''
				Returns the constraint's maximum allowed angle.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([]))
    return _ret


  @functools.native_method
  def set_constraint_angle_invert(self, invert:'bool'   ) -> None:
    r'''
				When `true`, the modification will use an inverted joint constraint.
				An inverted joint constraint only constraints the `Bone2D` to the angles _outside of_ the inputted minimum and maximum angles. For this reason, it is referred to as an inverted joint constraint, as it constraints the joint to the outside of the inputted values.
			'''

    assert isinstance(invert, bool), 'invert must be bool'







    self._ptr.call_with_return(104,tuple([invert]))

  @functools.native_method
  def get_constraint_angle_invert(self) -> typing.Union[bool]:
    r'''
				Returns whether the constraints to this modification are inverted or not.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(105,tuple([]))
    return _ret



register_cast_function('SkeletonModification2DLookAt', SkeletonModification2DLookAt.cast)
register_class('SkeletonModification2DLookAt', SkeletonModification2DLookAt)
