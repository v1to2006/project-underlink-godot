# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.Tree as py4godot_tree 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.TextEdit as py4godot_textedit 
  import py4godot.classes.Font as py4godot_font 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.RichTextEffect as py4godot_richtexteffect 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.GraphElement as py4godot_graphelement 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.TabBar as py4godot_tabbar 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.GraphNode as py4godot_graphnode 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.TextServer as py4godot_textserver 
  import py4godot.classes.Container as py4godot_container 
  import py4godot.classes.TextServerAdvanced as py4godot_textserveradvanced 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.TextServerDummy as py4godot_textserverdummy 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.PopupMenu as py4godot_popupmenu 
  import py4godot.classes.FoldableContainer as py4godot_foldablecontainer 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.TabContainer as py4godot_tabcontainer 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.TextServerExtension as py4godot_textserverextension 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
import py4godot.classes.Control as py4godot_control 
from py4godot.wrappers.wrappers import CPPRichTextLabelWrapper

class ListType:
  LIST_NUMBERS = 0
  LIST_LETTERS = 1
  LIST_ROMAN = 2
  LIST_DOTS = 3
class MenuItems:
  MENU_COPY = 0
  MENU_SELECT_ALL = 1
  MENU_MAX = 2
class MetaUnderline:
  META_UNDERLINE_NEVER = 0
  META_UNDERLINE_ALWAYS = 1
  META_UNDERLINE_ON_HOVER = 2
class ImageUpdateMask:
  UPDATE_TEXTURE = 1
  UPDATE_SIZE = 2
  UPDATE_COLOR = 4
  UPDATE_ALIGNMENT = 8
  UPDATE_REGION = 16
  UPDATE_PAD = 32
  UPDATE_TOOLTIP = 64
  UPDATE_WIDTH_IN_PERCENT = 128


class RichTextLabel(py4godot_control.Control):
  r'''
		A control for displaying text that can contain custom fonts, images, and basic formatting. `RichTextLabel` manages these as an internal tag stack. It also adapts itself to given width/heights.
		**Note:** `newline`, `push_paragraph`, `"\n"`, `"\r\n"`, `p` tag, and alignment tags start a new paragraph. Each paragraph is processed independently, in its own BiDi context. If you want to force line wrapping within paragraph, any other line breaking character can be used, for example, Form Feed (U+000C), Next Line (U+0085), Line Separator (U+2028).
		**Note:** Assignments to `text` clear the tag stack and reconstruct it from the property's contents. Any edits made to `text` will erase previous edits made from other manual sources such as `append_text` and the `push_*` / `pop` methods.
		**Note:** RichTextLabel doesn't support entangled BBCode tags. For example, instead of using `code skip-lint`**bold_bold italic**italic_`, use `code skip-lint`**bold_bold italic_**_italic_`.
		**Note:** `push_*/pop_*` functions won't affect BBCode.
		**Note:** While `bbcode_enabled` is enabled, alignment tags such as `code skip-lint``center`` will take priority over the `horizontal_alignment` setting which determines the default text alignment.
	'''

  @staticmethod
  def constructor():
    class_ = RichTextLabel.construct_without_init()
    class_._ptr = constructor(712,0, ())
    return class_
  @staticmethod
  def new():
    class_ = RichTextLabel.construct_without_init()
    class_._ptr = constructor(712,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPRichTextLabelWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(712,0, ())


  def generate_wrapper(self):
    return CPPRichTextLabelWrapper()
  def init_signals(self):
    super().init_signals()
    meta_clicked_name = utils.py_string_to_string_name("meta_clicked")
    self.meta_clicked = signals.BuiltinSignal(self, meta_clicked_name)
    meta_hover_started_name = utils.py_string_to_string_name("meta_hover_started")
    self.meta_hover_started = signals.BuiltinSignal(self, meta_hover_started_name)
    meta_hover_ended_name = utils.py_string_to_string_name("meta_hover_ended")
    self.meta_hover_ended = signals.BuiltinSignal(self, meta_hover_ended_name)
    finished_name = utils.py_string_to_string_name("finished")
    self.finished = signals.BuiltinSignal(self, finished_name)

  @staticmethod
  def construct_without_init():
    cls = RichTextLabel.__new__(RichTextLabel)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'RichTextLabel'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = RichTextLabel.construct_without_init()
    cls._ptr = CPPRichTextLabelWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = RichTextLabel.construct_without_init()
    cls._ptr = CPPRichTextLabelWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def bbcode_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_bbcode()
    return _ret
  @bbcode_enabled.setter
  def bbcode_enabled(self,  value:'bool'):
    self.set_use_bbcode(value)
  @property
  def text(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_text()
    return _ret
  @text.setter
  def text(self,  value:'str'):
    self.set_text(value)
  @property
  def fit_content(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_fit_content_enabled()
    return _ret
  @fit_content.setter
  def fit_content(self,  value:'bool'):
    self.set_fit_content(value)
  @property
  def scroll_active(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_scroll_active()
    return _ret
  @scroll_active.setter
  def scroll_active(self,  value:'bool'):
    self.set_scroll_active(value)
  @property
  def scroll_following(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_scroll_following()
    return _ret
  @scroll_following.setter
  def scroll_following(self,  value:'bool'):
    self.set_scroll_follow(value)
  @property
  def scroll_following_visible_characters(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_scroll_following_visible_characters()
    return _ret
  @scroll_following_visible_characters.setter
  def scroll_following_visible_characters(self,  value:'bool'):
    self.set_scroll_follow_visible_characters(value)
  @property
  def autowrap_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_autowrap_mode()
    return _ret
  @autowrap_mode.setter
  def autowrap_mode(self,  value:'int'):
    self.set_autowrap_mode(value)
  @property
  def autowrap_trim_flags(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_autowrap_trim_flags()
    return _ret
  @autowrap_trim_flags.setter
  def autowrap_trim_flags(self,  value:'int'):
    self.set_autowrap_trim_flags(value)
  @property
  def tab_size(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tab_size()
    return _ret
  @tab_size.setter
  def tab_size(self,  value:'int'):
    self.set_tab_size(value)
  @property
  def context_menu_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_context_menu_enabled()
    return _ret
  @context_menu_enabled.setter
  def context_menu_enabled(self,  value:'bool'):
    self.set_context_menu_enabled(value)
  @property
  def shortcut_keys_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_shortcut_keys_enabled()
    return _ret
  @shortcut_keys_enabled.setter
  def shortcut_keys_enabled(self,  value:'bool'):
    self.set_shortcut_keys_enabled(value)
  @property
  def horizontal_alignment(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_horizontal_alignment()
    return _ret
  @horizontal_alignment.setter
  def horizontal_alignment(self,  value:'int'):
    self.set_horizontal_alignment(value)
  @property
  def vertical_alignment(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_vertical_alignment()
    return _ret
  @vertical_alignment.setter
  def vertical_alignment(self,  value:'int'):
    self.set_vertical_alignment(value)
  @property
  def justification_flags(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_justification_flags()
    return _ret
  @justification_flags.setter
  def justification_flags(self,  value:'int'):
    self.set_justification_flags(value)
  @property
  def tab_stops(self) -> typing.Union['PackedFloat32Array']:
    r''''''
    _ret = self. get_tab_stops()
    return _ret
  @tab_stops.setter
  def tab_stops(self,  value:'PackedFloat32Array'):
    self.set_tab_stops(value)
  @property
  def custom_effects(self) -> typing.Union['py4godot_richtexteffecttypedarray.RichTextEffectTypedArray']:
    r''''''
    _ret = self. get_effects()
    return _ret
  @custom_effects.setter
  def custom_effects(self, value:'Array'):
    self.set_effects(value)
  @property
  def meta_underlined(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_meta_underlined()
    return _ret
  @meta_underlined.setter
  def meta_underlined(self,  value:'bool'):
    self.set_meta_underline(value)
  @property
  def hint_underlined(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_hint_underlined()
    return _ret
  @hint_underlined.setter
  def hint_underlined(self,  value:'bool'):
    self.set_hint_underline(value)
  @property
  def threaded(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_threaded()
    return _ret
  @threaded.setter
  def threaded(self,  value:'bool'):
    self.set_threaded(value)
  @property
  def progress_bar_delay(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_progress_bar_delay()
    return _ret
  @progress_bar_delay.setter
  def progress_bar_delay(self,  value:'int'):
    self.set_progress_bar_delay(value)
  @property
  def selection_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_selection_enabled()
    return _ret
  @selection_enabled.setter
  def selection_enabled(self,  value:'bool'):
    self.set_selection_enabled(value)
  @property
  def deselect_on_focus_loss_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_deselect_on_focus_loss_enabled()
    return _ret
  @deselect_on_focus_loss_enabled.setter
  def deselect_on_focus_loss_enabled(self,  value:'bool'):
    self.set_deselect_on_focus_loss_enabled(value)
  @property
  def drag_and_drop_selection_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_drag_and_drop_selection_enabled()
    return _ret
  @drag_and_drop_selection_enabled.setter
  def drag_and_drop_selection_enabled(self,  value:'bool'):
    self.set_drag_and_drop_selection_enabled(value)
  @property
  def visible_characters(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_visible_characters()
    return _ret
  @visible_characters.setter
  def visible_characters(self,  value:'int'):
    self.set_visible_characters(value)
  @property
  def visible_characters_behavior(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_visible_characters_behavior()
    return _ret
  @visible_characters_behavior.setter
  def visible_characters_behavior(self,  value:'int'):
    self.set_visible_characters_behavior(value)
  @property
  def visible_ratio(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_visible_ratio()
    return _ret
  @visible_ratio.setter
  def visible_ratio(self,  value:'float'):
    self.set_visible_ratio(value)
  @property
  def text_direction(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_text_direction()
    return _ret
  @text_direction.setter
  def text_direction(self,  value:'int'):
    self.set_text_direction(value)
  @property
  def language(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_language()
    return _ret
  @language.setter
  def language(self,  value:'str'):
    self.set_language(value)
  @property
  def structured_text_bidi_override(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_structured_text_bidi_override()
    return _ret
  @structured_text_bidi_override.setter
  def structured_text_bidi_override(self,  value:'int'):
    self.set_structured_text_bidi_override(value)
  @property
  def structured_text_bidi_override_options(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_structured_text_bidi_override_options()
    return _ret
  @structured_text_bidi_override_options.setter
  def structured_text_bidi_override_options(self,  value:'Array'):
    self.set_structured_text_bidi_override_options(value)
  @functools.native_method
  def get_parsed_text(self) -> typing.Union[str]:
    r'''
				Returns the text without BBCode mark-up.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(433,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def add_text(self, text:'str'   ) -> None:
    r'''
				Adds raw non-BBCode-parsed text to the tag stack.
			'''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    self._ptr.call_with_return(434,tuple([py_string_text._ptr]))

  @functools.native_method
  def set_text(self, text:'str'   ) -> None:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'


    self.py__text = text



    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    py__string_text = utils.py_string_to_string(text)
    py__string_text.shouldBeDeleted = False


    self._ptr.call_with_return(435,tuple([py__string_text._ptr]))

  @functools.native_method
  def add_hr(self, width:'int' =90  , height:'int' =2  , color:'Color' = None  , alignment:'int'  =1, width_in_percent:'bool' =True  , height_in_percent:'bool' =False  ) -> None:
    r'''
				Adds a horizontal rule that can be used to separate content.
				If `width_in_percent` is set, `width` values are percentages of the control width instead of pixels.
				If `height_in_percent` is set, `height` values are percentages of the control width instead of pixels.
			'''
    if color is None:
      color = Color.new0()


    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(alignment, (int, float)), 'alignment must be int or float'
    assert isinstance(width_in_percent, bool), 'width_in_percent must be bool'
    assert isinstance(height_in_percent, bool), 'height_in_percent must be bool'












    self._ptr.call_with_return(436,tuple([width, height, color._ptr, alignment, width_in_percent, height_in_percent]))

  @functools.native_method
  def add_image(self, image:'py4godot_texture2d.Texture2D'   , width:'int' =0  , height:'int' =0  , color:'Color' = None  , inline_align:'int'  =5, region:'Rect2' = None  , key:'object' =None  , pad:'bool' =False  , tooltip:'str' =""  , width_in_percent:'bool' =False  , height_in_percent:'bool' =False  , alt_text:'str' =""  ) -> None:
    r'''
				Adds an image's opening and closing tags to the tag stack, optionally providing a `width` and `height` to resize the image, a `color` to tint the image and a `region` to only use parts of the image.
				If `width` or `height` is set to 0, the image size will be adjusted in order to keep the original aspect ratio.
				If `width` and `height` are not set, but `region` is, the region's rect will be used.
				`key` is an optional identifier, that can be used to modify the image via `update_image`.
				If `pad` is set, and the image is smaller than the size specified by `width` and `height`, the image padding is added to match the size instead of upscaling.
				If `width_in_percent` is set, `width` values are percentages of the control width instead of pixels.
				If `height_in_percent` is set, `height` values are percentages of the control width instead of pixels.
				`alt_text` is used as the image description for assistive apps.
			'''
    if color is None:
      color = Color.new0()

    if region is None:
      region = Rect2.new0()

    if tooltip is None:
      tooltip = String.new0()
    if alt_text is None:
      alt_text = String.new0()

    assert(not image is None)
    assert isinstance(image, get_class('Texture2D')), 'image must be Texture2D'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(inline_align, (int, float)), 'inline_align must be int or float'
    
    assert isinstance(pad, bool), 'pad must be bool'
    assert isinstance(width_in_percent, bool), 'width_in_percent must be bool'
    assert isinstance(height_in_percent, bool), 'height_in_percent must be bool'

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )












    assert(isinstance(tooltip, (str, String)))
    py_string_tooltip = tooltip if isinstance(tooltip, StringName) else c_utils.py_string_to_string(tooltip)


    assert(isinstance(alt_text, (str, String)))
    py_string_alt_text = alt_text if isinstance(alt_text, StringName) else c_utils.py_string_to_string(alt_text)

    self._ptr.call_with_return(437,tuple([image._ptr, width, height, color._ptr, inline_align, region._ptr, key, pad, py_string_tooltip._ptr, width_in_percent, height_in_percent, py_string_alt_text._ptr]))

  @functools.native_method
  def update_image(self, key:'object'   , mask:'int'   , image:'py4godot_texture2d.Texture2D'   , width:'int' =0  , height:'int' =0  , color:'Color' = None  , inline_align:'int'  =5, region:'Rect2' = None  , pad:'bool' =False  , tooltip:'str' =""  , width_in_percent:'bool' =False  , height_in_percent:'bool' =False  ) -> None:
    r'''
				Updates the existing images with the key `key`. Only properties specified by `mask` bits are updated. See `add_image`.
			'''
    if color is None:
      color = Color.new0()

    if region is None:
      region = Rect2.new0()
    if tooltip is None:
      tooltip = String.new0()

    
    assert isinstance(mask, (int, float)), 'mask must be int or float'
    assert(not image is None)
    assert isinstance(image, get_class('Texture2D')), 'image must be Texture2D'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(inline_align, (int, float)), 'inline_align must be int or float'
    assert isinstance(pad, bool), 'pad must be bool'
    assert isinstance(width_in_percent, bool), 'width_in_percent must be bool'
    assert isinstance(height_in_percent, bool), 'height_in_percent must be bool'

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )













    assert(isinstance(tooltip, (str, String)))
    py_string_tooltip = tooltip if isinstance(tooltip, StringName) else c_utils.py_string_to_string(tooltip)



    self._ptr.call_with_return(438,tuple([key, mask, image._ptr, width, height, color._ptr, inline_align, region._ptr, pad, py_string_tooltip._ptr, width_in_percent, height_in_percent]))

  @functools.native_method
  def newline(self) -> None:
    r'''
				Adds a newline tag to the tag stack.
			'''




    self._ptr.call_with_return(439,tuple([]))

  @functools.native_method
  def remove_paragraph(self, paragraph:'int'   , no_invalidate:'bool' =False  ) -> typing.Union[bool]:
    r'''
				Removes a paragraph of content from the label. Returns `true` if the paragraph exists.
				The `paragraph` argument is the index of the paragraph to remove, it can take values in the interval ``0, get_paragraph_count() - 1``.
				If `no_invalidate` is set to `true`, cache for the subsequent paragraphs is not invalidated. Use it for faster updates if deleted paragraph is fully self-contained (have no unclosed tags), or this call is part of the complex edit operation and `invalidate_paragraph` will be called at the end of operation.
			'''

    assert isinstance(paragraph, (int, float)), 'paragraph must be int or float'
    assert isinstance(no_invalidate, bool), 'no_invalidate must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(440,tuple([paragraph, no_invalidate]))
    return _ret


  @functools.native_method
  def invalidate_paragraph(self, paragraph:'int'   ) -> typing.Union[bool]:
    r'''
				Invalidates `paragraph` and all subsequent paragraphs cache.
			'''

    assert isinstance(paragraph, (int, float)), 'paragraph must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(441,tuple([paragraph]))
    return _ret


  @functools.native_method
  def push_font(self, font:'py4godot_font.Font'   , font_size:'int' =0  ) -> None:
    r'''
				Adds a `code skip-lint``font`` tag to the tag stack. Overrides default fonts for its duration.
				Passing `0` to `font_size` will use the existing default font size.
			'''

    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'








    self._ptr.call_with_return(442,tuple([font._ptr, font_size]))

  @functools.native_method
  def push_font_size(self, font_size:'int'   ) -> None:
    r'''
				Adds a `code skip-lint``font_size`` tag to the tag stack. Overrides default font size for its duration.
			'''

    assert isinstance(font_size, (int, float)), 'font_size must be int or float'







    self._ptr.call_with_return(443,tuple([font_size]))

  @functools.native_method
  def push_normal(self) -> None:
    r'''
				Adds a `code skip-lint``font`` tag with a normal font to the tag stack.
			'''




    self._ptr.call_with_return(444,tuple([]))

  @functools.native_method
  def push_bold(self) -> None:
    r'''
				Adds a `code skip-lint``font`` tag with a bold font to the tag stack. This is the same as adding a `code skip-lint`**` tag if not currently in a `code skip-lint`_` tag.
			'''




    self._ptr.call_with_return(445,tuple([]))

  @functools.native_method
  def push_bold_italics(self) -> None:
    r'''
				Adds a `code skip-lint``font`` tag with a bold italics font to the tag stack.
			'''




    self._ptr.call_with_return(446,tuple([]))

  @functools.native_method
  def push_italics(self) -> None:
    r'''
				Adds a `code skip-lint``font`` tag with an italics font to the tag stack. This is the same as adding an `code skip-lint`_` tag if not currently in a `code skip-lint`**` tag.
			'''




    self._ptr.call_with_return(447,tuple([]))

  @functools.native_method
  def push_mono(self) -> None:
    r'''
				Adds a `code skip-lint``font`` tag with a monospace font to the tag stack.
			'''




    self._ptr.call_with_return(448,tuple([]))

  @functools.native_method
  def push_color(self, color:'Color'   ) -> None:
    r'''
				Adds a `code skip-lint``color`` tag to the tag stack.
			'''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(449,tuple([color._ptr]))

  @functools.native_method
  def push_outline_size(self, outline_size:'int'   ) -> None:
    r'''
				Adds a `code skip-lint``outline_size`` tag to the tag stack. Overrides default text outline size for its duration.
			'''

    assert isinstance(outline_size, (int, float)), 'outline_size must be int or float'







    self._ptr.call_with_return(450,tuple([outline_size]))

  @functools.native_method
  def push_outline_color(self, color:'Color'   ) -> None:
    r'''
				Adds a `code skip-lint``outline_color`` tag to the tag stack. Adds text outline for its duration.
			'''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(451,tuple([color._ptr]))

  @functools.native_method
  def push_paragraph(self, alignment:'int'  , base_direction:'int'  =0, language:'str' =""  , st_parser:'int'  =0, justification_flags:'int' =163  , tab_stops:'PackedFloat32Array' = None  ) -> None:
    r'''
				Adds a `code skip-lint``p`` tag to the tag stack.
			'''

    if language is None:
      language = String.new0()


    if tab_stops is None:
      tab_stops = PackedFloat32Array.new0()

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'
    assert isinstance(base_direction, (int, float)), 'base_direction must be int or float'
    assert isinstance(st_parser, (int, float)), 'st_parser must be int or float'
    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'







    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)




    self._ptr.call_with_return(452,tuple([alignment, base_direction, py_string_language._ptr, st_parser, justification_flags, tab_stops._ptr]))

  @functools.native_method
  def push_indent(self, level:'int'   ) -> None:
    r'''
				Adds an `code skip-lint``indent`` tag to the tag stack. Multiplies `level` by current `tab_size` to determine new margin length.
			'''

    assert isinstance(level, (int, float)), 'level must be int or float'







    self._ptr.call_with_return(453,tuple([level]))

  @functools.native_method
  def push_list(self, level:'int'   , type:'int'  , capitalize:'bool'   , bullet:'str' ="â€¢"  ) -> None:
    r'''
				Adds `code skip-lint``ol`` or `code skip-lint``ul`` tag to the tag stack. Multiplies `level` by current `tab_size` to determine new margin length.
			'''
    if bullet is None:
      bullet = String.new0()

    assert isinstance(level, (int, float)), 'level must be int or float'
    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(capitalize, bool), 'capitalize must be bool'








    assert(isinstance(bullet, (str, String)))
    py_string_bullet = bullet if isinstance(bullet, StringName) else c_utils.py_string_to_string(bullet)

    self._ptr.call_with_return(454,tuple([level, type, capitalize, py_string_bullet._ptr]))

  @functools.native_method
  def push_meta(self, data:'object'   , underline_mode:'int'  =1, tooltip:'str' =""  ) -> None:
    r'''
				Adds a meta tag to the tag stack. Similar to the BBCode `code skip-lint``url=something`{text}`/url``, but supports non-`String` metadata types.
				If `meta_underlined` is `true`, meta tags display an underline. This behavior can be customized with `underline_mode`.
				**Note:** Meta tags do nothing by default when clicked. To assign behavior when clicked, connect `signal meta_clicked` to a function that is called when the meta tag is clicked.
			'''

    if tooltip is None:
      tooltip = String.new0()

    
    assert isinstance(underline_mode, (int, float)), 'underline_mode must be int or float'

    if not (type(data).__name__ in py4godot.variant_types.core_types or isinstance(data, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'data': "
                f"{type(data).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    assert(isinstance(tooltip, (str, String)))
    py_string_tooltip = tooltip if isinstance(tooltip, StringName) else c_utils.py_string_to_string(tooltip)

    self._ptr.call_with_return(455,tuple([data, underline_mode, py_string_tooltip._ptr]))

  @functools.native_method
  def push_hint(self, description:'str'   ) -> None:
    r'''
				Adds a `code skip-lint``hint`` tag to the tag stack. Same as BBCode `code skip-lint``hint=something`{text}`/hint``.
			'''

    assert(not description is None)
    assert isinstance(description, (str, String)), 'description must be str or String'





    assert(isinstance(description, (str, String)))
    py_string_description = description if isinstance(description, StringName) else c_utils.py_string_to_string(description)

    self._ptr.call_with_return(456,tuple([py_string_description._ptr]))

  @functools.native_method
  def push_language(self, language:'str'   ) -> None:
    r'''
				Adds language code used for text shaping algorithm and Open-Type font features.
			'''

    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'





    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    self._ptr.call_with_return(457,tuple([py_string_language._ptr]))

  @functools.native_method
  def push_underline(self, color:'Color' = None  ) -> None:
    r'''
				Adds a `code skip-lint``u`` tag to the tag stack. If `color`'s alpha value is `0.0`, the current font's color with its alpha multiplied by `theme_item underline_alpha` is used.
			'''
    if color is None:
      color = Color.new0()








    self._ptr.call_with_return(458,tuple([color._ptr]))

  @functools.native_method
  def push_strikethrough(self, color:'Color' = None  ) -> None:
    r'''
				Adds a `code skip-lint``s`` tag to the tag stack. If `color`'s alpha value is `0.0`, the current font's color with its alpha multiplied by `theme_item strikethrough_alpha` is used.
			'''
    if color is None:
      color = Color.new0()








    self._ptr.call_with_return(459,tuple([color._ptr]))

  @functools.native_method
  def push_table(self, columns:'int'   , inline_align:'int'  =0, align_to_row:'int' =-1  , name:'str' =""  ) -> None:
    r'''
				Adds a `code skip-lint``table=columns,inline_align`` tag to the tag stack. Use `set_table_column_expand` to set column expansion ratio. Use `push_cell` to add cells. `name` is used as the table name for assistive apps.
			'''

    if name is None:
      name = String.new0()

    assert isinstance(columns, (int, float)), 'columns must be int or float'
    assert isinstance(inline_align, (int, float)), 'inline_align must be int or float'
    assert isinstance(align_to_row, (int, float)), 'align_to_row must be int or float'








    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(460,tuple([columns, inline_align, align_to_row, py_string_name._ptr]))

  @functools.native_method
  def push_dropcap(self, string:'str'   , font:'py4godot_font.Font'   , size:'int'   , dropcap_margins:'Rect2' = None  , color:'Color' = None  , outline_size:'int' =0  , outline_color:'Color' = None  ) -> None:
    r'''
				Adds a `code skip-lint``dropcap`` tag to the tag stack. Drop cap (dropped capital) is a decorative element at the beginning of a paragraph that is larger than the rest of the text.
			'''
    if dropcap_margins is None:
      dropcap_margins = Rect2.new0()
    if color is None:
      color = Color.new0()
    if outline_color is None:
      outline_color = Color.new0()

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'
    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(outline_size, (int, float)), 'outline_size must be int or float'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)







    self._ptr.call_with_return(461,tuple([py_string_string._ptr, font._ptr, size, dropcap_margins._ptr, color._ptr, outline_size, outline_color._ptr]))

  @functools.native_method
  def set_table_column_expand(self, column:'int'   , expand:'bool'   , ratio:'int' =1  , shrink:'bool' =True  ) -> None:
    r'''
				Edits the selected column's expansion options. If `expand` is `true`, the column expands in proportion to its expansion ratio versus the other columns' ratios.
				For example, 2 columns with ratios 3 and 4 plus 70 pixels in available width would expand 30 and 40 pixels, respectively.
				If `expand` is `false`, the column will not contribute to the total ratio.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(expand, bool), 'expand must be bool'
    assert isinstance(ratio, (int, float)), 'ratio must be int or float'
    assert isinstance(shrink, bool), 'shrink must be bool'










    self._ptr.call_with_return(462,tuple([column, expand, ratio, shrink]))

  @functools.native_method
  def set_table_column_name(self, column:'int'   , name:'str'   ) -> None:
    r'''
				Sets table column name for assistive apps.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(463,tuple([column, py_string_name._ptr]))

  @functools.native_method
  def set_cell_row_background_color(self, odd_row_bg:'Color'   , even_row_bg:'Color'   ) -> None:
    r'''
				Sets color of a table cell. Separate colors for alternating rows can be specified.
			'''

    assert(not odd_row_bg is None)
    assert isinstance(odd_row_bg, Color), 'odd_row_bg must be Color'
    assert(not even_row_bg is None)
    assert isinstance(even_row_bg, Color), 'even_row_bg must be Color'








    self._ptr.call_with_return(464,tuple([odd_row_bg._ptr, even_row_bg._ptr]))

  @functools.native_method
  def set_cell_border_color(self, color:'Color'   ) -> None:
    r'''
				Sets color of a table cell border.
			'''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(465,tuple([color._ptr]))

  @functools.native_method
  def set_cell_size_override(self, min_size:'Vector2'   , max_size:'Vector2'   ) -> None:
    r'''
				Sets minimum and maximum size overrides for a table cell.
			'''

    assert(not min_size is None)
    assert isinstance(min_size, Vector2), 'min_size must be Vector2'
    assert(not max_size is None)
    assert isinstance(max_size, Vector2), 'max_size must be Vector2'








    self._ptr.call_with_return(466,tuple([min_size._ptr, max_size._ptr]))

  @functools.native_method
  def set_cell_padding(self, padding:'Rect2'   ) -> None:
    r'''
				Sets inner padding of a table cell.
			'''

    assert(not padding is None)
    assert isinstance(padding, Rect2), 'padding must be Rect2'







    self._ptr.call_with_return(467,tuple([padding._ptr]))

  @functools.native_method
  def push_cell(self) -> None:
    r'''
				Adds a `code skip-lint``cell`` tag to the tag stack. Must be inside a `code skip-lint``table`` tag. See `push_table` for details. Use `set_table_column_expand` to set column expansion ratio, `set_cell_border_color` to set cell border, `set_cell_row_background_color` to set cell background, `set_cell_size_override` to override cell size, and `set_cell_padding` to set padding.
			'''




    self._ptr.call_with_return(468,tuple([]))

  @functools.native_method
  def push_fgcolor(self, fgcolor:'Color'   ) -> None:
    r'''
				Adds a `code skip-lint``fgcolor`` tag to the tag stack.
				**Note:** The foreground color has padding applied by default, which is controlled using `theme_item text_highlight_h_padding` and `theme_item text_highlight_v_padding`. This can lead to overlapping highlights if foreground colors are placed on neighboring lines/columns, so consider setting those theme items to `0` if you want to avoid this.
			'''

    assert(not fgcolor is None)
    assert isinstance(fgcolor, Color), 'fgcolor must be Color'







    self._ptr.call_with_return(469,tuple([fgcolor._ptr]))

  @functools.native_method
  def push_bgcolor(self, bgcolor:'Color'   ) -> None:
    r'''
				Adds a `code skip-lint``bgcolor`` tag to the tag stack.
				**Note:** The background color has padding applied by default, which is controlled using `theme_item text_highlight_h_padding` and `theme_item text_highlight_v_padding`. This can lead to overlapping highlights if background colors are placed on neighboring lines/columns, so consider setting those theme items to `0` if you want to avoid this.
			'''

    assert(not bgcolor is None)
    assert isinstance(bgcolor, Color), 'bgcolor must be Color'







    self._ptr.call_with_return(470,tuple([bgcolor._ptr]))

  @functools.native_method
  def push_customfx(self, effect:'py4godot_richtexteffect.RichTextEffect'   , env:'Dictionary'   ) -> None:
    r'''
				Adds a custom effect tag to the tag stack. The effect does not need to be in `custom_effects`. The environment is directly passed to the effect.
			'''

    assert(not effect is None)
    assert isinstance(effect, get_class('RichTextEffect')), 'effect must be RichTextEffect'
    assert(not env is None)
    assert isinstance(env, Dictionary), 'env must be Dictionary'








    self._ptr.call_with_return(471,tuple([effect._ptr, env._ptr]))

  @functools.native_method
  def push_context(self) -> None:
    r'''
				Adds a context marker to the tag stack. See `pop_context`.
			'''




    self._ptr.call_with_return(472,tuple([]))

  @functools.native_method
  def pop_context(self) -> None:
    r'''
				Terminates tags opened after the last `push_context` call (including context marker), or all tags if there's no context marker on the stack.
			'''




    self._ptr.call_with_return(473,tuple([]))

  @functools.native_method
  def pop(self) -> None:
    r'''
				Terminates the current tag. Use after `push_*` methods to close BBCodes manually. Does not need to follow `add_*` methods.
			'''




    self._ptr.call_with_return(474,tuple([]))

  @functools.native_method
  def pop_all(self) -> None:
    r'''
				Terminates all tags opened by `push_*` methods.
			'''




    self._ptr.call_with_return(475,tuple([]))

  @functools.native_method
  def clear(self) -> None:
    r'''
				Clears the tag stack, causing the label to display nothing.
				**Note:** This method does not affect `text`, and its contents will show again if the label is redrawn. However, setting `text` to an empty `String` also clears the stack.
			'''




    self._ptr.call_with_return(476,tuple([]))

  @functools.native_method
  def set_structured_text_bidi_override(self, parser:'int'  ) -> None:
    r''''''

    assert isinstance(parser, (int, float)), 'parser must be int or float'


    self.py__structured_text_bidi_override = parser






    self._ptr.call_with_return(477,tuple([parser]))

  @functools.native_method
  def get_structured_text_bidi_override(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(478,tuple([]))

    return _ret


  @functools.native_method
  def set_structured_text_bidi_override_options(self, args:'Array'   ) -> None:
    r''''''

    assert(not args is None)
    assert isinstance(args, Array), 'args must be Array'


    self.py__structured_text_bidi_override_options = args






    self._ptr.call_with_return(479,tuple([args._ptr]))

  @functools.native_method
  def get_structured_text_bidi_override_options(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(480,tuple([]))

    return _ret


  @functools.native_method
  def set_text_direction(self, direction:'int'  ) -> None:
    r''''''

    assert isinstance(direction, (int, float)), 'direction must be int or float'


    self.py__text_direction = direction






    self._ptr.call_with_return(481,tuple([direction]))

  @functools.native_method
  def get_text_direction(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(482,tuple([]))

    return _ret


  @functools.native_method
  def set_language(self, language:'str'   ) -> None:
    r''''''

    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'


    self.py__language = language



    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    py__string_language = utils.py_string_to_string(language)
    py__string_language.shouldBeDeleted = False


    self._ptr.call_with_return(483,tuple([py__string_language._ptr]))

  @functools.native_method
  def get_language(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(484,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_horizontal_alignment(self, alignment:'int'  ) -> None:
    r''''''

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'


    self.py__horizontal_alignment = alignment






    self._ptr.call_with_return(485,tuple([alignment]))

  @functools.native_method
  def get_horizontal_alignment(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(486,tuple([]))

    return _ret


  @functools.native_method
  def set_vertical_alignment(self, alignment:'int'  ) -> None:
    r''''''

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'


    self.py__vertical_alignment = alignment






    self._ptr.call_with_return(487,tuple([alignment]))

  @functools.native_method
  def get_vertical_alignment(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(488,tuple([]))

    return _ret


  @functools.native_method
  def set_justification_flags(self, justification_flags:'int'   ) -> None:
    r''''''

    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'


    self.py__justification_flags = justification_flags






    self._ptr.call_with_return(489,tuple([justification_flags]))

  @functools.native_method
  def get_justification_flags(self) -> typing.Union[int]:
    r''''''




    _ret
    _ret = self._ptr.call_with_return(490,tuple([]))

    return _ret


  @functools.native_method
  def set_tab_stops(self, tab_stops:'PackedFloat32Array'   ) -> None:
    r''''''

    assert(not tab_stops is None)
    assert isinstance(tab_stops, PackedFloat32Array), 'tab_stops must be PackedFloat32Array'


    self.py__tab_stops = tab_stops






    self._ptr.call_with_return(491,tuple([tab_stops._ptr]))

  @functools.native_method
  def get_tab_stops(self) -> typing.Union['PackedFloat32Array']:
    r''''''




    _ret = PackedFloat32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(492,tuple([]))

    return _ret


  @functools.native_method
  def set_autowrap_mode(self, autowrap_mode:'int'  ) -> None:
    r''''''

    assert isinstance(autowrap_mode, (int, float)), 'autowrap_mode must be int or float'


    self.py__autowrap_mode = autowrap_mode






    self._ptr.call_with_return(493,tuple([autowrap_mode]))

  @functools.native_method
  def get_autowrap_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(494,tuple([]))

    return _ret


  @functools.native_method
  def set_autowrap_trim_flags(self, autowrap_trim_flags:'int'   ) -> None:
    r''''''

    assert isinstance(autowrap_trim_flags, (int, float)), 'autowrap_trim_flags must be int or float'


    self.py__autowrap_trim_flags = autowrap_trim_flags






    self._ptr.call_with_return(495,tuple([autowrap_trim_flags]))

  @functools.native_method
  def get_autowrap_trim_flags(self) -> typing.Union[int]:
    r''''''




    _ret
    _ret = self._ptr.call_with_return(496,tuple([]))

    return _ret


  @functools.native_method
  def set_meta_underline(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__meta_underlined = enable






    self._ptr.call_with_return(497,tuple([enable]))

  @functools.native_method
  def is_meta_underlined(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(498,tuple([]))

    return _ret


  @functools.native_method
  def set_hint_underline(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__hint_underlined = enable






    self._ptr.call_with_return(499,tuple([enable]))

  @functools.native_method
  def is_hint_underlined(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(500,tuple([]))

    return _ret


  @functools.native_method
  def set_scroll_active(self, active:'bool'   ) -> None:
    r''''''

    assert isinstance(active, bool), 'active must be bool'


    self.py__scroll_active = active






    self._ptr.call_with_return(501,tuple([active]))

  @functools.native_method
  def is_scroll_active(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(502,tuple([]))

    return _ret


  @functools.native_method
  def set_scroll_follow_visible_characters(self, follow:'bool'   ) -> None:
    r''''''

    assert isinstance(follow, bool), 'follow must be bool'


    self.py__scroll_following_visible_characters = follow






    self._ptr.call_with_return(503,tuple([follow]))

  @functools.native_method
  def is_scroll_following_visible_characters(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(504,tuple([]))

    return _ret


  @functools.native_method
  def set_scroll_follow(self, follow:'bool'   ) -> None:
    r''''''

    assert isinstance(follow, bool), 'follow must be bool'


    self.py__scroll_following = follow






    self._ptr.call_with_return(505,tuple([follow]))

  @functools.native_method
  def is_scroll_following(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(506,tuple([]))

    return _ret


  @functools.native_method
  def get_v_scroll_bar(self) -> typing.Union['py4godot_vscrollbar.VScrollBar']:
    r'''
				Returns the vertical scrollbar.
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their `CanvasItem.visible` property.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: VScrollBar
    _ret._ptr = self._ptr.call_with_return(507,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def scroll_to_line(self, line:'int'   ) -> None:
    r'''
				Scrolls the window's top line to match `line`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    self._ptr.call_with_return(508,tuple([line]))

  @functools.native_method
  def scroll_to_paragraph(self, paragraph:'int'   ) -> None:
    r'''
				Scrolls the window's top line to match first line of the `paragraph`.
			'''

    assert isinstance(paragraph, (int, float)), 'paragraph must be int or float'







    self._ptr.call_with_return(509,tuple([paragraph]))

  @functools.native_method
  def scroll_to_selection(self) -> None:
    r'''
				Scrolls to the beginning of the current selection.
			'''




    self._ptr.call_with_return(510,tuple([]))

  @functools.native_method
  def set_tab_size(self, spaces:'int'   ) -> None:
    r''''''

    assert isinstance(spaces, (int, float)), 'spaces must be int or float'


    self.py__tab_size = spaces






    self._ptr.call_with_return(511,tuple([spaces]))

  @functools.native_method
  def get_tab_size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(512,tuple([]))

    return _ret


  @functools.native_method
  def set_fit_content(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__fit_content = enabled






    self._ptr.call_with_return(513,tuple([enabled]))

  @functools.native_method
  def is_fit_content_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(514,tuple([]))

    return _ret


  @functools.native_method
  def set_selection_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__selection_enabled = enabled






    self._ptr.call_with_return(515,tuple([enabled]))

  @functools.native_method
  def is_selection_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(516,tuple([]))

    return _ret


  @functools.native_method
  def set_context_menu_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__context_menu_enabled = enabled






    self._ptr.call_with_return(517,tuple([enabled]))

  @functools.native_method
  def is_context_menu_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(518,tuple([]))

    return _ret


  @functools.native_method
  def set_shortcut_keys_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__shortcut_keys_enabled = enabled






    self._ptr.call_with_return(519,tuple([enabled]))

  @functools.native_method
  def is_shortcut_keys_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(520,tuple([]))

    return _ret


  @functools.native_method
  def set_deselect_on_focus_loss_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__deselect_on_focus_loss_enabled = enable






    self._ptr.call_with_return(521,tuple([enable]))

  @functools.native_method
  def is_deselect_on_focus_loss_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(522,tuple([]))

    return _ret


  @functools.native_method
  def set_drag_and_drop_selection_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__drag_and_drop_selection_enabled = enable






    self._ptr.call_with_return(523,tuple([enable]))

  @functools.native_method
  def is_drag_and_drop_selection_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(524,tuple([]))

    return _ret


  @functools.native_method
  def get_selection_from(self) -> typing.Union[int]:
    r'''
				Returns the current selection first character index if a selection is active, `-1` otherwise. Does not include BBCodes.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(525,tuple([]))
    return _ret


  @functools.native_method
  def get_selection_to(self) -> typing.Union[int]:
    r'''
				Returns the current selection last character index if a selection is active, `-1` otherwise. Does not include BBCodes.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(526,tuple([]))
    return _ret


  @functools.native_method
  def get_selection_line_offset(self) -> typing.Union[float]:
    r'''
				Returns the current selection vertical line offset if a selection is active, `-1.0` otherwise.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(527,tuple([]))
    return _ret


  @functools.native_method
  def select_all(self) -> None:
    r'''
				Select all the text.
				If `selection_enabled` is `false`, no selection will occur.
			'''




    self._ptr.call_with_return(528,tuple([]))

  @functools.native_method
  def get_selected_text(self) -> typing.Union[str]:
    r'''
				Returns the current selection text. Does not include BBCodes.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(529,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def deselect(self) -> None:
    r'''
				Clears the current selection.
			'''




    self._ptr.call_with_return(530,tuple([]))

  @functools.native_method
  def parse_bbcode(self, bbcode:'str'   ) -> None:
    r'''
				The assignment version of `append_text`. Clears the tag stack and inserts the new content.
			'''

    assert(not bbcode is None)
    assert isinstance(bbcode, (str, String)), 'bbcode must be str or String'





    assert(isinstance(bbcode, (str, String)))
    py_string_bbcode = bbcode if isinstance(bbcode, StringName) else c_utils.py_string_to_string(bbcode)

    self._ptr.call_with_return(531,tuple([py_string_bbcode._ptr]))

  @functools.native_method
  def append_text(self, bbcode:'str'   ) -> None:
    r'''
				Parses `bbcode` and adds tags to the tag stack as needed.
				**Note:** Using this method, you can't close a tag that was opened in a previous `append_text` call. This is done to improve performance, especially when updating large RichTextLabels since rebuilding the whole BBCode every time would be slower. If you absolutely need to close a tag in a future method call, append the `text` instead of using `append_text`.
			'''

    assert(not bbcode is None)
    assert isinstance(bbcode, (str, String)), 'bbcode must be str or String'





    assert(isinstance(bbcode, (str, String)))
    py_string_bbcode = bbcode if isinstance(bbcode, StringName) else c_utils.py_string_to_string(bbcode)

    self._ptr.call_with_return(532,tuple([py_string_bbcode._ptr]))

  @functools.native_method
  def get_text(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(533,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def is_ready(self) -> typing.Union[bool]:
    r'''
				If `threaded` is enabled, returns `true` if the background thread has finished text processing, otherwise always return `true`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(534,tuple([]))
    return _ret


  @functools.native_method
  def is_finished(self) -> typing.Union[bool]:
    r'''
				If `threaded` is enabled, returns `true` if the background thread has finished text processing, otherwise always return `true`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(535,tuple([]))
    return _ret


  @functools.native_method
  def set_threaded(self, threaded:'bool'   ) -> None:
    r''''''

    assert isinstance(threaded, bool), 'threaded must be bool'


    self.py__threaded = threaded






    self._ptr.call_with_return(536,tuple([threaded]))

  @functools.native_method
  def is_threaded(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(537,tuple([]))

    return _ret


  @functools.native_method
  def set_progress_bar_delay(self, delay_ms:'int'   ) -> None:
    r''''''

    assert isinstance(delay_ms, (int, float)), 'delay_ms must be int or float'


    self.py__progress_bar_delay = delay_ms






    self._ptr.call_with_return(538,tuple([delay_ms]))

  @functools.native_method
  def get_progress_bar_delay(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(539,tuple([]))

    return _ret


  @functools.native_method
  def set_visible_characters(self, amount:'int'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__visible_characters = amount






    self._ptr.call_with_return(540,tuple([amount]))

  @functools.native_method
  def get_visible_characters(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(541,tuple([]))

    return _ret


  @functools.native_method
  def get_visible_characters_behavior(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(542,tuple([]))

    return _ret


  @functools.native_method
  def set_visible_characters_behavior(self, behavior:'int'  ) -> None:
    r''''''

    assert isinstance(behavior, (int, float)), 'behavior must be int or float'


    self.py__visible_characters_behavior = behavior






    self._ptr.call_with_return(543,tuple([behavior]))

  @functools.native_method
  def set_visible_ratio(self, ratio:'float'   ) -> None:
    r''''''

    assert isinstance(ratio, (int, float)), 'ratio must be int or float'


    self.py__visible_ratio = ratio






    self._ptr.call_with_return(544,tuple([ratio]))

  @functools.native_method
  def get_visible_ratio(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(545,tuple([]))

    return _ret


  @functools.native_method
  def get_character_line(self, character:'int'   ) -> typing.Union[int]:
    r'''
				Returns the line number of the character position provided. Line and character numbers are both zero-indexed.
				**Note:** If `threaded` is enabled, this method returns a value for the loaded part of the document. Use `is_finished` or `signal finished` to determine whether document is fully loaded.
			'''

    assert isinstance(character, (int, float)), 'character must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(546,tuple([character]))
    return _ret


  @functools.native_method
  def get_character_paragraph(self, character:'int'   ) -> typing.Union[int]:
    r'''
				Returns the paragraph number of the character position provided. Paragraph and character numbers are both zero-indexed.
				**Note:** If `threaded` is enabled, this method returns a value for the loaded part of the document. Use `is_finished` or `signal finished` to determine whether document is fully loaded.
			'''

    assert isinstance(character, (int, float)), 'character must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(547,tuple([character]))
    return _ret


  @functools.native_method
  def get_total_character_count(self) -> typing.Union[int]:
    r'''
				Returns the total number of characters from text tags. Does not include BBCodes.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(548,tuple([]))
    return _ret


  @functools.native_method
  def set_use_bbcode(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__bbcode_enabled = enable






    self._ptr.call_with_return(549,tuple([enable]))

  @functools.native_method
  def is_using_bbcode(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(550,tuple([]))

    return _ret


  @functools.native_method
  def get_line_count(self) -> typing.Union[int]:
    r'''
				Returns the total number of lines in the text. Wrapped text is counted as multiple lines.
				**Note:** If `threaded` is enabled, this method returns a value for the loaded part of the document. Use `is_finished` or `signal finished` to determine whether document is fully loaded.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(551,tuple([]))
    return _ret


  @functools.native_method
  def get_line_range(self, line:'int'   ) -> typing.Union['Vector2i']:
    r'''
				Returns the indexes of the first and last visible characters for the given `line`, as a `Vector2i`.
				**Note:** If `visible_characters_behavior` is set to `constant TextServer.VC_CHARS_BEFORE_SHAPING` only visible wrapped lines are counted.
				**Note:** If `threaded` is enabled, this method returns a value for the loaded part of the document. Use `is_finished` or `signal finished` to determine whether document is fully loaded.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(552,tuple([line]))
    return _ret


  @functools.native_method
  def get_visible_line_count(self) -> typing.Union[int]:
    r'''
				Returns the number of visible lines.
				**Note:** This method returns a correct value only after the label has been drawn.
				**Note:** If `threaded` is enabled, this method returns a value for the loaded part of the document. Use `is_finished` or `signal finished` to determine whether document is fully loaded.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(553,tuple([]))
    return _ret


  @functools.native_method
  def get_paragraph_count(self) -> typing.Union[int]:
    r'''
				Returns the total number of paragraphs (newlines or `p` tags in the tag stack's text tags). Considers wrapped text as one paragraph.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(554,tuple([]))
    return _ret


  @functools.native_method
  def get_visible_paragraph_count(self) -> typing.Union[int]:
    r'''
				Returns the number of visible paragraphs. A paragraph is considered visible if at least one of its lines is visible.
				**Note:** This method returns a correct value only after the label has been drawn.
				**Note:** If `threaded` is enabled, this method returns a value for the loaded part of the document. Use `is_finished` or `signal finished` to determine whether document is fully loaded.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(555,tuple([]))
    return _ret


  @functools.native_method
  def get_content_height(self) -> typing.Union[int]:
    r'''
				Returns the height of the content.
				**Note:** This method always returns the full content size, and is not affected by `visible_ratio` and `visible_characters`. To get the visible content size, use `get_visible_content_rect`.
				**Note:** If `threaded` is enabled, this method returns a value for the loaded part of the document. Use `is_finished` or `signal finished` to determine whether document is fully loaded.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(556,tuple([]))
    return _ret


  @functools.native_method
  def get_content_width(self) -> typing.Union[int]:
    r'''
				Returns the width of the content.
				**Note:** This method always returns the full content size, and is not affected by `visible_ratio` and `visible_characters`. To get the visible content size, use `get_visible_content_rect`.
				**Note:** If `threaded` is enabled, this method returns a value for the loaded part of the document. Use `is_finished` or `signal finished` to determine whether document is fully loaded.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(557,tuple([]))
    return _ret


  @functools.native_method
  def get_line_height(self, line:'int'   ) -> typing.Union[int]:
    r'''
				Returns the height of the line found at the provided index.
				**Note:** If `threaded` is enabled, this method returns a value for the loaded part of the document. Use `is_finished` or `signal finished` to determine whether the document is fully loaded.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(558,tuple([line]))
    return _ret


  @functools.native_method
  def get_line_width(self, line:'int'   ) -> typing.Union[int]:
    r'''
				Returns the width of the line found at the provided index.
				**Note:** If `threaded` is enabled, this method returns a value for the loaded part of the document. Use `is_finished` or `signal finished` to determine whether the document is fully loaded.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(559,tuple([line]))
    return _ret


  @functools.native_method
  def get_visible_content_rect(self) -> typing.Union['Rect2i']:
    r'''
				Returns the bounding rectangle of the visible content.
				**Note:** This method returns a correct value only after the label has been drawn.
				
				```gdscript
				extends RichTextLabel

				@export var background_panel: Panel

				func _ready():
					await draw
					background_panel.position = get_visible_content_rect().position
					background_panel.size = get_visible_content_rect().size
				```
				
				
			'''




    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(560,tuple([]))
    return _ret


  @functools.native_method
  def get_line_offset(self, line:'int'   ) -> typing.Union[float]:
    r'''
				Returns the vertical offset of the line found at the provided index.
				**Note:** If `threaded` is enabled, this method returns a value for the loaded part of the document. Use `is_finished` or `signal finished` to determine whether document is fully loaded.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(561,tuple([line]))
    return _ret


  @functools.native_method
  def get_paragraph_offset(self, paragraph:'int'   ) -> typing.Union[float]:
    r'''
				Returns the vertical offset of the paragraph found at the provided index.
				**Note:** If `threaded` is enabled, this method returns a value for the loaded part of the document. Use `is_finished` or `signal finished` to determine whether document is fully loaded.
			'''

    assert isinstance(paragraph, (int, float)), 'paragraph must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(562,tuple([paragraph]))
    return _ret


  @functools.native_method
  def parse_expressions_for_values(self, expressions:'PackedStringArray'   ) -> typing.Union['Dictionary']:
    r'''
				Parses BBCode parameter `expressions` into a dictionary.
			'''

    assert(not expressions is None)
    assert isinstance(expressions, PackedStringArray), 'expressions must be PackedStringArray'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(563,tuple([expressions._ptr]))
    return _ret


  @functools.native_method
  def set_effects(self, effects:'Array'   ) -> None:
    r''''''

    assert(not effects is None)
    assert isinstance(effects, Array), 'effects must be Array'


    self.py__custom_effects = effects






    self._ptr.call_with_return(564,tuple([effects._ptr]))

  @functools.native_method
  def get_effects(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(565,tuple([]))

    return _ret


  @functools.native_method
  def install_effect(self, effect:'object'   ) -> None:
    r'''
				Installs a custom effect. This can also be done in the Inspector through the `custom_effects` property. `effect` should be a valid `RichTextEffect`.
				**Example:** With the following script extending from `RichTextEffect`:
				```gdscript
				# effect.gd
				class_name MyCustomEffect
				extends RichTextEffect

				var bbcode = "my_custom_effect"

				# ...
				```
				The above effect can be installed in `RichTextLabel` from a script:
				```gdscript
				# rich_text_label.gd
				extends RichTextLabel

				func _ready():
					install_effect(MyCustomEffect.new())

					# Alternatively, if not using `class_name` in the script that extends RichTextEffect:
					install_effect(preload("res://effect.gd").new())
				```
			'''

    

    if not (type(effect).__name__ in py4godot.variant_types.core_types or isinstance(effect, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'effect': "
                f"{type(effect).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    self._ptr.call_with_return(566,tuple([effect]))

  @functools.native_method
  def reload_effects(self) -> None:
    r'''
				Reloads custom effects. Useful when `custom_effects` is modified manually.
			'''




    self._ptr.call_with_return(567,tuple([]))

  @functools.native_method
  def get_menu(self) -> typing.Union['py4godot_popupmenu.PopupMenu']:
    r'''
				Returns the `PopupMenu` of this `RichTextLabel`. By default, this menu is displayed when right-clicking on the `RichTextLabel`.
				You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see `enum MenuItems`). For example:
				
				```gdscript
				func _ready():
					var menu = get_menu()
					# Remove "Select All" item.
					menu.remove_item(MENU_SELECT_ALL)
					# Add custom items.
					menu.add_separator()
					menu.add_item("Duplicate Text", MENU_MAX + 1)
					# Connect callback.
					menu.id_pressed.connect(_on_item_pressed)

				func _on_item_pressed(id):
					if id == MENU_MAX + 1:
						add_text("\n" + get_parsed_text())
				```
				
				
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their `Window.visible` property.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: PopupMenu
    _ret._ptr = self._ptr.call_with_return(568,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def is_menu_visible(self) -> typing.Union[bool]:
    r'''
				Returns whether the menu is visible. Use this instead of `get_menu().visible` to improve performance (so the creation of the menu is avoided).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(569,tuple([]))
    return _ret


  @functools.native_method
  def menu_option(self, option:'int'   ) -> None:
    r'''
				Executes a given action as defined in the `enum MenuItems` enum.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'







    self._ptr.call_with_return(570,tuple([option]))


register_cast_function('RichTextLabel', RichTextLabel.cast)
register_class('RichTextLabel', RichTextLabel)
