# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.TextServerAdvanced as py4godot_textserveradvanced 
  import py4godot.classes.RIDTypedArray as py4godot_ridtypedarray 
  import py4godot.classes.Image as py4godot_image 
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
  import py4godot.classes.TextServerDummy as py4godot_textserverdummy 
  import py4godot.classes.TextServerExtension as py4godot_textserverextension 
  import py4godot.classes.Vector2iTypedArray as py4godot_vector2itypedarray 
  import py4godot.classes.Vector3iTypedArray as py4godot_vector3itypedarray 
import py4godot.classes.RefCounted as py4godot_refcounted 
import py4godot.classes.RIDTypedArray as py4godot_ridtypedarray 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.Vector2iTypedArray as py4godot_vector2itypedarray 
import py4godot.classes.Vector3iTypedArray as py4godot_vector3itypedarray 
from py4godot.wrappers.wrappers import CPPTextServerWrapper

class FontAntialiasing:
  FONT_ANTIALIASING_NONE = 0
  FONT_ANTIALIASING_GRAY = 1
  FONT_ANTIALIASING_LCD = 2
class FontLCDSubpixelLayout:
  FONT_LCD_SUBPIXEL_LAYOUT_NONE = 0
  FONT_LCD_SUBPIXEL_LAYOUT_HRGB = 1
  FONT_LCD_SUBPIXEL_LAYOUT_HBGR = 2
  FONT_LCD_SUBPIXEL_LAYOUT_VRGB = 3
  FONT_LCD_SUBPIXEL_LAYOUT_VBGR = 4
  FONT_LCD_SUBPIXEL_LAYOUT_MAX = 5
class Direction:
  DIRECTION_AUTO = 0
  DIRECTION_LTR = 1
  DIRECTION_RTL = 2
  DIRECTION_INHERITED = 3
class Orientation:
  ORIENTATION_HORIZONTAL = 0
  ORIENTATION_VERTICAL = 1
class JustificationFlag:
  JUSTIFICATION_NONE = 0
  JUSTIFICATION_KASHIDA = 1
  JUSTIFICATION_WORD_BOUND = 2
  JUSTIFICATION_TRIM_EDGE_SPACES = 4
  JUSTIFICATION_AFTER_LAST_TAB = 8
  JUSTIFICATION_CONSTRAIN_ELLIPSIS = 16
  JUSTIFICATION_SKIP_LAST_LINE = 32
  JUSTIFICATION_SKIP_LAST_LINE_WITH_VISIBLE_CHARS = 64
  JUSTIFICATION_DO_NOT_SKIP_SINGLE_LINE = 128
class AutowrapMode:
  AUTOWRAP_OFF = 0
  AUTOWRAP_ARBITRARY = 1
  AUTOWRAP_WORD = 2
  AUTOWRAP_WORD_SMART = 3
class LineBreakFlag:
  BREAK_NONE = 0
  BREAK_MANDATORY = 1
  BREAK_WORD_BOUND = 2
  BREAK_GRAPHEME_BOUND = 4
  BREAK_ADAPTIVE = 8
  BREAK_TRIM_EDGE_SPACES = 16
  BREAK_TRIM_INDENT = 32
  BREAK_TRIM_START_EDGE_SPACES = 64
  BREAK_TRIM_END_EDGE_SPACES = 128
class VisibleCharactersBehavior:
  VC_CHARS_BEFORE_SHAPING = 0
  VC_CHARS_AFTER_SHAPING = 1
  VC_GLYPHS_AUTO = 2
  VC_GLYPHS_LTR = 3
  VC_GLYPHS_RTL = 4
class OverrunBehavior:
  OVERRUN_NO_TRIMMING = 0
  OVERRUN_TRIM_CHAR = 1
  OVERRUN_TRIM_WORD = 2
  OVERRUN_TRIM_ELLIPSIS = 3
  OVERRUN_TRIM_WORD_ELLIPSIS = 4
  OVERRUN_TRIM_ELLIPSIS_FORCE = 5
  OVERRUN_TRIM_WORD_ELLIPSIS_FORCE = 6
class TextOverrunFlag:
  OVERRUN_NO_TRIM = 0
  OVERRUN_TRIM = 1
  OVERRUN_TRIM_WORD_ONLY = 2
  OVERRUN_ADD_ELLIPSIS = 4
  OVERRUN_ENFORCE_ELLIPSIS = 8
  OVERRUN_JUSTIFICATION_AWARE = 16
class GraphemeFlag:
  GRAPHEME_IS_VALID = 1
  GRAPHEME_IS_RTL = 2
  GRAPHEME_IS_VIRTUAL = 4
  GRAPHEME_IS_SPACE = 8
  GRAPHEME_IS_BREAK_HARD = 16
  GRAPHEME_IS_BREAK_SOFT = 32
  GRAPHEME_IS_TAB = 64
  GRAPHEME_IS_ELONGATION = 128
  GRAPHEME_IS_PUNCTUATION = 256
  GRAPHEME_IS_UNDERSCORE = 512
  GRAPHEME_IS_CONNECTED = 1024
  GRAPHEME_IS_SAFE_TO_INSERT_TATWEEL = 2048
  GRAPHEME_IS_EMBEDDED_OBJECT = 4096
  GRAPHEME_IS_SOFT_HYPHEN = 8192
class Hinting:
  HINTING_NONE = 0
  HINTING_LIGHT = 1
  HINTING_NORMAL = 2
class SubpixelPositioning:
  SUBPIXEL_POSITIONING_DISABLED = 0
  SUBPIXEL_POSITIONING_AUTO = 1
  SUBPIXEL_POSITIONING_ONE_HALF = 2
  SUBPIXEL_POSITIONING_ONE_QUARTER = 3
  SUBPIXEL_POSITIONING_ONE_HALF_MAX_SIZE = 20
  SUBPIXEL_POSITIONING_ONE_QUARTER_MAX_SIZE = 16
class Feature:
  FEATURE_SIMPLE_LAYOUT = 1
  FEATURE_BIDI_LAYOUT = 2
  FEATURE_VERTICAL_LAYOUT = 4
  FEATURE_SHAPING = 8
  FEATURE_KASHIDA_JUSTIFICATION = 16
  FEATURE_BREAK_ITERATORS = 32
  FEATURE_FONT_BITMAP = 64
  FEATURE_FONT_DYNAMIC = 128
  FEATURE_FONT_MSDF = 256
  FEATURE_FONT_SYSTEM = 512
  FEATURE_FONT_VARIABLE = 1024
  FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION = 2048
  FEATURE_USE_SUPPORT_DATA = 4096
  FEATURE_UNICODE_IDENTIFIERS = 8192
  FEATURE_UNICODE_SECURITY = 16384
class ContourPointTag:
  CONTOUR_CURVE_TAG_ON = 1
  CONTOUR_CURVE_TAG_OFF_CONIC = 0
  CONTOUR_CURVE_TAG_OFF_CUBIC = 2
class SpacingType:
  SPACING_GLYPH = 0
  SPACING_SPACE = 1
  SPACING_TOP = 2
  SPACING_BOTTOM = 3
  SPACING_MAX = 4
class FontStyle:
  FONT_BOLD = 1
  FONT_ITALIC = 2
  FONT_FIXED_WIDTH = 4
class StructuredTextParser:
  STRUCTURED_TEXT_DEFAULT = 0
  STRUCTURED_TEXT_URI = 1
  STRUCTURED_TEXT_FILE = 2
  STRUCTURED_TEXT_EMAIL = 3
  STRUCTURED_TEXT_LIST = 4
  STRUCTURED_TEXT_GDSCRIPT = 5
  STRUCTURED_TEXT_CUSTOM = 6
class FixedSizeScaleMode:
  FIXED_SIZE_SCALE_DISABLE = 0
  FIXED_SIZE_SCALE_INTEGER_ONLY = 1
  FIXED_SIZE_SCALE_ENABLED = 2


class TextServer(py4godot_refcounted.RefCounted):
  r'''
		`TextServer` is the API backend for managing fonts and rendering text.
		**Note:** This is a low-level API, consider using `TextLine`, `TextParagraph`, and `Font` classes instead.
		This is an abstract class, so to get the currently active `TextServer` instance, use the following code:
		
		```gdscript
		var ts = TextServerManager.get_primary_interface()
		```
		
		
	'''

  @staticmethod
  def constructor():
    class_ = TextServer.construct_without_init()
    class_._ptr = constructor(812,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TextServer.construct_without_init()
    class_._ptr = constructor(812,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTextServerWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(812,0, ())


  def generate_wrapper(self):
    return CPPTextServerWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = TextServer.__new__(TextServer)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TextServer'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(286, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TextServer.construct_without_init()
    cls._ptr = CPPTextServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TextServer.construct_without_init()
    cls._ptr = CPPTextServerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def has_feature(self, feature:'int'  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the server supports a feature.
			'''

    assert isinstance(feature, (int, float)), 'feature must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(53,tuple([feature]))
    return _ret


  @functools.native_method
  def get_name(self) -> typing.Union[str]:
    r'''
				Returns the name of the server interface.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_features(self) -> typing.Union[int]:
    r'''
				Returns text server features, see `enum Feature`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(55,tuple([]))
    return _ret


  @functools.native_method
  def load_support_data(self, filename:'str'   ) -> typing.Union[bool]:
    r'''
				Loads optional TextServer database (e.g. ICU break iterators and dictionaries).
				**Note:** This function should be called before any other TextServer functions used, otherwise it won't have any effect.
			'''

    assert(not filename is None)
    assert isinstance(filename, (str, String)), 'filename must be str or String'





    assert(isinstance(filename, (str, String)))
    py_string_filename = filename if isinstance(filename, StringName) else c_utils.py_string_to_string(filename)

    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([py_string_filename._ptr]))
    return _ret


  @functools.native_method
  def get_support_data_filename(self) -> typing.Union[str]:
    r'''
				Returns default TextServer database (e.g. ICU break iterators and dictionaries) filename.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(57,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_support_data_info(self) -> typing.Union[str]:
    r'''
				Returns TextServer database (e.g. ICU break iterators and dictionaries) description.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def save_support_data(self, filename:'str'   ) -> typing.Union[bool]:
    r'''
				Saves optional TextServer database (e.g. ICU break iterators and dictionaries) to the file.
				**Note:** This function is used by during project export, to include TextServer database.
			'''

    assert(not filename is None)
    assert isinstance(filename, (str, String)), 'filename must be str or String'





    assert(isinstance(filename, (str, String)))
    py_string_filename = filename if isinstance(filename, StringName) else c_utils.py_string_to_string(filename)

    _ret = 0
    _ret = self._ptr.call_with_return(59,tuple([py_string_filename._ptr]))
    return _ret


  @functools.native_method
  def get_support_data(self) -> typing.Union['PackedByteArray']:
    r'''
				Returns default TextServer database (e.g. ICU break iterators and dictionaries).
			'''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([]))
    return _ret


  @functools.native_method
  def is_locale_right_to_left(self, locale:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if locale is right-to-left.
			'''

    assert(not locale is None)
    assert isinstance(locale, (str, String)), 'locale must be str or String'





    assert(isinstance(locale, (str, String)))
    py_string_locale = locale if isinstance(locale, StringName) else c_utils.py_string_to_string(locale)

    _ret = 0
    _ret = self._ptr.call_with_return(61,tuple([py_string_locale._ptr]))
    return _ret


  @functools.native_method
  def name_to_tag(self, name:'str'   ) -> typing.Union[int]:
    r'''
				Converts the given readable name of a feature, variation, script, or language to an OpenType tag.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(62,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def tag_to_name(self, tag:'int'   ) -> typing.Union[str]:
    r'''
				Converts the given OpenType tag to the readable name of a feature, variation, script, or language.
			'''

    assert isinstance(tag, (int, float)), 'tag must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(63,tuple([tag]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def has(self, rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if `rid` is valid resource owned by this text server.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(64,tuple([rid._ptr]))
    return _ret


  @functools.native_method
  def free_rid(self, rid:'RID'   ) -> None:
    r'''
				Frees an object created by this `TextServer`.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    self._ptr.call_with_return(65,tuple([rid._ptr]))

  @functools.native_method
  def create_font(self) -> typing.Union['RID']:
    r'''
				Creates a new, empty font cache entry resource. To free the resulting resource, use the `free_rid` method.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(66,tuple([]))
    return _ret


  @functools.native_method
  def create_font_linked_variation(self, font_rid:'RID'   ) -> typing.Union['RID']:
    r'''
				Creates a new variation existing font which is reusing the same glyph cache and font data. To free the resulting resource, use the `free_rid` method.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(67,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_data(self, font_rid:'RID'   , data:'PackedByteArray'   ) -> None:
    r'''
				Sets font source data, e.g contents of the dynamic font source file.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'








    self._ptr.call_with_return(68,tuple([font_rid._ptr, data._ptr]))

  @functools.native_method
  def font_set_face_index(self, font_rid:'RID'   , face_index:'int'   ) -> None:
    r'''
				Sets an active face index in the TrueType / OpenType collection.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(face_index, (int, float)), 'face_index must be int or float'








    self._ptr.call_with_return(69,tuple([font_rid._ptr, face_index]))

  @functools.native_method
  def font_get_face_index(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns an active face index in the TrueType / OpenType collection.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(70,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_get_face_count(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns number of faces in the TrueType / OpenType collection.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(71,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_style(self, font_rid:'RID'   , style:'int'   ) -> None:
    r'''
				Sets the font style flags.
				**Note:** This value is used for font matching only and will not affect font rendering. Use `font_set_face_index`, `font_set_variation_coordinates`, `font_set_embolden`, or `font_set_transform` instead.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(style, (int, float)), 'style must be int or float'








    self._ptr.call_with_return(72,tuple([font_rid._ptr, style]))

  @functools.native_method
  def font_get_style(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns font style flags.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret
    _ret = self._ptr.call_with_return(73,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_name(self, font_rid:'RID'   , name:'str'   ) -> None:
    r'''
				Sets the font family name.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(74,tuple([font_rid._ptr, py_string_name._ptr]))

  @functools.native_method
  def font_get_name(self, font_rid:'RID'   ) -> typing.Union[str]:
    r'''
				Returns font family name.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(75,tuple([font_rid._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def font_get_ot_name_strings(self, font_rid:'RID'   ) -> typing.Union['Dictionary']:
    r'''
				Returns `Dictionary` with OpenType font name strings (localized font names, version, description, license information, sample text, etc.).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(76,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_style_name(self, font_rid:'RID'   , name:'str'   ) -> None:
    r'''
				Sets the font style name.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(77,tuple([font_rid._ptr, py_string_name._ptr]))

  @functools.native_method
  def font_get_style_name(self, font_rid:'RID'   ) -> typing.Union[str]:
    r'''
				Returns font style name.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([font_rid._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def font_set_weight(self, font_rid:'RID'   , weight:'int'   ) -> None:
    r'''
				Sets weight (boldness) of the font. A value in the `100...999` range, normal font weight is `400`, bold font weight is `700`.
				**Note:** This value is used for font matching only and will not affect font rendering. Use `font_set_face_index`, `font_set_variation_coordinates`, or `font_set_embolden` instead.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    self._ptr.call_with_return(79,tuple([font_rid._ptr, weight]))

  @functools.native_method
  def font_get_weight(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns weight (boldness) of the font. A value in the `100...999` range, normal font weight is `400`, bold font weight is `700`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(80,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_stretch(self, font_rid:'RID'   , weight:'int'   ) -> None:
    r'''
				Sets font stretch amount, compared to a normal width. A percentage value between `50%` and `200%`.
				**Note:** This value is used for font matching only and will not affect font rendering. Use `font_set_face_index`, `font_set_variation_coordinates`, or `font_set_transform` instead.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    self._ptr.call_with_return(81,tuple([font_rid._ptr, weight]))

  @functools.native_method
  def font_get_stretch(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns font stretch amount, compared to a normal width. A percentage value between `50%` and `200%`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_antialiasing(self, font_rid:'RID'   , antialiasing:'int'  ) -> None:
    r'''
				Sets font anti-aliasing mode.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(antialiasing, (int, float)), 'antialiasing must be int or float'








    self._ptr.call_with_return(83,tuple([font_rid._ptr, antialiasing]))

  @functools.native_method
  def font_get_antialiasing(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns font anti-aliasing mode.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(84,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_disable_embedded_bitmaps(self, font_rid:'RID'   , disable_embedded_bitmaps:'bool'   ) -> None:
    r'''
				If set to `true`, embedded font bitmap loading is disabled (bitmap-only and color fonts ignore this property).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(disable_embedded_bitmaps, bool), 'disable_embedded_bitmaps must be bool'








    self._ptr.call_with_return(85,tuple([font_rid._ptr, disable_embedded_bitmaps]))

  @functools.native_method
  def font_get_disable_embedded_bitmaps(self, font_rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns whether the font's embedded bitmap loading is disabled.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_generate_mipmaps(self, font_rid:'RID'   , generate_mipmaps:'bool'   ) -> None:
    r'''
				If set to `true` font texture mipmap generation is enabled.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(generate_mipmaps, bool), 'generate_mipmaps must be bool'








    self._ptr.call_with_return(87,tuple([font_rid._ptr, generate_mipmaps]))

  @functools.native_method
  def font_get_generate_mipmaps(self, font_rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if font texture mipmap generation is enabled.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_multichannel_signed_distance_field(self, font_rid:'RID'   , msdf:'bool'   ) -> None:
    r'''
				If set to `true`, glyphs of all sizes are rendered using single multichannel signed distance field generated from the dynamic font vector data. MSDF rendering allows displaying the font at any scaling factor without blurriness, and without incurring a CPU cost when the font size changes (since the font no longer needs to be rasterized on the CPU). As a downside, font hinting is not available with MSDF. The lack of font hinting may result in less crisp and less readable fonts at small sizes.
				**Note:** MSDF font rendering does not render glyphs with overlapping shapes correctly. Overlapping shapes are not valid per the OpenType standard, but are still commonly found in many font files, especially those converted by Google Fonts. To avoid issues with overlapping glyphs, consider downloading the font file directly from the type foundry instead of relying on Google Fonts.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(msdf, bool), 'msdf must be bool'








    self._ptr.call_with_return(89,tuple([font_rid._ptr, msdf]))

  @functools.native_method
  def font_is_multichannel_signed_distance_field(self, font_rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if glyphs of all sizes are rendered using single multichannel signed distance field generated from the dynamic font vector data.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_msdf_pixel_range(self, font_rid:'RID'   , msdf_pixel_range:'int'   ) -> None:
    r'''
				Sets the width of the range around the shape between the minimum and maximum representable signed distance.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(msdf_pixel_range, (int, float)), 'msdf_pixel_range must be int or float'








    self._ptr.call_with_return(91,tuple([font_rid._ptr, msdf_pixel_range]))

  @functools.native_method
  def font_get_msdf_pixel_range(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the width of the range around the shape between the minimum and maximum representable signed distance.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_msdf_size(self, font_rid:'RID'   , msdf_size:'int'   ) -> None:
    r'''
				Sets source font size used to generate MSDF textures.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(msdf_size, (int, float)), 'msdf_size must be int or float'








    self._ptr.call_with_return(93,tuple([font_rid._ptr, msdf_size]))

  @functools.native_method
  def font_get_msdf_size(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns source font size used to generate MSDF textures.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_fixed_size(self, font_rid:'RID'   , fixed_size:'int'   ) -> None:
    r'''
				Sets bitmap font fixed size. If set to value greater than zero, same cache entry will be used for all font sizes.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(fixed_size, (int, float)), 'fixed_size must be int or float'








    self._ptr.call_with_return(95,tuple([font_rid._ptr, fixed_size]))

  @functools.native_method
  def font_get_fixed_size(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns bitmap font fixed size.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(96,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_fixed_size_scale_mode(self, font_rid:'RID'   , fixed_size_scale_mode:'int'  ) -> None:
    r'''
				Sets bitmap font scaling mode. This property is used only if `fixed_size` is greater than zero.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(fixed_size_scale_mode, (int, float)), 'fixed_size_scale_mode must be int or float'








    self._ptr.call_with_return(97,tuple([font_rid._ptr, fixed_size_scale_mode]))

  @functools.native_method
  def font_get_fixed_size_scale_mode(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns bitmap font scaling mode.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(98,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_allow_system_fallback(self, font_rid:'RID'   , allow_system_fallback:'bool'   ) -> None:
    r'''
				If set to `true`, system fonts can be automatically used as fallbacks.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(allow_system_fallback, bool), 'allow_system_fallback must be bool'








    self._ptr.call_with_return(99,tuple([font_rid._ptr, allow_system_fallback]))

  @functools.native_method
  def font_is_allow_system_fallback(self, font_rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if system fonts can be automatically used as fallbacks.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_clear_system_fallback_cache(self) -> None:
    r'''
				Frees all automatically loaded system fonts.
			'''




    self._ptr.call_with_return(101,tuple([]))

  @functools.native_method
  def font_set_force_autohinter(self, font_rid:'RID'   , force_autohinter:'bool'   ) -> None:
    r'''
				If set to `true` auto-hinting is preferred over font built-in hinting.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(force_autohinter, bool), 'force_autohinter must be bool'








    self._ptr.call_with_return(102,tuple([font_rid._ptr, force_autohinter]))

  @functools.native_method
  def font_is_force_autohinter(self, font_rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if auto-hinting is supported and preferred over font built-in hinting. Used by dynamic fonts only.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_modulate_color_glyphs(self, font_rid:'RID'   , force_autohinter:'bool'   ) -> None:
    r'''
				If set to `true`, color modulation is applied when drawing colored glyphs, otherwise it's applied to the monochrome glyphs only.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(force_autohinter, bool), 'force_autohinter must be bool'








    self._ptr.call_with_return(104,tuple([font_rid._ptr, force_autohinter]))

  @functools.native_method
  def font_is_modulate_color_glyphs(self, font_rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if color modulation is applied when drawing the font's colored glyphs.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(105,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_hinting(self, font_rid:'RID'   , hinting:'int'  ) -> None:
    r'''
				Sets font hinting mode. Used by dynamic fonts only.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(hinting, (int, float)), 'hinting must be int or float'








    self._ptr.call_with_return(106,tuple([font_rid._ptr, hinting]))

  @functools.native_method
  def font_get_hinting(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the font hinting mode. Used by dynamic fonts only.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(107,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_subpixel_positioning(self, font_rid:'RID'   , subpixel_positioning:'int'  ) -> None:
    r'''
				Sets font subpixel glyph positioning mode.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(subpixel_positioning, (int, float)), 'subpixel_positioning must be int or float'








    self._ptr.call_with_return(108,tuple([font_rid._ptr, subpixel_positioning]))

  @functools.native_method
  def font_get_subpixel_positioning(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns font subpixel glyph positioning mode.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(109,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_keep_rounding_remainders(self, font_rid:'RID'   , keep_rounding_remainders:'bool'   ) -> None:
    r'''
				Sets glyph position rounding behavior. If set to `true`, when aligning glyphs to the pixel boundaries rounding remainders are accumulated to ensure more uniform glyph distribution. This setting has no effect if subpixel positioning is enabled.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(keep_rounding_remainders, bool), 'keep_rounding_remainders must be bool'








    self._ptr.call_with_return(110,tuple([font_rid._ptr, keep_rounding_remainders]))

  @functools.native_method
  def font_get_keep_rounding_remainders(self, font_rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns glyph position rounding behavior. If set to `true`, when aligning glyphs to the pixel boundaries rounding remainders are accumulated to ensure more uniform glyph distribution. This setting has no effect if subpixel positioning is enabled.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(111,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_embolden(self, font_rid:'RID'   , strength:'float'   ) -> None:
    r'''
				Sets font embolden strength. If `strength` is not equal to zero, emboldens the font outlines. Negative values reduce the outline thickness.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(strength, (int, float)), 'strength must be int or float'








    self._ptr.call_with_return(112,tuple([font_rid._ptr, strength]))

  @functools.native_method
  def font_get_embolden(self, font_rid:'RID'   ) -> typing.Union[float]:
    r'''
				Returns font embolden strength.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(113,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_spacing(self, font_rid:'RID'   , spacing:'int'  , value:'int'   ) -> None:
    r'''
				Sets the spacing for `spacing` to `value` in pixels (not relative to the font size).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(spacing, (int, float)), 'spacing must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'









    self._ptr.call_with_return(114,tuple([font_rid._ptr, spacing, value]))

  @functools.native_method
  def font_get_spacing(self, font_rid:'RID'   , spacing:'int'  ) -> typing.Union[int]:
    r'''
				Returns the spacing for `spacing` in pixels (not relative to the font size).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(spacing, (int, float)), 'spacing must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(115,tuple([font_rid._ptr, spacing]))
    return _ret


  @functools.native_method
  def font_set_baseline_offset(self, font_rid:'RID'   , baseline_offset:'float'   ) -> None:
    r'''
				Sets extra baseline offset (as a fraction of font height).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(baseline_offset, (int, float)), 'baseline_offset must be int or float'








    self._ptr.call_with_return(116,tuple([font_rid._ptr, baseline_offset]))

  @functools.native_method
  def font_get_baseline_offset(self, font_rid:'RID'   ) -> typing.Union[float]:
    r'''
				Returns extra baseline offset (as a fraction of font height).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(117,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_transform(self, font_rid:'RID'   , transform:'Transform2D'   ) -> None:
    r'''
				Sets 2D transform, applied to the font outlines, can be used for slanting, flipping, and rotating glyphs.
				For example, to simulate italic typeface by slanting, apply the following transform `Transform2D(1.0, slant, 0.0, 1.0, 0.0, 0.0)`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'








    self._ptr.call_with_return(118,tuple([font_rid._ptr, transform._ptr]))

  @functools.native_method
  def font_get_transform(self, font_rid:'RID'   ) -> typing.Union['Transform2D']:
    r'''
				Returns 2D transform applied to the font outlines.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(119,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_variation_coordinates(self, font_rid:'RID'   , variation_coordinates:'Dictionary'   ) -> None:
    r'''
				Sets variation coordinates for the specified font cache entry. See `font_supported_variation_list` for more info.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not variation_coordinates is None)
    assert isinstance(variation_coordinates, Dictionary), 'variation_coordinates must be Dictionary'








    self._ptr.call_with_return(120,tuple([font_rid._ptr, variation_coordinates._ptr]))

  @functools.native_method
  def font_get_variation_coordinates(self, font_rid:'RID'   ) -> typing.Union['Dictionary']:
    r'''
				Returns variation coordinates for the specified font cache entry. See `font_supported_variation_list` for more info.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(121,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_oversampling(self, font_rid:'RID'   , oversampling:'float'   ) -> None:
    r'''
				If set to a positive value, overrides the oversampling factor of the viewport this font is used in. See `Viewport.oversampling`. This value doesn't override the `code skip-lint`oversampling` parameter of `code skip-lint`draw_*` methods. Used by dynamic fonts only.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'








    self._ptr.call_with_return(122,tuple([font_rid._ptr, oversampling]))

  @functools.native_method
  def font_get_oversampling(self, font_rid:'RID'   ) -> typing.Union[float]:
    r'''
				Returns oversampling factor override. If set to a positive value, overrides the oversampling factor of the viewport this font is used in. See `Viewport.oversampling`. This value doesn't override the `code skip-lint`oversampling` parameter of `code skip-lint`draw_*` methods. Used by dynamic fonts only.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(123,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_get_size_cache_list(self, font_rid:'RID'   ) -> typing.Union['py4godot_vector2itypedarray.Vector2iTypedArray']:
    r'''
				Returns list of the font sizes in the cache. Each size is `Vector2i` with font size and outline size.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = py4godot_vector2itypedarray.Vector2iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(124,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_clear_size_cache(self, font_rid:'RID'   ) -> None:
    r'''
				Removes all font sizes from the cache entry.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    self._ptr.call_with_return(125,tuple([font_rid._ptr]))

  @functools.native_method
  def font_remove_size_cache(self, font_rid:'RID'   , size:'Vector2i'   ) -> None:
    r'''
				Removes specified font size from the cache entry.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'








    self._ptr.call_with_return(126,tuple([font_rid._ptr, size._ptr]))

  @functools.native_method
  def font_get_size_cache_info(self, font_rid:'RID'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns font cache information, each entry contains the following fields: `Vector2i size_px` - font size in pixels, `float viewport_oversampling` - viewport oversampling factor, `int glyphs` - number of rendered glyphs, `int textures` - number of used textures, `int textures_size` - size of texture data in bytes.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(127,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_ascent(self, font_rid:'RID'   , size:'int'   , ascent:'float'   ) -> None:
    r'''
				Sets the font ascent (number of pixels above the baseline).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(ascent, (int, float)), 'ascent must be int or float'









    self._ptr.call_with_return(128,tuple([font_rid._ptr, size, ascent]))

  @functools.native_method
  def font_get_ascent(self, font_rid:'RID'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns the font ascent (number of pixels above the baseline).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(129,tuple([font_rid._ptr, size]))
    return _ret


  @functools.native_method
  def font_set_descent(self, font_rid:'RID'   , size:'int'   , descent:'float'   ) -> None:
    r'''
				Sets the font descent (number of pixels below the baseline).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(descent, (int, float)), 'descent must be int or float'









    self._ptr.call_with_return(130,tuple([font_rid._ptr, size, descent]))

  @functools.native_method
  def font_get_descent(self, font_rid:'RID'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns the font descent (number of pixels below the baseline).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(131,tuple([font_rid._ptr, size]))
    return _ret


  @functools.native_method
  def font_set_underline_position(self, font_rid:'RID'   , size:'int'   , underline_position:'float'   ) -> None:
    r'''
				Sets pixel offset of the underline below the baseline.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(underline_position, (int, float)), 'underline_position must be int or float'









    self._ptr.call_with_return(132,tuple([font_rid._ptr, size, underline_position]))

  @functools.native_method
  def font_get_underline_position(self, font_rid:'RID'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns pixel offset of the underline below the baseline.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(133,tuple([font_rid._ptr, size]))
    return _ret


  @functools.native_method
  def font_set_underline_thickness(self, font_rid:'RID'   , size:'int'   , underline_thickness:'float'   ) -> None:
    r'''
				Sets thickness of the underline in pixels.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(underline_thickness, (int, float)), 'underline_thickness must be int or float'









    self._ptr.call_with_return(134,tuple([font_rid._ptr, size, underline_thickness]))

  @functools.native_method
  def font_get_underline_thickness(self, font_rid:'RID'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns thickness of the underline in pixels.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(135,tuple([font_rid._ptr, size]))
    return _ret


  @functools.native_method
  def font_set_scale(self, font_rid:'RID'   , size:'int'   , scale:'float'   ) -> None:
    r'''
				Sets scaling factor of the color bitmap font.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(scale, (int, float)), 'scale must be int or float'









    self._ptr.call_with_return(136,tuple([font_rid._ptr, size, scale]))

  @functools.native_method
  def font_get_scale(self, font_rid:'RID'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns scaling factor of the color bitmap font.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(137,tuple([font_rid._ptr, size]))
    return _ret


  @functools.native_method
  def font_get_texture_count(self, font_rid:'RID'   , size:'Vector2i'   ) -> typing.Union[int]:
    r'''
				Returns number of textures used by font cache entry.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'








    _ret = 0
    _ret = self._ptr.call_with_return(138,tuple([font_rid._ptr, size._ptr]))
    return _ret


  @functools.native_method
  def font_clear_textures(self, font_rid:'RID'   , size:'Vector2i'   ) -> None:
    r'''
				Removes all textures from font cache entry.
				**Note:** This function will not remove glyphs associated with the texture, use `font_remove_glyph` to remove them manually.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'








    self._ptr.call_with_return(139,tuple([font_rid._ptr, size._ptr]))

  @functools.native_method
  def font_remove_texture(self, font_rid:'RID'   , size:'Vector2i'   , texture_index:'int'   ) -> None:
    r'''
				Removes specified texture from the cache entry.
				**Note:** This function will not remove glyphs associated with the texture, remove them manually, using `font_remove_glyph`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'









    self._ptr.call_with_return(140,tuple([font_rid._ptr, size._ptr, texture_index]))

  @functools.native_method
  def font_set_texture_image(self, font_rid:'RID'   , size:'Vector2i'   , texture_index:'int'   , image:'py4godot_image.Image'   ) -> None:
    r'''
				Sets font cache texture image data.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'
    assert(not image is None)
    assert isinstance(image, get_class('Image')), 'image must be Image'










    self._ptr.call_with_return(141,tuple([font_rid._ptr, size._ptr, texture_index, image._ptr]))

  @functools.native_method
  def font_get_texture_image(self, font_rid:'RID'   , size:'Vector2i'   , texture_index:'int'   ) -> typing.Union['py4godot_image.Image']:
    r'''
				Returns font cache texture image data.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'









    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Image
    _ret._ptr = self._ptr.call_with_return(142,tuple([font_rid._ptr, size._ptr, texture_index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def font_set_texture_offsets(self, font_rid:'RID'   , size:'Vector2i'   , texture_index:'int'   , offset:'PackedInt32Array'   ) -> None:
    r'''
				Sets array containing glyph packing data.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'
    assert(not offset is None)
    assert isinstance(offset, PackedInt32Array), 'offset must be PackedInt32Array'










    self._ptr.call_with_return(143,tuple([font_rid._ptr, size._ptr, texture_index, offset._ptr]))

  @functools.native_method
  def font_get_texture_offsets(self, font_rid:'RID'   , size:'Vector2i'   , texture_index:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns array containing glyph packing data.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'









    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(144,tuple([font_rid._ptr, size._ptr, texture_index]))
    return _ret


  @functools.native_method
  def font_get_glyph_list(self, font_rid:'RID'   , size:'Vector2i'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns list of rendered glyphs in the cache entry.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'








    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(145,tuple([font_rid._ptr, size._ptr]))
    return _ret


  @functools.native_method
  def font_clear_glyphs(self, font_rid:'RID'   , size:'Vector2i'   ) -> None:
    r'''
				Removes all rendered glyph information from the cache entry.
				**Note:** This function will not remove textures associated with the glyphs, use `font_remove_texture` to remove them manually.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'








    self._ptr.call_with_return(146,tuple([font_rid._ptr, size._ptr]))

  @functools.native_method
  def font_remove_glyph(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   ) -> None:
    r'''
				Removes specified rendered glyph information from the cache entry.
				**Note:** This function will not remove textures associated with the glyphs, use `font_remove_texture` to remove them manually.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    self._ptr.call_with_return(147,tuple([font_rid._ptr, size._ptr, glyph]))

  @functools.native_method
  def font_get_glyph_advance(self, font_rid:'RID'   , size:'int'   , glyph:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns glyph advance (offset of the next glyph).
				**Note:** Advance for glyphs outlines is the same as the base glyph advance and is not saved.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(148,tuple([font_rid._ptr, size, glyph]))
    return _ret


  @functools.native_method
  def font_set_glyph_advance(self, font_rid:'RID'   , size:'int'   , glyph:'int'   , advance:'Vector2'   ) -> None:
    r'''
				Sets glyph advance (offset of the next glyph).
				**Note:** Advance for glyphs outlines is the same as the base glyph advance and is not saved.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert(not advance is None)
    assert isinstance(advance, Vector2), 'advance must be Vector2'










    self._ptr.call_with_return(149,tuple([font_rid._ptr, size, glyph, advance._ptr]))

  @functools.native_method
  def font_get_glyph_offset(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns glyph offset from the baseline.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(150,tuple([font_rid._ptr, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def font_set_glyph_offset(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   , offset:'Vector2'   ) -> None:
    r'''
				Sets glyph offset from the baseline.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'










    self._ptr.call_with_return(151,tuple([font_rid._ptr, size._ptr, glyph, offset._ptr]))

  @functools.native_method
  def font_get_glyph_size(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns size of the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(152,tuple([font_rid._ptr, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def font_set_glyph_size(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   , gl_size:'Vector2'   ) -> None:
    r'''
				Sets size of the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert(not gl_size is None)
    assert isinstance(gl_size, Vector2), 'gl_size must be Vector2'










    self._ptr.call_with_return(153,tuple([font_rid._ptr, size._ptr, glyph, gl_size._ptr]))

  @functools.native_method
  def font_get_glyph_uv_rect(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union['Rect2']:
    r'''
				Returns rectangle in the cache texture containing the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(154,tuple([font_rid._ptr, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def font_set_glyph_uv_rect(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   , uv_rect:'Rect2'   ) -> None:
    r'''
				Sets rectangle in the cache texture containing the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert(not uv_rect is None)
    assert isinstance(uv_rect, Rect2), 'uv_rect must be Rect2'










    self._ptr.call_with_return(155,tuple([font_rid._ptr, size._ptr, glyph, uv_rect._ptr]))

  @functools.native_method
  def font_get_glyph_texture_idx(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union[int]:
    r'''
				Returns index of the cache texture containing the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    _ret = 0
    _ret = self._ptr.call_with_return(156,tuple([font_rid._ptr, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def font_set_glyph_texture_idx(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   , texture_idx:'int'   ) -> None:
    r'''
				Sets index of the cache texture containing the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert isinstance(texture_idx, (int, float)), 'texture_idx must be int or float'










    self._ptr.call_with_return(157,tuple([font_rid._ptr, size._ptr, glyph, texture_idx]))

  @functools.native_method
  def font_get_glyph_texture_rid(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union['RID']:
    r'''
				Returns resource ID of the cache texture containing the glyph.
				**Note:** If there are pending glyphs to render, calling this function might trigger the texture cache update.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(158,tuple([font_rid._ptr, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def font_get_glyph_texture_size(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns size of the cache texture containing the glyph.
				**Note:** If there are pending glyphs to render, calling this function might trigger the texture cache update.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(159,tuple([font_rid._ptr, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def font_get_glyph_contours(self, font:'RID'   , size:'int'   , index:'int'   ) -> typing.Union['Dictionary']:
    r'''
				Returns outline contours of the glyph as a `Dictionary` with the following contents:
				`points`         - `PackedVector3Array`, containing outline points. `x` and `y` are point coordinates. `z` is the type of the point, using the `enum ContourPointTag` values.
				`contours`       - `PackedInt32Array`, containing indices the end points of each contour.
				`orientation`    - `bool`, contour orientation. If `true`, clockwise contours must be filled.
				- Two successive `constant CONTOUR_CURVE_TAG_ON` points indicate a line segment.
				- One `constant CONTOUR_CURVE_TAG_OFF_CONIC` point between two `constant CONTOUR_CURVE_TAG_ON` points indicates a single conic (quadratic) Bzier arc.
				- Two `constant CONTOUR_CURVE_TAG_OFF_CUBIC` points between two `constant CONTOUR_CURVE_TAG_ON` points indicate a single cubic Bzier arc.
				- Two successive `constant CONTOUR_CURVE_TAG_OFF_CONIC` points indicate two successive conic (quadratic) Bzier arcs with a virtual `constant CONTOUR_CURVE_TAG_ON` point at their middle.
				- Each contour is closed. The last point of a contour uses the first point of a contour as its next point, and vice versa. The first point can be `constant CONTOUR_CURVE_TAG_OFF_CONIC` point.
			'''

    assert(not font is None)
    assert isinstance(font, RID), 'font must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'









    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(160,tuple([font._ptr, size, index]))
    return _ret


  @functools.native_method
  def font_get_kerning_list(self, font_rid:'RID'   , size:'int'   ) -> typing.Union['py4godot_vector2itypedarray.Vector2iTypedArray']:
    r'''
				Returns list of the kerning overrides.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'








    _ret = py4godot_vector2itypedarray.Vector2iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(161,tuple([font_rid._ptr, size]))
    return _ret


  @functools.native_method
  def font_clear_kerning_map(self, font_rid:'RID'   , size:'int'   ) -> None:
    r'''
				Removes all kerning overrides.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'








    self._ptr.call_with_return(162,tuple([font_rid._ptr, size]))

  @functools.native_method
  def font_remove_kerning(self, font_rid:'RID'   , size:'int'   , glyph_pair:'Vector2i'   ) -> None:
    r'''
				Removes kerning override for the pair of glyphs.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not glyph_pair is None)
    assert isinstance(glyph_pair, Vector2i), 'glyph_pair must be Vector2i'









    self._ptr.call_with_return(163,tuple([font_rid._ptr, size, glyph_pair._ptr]))

  @functools.native_method
  def font_set_kerning(self, font_rid:'RID'   , size:'int'   , glyph_pair:'Vector2i'   , kerning:'Vector2'   ) -> None:
    r'''
				Sets kerning for the pair of glyphs.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not glyph_pair is None)
    assert isinstance(glyph_pair, Vector2i), 'glyph_pair must be Vector2i'
    assert(not kerning is None)
    assert isinstance(kerning, Vector2), 'kerning must be Vector2'










    self._ptr.call_with_return(164,tuple([font_rid._ptr, size, glyph_pair._ptr, kerning._ptr]))

  @functools.native_method
  def font_get_kerning(self, font_rid:'RID'   , size:'int'   , glyph_pair:'Vector2i'   ) -> typing.Union['Vector2']:
    r'''
				Returns kerning for the pair of glyphs.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not glyph_pair is None)
    assert isinstance(glyph_pair, Vector2i), 'glyph_pair must be Vector2i'









    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(165,tuple([font_rid._ptr, size, glyph_pair._ptr]))
    return _ret


  @functools.native_method
  def font_get_glyph_index(self, font_rid:'RID'   , size:'int'   , char:'int'   , variation_selector:'int'   ) -> typing.Union[int]:
    r'''
				Returns the glyph index of a `char`, optionally modified by the `variation_selector`. See `font_get_char_from_glyph_index`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(char, (int, float)), 'char must be int or float'
    assert isinstance(variation_selector, (int, float)), 'variation_selector must be int or float'










    _ret = 0
    _ret = self._ptr.call_with_return(166,tuple([font_rid._ptr, size, char, variation_selector]))
    return _ret


  @functools.native_method
  def font_get_char_from_glyph_index(self, font_rid:'RID'   , size:'int'   , glyph_index:'int'   ) -> typing.Union[int]:
    r'''
				Returns character code associated with `glyph_index`, or `0` if `glyph_index` is invalid. See `font_get_glyph_index`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(glyph_index, (int, float)), 'glyph_index must be int or float'









    _ret = 0
    _ret = self._ptr.call_with_return(167,tuple([font_rid._ptr, size, glyph_index]))
    return _ret


  @functools.native_method
  def font_has_char(self, font_rid:'RID'   , char:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if a Unicode `char` is available in the font.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(char, (int, float)), 'char must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(168,tuple([font_rid._ptr, char]))
    return _ret


  @functools.native_method
  def font_get_supported_chars(self, font_rid:'RID'   ) -> typing.Union[str]:
    r'''
				Returns a string containing all the characters available in the font.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(169,tuple([font_rid._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def font_get_supported_glyphs(self, font_rid:'RID'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns an array containing all glyph indices in the font.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(170,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_render_range(self, font_rid:'RID'   , size:'Vector2i'   , start:'int'   , end:'int'   ) -> None:
    r'''
				Renders the range of characters to the font cache texture.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(start, (int, float)), 'start must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'










    self._ptr.call_with_return(171,tuple([font_rid._ptr, size._ptr, start, end]))

  @functools.native_method
  def font_render_glyph(self, font_rid:'RID'   , size:'Vector2i'   , index:'int'   ) -> None:
    r'''
				Renders specified glyph to the font cache texture.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(index, (int, float)), 'index must be int or float'









    self._ptr.call_with_return(172,tuple([font_rid._ptr, size._ptr, index]))

  @functools.native_method
  def font_draw_glyph(self, font_rid:'RID'   , canvas:'RID'   , size:'int'   , pos:'Vector2'   , index:'int'   , color:'Color' = None  , oversampling:'float' =0.0  ) -> None:
    r'''
				Draws single glyph into a canvas item at the position, using `font_rid` at the size `size`. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
				**Note:** Glyph index is specific to the font, use glyphs indices returned by `shaped_text_get_glyphs` or `font_get_glyph_index`.
				**Note:** If there are pending glyphs to render, calling this function might trigger the texture cache update.
			'''
    if color is None:
      color = Color.new0()

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'













    self._ptr.call_with_return(173,tuple([font_rid._ptr, canvas._ptr, size, pos._ptr, index, color._ptr, oversampling]))

  @functools.native_method
  def font_draw_glyph_outline(self, font_rid:'RID'   , canvas:'RID'   , size:'int'   , outline_size:'int'   , pos:'Vector2'   , index:'int'   , color:'Color' = None  , oversampling:'float' =0.0  ) -> None:
    r'''
				Draws single glyph outline of size `outline_size` into a canvas item at the position, using `font_rid` at the size `size`. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
				**Note:** Glyph index is specific to the font, use glyphs indices returned by `shaped_text_get_glyphs` or `font_get_glyph_index`.
				**Note:** If there are pending glyphs to render, calling this function might trigger the texture cache update.
			'''
    if color is None:
      color = Color.new0()

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(outline_size, (int, float)), 'outline_size must be int or float'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'














    self._ptr.call_with_return(174,tuple([font_rid._ptr, canvas._ptr, size, outline_size, pos._ptr, index, color._ptr, oversampling]))

  @functools.native_method
  def font_is_language_supported(self, font_rid:'RID'   , language:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the font supports the given language (as a `url=https://en.wikipedia.org/wiki/ISO_639-1`ISO 639`/url` code).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'






    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = 0
    _ret = self._ptr.call_with_return(175,tuple([font_rid._ptr, py_string_language._ptr]))
    return _ret


  @functools.native_method
  def font_set_language_support_override(self, font_rid:'RID'   , language:'str'   , supported:'bool'   ) -> None:
    r'''
				Adds override for `font_is_language_supported`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'
    assert isinstance(supported, bool), 'supported must be bool'






    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)


    self._ptr.call_with_return(176,tuple([font_rid._ptr, py_string_language._ptr, supported]))

  @functools.native_method
  def font_get_language_support_override(self, font_rid:'RID'   , language:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if support override is enabled for the `language`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'






    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = 0
    _ret = self._ptr.call_with_return(177,tuple([font_rid._ptr, py_string_language._ptr]))
    return _ret


  @functools.native_method
  def font_remove_language_support_override(self, font_rid:'RID'   , language:'str'   ) -> None:
    r'''
				Remove language support override.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'






    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    self._ptr.call_with_return(178,tuple([font_rid._ptr, py_string_language._ptr]))

  @functools.native_method
  def font_get_language_support_overrides(self, font_rid:'RID'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns list of language support overrides.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(179,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_is_script_supported(self, font_rid:'RID'   , script:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the font supports the given script (as a `url=https://en.wikipedia.org/wiki/ISO_15924`ISO 15924`/url` code).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not script is None)
    assert isinstance(script, (str, String)), 'script must be str or String'






    assert(isinstance(script, (str, String)))
    py_string_script = script if isinstance(script, StringName) else c_utils.py_string_to_string(script)

    _ret = 0
    _ret = self._ptr.call_with_return(180,tuple([font_rid._ptr, py_string_script._ptr]))
    return _ret


  @functools.native_method
  def font_set_script_support_override(self, font_rid:'RID'   , script:'str'   , supported:'bool'   ) -> None:
    r'''
				Adds override for `font_is_script_supported`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not script is None)
    assert isinstance(script, (str, String)), 'script must be str or String'
    assert isinstance(supported, bool), 'supported must be bool'






    assert(isinstance(script, (str, String)))
    py_string_script = script if isinstance(script, StringName) else c_utils.py_string_to_string(script)


    self._ptr.call_with_return(181,tuple([font_rid._ptr, py_string_script._ptr, supported]))

  @functools.native_method
  def font_get_script_support_override(self, font_rid:'RID'   , script:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if support override is enabled for the `script`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not script is None)
    assert isinstance(script, (str, String)), 'script must be str or String'






    assert(isinstance(script, (str, String)))
    py_string_script = script if isinstance(script, StringName) else c_utils.py_string_to_string(script)

    _ret = 0
    _ret = self._ptr.call_with_return(182,tuple([font_rid._ptr, py_string_script._ptr]))
    return _ret


  @functools.native_method
  def font_remove_script_support_override(self, font_rid:'RID'   , script:'str'   ) -> None:
    r'''
				Removes script support override.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not script is None)
    assert isinstance(script, (str, String)), 'script must be str or String'






    assert(isinstance(script, (str, String)))
    py_string_script = script if isinstance(script, StringName) else c_utils.py_string_to_string(script)

    self._ptr.call_with_return(183,tuple([font_rid._ptr, py_string_script._ptr]))

  @functools.native_method
  def font_get_script_support_overrides(self, font_rid:'RID'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns list of script support overrides.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(184,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_set_opentype_feature_overrides(self, font_rid:'RID'   , overrides:'Dictionary'   ) -> None:
    r'''
				Sets font OpenType feature set override.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not overrides is None)
    assert isinstance(overrides, Dictionary), 'overrides must be Dictionary'








    self._ptr.call_with_return(185,tuple([font_rid._ptr, overrides._ptr]))

  @functools.native_method
  def font_get_opentype_feature_overrides(self, font_rid:'RID'   ) -> typing.Union['Dictionary']:
    r'''
				Returns font OpenType feature set override.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(186,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_supported_feature_list(self, font_rid:'RID'   ) -> typing.Union['Dictionary']:
    r'''
				Returns the dictionary of the supported OpenType features.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(187,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_supported_variation_list(self, font_rid:'RID'   ) -> typing.Union['Dictionary']:
    r'''
				Returns the dictionary of the supported OpenType variation coordinates.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(188,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def font_get_global_oversampling(self) -> typing.Union[float]:
    r'''
				This method does nothing and always returns `1.0`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(189,tuple([]))
    return _ret


  @functools.native_method
  def font_set_global_oversampling(self, oversampling:'float'   ) -> None:
    r'''
				This method does nothing.
			'''

    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'







    self._ptr.call_with_return(190,tuple([oversampling]))

  @functools.native_method
  def get_hex_code_box_size(self, size:'int'   , index:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns size of the replacement character (box with character hexadecimal code that is drawn in place of invalid characters).
			'''

    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(191,tuple([size, index]))
    return _ret


  @functools.native_method
  def draw_hex_code_box(self, canvas:'RID'   , size:'int'   , pos:'Vector2'   , index:'int'   , color:'Color'   ) -> None:
    r'''
				Draws box displaying character hexadecimal code. Used for replacing missing characters.
			'''

    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'











    self._ptr.call_with_return(192,tuple([canvas._ptr, size, pos._ptr, index, color._ptr]))

  @functools.native_method
  def create_shaped_text(self, direction:'int'  =0, orientation:'int'  =0) -> typing.Union['RID']:
    r'''
				Creates a new buffer for complex text layout, with the given `direction` and `orientation`. To free the resulting buffer, use `free_rid` method.
				**Note:** Direction is ignored if server does not support `constant FEATURE_BIDI_LAYOUT` feature (supported by `TextServerAdvanced`).
				**Note:** Orientation is ignored if server does not support `constant FEATURE_VERTICAL_LAYOUT` feature (supported by `TextServerAdvanced`).
			'''



    assert isinstance(direction, (int, float)), 'direction must be int or float'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(193,tuple([direction, orientation]))
    return _ret


  @functools.native_method
  def shaped_text_clear(self, rid:'RID'   ) -> None:
    r'''
				Clears text buffer (removes text and inline objects).
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    self._ptr.call_with_return(194,tuple([rid._ptr]))

  @functools.native_method
  def shaped_text_set_direction(self, shaped:'RID'   , direction:'int'  =0) -> None:
    r'''
				Sets desired text direction. If set to `constant DIRECTION_AUTO`, direction will be detected based on the buffer contents and current locale.
				**Note:** Direction is ignored if server does not support `constant FEATURE_BIDI_LAYOUT` feature (supported by `TextServerAdvanced`).
			'''


    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(direction, (int, float)), 'direction must be int or float'








    self._ptr.call_with_return(195,tuple([shaped._ptr, direction]))

  @functools.native_method
  def shaped_text_get_direction(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns direction of the text.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(196,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_inferred_direction(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns direction of the text, inferred by the BiDi algorithm.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(197,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_set_bidi_override(self, shaped:'RID'   , override:'Array'   ) -> None:
    r'''
				Overrides BiDi for the structured text.
				Override ranges should cover full source text without overlaps. BiDi algorithm will be used on each range separately.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert(not override is None)
    assert isinstance(override, Array), 'override must be Array'








    self._ptr.call_with_return(198,tuple([shaped._ptr, override._ptr]))

  @functools.native_method
  def shaped_text_set_custom_punctuation(self, shaped:'RID'   , punct:'str'   ) -> None:
    r'''
				Sets custom punctuation character list, used for word breaking. If set to empty string, server defaults are used.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert(not punct is None)
    assert isinstance(punct, (str, String)), 'punct must be str or String'






    assert(isinstance(punct, (str, String)))
    py_string_punct = punct if isinstance(punct, StringName) else c_utils.py_string_to_string(punct)

    self._ptr.call_with_return(199,tuple([shaped._ptr, py_string_punct._ptr]))

  @functools.native_method
  def shaped_text_get_custom_punctuation(self, shaped:'RID'   ) -> typing.Union[str]:
    r'''
				Returns custom punctuation character list, used for word breaking. If set to empty string, server defaults are used.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(200,tuple([shaped._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def shaped_text_set_custom_ellipsis(self, shaped:'RID'   , char:'int'   ) -> None:
    r'''
				Sets ellipsis character used for text clipping.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(char, (int, float)), 'char must be int or float'








    self._ptr.call_with_return(201,tuple([shaped._ptr, char]))

  @functools.native_method
  def shaped_text_get_custom_ellipsis(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns ellipsis character used for text clipping.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(202,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_set_orientation(self, shaped:'RID'   , orientation:'int'  =0) -> None:
    r'''
				Sets desired text orientation.
				**Note:** Orientation is ignored if server does not support `constant FEATURE_VERTICAL_LAYOUT` feature (supported by `TextServerAdvanced`).
			'''


    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'








    self._ptr.call_with_return(203,tuple([shaped._ptr, orientation]))

  @functools.native_method
  def shaped_text_get_orientation(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns text orientation.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(204,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_set_preserve_invalid(self, shaped:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If set to `true` text buffer will display invalid characters as hexadecimal codes, otherwise nothing is displayed.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(205,tuple([shaped._ptr, enabled]))

  @functools.native_method
  def shaped_text_get_preserve_invalid(self, shaped:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if text buffer is configured to display hexadecimal codes in place of invalid characters.
				**Note:** If set to `false`, nothing is displayed in place of invalid characters.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(206,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_set_preserve_control(self, shaped:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If set to `true` text buffer will display control characters.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(207,tuple([shaped._ptr, enabled]))

  @functools.native_method
  def shaped_text_get_preserve_control(self, shaped:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if text buffer is configured to display control characters.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(208,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_set_spacing(self, shaped:'RID'   , spacing:'int'  , value:'int'   ) -> None:
    r'''
				Sets extra spacing added between glyphs or lines in pixels.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(spacing, (int, float)), 'spacing must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'









    self._ptr.call_with_return(209,tuple([shaped._ptr, spacing, value]))

  @functools.native_method
  def shaped_text_get_spacing(self, shaped:'RID'   , spacing:'int'  ) -> typing.Union[int]:
    r'''
				Returns extra spacing added between glyphs or lines in pixels.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(spacing, (int, float)), 'spacing must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(210,tuple([shaped._ptr, spacing]))
    return _ret


  @functools.native_method
  def shaped_text_add_string(self, shaped:'RID'   , text:'str'   , fonts:'py4godot_ridtypedarray.RIDTypedArray'   , size:'int'   , opentype_features:'Dictionary' = None  , language:'str' =""  , meta:'object' =None  ) -> typing.Union[bool]:
    r'''
				Adds text span and font to draw it to the text buffer.
			'''
    if opentype_features is None:
      opentype_features = Dictionary.new0()
    if language is None:
      language = String.new0()


    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(fonts, Array), 'fonts must be Array'
    assert isinstance(size, (int, float)), 'size must be int or float'
    

    if not (type(meta).__name__ in py4godot.variant_types.core_types or isinstance(meta, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'meta': "
                f"{type(meta).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)



    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)


    _ret = 0
    _ret = self._ptr.call_with_return(211,tuple([shaped._ptr, py_string_text._ptr, fonts._ptr, size, opentype_features._ptr, py_string_language._ptr, meta]))
    return _ret


  @functools.native_method
  def shaped_text_add_object(self, shaped:'RID'   , key:'object'   , size:'Vector2'   , inline_align:'int'  =5, length:'int' =1  , baseline:'float' =0.0  ) -> typing.Union[bool]:
    r'''
				Adds inline object to the text buffer, `key` must be unique. In the text, object is represented as `length` object replacement characters.
			'''


    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    
    assert(not size is None)
    assert isinstance(size, Vector2), 'size must be Vector2'
    assert isinstance(inline_align, (int, float)), 'inline_align must be int or float'
    assert isinstance(length, (int, float)), 'length must be int or float'
    assert isinstance(baseline, (int, float)), 'baseline must be int or float'

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )











    _ret = 0
    _ret = self._ptr.call_with_return(212,tuple([shaped._ptr, key, size._ptr, inline_align, length, baseline]))
    return _ret


  @functools.native_method
  def shaped_text_resize_object(self, shaped:'RID'   , key:'object'   , size:'Vector2'   , inline_align:'int'  =5, baseline:'float' =0.0  ) -> typing.Union[bool]:
    r'''
				Sets new size and alignment of embedded object.
			'''


    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    
    assert(not size is None)
    assert isinstance(size, Vector2), 'size must be Vector2'
    assert isinstance(inline_align, (int, float)), 'inline_align must be int or float'
    assert isinstance(baseline, (int, float)), 'baseline must be int or float'

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )










    _ret = 0
    _ret = self._ptr.call_with_return(213,tuple([shaped._ptr, key, size._ptr, inline_align, baseline]))
    return _ret


  @functools.native_method
  def shaped_get_text(self, shaped:'RID'   ) -> typing.Union[str]:
    r'''
				Returns the text buffer source text, including object replacement characters.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(214,tuple([shaped._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def shaped_get_span_count(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns number of text spans added using `shaped_text_add_string` or `shaped_text_add_object`.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(215,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_get_span_meta(self, shaped:'RID'   , index:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns text span metadata.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(216,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def shaped_get_span_embedded_object(self, shaped:'RID'   , index:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns text embedded object key.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(217,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def shaped_get_span_text(self, shaped:'RID'   , index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the text span source text.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(218,tuple([shaped._ptr, index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def shaped_get_span_object(self, shaped:'RID'   , index:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the text span embedded object key.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(219,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def shaped_set_span_update_font(self, shaped:'RID'   , index:'int'   , fonts:'py4godot_ridtypedarray.RIDTypedArray'   , size:'int'   , opentype_features:'Dictionary' = None  ) -> None:
    r'''
				Changes text span font, font size, and OpenType features, without changing the text.
			'''
    if opentype_features is None:
      opentype_features = Dictionary.new0()

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(fonts, Array), 'fonts must be Array'
    assert isinstance(size, (int, float)), 'size must be int or float'











    self._ptr.call_with_return(220,tuple([shaped._ptr, index, fonts._ptr, size, opentype_features._ptr]))

  @functools.native_method
  def shaped_get_run_count(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the number of uniform text runs in the buffer.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(221,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_get_run_text(self, shaped:'RID'   , index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the source text of the `index` text run (in visual order).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(222,tuple([shaped._ptr, index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def shaped_get_run_range(self, shaped:'RID'   , index:'int'   ) -> typing.Union['Vector2i']:
    r'''
				Returns the source text range of the `index` text run (in visual order).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(223,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def shaped_get_run_font_rid(self, shaped:'RID'   , index:'int'   ) -> typing.Union['RID']:
    r'''
				Returns the font RID of the `index` text run (in visual order).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(224,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def shaped_get_run_font_size(self, shaped:'RID'   , index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the font size of the `index` text run (in visual order).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(225,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def shaped_get_run_language(self, shaped:'RID'   , index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the language of the `index` text run (in visual order).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(226,tuple([shaped._ptr, index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def shaped_get_run_direction(self, shaped:'RID'   , index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the direction of the `index` text run (in visual order).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret:int
    _ret = self._ptr.call_with_return(227,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def shaped_get_run_object(self, shaped:'RID'   , index:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the embedded object of the `index` text run (in visual order).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(228,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def shaped_text_substr(self, shaped:'RID'   , start:'int'   , length:'int'   ) -> typing.Union['RID']:
    r'''
				Returns text buffer for the substring of the text in the `shaped` text buffer (including inline objects).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(start, (int, float)), 'start must be int or float'
    assert isinstance(length, (int, float)), 'length must be int or float'









    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(229,tuple([shaped._ptr, start, length]))
    return _ret


  @functools.native_method
  def shaped_text_get_parent(self, shaped:'RID'   ) -> typing.Union['RID']:
    r'''
				Returns the parent buffer from which the substring originates.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(230,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_fit_to_width(self, shaped:'RID'   , width:'float'   , justification_flags:'int' =3  ) -> typing.Union[float]:
    r'''
				Adjusts text width to fit to specified width, returns new text width.
			'''


    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'









    _ret = 0
    _ret = self._ptr.call_with_return(231,tuple([shaped._ptr, width, justification_flags]))
    return _ret


  @functools.native_method
  def shaped_text_tab_align(self, shaped:'RID'   , tab_stops:'PackedFloat32Array'   ) -> typing.Union[float]:
    r'''
				Aligns shaped text to the given tab-stops.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert(not tab_stops is None)
    assert isinstance(tab_stops, PackedFloat32Array), 'tab_stops must be PackedFloat32Array'








    _ret = 0
    _ret = self._ptr.call_with_return(232,tuple([shaped._ptr, tab_stops._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_shape(self, shaped:'RID'   ) -> typing.Union[bool]:
    r'''
				Shapes buffer if it's not shaped. Returns `true` if the string is shaped successfully.
				**Note:** It is not necessary to call this function manually, buffer will be shaped automatically as soon as any of its output data is requested.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(233,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_is_ready(self, shaped:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if buffer is successfully shaped.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(234,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_has_visible_chars(self, shaped:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if text buffer contains any visible characters.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(235,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_glyphs(self, shaped:'RID'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns an array of glyphs in the visual order.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(236,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_sort_logical(self, shaped:'RID'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns text glyphs in the logical order.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(237,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_glyph_count(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns number of glyphs in the buffer.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(238,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_range(self, shaped:'RID'   ) -> typing.Union['Vector2i']:
    r'''
				Returns substring buffer character range in the parent buffer.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(239,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_line_breaks_adv(self, shaped:'RID'   , width:'PackedFloat32Array'   , start:'int' =0  , once:'bool' =True  , break_flags:'int' =3  ) -> typing.Union['PackedInt32Array']:
    r'''
				Breaks text to the lines and columns. Returns character ranges for each segment.
			'''


    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert(not width is None)
    assert isinstance(width, PackedFloat32Array), 'width must be PackedFloat32Array'
    assert isinstance(start, (int, float)), 'start must be int or float'
    assert isinstance(once, bool), 'once must be bool'
    assert isinstance(break_flags, (int, float)), 'break_flags must be int or float'











    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(240,tuple([shaped._ptr, width._ptr, start, once, break_flags]))
    return _ret


  @functools.native_method
  def shaped_text_get_line_breaks(self, shaped:'RID'   , width:'float'   , start:'int' =0  , break_flags:'int' =3  ) -> typing.Union['PackedInt32Array']:
    r'''
				Breaks text to the lines and returns character ranges for each line.
			'''


    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(start, (int, float)), 'start must be int or float'
    assert isinstance(break_flags, (int, float)), 'break_flags must be int or float'










    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(241,tuple([shaped._ptr, width, start, break_flags]))
    return _ret


  @functools.native_method
  def shaped_text_get_word_breaks(self, shaped:'RID'   , grapheme_flags:'int' =264  , skip_grapheme_flags:'int' =4  ) -> typing.Union['PackedInt32Array']:
    r'''
				Breaks text into words and returns array of character ranges. Use `grapheme_flags` to set what characters are used for breaking.
			'''



    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(grapheme_flags, (int, float)), 'grapheme_flags must be int or float'
    assert isinstance(skip_grapheme_flags, (int, float)), 'skip_grapheme_flags must be int or float'









    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(242,tuple([shaped._ptr, grapheme_flags, skip_grapheme_flags]))
    return _ret


  @functools.native_method
  def shaped_text_get_trim_pos(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the position of the overrun trim.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(243,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_ellipsis_pos(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns position of the ellipsis.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(244,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_ellipsis_glyphs(self, shaped:'RID'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns array of the glyphs in the ellipsis.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(245,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_ellipsis_glyph_count(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns number of glyphs in the ellipsis.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(246,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_overrun_trim_to_width(self, shaped:'RID'   , width:'float' =0  , overrun_trim_flags:'int' =0  ) -> None:
    r'''
				Trims text if it exceeds the given width.
			'''


    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(overrun_trim_flags, (int, float)), 'overrun_trim_flags must be int or float'









    self._ptr.call_with_return(247,tuple([shaped._ptr, width, overrun_trim_flags]))

  @functools.native_method
  def shaped_text_get_objects(self, shaped:'RID'   ) -> typing.Union['Array']:
    r'''
				Returns array of inline objects.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(248,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_object_rect(self, shaped:'RID'   , key:'object'   ) -> typing.Union['Rect2']:
    r'''
				Returns bounding rectangle of the inline object.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(249,tuple([shaped._ptr, key]))
    return _ret


  @functools.native_method
  def shaped_text_get_object_range(self, shaped:'RID'   , key:'object'   ) -> typing.Union['Vector2i']:
    r'''
				Returns the character range of the inline object.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(250,tuple([shaped._ptr, key]))
    return _ret


  @functools.native_method
  def shaped_text_get_object_glyph(self, shaped:'RID'   , key:'object'   ) -> typing.Union[int]:
    r'''
				Returns the glyph index of the inline object.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = 0
    _ret = self._ptr.call_with_return(251,tuple([shaped._ptr, key]))
    return _ret


  @functools.native_method
  def shaped_text_get_size(self, shaped:'RID'   ) -> typing.Union['Vector2']:
    r'''
				Returns size of the text.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(252,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_ascent(self, shaped:'RID'   ) -> typing.Union[float]:
    r'''
				Returns the text ascent (number of pixels above the baseline for horizontal layout or to the left of baseline for vertical).
				**Note:** Overall ascent can be higher than font ascent, if some glyphs are displaced from the baseline.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(253,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_descent(self, shaped:'RID'   ) -> typing.Union[float]:
    r'''
				Returns the text descent (number of pixels below the baseline for horizontal layout or to the right of baseline for vertical).
				**Note:** Overall descent can be higher than font descent, if some glyphs are displaced from the baseline.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(254,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_width(self, shaped:'RID'   ) -> typing.Union[float]:
    r'''
				Returns width (for horizontal layout) or height (for vertical) of the text.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(255,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_underline_position(self, shaped:'RID'   ) -> typing.Union[float]:
    r'''
				Returns pixel offset of the underline below the baseline.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(256,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_underline_thickness(self, shaped:'RID'   ) -> typing.Union[float]:
    r'''
				Returns thickness of the underline.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(257,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_get_carets(self, shaped:'RID'   , position:'int'   ) -> typing.Union['Dictionary']:
    r'''
				Returns shapes of the carets corresponding to the character offset `position` in the text. Returned caret shape is 1 pixel wide rectangle.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(position, (int, float)), 'position must be int or float'








    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(258,tuple([shaped._ptr, position]))
    return _ret


  @functools.native_method
  def shaped_text_get_selection(self, shaped:'RID'   , start:'int'   , end:'int'   ) -> typing.Union['PackedVector2Array']:
    r'''
				Returns selection rectangles for the specified character range.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(start, (int, float)), 'start must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'









    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(259,tuple([shaped._ptr, start, end]))
    return _ret


  @functools.native_method
  def shaped_text_hit_test_grapheme(self, shaped:'RID'   , coords:'float'   ) -> typing.Union[int]:
    r'''
				Returns grapheme index at the specified pixel offset at the baseline, or `-1` if none is found.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(coords, (int, float)), 'coords must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(260,tuple([shaped._ptr, coords]))
    return _ret


  @functools.native_method
  def shaped_text_hit_test_position(self, shaped:'RID'   , coords:'float'   ) -> typing.Union[int]:
    r'''
				Returns caret character offset at the specified pixel offset at the baseline. This function always returns a valid position.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(coords, (int, float)), 'coords must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(261,tuple([shaped._ptr, coords]))
    return _ret


  @functools.native_method
  def shaped_text_get_grapheme_bounds(self, shaped:'RID'   , pos:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns composite character's bounds as offsets from the start of the line.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(pos, (int, float)), 'pos must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(262,tuple([shaped._ptr, pos]))
    return _ret


  @functools.native_method
  def shaped_text_next_grapheme_pos(self, shaped:'RID'   , pos:'int'   ) -> typing.Union[int]:
    r'''
				Returns grapheme end position closest to the `pos`.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(pos, (int, float)), 'pos must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(263,tuple([shaped._ptr, pos]))
    return _ret


  @functools.native_method
  def shaped_text_prev_grapheme_pos(self, shaped:'RID'   , pos:'int'   ) -> typing.Union[int]:
    r'''
				Returns grapheme start position closest to the `pos`.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(pos, (int, float)), 'pos must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(264,tuple([shaped._ptr, pos]))
    return _ret


  @functools.native_method
  def shaped_text_get_character_breaks(self, shaped:'RID'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns array of the composite character boundaries.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(265,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def shaped_text_next_character_pos(self, shaped:'RID'   , pos:'int'   ) -> typing.Union[int]:
    r'''
				Returns composite character end position closest to the `pos`.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(pos, (int, float)), 'pos must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(266,tuple([shaped._ptr, pos]))
    return _ret


  @functools.native_method
  def shaped_text_prev_character_pos(self, shaped:'RID'   , pos:'int'   ) -> typing.Union[int]:
    r'''
				Returns composite character start position closest to the `pos`.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(pos, (int, float)), 'pos must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(267,tuple([shaped._ptr, pos]))
    return _ret


  @functools.native_method
  def shaped_text_closest_character_pos(self, shaped:'RID'   , pos:'int'   ) -> typing.Union[int]:
    r'''
				Returns composite character position closest to the `pos`.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(pos, (int, float)), 'pos must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(268,tuple([shaped._ptr, pos]))
    return _ret


  @functools.native_method
  def shaped_text_draw(self, shaped:'RID'   , canvas:'RID'   , pos:'Vector2'   , clip_l:'float' =-1  , clip_r:'float' =-1  , color:'Color' = None  , oversampling:'float' =0.0  ) -> None:
    r'''
				Draw shaped text into a canvas item at a given position, with `color`. `pos` specifies the leftmost point of the baseline (for horizontal layout) or topmost point of the baseline (for vertical layout). If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
				`clip_l` and `clip_r` are offsets relative to `pos`, going to the right in horizontal layout and downward in vertical layout. If `clip_l` is not negative, glyphs starting before the offset are clipped. If `clip_r` is not negative, glyphs ending after the offset are clipped.
			'''
    if color is None:
      color = Color.new0()

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(clip_l, (int, float)), 'clip_l must be int or float'
    assert isinstance(clip_r, (int, float)), 'clip_r must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'













    self._ptr.call_with_return(269,tuple([shaped._ptr, canvas._ptr, pos._ptr, clip_l, clip_r, color._ptr, oversampling]))

  @functools.native_method
  def shaped_text_draw_outline(self, shaped:'RID'   , canvas:'RID'   , pos:'Vector2'   , clip_l:'float' =-1  , clip_r:'float' =-1  , outline_size:'int' =1  , color:'Color' = None  , oversampling:'float' =0.0  ) -> None:
    r'''
				Draw the outline of the shaped text into a canvas item at a given position, with `color`. `pos` specifies the leftmost point of the baseline (for horizontal layout) or topmost point of the baseline (for vertical layout). If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
				`clip_l` and `clip_r` are offsets relative to `pos`, going to the right in horizontal layout and downward in vertical layout. If `clip_l` is not negative, glyphs starting before the offset are clipped. If `clip_r` is not negative, glyphs ending after the offset are clipped.
			'''
    if color is None:
      color = Color.new0()

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(clip_l, (int, float)), 'clip_l must be int or float'
    assert isinstance(clip_r, (int, float)), 'clip_r must be int or float'
    assert isinstance(outline_size, (int, float)), 'outline_size must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'














    self._ptr.call_with_return(270,tuple([shaped._ptr, canvas._ptr, pos._ptr, clip_l, clip_r, outline_size, color._ptr, oversampling]))

  @functools.native_method
  def shaped_text_get_dominant_direction_in_range(self, shaped:'RID'   , start:'int'   , end:'int'   ) -> typing.Union[int]:
    r'''
				Returns dominant direction of in the range of text.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(start, (int, float)), 'start must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'









    _ret:int
    _ret = self._ptr.call_with_return(271,tuple([shaped._ptr, start, end]))
    return _ret


  @functools.native_method
  def format_number(self, number:'str'   , language:'str' =""  ) -> typing.Union[str]:
    r'''
				Converts a number from Western Arabic (0..9) to the numeral system used in the given `language`.
				If `language` is an empty string, the active locale will be used.
			'''
    if language is None:
      language = String.new0()

    assert(not number is None)
    assert isinstance(number, (str, String)), 'number must be str or String'





    assert(isinstance(number, (str, String)))
    py_string_number = number if isinstance(number, StringName) else c_utils.py_string_to_string(number)
    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(272,tuple([py_string_number._ptr, py_string_language._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def parse_number(self, number:'str'   , language:'str' =""  ) -> typing.Union[str]:
    r'''
				Converts `number` from the numeral system used in the given `language` to Western Arabic (0..9).
				If `language` is an empty string, the active locale will be used.
			'''
    if language is None:
      language = String.new0()

    assert(not number is None)
    assert isinstance(number, (str, String)), 'number must be str or String'





    assert(isinstance(number, (str, String)))
    py_string_number = number if isinstance(number, StringName) else c_utils.py_string_to_string(number)
    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(273,tuple([py_string_number._ptr, py_string_language._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def percent_sign(self, language:'str' =""  ) -> typing.Union[str]:
    r'''
				Returns the percent sign used in the given `language`.
				If `language` is an empty string, the active locale will be used.
			'''
    if language is None:
      language = String.new0()






    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(274,tuple([py_string_language._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def string_get_word_breaks(self, string:'str'   , language:'str' =""  , chars_per_line:'int' =0  ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns an array of the word break boundaries. Elements in the returned array are the offsets of the start and end of words. Therefore the length of the array is always even.
				When `chars_per_line` is greater than zero, line break boundaries are returned instead.
				```gdscript
				var ts = TextServerManager.get_primary_interface()
				# Corresponds to the substrings "The", "Godot", "Engine", and "4".
				print(ts.string_get_word_breaks("The Godot Engine, 4")) # Prints `0, 3, 4, 9, 10, 16, 18, 19`
				# Corresponds to the substrings "The", "Godot", "Engin", and "e, 4".
				print(ts.string_get_word_breaks("The Godot Engine, 4", "en", 5)) # Prints `0, 3, 4, 9, 10, 15, 15, 19`
				# Corresponds to the substrings "The Godot" and "Engine, 4".
				print(ts.string_get_word_breaks("The Godot Engine, 4", "en", 10)) # Prints `0, 9, 10, 19`
				```
			'''
    if language is None:
      language = String.new0()

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'
    assert isinstance(chars_per_line, (int, float)), 'chars_per_line must be int or float'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)
    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)


    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(275,tuple([py_string_string._ptr, py_string_language._ptr, chars_per_line]))
    return _ret


  @functools.native_method
  def string_get_character_breaks(self, string:'str'   , language:'str' =""  ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns array of the composite character boundaries.
				```gdscript
				var ts = TextServerManager.get_primary_interface()
				print(ts.string_get_character_breaks("Test  Test")) # Prints `1, 2, 3, 4, 5, 9, 10, 11, 12, 13, 14`
				```
			'''
    if language is None:
      language = String.new0()

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)
    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(276,tuple([py_string_string._ptr, py_string_language._ptr]))
    return _ret


  @functools.native_method
  def is_confusable(self, string:'str'   , dict:'PackedStringArray'   ) -> typing.Union[int]:
    r'''
				Returns index of the first string in `dict` which is visually confusable with the `string`, or `-1` if none is found.
				**Note:** This method doesn't detect invisible characters, for spoof detection use it in combination with `spoof_check`.
				**Note:** Always returns `-1` if the server does not support the `constant FEATURE_UNICODE_SECURITY` feature.
			'''

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'
    assert(not dict is None)
    assert isinstance(dict, PackedStringArray), 'dict must be PackedStringArray'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)


    _ret = 0
    _ret = self._ptr.call_with_return(277,tuple([py_string_string._ptr, dict._ptr]))
    return _ret


  @functools.native_method
  def spoof_check(self, string:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if `string` is likely to be an attempt at confusing the reader.
				**Note:** Always returns `false` if the server does not support the `constant FEATURE_UNICODE_SECURITY` feature.
			'''

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)

    _ret = 0
    _ret = self._ptr.call_with_return(278,tuple([py_string_string._ptr]))
    return _ret


  @functools.native_method
  def strip_diacritics(self, string:'str'   ) -> typing.Union[str]:
    r'''
				Strips diacritics from the string.
				**Note:** The result may be longer or shorter than the original.
			'''

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(279,tuple([py_string_string._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def is_valid_identifier(self, string:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if `string` is a valid identifier.
				If the text server supports the `constant FEATURE_UNICODE_IDENTIFIERS` feature, a valid identifier must:
				- Conform to normalization form C.
				- Begin with a Unicode character of class XID_Start or `"_"`.
				- May contain Unicode characters of class XID_Continue in the other positions.
				- Use UAX #31 recommended scripts only (mixed scripts are allowed).
				If the `constant FEATURE_UNICODE_IDENTIFIERS` feature is not supported, a valid identifier must:
				- Begin with a Unicode character of class XID_Start or `"_"`.
				- May contain Unicode characters of class XID_Continue in the other positions.
			'''

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)

    _ret = 0
    _ret = self._ptr.call_with_return(280,tuple([py_string_string._ptr]))
    return _ret


  @functools.native_method
  def is_valid_letter(self, unicode:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given code point is a valid letter, i.e. it belongs to the Unicode category "L".
			'''

    assert isinstance(unicode, (int, float)), 'unicode must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(281,tuple([unicode]))
    return _ret


  @functools.native_method
  def string_to_upper(self, string:'str'   , language:'str' =""  ) -> typing.Union[str]:
    r'''
				Returns the string converted to `UPPERCASE`.
				**Note:** Casing is locale dependent and context sensitive if server support `constant FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION` feature (supported by `TextServerAdvanced`).
				**Note:** The result may be longer or shorter than the original.
			'''
    if language is None:
      language = String.new0()

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)
    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(282,tuple([py_string_string._ptr, py_string_language._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def string_to_lower(self, string:'str'   , language:'str' =""  ) -> typing.Union[str]:
    r'''
				Returns the string converted to `lowercase`.
				**Note:** Casing is locale dependent and context sensitive if server support `constant FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION` feature (supported by `TextServerAdvanced`).
				**Note:** The result may be longer or shorter than the original.
			'''
    if language is None:
      language = String.new0()

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)
    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(283,tuple([py_string_string._ptr, py_string_language._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def string_to_title(self, string:'str'   , language:'str' =""  ) -> typing.Union[str]:
    r'''
				Returns the string converted to `Title Case`.
				**Note:** Casing is locale dependent and context sensitive if server support `constant FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION` feature (supported by `TextServerAdvanced`).
				**Note:** The result may be longer or shorter than the original.
			'''
    if language is None:
      language = String.new0()

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)
    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(284,tuple([py_string_string._ptr, py_string_language._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def parse_structured_text(self, parser_type:'int'  , args:'Array'   , text:'str'   ) -> typing.Union['py4godot_vector3itypedarray.Vector3iTypedArray']:
    r'''
				Default implementation of the BiDi algorithm override function.
			'''

    assert isinstance(parser_type, (int, float)), 'parser_type must be int or float'
    assert(not args is None)
    assert isinstance(args, Array), 'args must be Array'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'







    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = py4godot_vector3itypedarray.Vector3iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(285,tuple([parser_type, args._ptr, py_string_text._ptr]))
    return _ret



register_cast_function('TextServer', TextServer.cast)
register_class('TextServer', TextServer)
