# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ENetMultiplayerPeer as py4godot_enetmultiplayerpeer 
  import py4godot.classes.OfflineMultiplayerPeer as py4godot_offlinemultiplayerpeer 
  import py4godot.classes.WebSocketMultiplayerPeer as py4godot_websocketmultiplayerpeer 
  import py4godot.classes.WebRTCMultiplayerPeer as py4godot_webrtcmultiplayerpeer 
import py4godot.classes.MultiplayerPeer as py4godot_multiplayerpeer 
from py4godot.wrappers.wrappers import CPPMultiplayerPeerExtensionWrapper


class MultiplayerPeerExtension(py4godot_multiplayerpeer.MultiplayerPeer):
  r'''
		This class is designed to be inherited from a GDExtension plugin to implement custom networking layers for the multiplayer API (such as WebRTC). All the methods below **must** be implemented to have a working custom multiplayer implementation. See also `MultiplayerAPI`.
	'''

  @staticmethod
  def constructor():
    class_ = MultiplayerPeerExtension.construct_without_init()
    class_._ptr = constructor(489,0, ())
    return class_
  @staticmethod
  def new():
    class_ = MultiplayerPeerExtension.construct_without_init()
    class_._ptr = constructor(489,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPMultiplayerPeerExtensionWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(489,0, ())


  def generate_wrapper(self):
    return CPPMultiplayerPeerExtensionWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = MultiplayerPeerExtension.__new__(MultiplayerPeerExtension)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'MultiplayerPeerExtension'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(99, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = MultiplayerPeerExtension.construct_without_init()
    cls._ptr = CPPMultiplayerPeerExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = MultiplayerPeerExtension.construct_without_init()
    cls._ptr = CPPMultiplayerPeerExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _get_available_packet_count(self) -> typing.Union[int]:
    r'''
				Called when the available packet count is internally requested by the `MultiplayerAPI`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([]))
    return _ret


  @functools.native_method
  def _get_max_packet_size(self) -> typing.Union[int]:
    r'''
				Called when the maximum allowed packet size (in bytes) is requested by the `MultiplayerAPI`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(79,tuple([]))
    return _ret


  @functools.native_method
  def _get_packet_script(self) -> typing.Union['PackedByteArray']:
    r'''
				Called when a packet needs to be received by the `MultiplayerAPI`, if `_get_packet` isn't implemented. Use this when extending this class via GDScript.
			'''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))
    return _ret


  @functools.native_method
  def _put_packet_script(self, p_buffer:'PackedByteArray'   ) -> typing.Union[int]:
    r'''
				Called when a packet needs to be sent by the `MultiplayerAPI`, if `_put_packet` isn't implemented. Use this when extending this class via GDScript.
			'''

    assert(not p_buffer is None)
    assert isinstance(p_buffer, PackedByteArray), 'p_buffer must be PackedByteArray'







    _ret:int
    _ret = self._ptr.call_with_return(81,tuple([p_buffer._ptr]))
    return _ret


  @functools.native_method
  def _get_packet_channel(self) -> typing.Union[int]:
    r'''
				Called to get the channel over which the next available packet was received. See `MultiplayerPeer.get_packet_channel`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([]))
    return _ret


  @functools.native_method
  def _get_packet_mode(self) -> typing.Union[int]:
    r'''
				Called to get the transfer mode the remote peer used to send the next available packet. See `MultiplayerPeer.get_packet_mode`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(83,tuple([]))
    return _ret


  @functools.native_method
  def _set_transfer_channel(self, p_channel:'int'   ) -> None:
    r'''
				Called when the channel to use is set for this `MultiplayerPeer` (see `MultiplayerPeer.transfer_channel`).
			'''

    assert isinstance(p_channel, (int, float)), 'p_channel must be int or float'







    self._ptr.call_with_return(84,tuple([p_channel]))

  @functools.native_method
  def _get_transfer_channel(self) -> typing.Union[int]:
    r'''
				Called when the transfer channel to use is read on this `MultiplayerPeer` (see `MultiplayerPeer.transfer_channel`).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([]))
    return _ret


  @functools.native_method
  def _set_transfer_mode(self, p_mode:'int'  ) -> None:
    r'''
				Called when the transfer mode is set on this `MultiplayerPeer` (see `MultiplayerPeer.transfer_mode`).
			'''

    assert isinstance(p_mode, (int, float)), 'p_mode must be int or float'







    self._ptr.call_with_return(86,tuple([p_mode]))

  @functools.native_method
  def _get_transfer_mode(self) -> typing.Union[int]:
    r'''
				Called when the transfer mode to use is read on this `MultiplayerPeer` (see `MultiplayerPeer.transfer_mode`).
			'''




    _ret:int
    _ret = self._ptr.call_with_return(87,tuple([]))
    return _ret


  @functools.native_method
  def _set_target_peer(self, p_peer:'int'   ) -> None:
    r'''
				Called when the target peer to use is set for this `MultiplayerPeer` (see `MultiplayerPeer.set_target_peer`).
			'''

    assert isinstance(p_peer, (int, float)), 'p_peer must be int or float'







    self._ptr.call_with_return(88,tuple([p_peer]))

  @functools.native_method
  def _get_packet_peer(self) -> typing.Union[int]:
    r'''
				Called when the ID of the `MultiplayerPeer` who sent the most recent packet is requested (see `MultiplayerPeer.get_packet_peer`).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([]))
    return _ret


  @functools.native_method
  def _is_server(self) -> typing.Union[bool]:
    r'''
				Called when the "is server" status is requested on the `MultiplayerAPI`. See `MultiplayerAPI.is_server`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([]))
    return _ret


  @functools.native_method
  def _poll(self) -> None:
    r'''
				Called when the `MultiplayerAPI` is polled. See `MultiplayerAPI.poll`.
			'''




    self._ptr.call_with_return(91,tuple([]))

  @functools.native_method
  def _close(self) -> None:
    r'''
				Called when the multiplayer peer should be immediately closed (see `MultiplayerPeer.close`).
			'''




    self._ptr.call_with_return(92,tuple([]))

  @functools.native_method
  def _disconnect_peer(self, p_peer:'int'   , p_force:'bool'   ) -> None:
    r'''
				Called when the connected `p_peer` should be forcibly disconnected (see `MultiplayerPeer.disconnect_peer`).
			'''

    assert isinstance(p_peer, (int, float)), 'p_peer must be int or float'
    assert isinstance(p_force, bool), 'p_force must be bool'








    self._ptr.call_with_return(93,tuple([p_peer, p_force]))

  @functools.native_method
  def _get_unique_id(self) -> typing.Union[int]:
    r'''
				Called when the unique ID of this `MultiplayerPeer` is requested (see `MultiplayerPeer.get_unique_id`). The value must be between `1` and `2147483647`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([]))
    return _ret


  @functools.native_method
  def _set_refuse_new_connections(self, p_enable:'bool'   ) -> None:
    r'''
				Called when the "refuse new connections" status is set on this `MultiplayerPeer` (see `MultiplayerPeer.refuse_new_connections`).
			'''

    assert isinstance(p_enable, bool), 'p_enable must be bool'







    self._ptr.call_with_return(95,tuple([p_enable]))

  @functools.native_method
  def _is_refusing_new_connections(self) -> typing.Union[bool]:
    r'''
				Called when the "refuse new connections" status is requested on this `MultiplayerPeer` (see `MultiplayerPeer.refuse_new_connections`).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(96,tuple([]))
    return _ret


  @functools.native_method
  def _is_server_relay_supported(self) -> typing.Union[bool]:
    r'''
				Called to check if the server can act as a relay in the current configuration. See `MultiplayerPeer.is_server_relay_supported`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([]))
    return _ret


  @functools.native_method
  def _get_connection_status(self) -> typing.Union[int]:
    r'''
				Called when the connection status is requested on the `MultiplayerPeer` (see `MultiplayerPeer.get_connection_status`).
			'''




    _ret:int
    _ret = self._ptr.call_with_return(98,tuple([]))
    return _ret



register_cast_function('MultiplayerPeerExtension', MultiplayerPeerExtension.cast)
register_class('MultiplayerPeerExtension', MultiplayerPeerExtension)
