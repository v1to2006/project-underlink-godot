# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.EditorExportPreset as py4godot_editorexportpreset 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.EditorExportPlatform as py4godot_editorexportplatform 
from py4godot.wrappers.wrappers import CPPEditorExportPlatformExtensionWrapper


class EditorExportPlatformExtension(py4godot_editorexportplatform.EditorExportPlatform):
  r'''
		External `EditorExportPlatform` implementations should inherit from this class.
		To use `EditorExportPlatform`, register it using the `EditorPlugin.add_export_platform` method first.
	'''

  @staticmethod
  def constructor():
    class_ = EditorExportPlatformExtension.construct_without_init()
    class_._ptr = constructor(273,0, ())
    return class_
  @staticmethod
  def new():
    class_ = EditorExportPlatformExtension.construct_without_init()
    class_._ptr = constructor(273,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEditorExportPlatformExtensionWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(273,0, ())


  def generate_wrapper(self):
    return CPPEditorExportPlatformExtensionWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = EditorExportPlatformExtension.__new__(EditorExportPlatformExtension)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorExportPlatformExtension'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(113, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorExportPlatformExtension.construct_without_init()
    cls._ptr = CPPEditorExportPlatformExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorExportPlatformExtension.construct_without_init()
    cls._ptr = CPPEditorExportPlatformExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _get_preset_features(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns array of platform specific features for the specified `preset`.
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'







    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([preset._ptr]))
    return _ret


  @functools.native_method
  def _is_executable(self, path:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if specified file is a valid executable (native executable or script) for the target platform.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = 0
    _ret = self._ptr.call_with_return(80,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def _get_export_options(self) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns a property list, as an `Array` of dictionaries. Each `Dictionary` must at least contain the `name: StringName` and `type: Variant.Type` entries.
				Additionally, the following keys are supported:
				- `hint: PropertyHint`
				- `hint_string: String`
				- `usage: PropertyUsageFlags`
				- `class_name: StringName`
				- `default_value: Variant`, default value of the property.
				- `update_visibility: bool`, if set to `true`, `_get_export_option_visibility` is called for each property when this property is changed.
				- `required: bool`, if set to `true`, this property warnings are critical, and should be resolved to make export possible. This value is a hint for the `_has_valid_export_configuration` implementation, and not used by the engine directly.
				See also `Object._get_property_list`.
			'''




    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([]))
    return _ret


  @functools.native_method
  def _should_update_export_options(self) -> typing.Union[bool]:
    r'''
				Returns `true` if export options list is changed and presets should be updated.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([]))
    return _ret


  @functools.native_method
  def _get_export_option_visibility(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , option:'str'   ) -> typing.Union[bool]:
    r'''
				Validates `option` and returns visibility for the specified `preset`. Default implementation return `true` for all options.
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert(not option is None)
    assert isinstance(option, (str, String)), 'option must be str or String'






    assert(isinstance(option, (str, String)))
    py_string_option = option if isinstance(option, StringName) else c_utils.py_string_to_string(option)

    _ret = 0
    _ret = self._ptr.call_with_return(83,tuple([preset._ptr, py_string_option._ptr]))
    return _ret


  @functools.native_method
  def _get_export_option_warning(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , option:'object'   ) -> typing.Union[str]:
    r'''
				Validates `option` and returns warning message for the specified `preset`. Default implementation return empty string for all options.
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert(not option is None)
    assert isinstance(option, (str, StringName)), 'option must be str or StringName'






    assert(isinstance(option, (str, StringName)))
    py_stringname_option = option if isinstance(option, StringName) else c_utils.py_string_to_string_name(option)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(84,tuple([preset._ptr, py_stringname_option._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _get_os_name(self) -> typing.Union[str]:
    r'''
				Returns target OS name.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(85,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _get_name(self) -> typing.Union[str]:
    r'''
				Returns export platform name.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _get_logo(self) -> typing.Any:
    r'''
				Returns the platform logo displayed in the export dialog. The logo should be 32×32 pixels, adjusted for the current editor scale (see `EditorInterface.get_editor_scale`).
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(87,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def _poll_export(self) -> typing.Union[bool]:
    r'''
				Returns `true` if one-click deploy options are changed and editor interface should be updated.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([]))
    return _ret


  @functools.native_method
  def _get_options_count(self) -> typing.Union[int]:
    r'''
				Returns the number of devices (or other options) available in the one-click deploy menu.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([]))
    return _ret


  @functools.native_method
  def _get_options_tooltip(self) -> typing.Union[str]:
    r'''
				Returns tooltip of the one-click deploy menu button.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(90,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _get_option_icon(self, device:'int'   ) -> typing.Any:
    r'''
				Returns the item icon for the specified `device` in the one-click deploy menu. The icon should be 16×16 pixels, adjusted for the current editor scale (see `EditorInterface.get_editor_scale`).
			'''

    assert isinstance(device, (int, float)), 'device must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(91,tuple([device]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def _get_option_label(self, device:'int'   ) -> typing.Union[str]:
    r'''
				Returns one-click deploy menu item label for the specified `device`.
			'''

    assert isinstance(device, (int, float)), 'device must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(92,tuple([device]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _get_option_tooltip(self, device:'int'   ) -> typing.Union[str]:
    r'''
				Returns one-click deploy menu item tooltip for the specified `device`.
			'''

    assert isinstance(device, (int, float)), 'device must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(93,tuple([device]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _get_device_architecture(self, device:'int'   ) -> typing.Union[str]:
    r'''
				Returns device architecture for one-click deploy.
			'''

    assert isinstance(device, (int, float)), 'device must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(94,tuple([device]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _cleanup(self) -> None:
    r'''
				Called by the editor before platform is unregistered.
			'''




    self._ptr.call_with_return(95,tuple([]))

  @functools.native_method
  def _run(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , device:'int'   , debug_flags:'int'   ) -> typing.Union[int]:
    r'''
				This method is called when `device` one-click deploy menu option is selected.
				Implementation should export project to a temporary location, upload and run it on the specific `device`, or perform another action associated with the menu item.
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(device, (int, float)), 'device must be int or float'
    assert isinstance(debug_flags, (int, float)), 'debug_flags must be int or float'









    _ret:int
    _ret = self._ptr.call_with_return(96,tuple([preset._ptr, device, debug_flags]))
    return _ret


  @functools.native_method
  def _get_run_icon(self) -> typing.Any:
    r'''
				Returns the icon of the one-click deploy menu button. The icon should be 16×16 pixels, adjusted for the current editor scale (see `EditorInterface.get_editor_scale`).
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(97,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def _can_export(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified `preset` is valid and can be exported. Use `set_config_error` and `set_config_missing_templates` to set error details.
				Usual implementations call `_has_valid_export_configuration` and `_has_valid_project_configuration` to determine if exporting is possible.
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(98,tuple([preset._ptr, debug]))
    return _ret


  @functools.native_method
  def _has_valid_export_configuration(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if export configuration is valid.
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([preset._ptr, debug]))
    return _ret


  @functools.native_method
  def _has_valid_project_configuration(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if project configuration is valid.
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'







    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([preset._ptr]))
    return _ret


  @functools.native_method
  def _get_binary_extensions(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns array of supported binary extensions for the full project export.
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'







    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(101,tuple([preset._ptr]))
    return _ret


  @functools.native_method
  def _export_project(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , path:'str'   , flags:'int'   ) -> typing.Union[int]:
    r'''
				Creates a full project at `path` for the specified `preset`.
				This method is called when "Export" button is pressed in the export dialog.
				This method implementation can call `EditorExportPlatform.save_pack` or `EditorExportPlatform.save_zip` to use default PCK/ZIP export process, or calls `EditorExportPlatform.export_project_files` and implement custom callback for processing each exported file.
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(flags, (int, float)), 'flags must be int or float'







    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)


    _ret:int
    _ret = self._ptr.call_with_return(102,tuple([preset._ptr, debug, py_string_path._ptr, flags]))
    return _ret


  @functools.native_method
  def _export_pack(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , path:'str'   , flags:'int'   ) -> typing.Union[int]:
    r'''
				Creates a PCK archive at `path` for the specified `preset`.
				This method is called when "Export PCK/ZIP" button is pressed in the export dialog, with "Export as Patch" disabled, and PCK is selected as a file type.
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(flags, (int, float)), 'flags must be int or float'







    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)


    _ret:int
    _ret = self._ptr.call_with_return(103,tuple([preset._ptr, debug, py_string_path._ptr, flags]))
    return _ret


  @functools.native_method
  def _export_zip(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , path:'str'   , flags:'int'   ) -> typing.Union[int]:
    r'''
				Create a ZIP archive at `path` for the specified `preset`.
				This method is called when "Export PCK/ZIP" button is pressed in the export dialog, with "Export as Patch" disabled, and ZIP is selected as a file type.
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(flags, (int, float)), 'flags must be int or float'







    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)


    _ret:int
    _ret = self._ptr.call_with_return(104,tuple([preset._ptr, debug, py_string_path._ptr, flags]))
    return _ret


  @functools.native_method
  def _export_pack_patch(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , path:'str'   , patches:'PackedStringArray'   , flags:'int'   ) -> typing.Union[int]:
    r'''
				Creates a patch PCK archive at `path` for the specified `preset`, containing only the files that have changed since the last patch.
				This method is called when "Export PCK/ZIP" button is pressed in the export dialog, with "Export as Patch" enabled, and PCK is selected as a file type.
				**Note:** The patches provided in `patches` have already been loaded when this method is called and are merely provided as context. When empty the patches defined in the export preset have been loaded instead.
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert(not patches is None)
    assert isinstance(patches, PackedStringArray), 'patches must be PackedStringArray'
    assert isinstance(flags, (int, float)), 'flags must be int or float'







    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)



    _ret:int
    _ret = self._ptr.call_with_return(105,tuple([preset._ptr, debug, py_string_path._ptr, patches._ptr, flags]))
    return _ret


  @functools.native_method
  def _export_zip_patch(self, preset:'py4godot_editorexportpreset.EditorExportPreset'   , debug:'bool'   , path:'str'   , patches:'PackedStringArray'   , flags:'int'   ) -> typing.Union[int]:
    r'''
				Create a ZIP archive at `path` for the specified `preset`, containing only the files that have changed since the last patch.
				This method is called when "Export PCK/ZIP" button is pressed in the export dialog, with "Export as Patch" enabled, and ZIP is selected as a file type.
				**Note:** The patches provided in `patches` have already been loaded when this method is called and are merely provided as context. When empty the patches defined in the export preset have been loaded instead.
			'''

    assert(not preset is None)
    assert isinstance(preset, get_class('EditorExportPreset')), 'preset must be EditorExportPreset'
    assert isinstance(debug, bool), 'debug must be bool'
    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert(not patches is None)
    assert isinstance(patches, PackedStringArray), 'patches must be PackedStringArray'
    assert isinstance(flags, (int, float)), 'flags must be int or float'







    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)



    _ret:int
    _ret = self._ptr.call_with_return(106,tuple([preset._ptr, debug, py_string_path._ptr, patches._ptr, flags]))
    return _ret


  @functools.native_method
  def _get_platform_features(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns array of platform specific features.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(107,tuple([]))
    return _ret


  @functools.native_method
  def _get_debug_protocol(self) -> typing.Union[str]:
    r'''
				Returns protocol used for remote debugging. Default implementation return `tcp://`.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(108,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_config_error(self, error_text:'str'   ) -> None:
    r'''
				Sets current configuration error message text. This method should be called only from the `_can_export`, `_has_valid_export_configuration`, or `_has_valid_project_configuration` implementations.
			'''

    assert(not error_text is None)
    assert isinstance(error_text, (str, String)), 'error_text must be str or String'





    assert(isinstance(error_text, (str, String)))
    py_string_error_text = error_text if isinstance(error_text, StringName) else c_utils.py_string_to_string(error_text)

    self._ptr.call_with_return(109,tuple([py_string_error_text._ptr]))

  @functools.native_method
  def get_config_error(self) -> typing.Union[str]:
    r'''
				Returns current configuration error message text. This method should be called only from the `_can_export`, `_has_valid_export_configuration`, or `_has_valid_project_configuration` implementations.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(110,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_config_missing_templates(self, missing_templates:'bool'   ) -> None:
    r'''
				Set to `true` is export templates are missing from the current configuration. This method should be called only from the `_can_export`, `_has_valid_export_configuration`, or `_has_valid_project_configuration` implementations.
			'''

    assert isinstance(missing_templates, bool), 'missing_templates must be bool'







    self._ptr.call_with_return(111,tuple([missing_templates]))

  @functools.native_method
  def get_config_missing_templates(self) -> typing.Union[bool]:
    r'''
				Returns `true` is export templates are missing from the current configuration. This method should be called only from the `_can_export`, `_has_valid_export_configuration`, or `_has_valid_project_configuration` implementations.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(112,tuple([]))
    return _ret



register_cast_function('EditorExportPlatformExtension', EditorExportPlatformExtension.cast)
register_class('EditorExportPlatformExtension', EditorExportPlatformExtension)
