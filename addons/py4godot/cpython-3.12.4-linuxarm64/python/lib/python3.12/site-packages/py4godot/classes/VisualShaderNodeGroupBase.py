# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.VisualShaderNodeResizableBase as py4godot_visualshadernoderesizablebase 
from py4godot.wrappers.wrappers import CPPVisualShaderNodeGroupBaseWrapper


class VisualShaderNodeGroupBase(py4godot_visualshadernoderesizablebase.VisualShaderNodeResizableBase):
  r'''
		Currently, has no direct usage, use the derived classes instead.
	'''

  @staticmethod
  def constructor():
    class_ = VisualShaderNodeGroupBase.construct_without_init()
    class_._ptr = constructor(910,0, ())
    return class_
  @staticmethod
  def new():
    class_ = VisualShaderNodeGroupBase.construct_without_init()
    class_._ptr = constructor(910,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPVisualShaderNodeGroupBaseWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(910,0, ())


  def generate_wrapper(self):
    return CPPVisualShaderNodeGroupBaseWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = VisualShaderNodeGroupBase.__new__(VisualShaderNodeGroupBase)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'VisualShaderNodeGroupBase'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(111, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = VisualShaderNodeGroupBase.construct_without_init()
    cls._ptr = CPPVisualShaderNodeGroupBaseWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = VisualShaderNodeGroupBase.construct_without_init()
    cls._ptr = CPPVisualShaderNodeGroupBaseWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def set_inputs(self, inputs:'str'   ) -> None:
    r'''
				Defines all input ports using a `String` formatted as a colon-separated list: `id,type,name;` (see `add_input_port`).
			'''

    assert(not inputs is None)
    assert isinstance(inputs, (str, String)), 'inputs must be str or String'





    assert(isinstance(inputs, (str, String)))
    py_string_inputs = inputs if isinstance(inputs, StringName) else c_utils.py_string_to_string(inputs)

    self._ptr.call_with_return(90,tuple([py_string_inputs._ptr]))

  @functools.native_method
  def get_inputs(self) -> typing.Union[str]:
    r'''
				Returns a `String` description of the input ports as a colon-separated list using the format `id,type,name;` (see `add_input_port`).
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_outputs(self, outputs:'str'   ) -> None:
    r'''
				Defines all output ports using a `String` formatted as a colon-separated list: `id,type,name;` (see `add_output_port`).
			'''

    assert(not outputs is None)
    assert isinstance(outputs, (str, String)), 'outputs must be str or String'





    assert(isinstance(outputs, (str, String)))
    py_string_outputs = outputs if isinstance(outputs, StringName) else c_utils.py_string_to_string(outputs)

    self._ptr.call_with_return(92,tuple([py_string_outputs._ptr]))

  @functools.native_method
  def get_outputs(self) -> typing.Union[str]:
    r'''
				Returns a `String` description of the output ports as a colon-separated list using the format `id,type,name;` (see `add_output_port`).
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(93,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def is_valid_port_name(self, name:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified port name does not override an existed port name and is valid within the shader.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def add_input_port(self, id:'int'   , type:'int'   , name:'str'   ) -> None:
    r'''
				Adds an input port with the specified `type` (see `enum VisualShaderNode.PortType`) and `name`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(type, (int, float)), 'type must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'







    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(95,tuple([id, type, py_string_name._ptr]))

  @functools.native_method
  def remove_input_port(self, id:'int'   ) -> None:
    r'''
				Removes the specified input port.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    self._ptr.call_with_return(96,tuple([id]))

  @functools.native_method
  def get_input_port_count(self) -> typing.Union[int]:
    r'''
				Returns the number of input ports in use. Alternative for `get_free_input_port_id`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([]))
    return _ret


  @functools.native_method
  def has_input_port(self, id:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified input port exists.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(98,tuple([id]))
    return _ret


  @functools.native_method
  def clear_input_ports(self) -> None:
    r'''
				Removes all previously specified input ports.
			'''




    self._ptr.call_with_return(99,tuple([]))

  @functools.native_method
  def add_output_port(self, id:'int'   , type:'int'   , name:'str'   ) -> None:
    r'''
				Adds an output port with the specified `type` (see `enum VisualShaderNode.PortType`) and `name`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(type, (int, float)), 'type must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'







    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(100,tuple([id, type, py_string_name._ptr]))

  @functools.native_method
  def remove_output_port(self, id:'int'   ) -> None:
    r'''
				Removes the specified output port.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    self._ptr.call_with_return(101,tuple([id]))

  @functools.native_method
  def get_output_port_count(self) -> typing.Union[int]:
    r'''
				Returns the number of output ports in use. Alternative for `get_free_output_port_id`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([]))
    return _ret


  @functools.native_method
  def has_output_port(self, id:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified output port exists.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([id]))
    return _ret


  @functools.native_method
  def clear_output_ports(self) -> None:
    r'''
				Removes all previously specified output ports.
			'''




    self._ptr.call_with_return(104,tuple([]))

  @functools.native_method
  def set_input_port_name(self, id:'int'   , name:'str'   ) -> None:
    r'''
				Renames the specified input port.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(105,tuple([id, py_string_name._ptr]))

  @functools.native_method
  def set_input_port_type(self, id:'int'   , type:'int'   ) -> None:
    r'''
				Sets the specified input port's type (see `enum VisualShaderNode.PortType`).
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(type, (int, float)), 'type must be int or float'








    self._ptr.call_with_return(106,tuple([id, type]))

  @functools.native_method
  def set_output_port_name(self, id:'int'   , name:'str'   ) -> None:
    r'''
				Renames the specified output port.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(107,tuple([id, py_string_name._ptr]))

  @functools.native_method
  def set_output_port_type(self, id:'int'   , type:'int'   ) -> None:
    r'''
				Sets the specified output port's type (see `enum VisualShaderNode.PortType`).
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(type, (int, float)), 'type must be int or float'








    self._ptr.call_with_return(108,tuple([id, type]))

  @functools.native_method
  def get_free_input_port_id(self) -> typing.Union[int]:
    r'''
				Returns a free input port ID which can be used in `add_input_port`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(109,tuple([]))
    return _ret


  @functools.native_method
  def get_free_output_port_id(self) -> typing.Union[int]:
    r'''
				Returns a free output port ID which can be used in `add_output_port`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(110,tuple([]))
    return _ret



register_cast_function('VisualShaderNodeGroupBase', VisualShaderNodeGroupBase.cast)
register_class('VisualShaderNodeGroupBase', VisualShaderNodeGroupBase)
