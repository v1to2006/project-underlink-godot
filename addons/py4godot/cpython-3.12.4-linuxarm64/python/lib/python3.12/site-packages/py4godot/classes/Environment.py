# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.Texture2DArrayRD as py4godot_texture2darrayrd 
  import py4godot.classes.PlaceholderTexture2DArray as py4godot_placeholdertexture2darray 
  import py4godot.classes.CubemapArray as py4godot_cubemaparray 
  import py4godot.classes.Cubemap as py4godot_cubemap 
  import py4godot.classes.Texture as py4godot_texture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.Sky as py4godot_sky 
  import py4godot.classes.CompressedCubemap as py4godot_compressedcubemap 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.CompressedCubemapArray as py4godot_compressedcubemaparray 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.CompressedTexture3D as py4godot_compressedtexture3d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.TextureLayeredRD as py4godot_texturelayeredrd 
  import py4godot.classes.PlaceholderCubemap as py4godot_placeholdercubemap 
  import py4godot.classes.PlaceholderTextureLayered as py4godot_placeholdertexturelayered 
  import py4godot.classes.CompressedTextureLayered as py4godot_compressedtexturelayered 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.PlaceholderCubemapArray as py4godot_placeholdercubemaparray 
  import py4godot.classes.Texture3DRD as py4godot_texture3drd 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.TextureLayered as py4godot_texturelayered 
  import py4godot.classes.TextureCubemapArrayRD as py4godot_texturecubemaparrayrd 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.CompressedTexture2DArray as py4godot_compressedtexture2darray 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.NoiseTexture3D as py4godot_noisetexture3d 
  import py4godot.classes.ImageTextureLayered as py4godot_imagetexturelayered 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.PlaceholderTexture3D as py4godot_placeholdertexture3d 
  import py4godot.classes.ImageTexture3D as py4godot_imagetexture3d 
  import py4godot.classes.TextureCubemapRD as py4godot_texturecubemaprd 
  import py4godot.classes.Texture3D as py4godot_texture3d 
  import py4godot.classes.Texture2DArray as py4godot_texture2darray 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPEnvironmentWrapper

class BGMode:
  BG_CLEAR_COLOR = 0
  BG_COLOR = 1
  BG_SKY = 2
  BG_CANVAS = 3
  BG_KEEP = 4
  BG_CAMERA_FEED = 5
  BG_MAX = 6
class AmbientSource:
  AMBIENT_SOURCE_BG = 0
  AMBIENT_SOURCE_DISABLED = 1
  AMBIENT_SOURCE_COLOR = 2
  AMBIENT_SOURCE_SKY = 3
class ReflectionSource:
  REFLECTION_SOURCE_BG = 0
  REFLECTION_SOURCE_DISABLED = 1
  REFLECTION_SOURCE_SKY = 2
class ToneMapper:
  TONE_MAPPER_LINEAR = 0
  TONE_MAPPER_REINHARDT = 1
  TONE_MAPPER_FILMIC = 2
  TONE_MAPPER_ACES = 3
  TONE_MAPPER_AGX = 4
class GlowBlendMode:
  GLOW_BLEND_MODE_ADDITIVE = 0
  GLOW_BLEND_MODE_SCREEN = 1
  GLOW_BLEND_MODE_SOFTLIGHT = 2
  GLOW_BLEND_MODE_REPLACE = 3
  GLOW_BLEND_MODE_MIX = 4
class FogMode:
  FOG_MODE_EXPONENTIAL = 0
  FOG_MODE_DEPTH = 1
class SDFGIYScale:
  SDFGI_Y_SCALE_50_PERCENT = 0
  SDFGI_Y_SCALE_75_PERCENT = 1
  SDFGI_Y_SCALE_100_PERCENT = 2


class Environment(py4godot_resource.Resource):
  r'''
		Resource for environment nodes (like `WorldEnvironment`) that define multiple environment operations (such as background `Sky` or `Color`, ambient light, fog, depth-of-field...). These parameters affect the final render of the scene. The order of these operations is:
		- Depth of Field Blur
		- Auto Exposure
		- Glow
		- Tonemap
		- Adjustments
	'''

  @staticmethod
  def constructor():
    class_ = Environment.construct_without_init()
    class_._ptr = constructor(323,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Environment.construct_without_init()
    class_._ptr = constructor(323,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEnvironmentWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(323,0, ())


  def generate_wrapper(self):
    return CPPEnvironmentWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Environment.__new__(Environment)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Environment'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(261, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Environment.construct_without_init()
    cls._ptr = CPPEnvironmentWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Environment.construct_without_init()
    cls._ptr = CPPEnvironmentWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def background_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_background()
    return _ret
  @background_mode.setter
  def background_mode(self,  value:'int'):
    self.set_background(value)
  @property
  def background_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_bg_color()
    return _ret
  @background_color.setter
  def background_color(self,  value:'Color'):
    self.set_bg_color(value)
  @property
  def background_energy_multiplier(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_bg_energy_multiplier()
    return _ret
  @background_energy_multiplier.setter
  def background_energy_multiplier(self,  value:'float'):
    self.set_bg_energy_multiplier(value)
  @property
  def background_intensity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_bg_intensity()
    return _ret
  @background_intensity.setter
  def background_intensity(self,  value:'float'):
    self.set_bg_intensity(value)
  @property
  def background_canvas_max_layer(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_canvas_max_layer()
    return _ret
  @background_canvas_max_layer.setter
  def background_canvas_max_layer(self,  value:'int'):
    self.set_canvas_max_layer(value)
  @property
  def background_camera_feed_id(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_camera_feed_id()
    return _ret
  @background_camera_feed_id.setter
  def background_camera_feed_id(self,  value:'int'):
    self.set_camera_feed_id(value)
  @property
  def sky(self) -> typing.Union['py4godot_sky.Sky']:
    r''''''
    _ret = self. get_sky()
    return _ret
  @sky.setter
  def sky(self,  value:'py4godot_object.Object'):
    self.set_sky(value)
  @property
  def sky_custom_fov(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_sky_custom_fov()
    return _ret
  @sky_custom_fov.setter
  def sky_custom_fov(self,  value:'float'):
    self.set_sky_custom_fov(value)
  @property
  def sky_rotation(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_sky_rotation()
    return _ret
  @sky_rotation.setter
  def sky_rotation(self,  value:'Vector3'):
    self.set_sky_rotation(value)
  @property
  def ambient_light_source(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_ambient_source()
    return _ret
  @ambient_light_source.setter
  def ambient_light_source(self,  value:'int'):
    self.set_ambient_source(value)
  @property
  def ambient_light_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_ambient_light_color()
    return _ret
  @ambient_light_color.setter
  def ambient_light_color(self,  value:'Color'):
    self.set_ambient_light_color(value)
  @property
  def ambient_light_sky_contribution(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ambient_light_sky_contribution()
    return _ret
  @ambient_light_sky_contribution.setter
  def ambient_light_sky_contribution(self,  value:'float'):
    self.set_ambient_light_sky_contribution(value)
  @property
  def ambient_light_energy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ambient_light_energy()
    return _ret
  @ambient_light_energy.setter
  def ambient_light_energy(self,  value:'float'):
    self.set_ambient_light_energy(value)
  @property
  def reflected_light_source(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_reflection_source()
    return _ret
  @reflected_light_source.setter
  def reflected_light_source(self,  value:'int'):
    self.set_reflection_source(value)
  @property
  def tonemap_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tonemapper()
    return _ret
  @tonemap_mode.setter
  def tonemap_mode(self,  value:'int'):
    self.set_tonemapper(value)
  @property
  def tonemap_exposure(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_tonemap_exposure()
    return _ret
  @tonemap_exposure.setter
  def tonemap_exposure(self,  value:'float'):
    self.set_tonemap_exposure(value)
  @property
  def tonemap_white(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_tonemap_white()
    return _ret
  @tonemap_white.setter
  def tonemap_white(self,  value:'float'):
    self.set_tonemap_white(value)
  @property
  def ssr_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_ssr_enabled()
    return _ret
  @ssr_enabled.setter
  def ssr_enabled(self,  value:'bool'):
    self.set_ssr_enabled(value)
  @property
  def ssr_max_steps(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_ssr_max_steps()
    return _ret
  @ssr_max_steps.setter
  def ssr_max_steps(self,  value:'int'):
    self.set_ssr_max_steps(value)
  @property
  def ssr_fade_in(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssr_fade_in()
    return _ret
  @ssr_fade_in.setter
  def ssr_fade_in(self,  value:'float'):
    self.set_ssr_fade_in(value)
  @property
  def ssr_fade_out(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssr_fade_out()
    return _ret
  @ssr_fade_out.setter
  def ssr_fade_out(self,  value:'float'):
    self.set_ssr_fade_out(value)
  @property
  def ssr_depth_tolerance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssr_depth_tolerance()
    return _ret
  @ssr_depth_tolerance.setter
  def ssr_depth_tolerance(self,  value:'float'):
    self.set_ssr_depth_tolerance(value)
  @property
  def ssao_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_ssao_enabled()
    return _ret
  @ssao_enabled.setter
  def ssao_enabled(self,  value:'bool'):
    self.set_ssao_enabled(value)
  @property
  def ssao_radius(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssao_radius()
    return _ret
  @ssao_radius.setter
  def ssao_radius(self,  value:'float'):
    self.set_ssao_radius(value)
  @property
  def ssao_intensity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssao_intensity()
    return _ret
  @ssao_intensity.setter
  def ssao_intensity(self,  value:'float'):
    self.set_ssao_intensity(value)
  @property
  def ssao_power(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssao_power()
    return _ret
  @ssao_power.setter
  def ssao_power(self,  value:'float'):
    self.set_ssao_power(value)
  @property
  def ssao_detail(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssao_detail()
    return _ret
  @ssao_detail.setter
  def ssao_detail(self,  value:'float'):
    self.set_ssao_detail(value)
  @property
  def ssao_horizon(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssao_horizon()
    return _ret
  @ssao_horizon.setter
  def ssao_horizon(self,  value:'float'):
    self.set_ssao_horizon(value)
  @property
  def ssao_sharpness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssao_sharpness()
    return _ret
  @ssao_sharpness.setter
  def ssao_sharpness(self,  value:'float'):
    self.set_ssao_sharpness(value)
  @property
  def ssao_light_affect(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssao_direct_light_affect()
    return _ret
  @ssao_light_affect.setter
  def ssao_light_affect(self,  value:'float'):
    self.set_ssao_direct_light_affect(value)
  @property
  def ssao_ao_channel_affect(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssao_ao_channel_affect()
    return _ret
  @ssao_ao_channel_affect.setter
  def ssao_ao_channel_affect(self,  value:'float'):
    self.set_ssao_ao_channel_affect(value)
  @property
  def ssil_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_ssil_enabled()
    return _ret
  @ssil_enabled.setter
  def ssil_enabled(self,  value:'bool'):
    self.set_ssil_enabled(value)
  @property
  def ssil_radius(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssil_radius()
    return _ret
  @ssil_radius.setter
  def ssil_radius(self,  value:'float'):
    self.set_ssil_radius(value)
  @property
  def ssil_intensity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssil_intensity()
    return _ret
  @ssil_intensity.setter
  def ssil_intensity(self,  value:'float'):
    self.set_ssil_intensity(value)
  @property
  def ssil_sharpness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssil_sharpness()
    return _ret
  @ssil_sharpness.setter
  def ssil_sharpness(self,  value:'float'):
    self.set_ssil_sharpness(value)
  @property
  def ssil_normal_rejection(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ssil_normal_rejection()
    return _ret
  @ssil_normal_rejection.setter
  def ssil_normal_rejection(self,  value:'float'):
    self.set_ssil_normal_rejection(value)
  @property
  def sdfgi_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_sdfgi_enabled()
    return _ret
  @sdfgi_enabled.setter
  def sdfgi_enabled(self,  value:'bool'):
    self.set_sdfgi_enabled(value)
  @property
  def sdfgi_use_occlusion(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_sdfgi_using_occlusion()
    return _ret
  @sdfgi_use_occlusion.setter
  def sdfgi_use_occlusion(self,  value:'bool'):
    self.set_sdfgi_use_occlusion(value)
  @property
  def sdfgi_read_sky_light(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_sdfgi_reading_sky_light()
    return _ret
  @sdfgi_read_sky_light.setter
  def sdfgi_read_sky_light(self,  value:'bool'):
    self.set_sdfgi_read_sky_light(value)
  @property
  def sdfgi_bounce_feedback(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_sdfgi_bounce_feedback()
    return _ret
  @sdfgi_bounce_feedback.setter
  def sdfgi_bounce_feedback(self,  value:'float'):
    self.set_sdfgi_bounce_feedback(value)
  @property
  def sdfgi_cascades(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_sdfgi_cascades()
    return _ret
  @sdfgi_cascades.setter
  def sdfgi_cascades(self,  value:'int'):
    self.set_sdfgi_cascades(value)
  @property
  def sdfgi_min_cell_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_sdfgi_min_cell_size()
    return _ret
  @sdfgi_min_cell_size.setter
  def sdfgi_min_cell_size(self,  value:'float'):
    self.set_sdfgi_min_cell_size(value)
  @property
  def sdfgi_cascade0_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_sdfgi_cascade0_distance()
    return _ret
  @sdfgi_cascade0_distance.setter
  def sdfgi_cascade0_distance(self,  value:'float'):
    self.set_sdfgi_cascade0_distance(value)
  @property
  def sdfgi_max_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_sdfgi_max_distance()
    return _ret
  @sdfgi_max_distance.setter
  def sdfgi_max_distance(self,  value:'float'):
    self.set_sdfgi_max_distance(value)
  @property
  def sdfgi_y_scale(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_sdfgi_y_scale()
    return _ret
  @sdfgi_y_scale.setter
  def sdfgi_y_scale(self,  value:'int'):
    self.set_sdfgi_y_scale(value)
  @property
  def sdfgi_energy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_sdfgi_energy()
    return _ret
  @sdfgi_energy.setter
  def sdfgi_energy(self,  value:'float'):
    self.set_sdfgi_energy(value)
  @property
  def sdfgi_normal_bias(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_sdfgi_normal_bias()
    return _ret
  @sdfgi_normal_bias.setter
  def sdfgi_normal_bias(self,  value:'float'):
    self.set_sdfgi_normal_bias(value)
  @property
  def sdfgi_probe_bias(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_sdfgi_probe_bias()
    return _ret
  @sdfgi_probe_bias.setter
  def sdfgi_probe_bias(self,  value:'float'):
    self.set_sdfgi_probe_bias(value)
  @property
  def glow_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_glow_enabled()
    return _ret
  @glow_enabled.setter
  def glow_enabled(self,  value:'bool'):
    self.set_glow_enabled(value)
  @property
  def glow_normalized(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_glow_normalized()
    return _ret
  @glow_normalized.setter
  def glow_normalized(self,  value:'bool'):
    self.set_glow_normalized(value)
  @property
  def glow_intensity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_glow_intensity()
    return _ret
  @glow_intensity.setter
  def glow_intensity(self,  value:'float'):
    self.set_glow_intensity(value)
  @property
  def glow_strength(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_glow_strength()
    return _ret
  @glow_strength.setter
  def glow_strength(self,  value:'float'):
    self.set_glow_strength(value)
  @property
  def glow_mix(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_glow_mix()
    return _ret
  @glow_mix.setter
  def glow_mix(self,  value:'float'):
    self.set_glow_mix(value)
  @property
  def glow_bloom(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_glow_bloom()
    return _ret
  @glow_bloom.setter
  def glow_bloom(self,  value:'float'):
    self.set_glow_bloom(value)
  @property
  def glow_blend_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_glow_blend_mode()
    return _ret
  @glow_blend_mode.setter
  def glow_blend_mode(self,  value:'int'):
    self.set_glow_blend_mode(value)
  @property
  def glow_hdr_threshold(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_glow_hdr_bleed_threshold()
    return _ret
  @glow_hdr_threshold.setter
  def glow_hdr_threshold(self,  value:'float'):
    self.set_glow_hdr_bleed_threshold(value)
  @property
  def glow_hdr_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_glow_hdr_bleed_scale()
    return _ret
  @glow_hdr_scale.setter
  def glow_hdr_scale(self,  value:'float'):
    self.set_glow_hdr_bleed_scale(value)
  @property
  def glow_hdr_luminance_cap(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_glow_hdr_luminance_cap()
    return _ret
  @glow_hdr_luminance_cap.setter
  def glow_hdr_luminance_cap(self,  value:'float'):
    self.set_glow_hdr_luminance_cap(value)
  @property
  def glow_map_strength(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_glow_map_strength()
    return _ret
  @glow_map_strength.setter
  def glow_map_strength(self,  value:'float'):
    self.set_glow_map_strength(value)
  @property
  def glow_map(self) -> typing.Any:
    r''''''
    _ret = self. get_glow_map()
    return _ret
  @glow_map.setter
  def glow_map(self,  value:'py4godot_object.Object'):
    self.set_glow_map(value)
  @property
  def fog_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_fog_enabled()
    return _ret
  @fog_enabled.setter
  def fog_enabled(self,  value:'bool'):
    self.set_fog_enabled(value)
  @property
  def fog_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_fog_mode()
    return _ret
  @fog_mode.setter
  def fog_mode(self,  value:'int'):
    self.set_fog_mode(value)
  @property
  def fog_light_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_fog_light_color()
    return _ret
  @fog_light_color.setter
  def fog_light_color(self,  value:'Color'):
    self.set_fog_light_color(value)
  @property
  def fog_light_energy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fog_light_energy()
    return _ret
  @fog_light_energy.setter
  def fog_light_energy(self,  value:'float'):
    self.set_fog_light_energy(value)
  @property
  def fog_sun_scatter(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fog_sun_scatter()
    return _ret
  @fog_sun_scatter.setter
  def fog_sun_scatter(self,  value:'float'):
    self.set_fog_sun_scatter(value)
  @property
  def fog_density(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fog_density()
    return _ret
  @fog_density.setter
  def fog_density(self,  value:'float'):
    self.set_fog_density(value)
  @property
  def fog_aerial_perspective(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fog_aerial_perspective()
    return _ret
  @fog_aerial_perspective.setter
  def fog_aerial_perspective(self,  value:'float'):
    self.set_fog_aerial_perspective(value)
  @property
  def fog_sky_affect(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fog_sky_affect()
    return _ret
  @fog_sky_affect.setter
  def fog_sky_affect(self,  value:'float'):
    self.set_fog_sky_affect(value)
  @property
  def fog_height(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fog_height()
    return _ret
  @fog_height.setter
  def fog_height(self,  value:'float'):
    self.set_fog_height(value)
  @property
  def fog_height_density(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fog_height_density()
    return _ret
  @fog_height_density.setter
  def fog_height_density(self,  value:'float'):
    self.set_fog_height_density(value)
  @property
  def fog_depth_curve(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fog_depth_curve()
    return _ret
  @fog_depth_curve.setter
  def fog_depth_curve(self,  value:'float'):
    self.set_fog_depth_curve(value)
  @property
  def fog_depth_begin(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fog_depth_begin()
    return _ret
  @fog_depth_begin.setter
  def fog_depth_begin(self,  value:'float'):
    self.set_fog_depth_begin(value)
  @property
  def fog_depth_end(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fog_depth_end()
    return _ret
  @fog_depth_end.setter
  def fog_depth_end(self,  value:'float'):
    self.set_fog_depth_end(value)
  @property
  def volumetric_fog_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_volumetric_fog_enabled()
    return _ret
  @volumetric_fog_enabled.setter
  def volumetric_fog_enabled(self,  value:'bool'):
    self.set_volumetric_fog_enabled(value)
  @property
  def volumetric_fog_density(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volumetric_fog_density()
    return _ret
  @volumetric_fog_density.setter
  def volumetric_fog_density(self,  value:'float'):
    self.set_volumetric_fog_density(value)
  @property
  def volumetric_fog_albedo(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_volumetric_fog_albedo()
    return _ret
  @volumetric_fog_albedo.setter
  def volumetric_fog_albedo(self,  value:'Color'):
    self.set_volumetric_fog_albedo(value)
  @property
  def volumetric_fog_emission(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_volumetric_fog_emission()
    return _ret
  @volumetric_fog_emission.setter
  def volumetric_fog_emission(self,  value:'Color'):
    self.set_volumetric_fog_emission(value)
  @property
  def volumetric_fog_emission_energy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volumetric_fog_emission_energy()
    return _ret
  @volumetric_fog_emission_energy.setter
  def volumetric_fog_emission_energy(self,  value:'float'):
    self.set_volumetric_fog_emission_energy(value)
  @property
  def volumetric_fog_gi_inject(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volumetric_fog_gi_inject()
    return _ret
  @volumetric_fog_gi_inject.setter
  def volumetric_fog_gi_inject(self,  value:'float'):
    self.set_volumetric_fog_gi_inject(value)
  @property
  def volumetric_fog_anisotropy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volumetric_fog_anisotropy()
    return _ret
  @volumetric_fog_anisotropy.setter
  def volumetric_fog_anisotropy(self,  value:'float'):
    self.set_volumetric_fog_anisotropy(value)
  @property
  def volumetric_fog_length(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volumetric_fog_length()
    return _ret
  @volumetric_fog_length.setter
  def volumetric_fog_length(self,  value:'float'):
    self.set_volumetric_fog_length(value)
  @property
  def volumetric_fog_detail_spread(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volumetric_fog_detail_spread()
    return _ret
  @volumetric_fog_detail_spread.setter
  def volumetric_fog_detail_spread(self,  value:'float'):
    self.set_volumetric_fog_detail_spread(value)
  @property
  def volumetric_fog_ambient_inject(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volumetric_fog_ambient_inject()
    return _ret
  @volumetric_fog_ambient_inject.setter
  def volumetric_fog_ambient_inject(self,  value:'float'):
    self.set_volumetric_fog_ambient_inject(value)
  @property
  def volumetric_fog_sky_affect(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volumetric_fog_sky_affect()
    return _ret
  @volumetric_fog_sky_affect.setter
  def volumetric_fog_sky_affect(self,  value:'float'):
    self.set_volumetric_fog_sky_affect(value)
  @property
  def volumetric_fog_temporal_reprojection_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_volumetric_fog_temporal_reprojection_enabled()
    return _ret
  @volumetric_fog_temporal_reprojection_enabled.setter
  def volumetric_fog_temporal_reprojection_enabled(self,  value:'bool'):
    self.set_volumetric_fog_temporal_reprojection_enabled(value)
  @property
  def volumetric_fog_temporal_reprojection_amount(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volumetric_fog_temporal_reprojection_amount()
    return _ret
  @volumetric_fog_temporal_reprojection_amount.setter
  def volumetric_fog_temporal_reprojection_amount(self,  value:'float'):
    self.set_volumetric_fog_temporal_reprojection_amount(value)
  @property
  def adjustment_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_adjustment_enabled()
    return _ret
  @adjustment_enabled.setter
  def adjustment_enabled(self,  value:'bool'):
    self.set_adjustment_enabled(value)
  @property
  def adjustment_brightness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_adjustment_brightness()
    return _ret
  @adjustment_brightness.setter
  def adjustment_brightness(self,  value:'float'):
    self.set_adjustment_brightness(value)
  @property
  def adjustment_contrast(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_adjustment_contrast()
    return _ret
  @adjustment_contrast.setter
  def adjustment_contrast(self,  value:'float'):
    self.set_adjustment_contrast(value)
  @property
  def adjustment_saturation(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_adjustment_saturation()
    return _ret
  @adjustment_saturation.setter
  def adjustment_saturation(self,  value:'float'):
    self.set_adjustment_saturation(value)
  @property
  def adjustment_color_correction(self) -> typing.Any:
    r''''''
    _ret = self. get_adjustment_color_correction()
    return _ret
  @adjustment_color_correction.setter
  def adjustment_color_correction(self,  value:'py4godot_object.Object'):
    self.set_adjustment_color_correction(value)
  @functools.native_method
  def set_background(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__background_mode = mode






    self._ptr.call_with_return(77,tuple([mode]))

  @functools.native_method
  def get_background(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(78,tuple([]))

    return _ret


  @functools.native_method
  def set_sky(self, sky:'py4godot_sky.Sky'   ) -> None:
    r''''''

    assert(not sky is None)
    assert isinstance(sky, get_class('Sky')), 'sky must be Sky'


    self.py__sky = sky






    self._ptr.call_with_return(79,tuple([sky._ptr]))

  @functools.native_method
  def get_sky(self) -> typing.Union['py4godot_sky.Sky']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Sky
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_sky_custom_fov(self, scale:'float'   ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'


    self.py__sky_custom_fov = scale






    self._ptr.call_with_return(81,tuple([scale]))

  @functools.native_method
  def get_sky_custom_fov(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([]))

    return _ret


  @functools.native_method
  def set_sky_rotation(self, euler_radians:'Vector3'   ) -> None:
    r''''''

    assert(not euler_radians is None)
    assert isinstance(euler_radians, Vector3), 'euler_radians must be Vector3'


    self.py__sky_rotation = euler_radians






    self._ptr.call_with_return(83,tuple([euler_radians._ptr]))

  @functools.native_method
  def get_sky_rotation(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(84,tuple([]))

    return _ret


  @functools.native_method
  def set_bg_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__background_color = color






    self._ptr.call_with_return(85,tuple([color._ptr]))

  @functools.native_method
  def get_bg_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([]))

    return _ret


  @functools.native_method
  def set_bg_energy_multiplier(self, energy:'float'   ) -> None:
    r''''''

    assert isinstance(energy, (int, float)), 'energy must be int or float'


    self.py__background_energy_multiplier = energy






    self._ptr.call_with_return(87,tuple([energy]))

  @functools.native_method
  def get_bg_energy_multiplier(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([]))

    return _ret


  @functools.native_method
  def set_bg_intensity(self, energy:'float'   ) -> None:
    r''''''

    assert isinstance(energy, (int, float)), 'energy must be int or float'


    self.py__background_intensity = energy






    self._ptr.call_with_return(89,tuple([energy]))

  @functools.native_method
  def get_bg_intensity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([]))

    return _ret


  @functools.native_method
  def set_canvas_max_layer(self, layer:'int'   ) -> None:
    r''''''

    assert isinstance(layer, (int, float)), 'layer must be int or float'


    self.py__background_canvas_max_layer = layer






    self._ptr.call_with_return(91,tuple([layer]))

  @functools.native_method
  def get_canvas_max_layer(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([]))

    return _ret


  @functools.native_method
  def set_camera_feed_id(self, id:'int'   ) -> None:
    r''''''

    assert isinstance(id, (int, float)), 'id must be int or float'


    self.py__background_camera_feed_id = id






    self._ptr.call_with_return(93,tuple([id]))

  @functools.native_method
  def get_camera_feed_id(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([]))

    return _ret


  @functools.native_method
  def set_ambient_light_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__ambient_light_color = color






    self._ptr.call_with_return(95,tuple([color._ptr]))

  @functools.native_method
  def get_ambient_light_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([]))

    return _ret


  @functools.native_method
  def set_ambient_source(self, source:'int'  ) -> None:
    r''''''

    assert isinstance(source, (int, float)), 'source must be int or float'


    self.py__ambient_light_source = source






    self._ptr.call_with_return(97,tuple([source]))

  @functools.native_method
  def get_ambient_source(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(98,tuple([]))

    return _ret


  @functools.native_method
  def set_ambient_light_energy(self, energy:'float'   ) -> None:
    r''''''

    assert isinstance(energy, (int, float)), 'energy must be int or float'


    self.py__ambient_light_energy = energy






    self._ptr.call_with_return(99,tuple([energy]))

  @functools.native_method
  def get_ambient_light_energy(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([]))

    return _ret


  @functools.native_method
  def set_ambient_light_sky_contribution(self, ratio:'float'   ) -> None:
    r''''''

    assert isinstance(ratio, (int, float)), 'ratio must be int or float'


    self.py__ambient_light_sky_contribution = ratio






    self._ptr.call_with_return(101,tuple([ratio]))

  @functools.native_method
  def get_ambient_light_sky_contribution(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([]))

    return _ret


  @functools.native_method
  def set_reflection_source(self, source:'int'  ) -> None:
    r''''''

    assert isinstance(source, (int, float)), 'source must be int or float'


    self.py__reflected_light_source = source






    self._ptr.call_with_return(103,tuple([source]))

  @functools.native_method
  def get_reflection_source(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(104,tuple([]))

    return _ret


  @functools.native_method
  def set_tonemapper(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__tonemap_mode = mode






    self._ptr.call_with_return(105,tuple([mode]))

  @functools.native_method
  def get_tonemapper(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(106,tuple([]))

    return _ret


  @functools.native_method
  def set_tonemap_exposure(self, exposure:'float'   ) -> None:
    r''''''

    assert isinstance(exposure, (int, float)), 'exposure must be int or float'


    self.py__tonemap_exposure = exposure






    self._ptr.call_with_return(107,tuple([exposure]))

  @functools.native_method
  def get_tonemap_exposure(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(108,tuple([]))

    return _ret


  @functools.native_method
  def set_tonemap_white(self, white:'float'   ) -> None:
    r''''''

    assert isinstance(white, (int, float)), 'white must be int or float'


    self.py__tonemap_white = white






    self._ptr.call_with_return(109,tuple([white]))

  @functools.native_method
  def get_tonemap_white(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(110,tuple([]))

    return _ret


  @functools.native_method
  def set_ssr_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__ssr_enabled = enabled






    self._ptr.call_with_return(111,tuple([enabled]))

  @functools.native_method
  def is_ssr_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(112,tuple([]))

    return _ret


  @functools.native_method
  def set_ssr_max_steps(self, max_steps:'int'   ) -> None:
    r''''''

    assert isinstance(max_steps, (int, float)), 'max_steps must be int or float'


    self.py__ssr_max_steps = max_steps






    self._ptr.call_with_return(113,tuple([max_steps]))

  @functools.native_method
  def get_ssr_max_steps(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(114,tuple([]))

    return _ret


  @functools.native_method
  def set_ssr_fade_in(self, fade_in:'float'   ) -> None:
    r''''''

    assert isinstance(fade_in, (int, float)), 'fade_in must be int or float'


    self.py__ssr_fade_in = fade_in






    self._ptr.call_with_return(115,tuple([fade_in]))

  @functools.native_method
  def get_ssr_fade_in(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(116,tuple([]))

    return _ret


  @functools.native_method
  def set_ssr_fade_out(self, fade_out:'float'   ) -> None:
    r''''''

    assert isinstance(fade_out, (int, float)), 'fade_out must be int or float'


    self.py__ssr_fade_out = fade_out






    self._ptr.call_with_return(117,tuple([fade_out]))

  @functools.native_method
  def get_ssr_fade_out(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(118,tuple([]))

    return _ret


  @functools.native_method
  def set_ssr_depth_tolerance(self, depth_tolerance:'float'   ) -> None:
    r''''''

    assert isinstance(depth_tolerance, (int, float)), 'depth_tolerance must be int or float'


    self.py__ssr_depth_tolerance = depth_tolerance






    self._ptr.call_with_return(119,tuple([depth_tolerance]))

  @functools.native_method
  def get_ssr_depth_tolerance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(120,tuple([]))

    return _ret


  @functools.native_method
  def set_ssao_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__ssao_enabled = enabled






    self._ptr.call_with_return(121,tuple([enabled]))

  @functools.native_method
  def is_ssao_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(122,tuple([]))

    return _ret


  @functools.native_method
  def set_ssao_radius(self, radius:'float'   ) -> None:
    r''''''

    assert isinstance(radius, (int, float)), 'radius must be int or float'


    self.py__ssao_radius = radius






    self._ptr.call_with_return(123,tuple([radius]))

  @functools.native_method
  def get_ssao_radius(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(124,tuple([]))

    return _ret


  @functools.native_method
  def set_ssao_intensity(self, intensity:'float'   ) -> None:
    r''''''

    assert isinstance(intensity, (int, float)), 'intensity must be int or float'


    self.py__ssao_intensity = intensity






    self._ptr.call_with_return(125,tuple([intensity]))

  @functools.native_method
  def get_ssao_intensity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(126,tuple([]))

    return _ret


  @functools.native_method
  def set_ssao_power(self, power:'float'   ) -> None:
    r''''''

    assert isinstance(power, (int, float)), 'power must be int or float'


    self.py__ssao_power = power






    self._ptr.call_with_return(127,tuple([power]))

  @functools.native_method
  def get_ssao_power(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(128,tuple([]))

    return _ret


  @functools.native_method
  def set_ssao_detail(self, detail:'float'   ) -> None:
    r''''''

    assert isinstance(detail, (int, float)), 'detail must be int or float'


    self.py__ssao_detail = detail






    self._ptr.call_with_return(129,tuple([detail]))

  @functools.native_method
  def get_ssao_detail(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(130,tuple([]))

    return _ret


  @functools.native_method
  def set_ssao_horizon(self, horizon:'float'   ) -> None:
    r''''''

    assert isinstance(horizon, (int, float)), 'horizon must be int or float'


    self.py__ssao_horizon = horizon






    self._ptr.call_with_return(131,tuple([horizon]))

  @functools.native_method
  def get_ssao_horizon(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(132,tuple([]))

    return _ret


  @functools.native_method
  def set_ssao_sharpness(self, sharpness:'float'   ) -> None:
    r''''''

    assert isinstance(sharpness, (int, float)), 'sharpness must be int or float'


    self.py__ssao_sharpness = sharpness






    self._ptr.call_with_return(133,tuple([sharpness]))

  @functools.native_method
  def get_ssao_sharpness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(134,tuple([]))

    return _ret


  @functools.native_method
  def set_ssao_direct_light_affect(self, amount:'float'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__ssao_light_affect = amount






    self._ptr.call_with_return(135,tuple([amount]))

  @functools.native_method
  def get_ssao_direct_light_affect(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(136,tuple([]))

    return _ret


  @functools.native_method
  def set_ssao_ao_channel_affect(self, amount:'float'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__ssao_ao_channel_affect = amount






    self._ptr.call_with_return(137,tuple([amount]))

  @functools.native_method
  def get_ssao_ao_channel_affect(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(138,tuple([]))

    return _ret


  @functools.native_method
  def set_ssil_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__ssil_enabled = enabled






    self._ptr.call_with_return(139,tuple([enabled]))

  @functools.native_method
  def is_ssil_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(140,tuple([]))

    return _ret


  @functools.native_method
  def set_ssil_radius(self, radius:'float'   ) -> None:
    r''''''

    assert isinstance(radius, (int, float)), 'radius must be int or float'


    self.py__ssil_radius = radius






    self._ptr.call_with_return(141,tuple([radius]))

  @functools.native_method
  def get_ssil_radius(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(142,tuple([]))

    return _ret


  @functools.native_method
  def set_ssil_intensity(self, intensity:'float'   ) -> None:
    r''''''

    assert isinstance(intensity, (int, float)), 'intensity must be int or float'


    self.py__ssil_intensity = intensity






    self._ptr.call_with_return(143,tuple([intensity]))

  @functools.native_method
  def get_ssil_intensity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(144,tuple([]))

    return _ret


  @functools.native_method
  def set_ssil_sharpness(self, sharpness:'float'   ) -> None:
    r''''''

    assert isinstance(sharpness, (int, float)), 'sharpness must be int or float'


    self.py__ssil_sharpness = sharpness






    self._ptr.call_with_return(145,tuple([sharpness]))

  @functools.native_method
  def get_ssil_sharpness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(146,tuple([]))

    return _ret


  @functools.native_method
  def set_ssil_normal_rejection(self, normal_rejection:'float'   ) -> None:
    r''''''

    assert isinstance(normal_rejection, (int, float)), 'normal_rejection must be int or float'


    self.py__ssil_normal_rejection = normal_rejection






    self._ptr.call_with_return(147,tuple([normal_rejection]))

  @functools.native_method
  def get_ssil_normal_rejection(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(148,tuple([]))

    return _ret


  @functools.native_method
  def set_sdfgi_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__sdfgi_enabled = enabled






    self._ptr.call_with_return(149,tuple([enabled]))

  @functools.native_method
  def is_sdfgi_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(150,tuple([]))

    return _ret


  @functools.native_method
  def set_sdfgi_cascades(self, amount:'int'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__sdfgi_cascades = amount






    self._ptr.call_with_return(151,tuple([amount]))

  @functools.native_method
  def get_sdfgi_cascades(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(152,tuple([]))

    return _ret


  @functools.native_method
  def set_sdfgi_min_cell_size(self, size:'float'   ) -> None:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'


    self.py__sdfgi_min_cell_size = size






    self._ptr.call_with_return(153,tuple([size]))

  @functools.native_method
  def get_sdfgi_min_cell_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(154,tuple([]))

    return _ret


  @functools.native_method
  def set_sdfgi_max_distance(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__sdfgi_max_distance = distance






    self._ptr.call_with_return(155,tuple([distance]))

  @functools.native_method
  def get_sdfgi_max_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(156,tuple([]))

    return _ret


  @functools.native_method
  def set_sdfgi_cascade0_distance(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__sdfgi_cascade0_distance = distance






    self._ptr.call_with_return(157,tuple([distance]))

  @functools.native_method
  def get_sdfgi_cascade0_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(158,tuple([]))

    return _ret


  @functools.native_method
  def set_sdfgi_y_scale(self, scale:'int'  ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'


    self.py__sdfgi_y_scale = scale






    self._ptr.call_with_return(159,tuple([scale]))

  @functools.native_method
  def get_sdfgi_y_scale(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(160,tuple([]))

    return _ret


  @functools.native_method
  def set_sdfgi_use_occlusion(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__sdfgi_use_occlusion = enable






    self._ptr.call_with_return(161,tuple([enable]))

  @functools.native_method
  def is_sdfgi_using_occlusion(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(162,tuple([]))

    return _ret


  @functools.native_method
  def set_sdfgi_bounce_feedback(self, amount:'float'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__sdfgi_bounce_feedback = amount






    self._ptr.call_with_return(163,tuple([amount]))

  @functools.native_method
  def get_sdfgi_bounce_feedback(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(164,tuple([]))

    return _ret


  @functools.native_method
  def set_sdfgi_read_sky_light(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__sdfgi_read_sky_light = enable






    self._ptr.call_with_return(165,tuple([enable]))

  @functools.native_method
  def is_sdfgi_reading_sky_light(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(166,tuple([]))

    return _ret


  @functools.native_method
  def set_sdfgi_energy(self, amount:'float'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__sdfgi_energy = amount






    self._ptr.call_with_return(167,tuple([amount]))

  @functools.native_method
  def get_sdfgi_energy(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(168,tuple([]))

    return _ret


  @functools.native_method
  def set_sdfgi_normal_bias(self, bias:'float'   ) -> None:
    r''''''

    assert isinstance(bias, (int, float)), 'bias must be int or float'


    self.py__sdfgi_normal_bias = bias






    self._ptr.call_with_return(169,tuple([bias]))

  @functools.native_method
  def get_sdfgi_normal_bias(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(170,tuple([]))

    return _ret


  @functools.native_method
  def set_sdfgi_probe_bias(self, bias:'float'   ) -> None:
    r''''''

    assert isinstance(bias, (int, float)), 'bias must be int or float'


    self.py__sdfgi_probe_bias = bias






    self._ptr.call_with_return(171,tuple([bias]))

  @functools.native_method
  def get_sdfgi_probe_bias(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(172,tuple([]))

    return _ret


  @functools.native_method
  def set_glow_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__glow_enabled = enabled






    self._ptr.call_with_return(173,tuple([enabled]))

  @functools.native_method
  def is_glow_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(174,tuple([]))

    return _ret


  @functools.native_method
  def set_glow_level(self, idx:'int'   , intensity:'float'   ) -> None:
    r'''
				Sets the intensity of the glow level `idx`. A value above `0.0` enables the level. Each level relies on the previous level. This means that enabling higher glow levels will slow down the glow effect rendering, even if previous levels aren't enabled.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(intensity, (int, float)), 'intensity must be int or float'








    self._ptr.call_with_return(175,tuple([idx, intensity]))

  @functools.native_method
  def get_glow_level(self, idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the intensity of the glow level `idx`.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(176,tuple([idx]))
    return _ret


  @functools.native_method
  def set_glow_normalized(self, normalize:'bool'   ) -> None:
    r''''''

    assert isinstance(normalize, bool), 'normalize must be bool'


    self.py__glow_normalized = normalize






    self._ptr.call_with_return(177,tuple([normalize]))

  @functools.native_method
  def is_glow_normalized(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(178,tuple([]))

    return _ret


  @functools.native_method
  def set_glow_intensity(self, intensity:'float'   ) -> None:
    r''''''

    assert isinstance(intensity, (int, float)), 'intensity must be int or float'


    self.py__glow_intensity = intensity






    self._ptr.call_with_return(179,tuple([intensity]))

  @functools.native_method
  def get_glow_intensity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(180,tuple([]))

    return _ret


  @functools.native_method
  def set_glow_strength(self, strength:'float'   ) -> None:
    r''''''

    assert isinstance(strength, (int, float)), 'strength must be int or float'


    self.py__glow_strength = strength






    self._ptr.call_with_return(181,tuple([strength]))

  @functools.native_method
  def get_glow_strength(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(182,tuple([]))

    return _ret


  @functools.native_method
  def set_glow_mix(self, mix:'float'   ) -> None:
    r''''''

    assert isinstance(mix, (int, float)), 'mix must be int or float'


    self.py__glow_mix = mix






    self._ptr.call_with_return(183,tuple([mix]))

  @functools.native_method
  def get_glow_mix(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(184,tuple([]))

    return _ret


  @functools.native_method
  def set_glow_bloom(self, amount:'float'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__glow_bloom = amount






    self._ptr.call_with_return(185,tuple([amount]))

  @functools.native_method
  def get_glow_bloom(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(186,tuple([]))

    return _ret


  @functools.native_method
  def set_glow_blend_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__glow_blend_mode = mode






    self._ptr.call_with_return(187,tuple([mode]))

  @functools.native_method
  def get_glow_blend_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(188,tuple([]))

    return _ret


  @functools.native_method
  def set_glow_hdr_bleed_threshold(self, threshold:'float'   ) -> None:
    r''''''

    assert isinstance(threshold, (int, float)), 'threshold must be int or float'


    self.py__glow_hdr_threshold = threshold






    self._ptr.call_with_return(189,tuple([threshold]))

  @functools.native_method
  def get_glow_hdr_bleed_threshold(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(190,tuple([]))

    return _ret


  @functools.native_method
  def set_glow_hdr_bleed_scale(self, scale:'float'   ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'


    self.py__glow_hdr_scale = scale






    self._ptr.call_with_return(191,tuple([scale]))

  @functools.native_method
  def get_glow_hdr_bleed_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(192,tuple([]))

    return _ret


  @functools.native_method
  def set_glow_hdr_luminance_cap(self, amount:'float'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__glow_hdr_luminance_cap = amount






    self._ptr.call_with_return(193,tuple([amount]))

  @functools.native_method
  def get_glow_hdr_luminance_cap(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(194,tuple([]))

    return _ret


  @functools.native_method
  def set_glow_map_strength(self, strength:'float'   ) -> None:
    r''''''

    assert isinstance(strength, (int, float)), 'strength must be int or float'


    self.py__glow_map_strength = strength






    self._ptr.call_with_return(195,tuple([strength]))

  @functools.native_method
  def get_glow_map_strength(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(196,tuple([]))

    return _ret


  @functools.native_method
  def set_glow_map(self, mode:'py4godot_texture.Texture'   ) -> None:
    r''''''

    assert(not mode is None)
    assert isinstance(mode, get_class('Texture')), 'mode must be Texture'


    self.py__glow_map = mode






    self._ptr.call_with_return(197,tuple([mode._ptr]))

  @functools.native_method
  def get_glow_map(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture
    _ret._ptr = self._ptr.call_with_return(198,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_fog_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__fog_enabled = enabled






    self._ptr.call_with_return(199,tuple([enabled]))

  @functools.native_method
  def is_fog_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(200,tuple([]))

    return _ret


  @functools.native_method
  def set_fog_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__fog_mode = mode






    self._ptr.call_with_return(201,tuple([mode]))

  @functools.native_method
  def get_fog_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(202,tuple([]))

    return _ret


  @functools.native_method
  def set_fog_light_color(self, light_color:'Color'   ) -> None:
    r''''''

    assert(not light_color is None)
    assert isinstance(light_color, Color), 'light_color must be Color'


    self.py__fog_light_color = light_color






    self._ptr.call_with_return(203,tuple([light_color._ptr]))

  @functools.native_method
  def get_fog_light_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(204,tuple([]))

    return _ret


  @functools.native_method
  def set_fog_light_energy(self, light_energy:'float'   ) -> None:
    r''''''

    assert isinstance(light_energy, (int, float)), 'light_energy must be int or float'


    self.py__fog_light_energy = light_energy






    self._ptr.call_with_return(205,tuple([light_energy]))

  @functools.native_method
  def get_fog_light_energy(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(206,tuple([]))

    return _ret


  @functools.native_method
  def set_fog_sun_scatter(self, sun_scatter:'float'   ) -> None:
    r''''''

    assert isinstance(sun_scatter, (int, float)), 'sun_scatter must be int or float'


    self.py__fog_sun_scatter = sun_scatter






    self._ptr.call_with_return(207,tuple([sun_scatter]))

  @functools.native_method
  def get_fog_sun_scatter(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(208,tuple([]))

    return _ret


  @functools.native_method
  def set_fog_density(self, density:'float'   ) -> None:
    r''''''

    assert isinstance(density, (int, float)), 'density must be int or float'


    self.py__fog_density = density






    self._ptr.call_with_return(209,tuple([density]))

  @functools.native_method
  def get_fog_density(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(210,tuple([]))

    return _ret


  @functools.native_method
  def set_fog_height(self, height:'float'   ) -> None:
    r''''''

    assert isinstance(height, (int, float)), 'height must be int or float'


    self.py__fog_height = height






    self._ptr.call_with_return(211,tuple([height]))

  @functools.native_method
  def get_fog_height(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(212,tuple([]))

    return _ret


  @functools.native_method
  def set_fog_height_density(self, height_density:'float'   ) -> None:
    r''''''

    assert isinstance(height_density, (int, float)), 'height_density must be int or float'


    self.py__fog_height_density = height_density






    self._ptr.call_with_return(213,tuple([height_density]))

  @functools.native_method
  def get_fog_height_density(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(214,tuple([]))

    return _ret


  @functools.native_method
  def set_fog_aerial_perspective(self, aerial_perspective:'float'   ) -> None:
    r''''''

    assert isinstance(aerial_perspective, (int, float)), 'aerial_perspective must be int or float'


    self.py__fog_aerial_perspective = aerial_perspective






    self._ptr.call_with_return(215,tuple([aerial_perspective]))

  @functools.native_method
  def get_fog_aerial_perspective(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(216,tuple([]))

    return _ret


  @functools.native_method
  def set_fog_sky_affect(self, sky_affect:'float'   ) -> None:
    r''''''

    assert isinstance(sky_affect, (int, float)), 'sky_affect must be int or float'


    self.py__fog_sky_affect = sky_affect






    self._ptr.call_with_return(217,tuple([sky_affect]))

  @functools.native_method
  def get_fog_sky_affect(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(218,tuple([]))

    return _ret


  @functools.native_method
  def set_fog_depth_curve(self, curve:'float'   ) -> None:
    r''''''

    assert isinstance(curve, (int, float)), 'curve must be int or float'


    self.py__fog_depth_curve = curve






    self._ptr.call_with_return(219,tuple([curve]))

  @functools.native_method
  def get_fog_depth_curve(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(220,tuple([]))

    return _ret


  @functools.native_method
  def set_fog_depth_begin(self, begin:'float'   ) -> None:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'


    self.py__fog_depth_begin = begin






    self._ptr.call_with_return(221,tuple([begin]))

  @functools.native_method
  def get_fog_depth_begin(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(222,tuple([]))

    return _ret


  @functools.native_method
  def set_fog_depth_end(self, end:'float'   ) -> None:
    r''''''

    assert isinstance(end, (int, float)), 'end must be int or float'


    self.py__fog_depth_end = end






    self._ptr.call_with_return(223,tuple([end]))

  @functools.native_method
  def get_fog_depth_end(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(224,tuple([]))

    return _ret


  @functools.native_method
  def set_volumetric_fog_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__volumetric_fog_enabled = enabled






    self._ptr.call_with_return(225,tuple([enabled]))

  @functools.native_method
  def is_volumetric_fog_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(226,tuple([]))

    return _ret


  @functools.native_method
  def set_volumetric_fog_emission(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__volumetric_fog_emission = color






    self._ptr.call_with_return(227,tuple([color._ptr]))

  @functools.native_method
  def get_volumetric_fog_emission(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(228,tuple([]))

    return _ret


  @functools.native_method
  def set_volumetric_fog_albedo(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__volumetric_fog_albedo = color






    self._ptr.call_with_return(229,tuple([color._ptr]))

  @functools.native_method
  def get_volumetric_fog_albedo(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(230,tuple([]))

    return _ret


  @functools.native_method
  def set_volumetric_fog_density(self, density:'float'   ) -> None:
    r''''''

    assert isinstance(density, (int, float)), 'density must be int or float'


    self.py__volumetric_fog_density = density






    self._ptr.call_with_return(231,tuple([density]))

  @functools.native_method
  def get_volumetric_fog_density(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(232,tuple([]))

    return _ret


  @functools.native_method
  def set_volumetric_fog_emission_energy(self, begin:'float'   ) -> None:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'


    self.py__volumetric_fog_emission_energy = begin






    self._ptr.call_with_return(233,tuple([begin]))

  @functools.native_method
  def get_volumetric_fog_emission_energy(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(234,tuple([]))

    return _ret


  @functools.native_method
  def set_volumetric_fog_anisotropy(self, anisotropy:'float'   ) -> None:
    r''''''

    assert isinstance(anisotropy, (int, float)), 'anisotropy must be int or float'


    self.py__volumetric_fog_anisotropy = anisotropy






    self._ptr.call_with_return(235,tuple([anisotropy]))

  @functools.native_method
  def get_volumetric_fog_anisotropy(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(236,tuple([]))

    return _ret


  @functools.native_method
  def set_volumetric_fog_length(self, length:'float'   ) -> None:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'


    self.py__volumetric_fog_length = length






    self._ptr.call_with_return(237,tuple([length]))

  @functools.native_method
  def get_volumetric_fog_length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(238,tuple([]))

    return _ret


  @functools.native_method
  def set_volumetric_fog_detail_spread(self, detail_spread:'float'   ) -> None:
    r''''''

    assert isinstance(detail_spread, (int, float)), 'detail_spread must be int or float'


    self.py__volumetric_fog_detail_spread = detail_spread






    self._ptr.call_with_return(239,tuple([detail_spread]))

  @functools.native_method
  def get_volumetric_fog_detail_spread(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(240,tuple([]))

    return _ret


  @functools.native_method
  def set_volumetric_fog_gi_inject(self, gi_inject:'float'   ) -> None:
    r''''''

    assert isinstance(gi_inject, (int, float)), 'gi_inject must be int or float'


    self.py__volumetric_fog_gi_inject = gi_inject






    self._ptr.call_with_return(241,tuple([gi_inject]))

  @functools.native_method
  def get_volumetric_fog_gi_inject(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(242,tuple([]))

    return _ret


  @functools.native_method
  def set_volumetric_fog_ambient_inject(self, enabled:'float'   ) -> None:
    r''''''

    assert isinstance(enabled, (int, float)), 'enabled must be int or float'


    self.py__volumetric_fog_ambient_inject = enabled






    self._ptr.call_with_return(243,tuple([enabled]))

  @functools.native_method
  def get_volumetric_fog_ambient_inject(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(244,tuple([]))

    return _ret


  @functools.native_method
  def set_volumetric_fog_sky_affect(self, sky_affect:'float'   ) -> None:
    r''''''

    assert isinstance(sky_affect, (int, float)), 'sky_affect must be int or float'


    self.py__volumetric_fog_sky_affect = sky_affect






    self._ptr.call_with_return(245,tuple([sky_affect]))

  @functools.native_method
  def get_volumetric_fog_sky_affect(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(246,tuple([]))

    return _ret


  @functools.native_method
  def set_volumetric_fog_temporal_reprojection_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__volumetric_fog_temporal_reprojection_enabled = enabled






    self._ptr.call_with_return(247,tuple([enabled]))

  @functools.native_method
  def is_volumetric_fog_temporal_reprojection_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(248,tuple([]))

    return _ret


  @functools.native_method
  def set_volumetric_fog_temporal_reprojection_amount(self, temporal_reprojection_amount:'float'   ) -> None:
    r''''''

    assert isinstance(temporal_reprojection_amount, (int, float)), 'temporal_reprojection_amount must be int or float'


    self.py__volumetric_fog_temporal_reprojection_amount = temporal_reprojection_amount






    self._ptr.call_with_return(249,tuple([temporal_reprojection_amount]))

  @functools.native_method
  def get_volumetric_fog_temporal_reprojection_amount(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(250,tuple([]))

    return _ret


  @functools.native_method
  def set_adjustment_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__adjustment_enabled = enabled






    self._ptr.call_with_return(251,tuple([enabled]))

  @functools.native_method
  def is_adjustment_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(252,tuple([]))

    return _ret


  @functools.native_method
  def set_adjustment_brightness(self, brightness:'float'   ) -> None:
    r''''''

    assert isinstance(brightness, (int, float)), 'brightness must be int or float'


    self.py__adjustment_brightness = brightness






    self._ptr.call_with_return(253,tuple([brightness]))

  @functools.native_method
  def get_adjustment_brightness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(254,tuple([]))

    return _ret


  @functools.native_method
  def set_adjustment_contrast(self, contrast:'float'   ) -> None:
    r''''''

    assert isinstance(contrast, (int, float)), 'contrast must be int or float'


    self.py__adjustment_contrast = contrast






    self._ptr.call_with_return(255,tuple([contrast]))

  @functools.native_method
  def get_adjustment_contrast(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(256,tuple([]))

    return _ret


  @functools.native_method
  def set_adjustment_saturation(self, saturation:'float'   ) -> None:
    r''''''

    assert isinstance(saturation, (int, float)), 'saturation must be int or float'


    self.py__adjustment_saturation = saturation






    self._ptr.call_with_return(257,tuple([saturation]))

  @functools.native_method
  def get_adjustment_saturation(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(258,tuple([]))

    return _ret


  @functools.native_method
  def set_adjustment_color_correction(self, color_correction:'py4godot_texture.Texture'   ) -> None:
    r''''''

    assert(not color_correction is None)
    assert isinstance(color_correction, get_class('Texture')), 'color_correction must be Texture'


    self.py__adjustment_color_correction = color_correction






    self._ptr.call_with_return(259,tuple([color_correction._ptr]))

  @functools.native_method
  def get_adjustment_color_correction(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture
    _ret._ptr = self._ptr.call_with_return(260,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('Environment', Environment.cast)
register_class('Environment', Environment)
