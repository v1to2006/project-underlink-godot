# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.GrooveJoint2D as py4godot_groovejoint2d 
  import py4godot.classes.Marker2D as py4godot_marker2d 
  import py4godot.classes.Tree as py4godot_tree 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.WorldEnvironment as py4godot_worldenvironment 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.FontFile as py4godot_fontfile 
  import py4godot.classes.ShapeCast2D as py4godot_shapecast2d 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.SpriteBase3D as py4godot_spritebase3d 
  import py4godot.classes.AnimationMixer as py4godot_animationmixer 
  import py4godot.classes.EditorPlugin as py4godot_editorplugin 
  import py4godot.classes.GPUParticles3D as py4godot_gpuparticles3d 
  import py4godot.classes.OpenXRCompositionLayer as py4godot_openxrcompositionlayer 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.RichTextLabel as py4godot_richtextlabel 
  import py4godot.classes.CollisionObject3D as py4godot_collisionobject3d 
  import py4godot.classes.LightmapProbe as py4godot_lightmapprobe 
  import py4godot.classes.ParallaxBackground as py4godot_parallaxbackground 
  import py4godot.classes.RemoteTransform3D as py4godot_remotetransform3d 
  import py4godot.classes.EditorFileSystem as py4godot_editorfilesystem 
  import py4godot.classes.GPUParticles2D as py4godot_gpuparticles2d 
  import py4godot.classes.MultiplayerSynchronizer as py4godot_multiplayersynchronizer 
  import py4godot.classes.MeshInstance3D as py4godot_meshinstance3d 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.Window as py4godot_window 
  import py4godot.classes.NavigationLink2D as py4godot_navigationlink2d 
  import py4godot.classes.LightOccluder2D as py4godot_lightoccluder2d 
  import py4godot.classes.CSGPolygon3D as py4godot_csgpolygon3d 
  import py4godot.classes.StaticBody2D as py4godot_staticbody2d 
  import py4godot.classes.FileDialog as py4godot_filedialog 
  import py4godot.classes.RayCast3D as py4godot_raycast3d 
  import py4godot.classes.AudioListener2D as py4godot_audiolistener2d 
  import py4godot.classes.AnimationPlayer as py4godot_animationplayer 
  import py4godot.classes.Container as py4godot_container 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.PinJoint3D as py4godot_pinjoint3d 
  import py4godot.classes.ConfirmationDialog as py4godot_confirmationdialog 
  import py4godot.classes.CollisionPolygon2D as py4godot_collisionpolygon2d 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.CSGCylinder3D as py4godot_csgcylinder3d 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.AudioStreamPlayer2D as py4godot_audiostreamplayer2d 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.MeshInstance2D as py4godot_meshinstance2d 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.OpenXRCompositionLayerEquirect as py4godot_openxrcompositionlayerequirect 
  import py4godot.classes.CSGMesh3D as py4godot_csgmesh3d 
  import py4godot.classes.Light2D as py4godot_light2d 
  import py4godot.classes.OpenXRCompositionLayerCylinder as py4godot_openxrcompositionlayercylinder 
  import py4godot.classes.RetargetModifier3D as py4godot_retargetmodifier3d 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.GPUParticlesAttractorSphere3D as py4godot_gpuparticlesattractorsphere3d 
  import py4godot.classes.CanvasModulate as py4godot_canvasmodulate 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.AimModifier3D as py4godot_aimmodifier3d 
  import py4godot.classes.ResourcePreloader as py4godot_resourcepreloader 
  import py4godot.classes.XRController3D as py4godot_xrcontroller3d 
  import py4godot.classes.CSGCombiner3D as py4godot_csgcombiner3d 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.PinJoint2D as py4godot_pinjoint2d 
  import py4godot.classes.ReflectionProbe as py4godot_reflectionprobe 
  import py4godot.classes.PointLight2D as py4godot_pointlight2d 
  import py4godot.classes.XRAnchor3D as py4godot_xranchor3d 
  import py4godot.classes.HingeJoint3D as py4godot_hingejoint3d 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.SpringBoneCollisionPlane3D as py4godot_springbonecollisionplane3d 
  import py4godot.classes.AnimatableBody2D as py4godot_animatablebody2d 
  import py4godot.classes.CharacterBody2D as py4godot_characterbody2d 
  import py4godot.classes.Generic6DOFJoint3D as py4godot_generic6dofjoint3d 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.FontVariation as py4godot_fontvariation 
  import py4godot.classes.XROrigin3D as py4godot_xrorigin3d 
  import py4godot.classes.ImporterMeshInstance3D as py4godot_importermeshinstance3d 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.AudioListener3D as py4godot_audiolistener3d 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.GPUParticlesAttractorBox3D as py4godot_gpuparticlesattractorbox3d 
  import py4godot.classes.Bone2D as py4godot_bone2d 
  import py4godot.classes.AnimatableBody3D as py4godot_animatablebody3d 
  import py4godot.classes.SkeletonIK3D as py4godot_skeletonik3d 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.Camera3D as py4godot_camera3d 
  import py4godot.classes.TreeItemTypedArray as py4godot_treeitemtypedarray 
  import py4godot.classes.BoneConstraint3D as py4godot_boneconstraint3d 
  import py4godot.classes.VisibleOnScreenNotifier2D as py4godot_visibleonscreennotifier2d 
  import py4godot.classes.VoxelGI as py4godot_voxelgi 
  import py4godot.classes.EditorResourcePreview as py4godot_editorresourcepreview 
  import py4godot.classes.Decal as py4godot_decal 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.GridMap as py4godot_gridmap 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.RayCast2D as py4godot_raycast2d 
  import py4godot.classes.OpenXRVisibilityMask as py4godot_openxrvisibilitymask 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.TextServer as py4godot_textserver 
  import py4godot.classes.VisualInstance3D as py4godot_visualinstance3d 
  import py4godot.classes.ScriptCreateDialog as py4godot_scriptcreatedialog 
  import py4godot.classes.SpringBoneCollisionSphere3D as py4godot_springbonecollisionsphere3d 
  import py4godot.classes.HTTPRequest as py4godot_httprequest 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.Area2D as py4godot_area2d 
  import py4godot.classes.InstancePlaceholder as py4godot_instanceplaceholder 
  import py4godot.classes.FogVolume as py4godot_fogvolume 
  import py4godot.classes.PathFollow3D as py4godot_pathfollow3d 
  import py4godot.classes.Timer as py4godot_timer 
  import py4godot.classes.ShaderGlobalsOverride as py4godot_shaderglobalsoverride 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.PhysicsBody3D as py4godot_physicsbody3d 
  import py4godot.classes.Control as py4godot_control 
  import py4godot.classes.StaticBody3D as py4godot_staticbody3d 
  import py4godot.classes.PathFollow2D as py4godot_pathfollow2d 
  import py4godot.classes.BackBufferCopy as py4godot_backbuffercopy 
  import py4godot.classes.AnimationTree as py4godot_animationtree 
  import py4godot.classes.PhysicsBody2D as py4godot_physicsbody2d 
  import py4godot.classes.NavigationObstacle3D as py4godot_navigationobstacle3d 
  import py4godot.classes.RigidBody2D as py4godot_rigidbody2d 
  import py4godot.classes.GPUParticlesCollisionSDF3D as py4godot_gpuparticlescollisionsdf3d 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.XRFaceModifier3D as py4godot_xrfacemodifier3d 
  import py4godot.classes.CanvasLayer as py4godot_canvaslayer 
  import py4godot.classes.Polygon2D as py4godot_polygon2d 
  import py4godot.classes.OccluderInstance3D as py4godot_occluderinstance3d 
  import py4godot.classes.CSGTorus3D as py4godot_csgtorus3d 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.EditorFileDialog as py4godot_editorfiledialog 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.CharacterBody3D as py4godot_characterbody3d 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.StatusIndicator as py4godot_statusindicator 
  import py4godot.classes.CanvasGroup as py4godot_canvasgroup 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.MissingNode as py4godot_missingnode 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.BoneAttachment3D as py4godot_boneattachment3d 
  import py4godot.classes.LookAtModifier3D as py4godot_lookatmodifier3d 
  import py4godot.classes.TouchScreenButton as py4godot_touchscreenbutton 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.NavigationLink3D as py4godot_navigationlink3d 
  import py4godot.classes.GPUParticlesCollisionSphere3D as py4godot_gpuparticlescollisionsphere3d 
  import py4godot.classes.VisibleOnScreenNotifier3D as py4godot_visibleonscreennotifier3d 
  import py4godot.classes.Skeleton2D as py4godot_skeleton2d 
  import py4godot.classes.Joint3D as py4godot_joint3d 
  import py4godot.classes.Viewport as py4godot_viewport 
  import py4godot.classes.SpotLight3D as py4godot_spotlight3d 
  import py4godot.classes.SubViewport as py4godot_subviewport 
  import py4godot.classes.PopupPanel as py4godot_popuppanel 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.ModifierBoneTarget3D as py4godot_modifierbonetarget3d 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.SpringBoneCollisionCapsule3D as py4godot_springbonecollisioncapsule3d 
  import py4godot.classes.GridMapEditorPlugin as py4godot_gridmapeditorplugin 
  import py4godot.classes.ConeTwistJoint3D as py4godot_conetwistjoint3d 
  import py4godot.classes.PhysicalBoneSimulator3D as py4godot_physicalbonesimulator3d 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.NavigationRegion2D as py4godot_navigationregion2d 
  import py4godot.classes.OpenXRRenderModel as py4godot_openxrrendermodel 
  import py4godot.classes.TabBar as py4godot_tabbar 
  import py4godot.classes.CPUParticles3D as py4godot_cpuparticles3d 
  import py4godot.classes.Popup as py4godot_popup 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.VisibleOnScreenEnabler2D as py4godot_visibleonscreenenabler2d 
  import py4godot.classes.XRCamera3D as py4godot_xrcamera3d 
  import py4godot.classes.NavigationRegion3D as py4godot_navigationregion3d 
  import py4godot.classes.AcceptDialog as py4godot_acceptdialog 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.AudioStreamPlayer3D as py4godot_audiostreamplayer3d 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.Node2D as py4godot_node2d 
  import py4godot.classes.AnimatedSprite2D as py4godot_animatedsprite2d 
  import py4godot.classes.Path2D as py4godot_path2d 
  import py4godot.classes.Parallax2D as py4godot_parallax2d 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.MultiMeshInstance3D as py4godot_multimeshinstance3d 
  import py4godot.classes.ConvertTransformModifier3D as py4godot_converttransformmodifier3d 
  import py4godot.classes.GeometryInstance3D as py4godot_geometryinstance3d 
  import py4godot.classes.SpringArm3D as py4godot_springarm3d 
  import py4godot.classes.LightmapGI as py4godot_lightmapgi 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.CSGBox3D as py4godot_csgbox3d 
  import py4godot.classes.RigidBody3D as py4godot_rigidbody3d 
  import py4godot.classes.ShapeCast3D as py4godot_shapecast3d 
  import py4godot.classes.TileMapLayer as py4godot_tilemaplayer 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.CollisionObject2D as py4godot_collisionobject2d 
  import py4godot.classes.Sprite3D as py4godot_sprite3d 
  import py4godot.classes.SoftBody3D as py4godot_softbody3d 
  import py4godot.classes.PopupMenu as py4godot_popupmenu 
  import py4godot.classes.SystemFont as py4godot_systemfont 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.NavigationAgent3D as py4godot_navigationagent3d 
  import py4godot.classes.NavigationObstacle2D as py4godot_navigationobstacle2d 
  import py4godot.classes.OpenXRCompositionLayerQuad as py4godot_openxrcompositionlayerquad 
  import py4godot.classes.GPUParticlesAttractor3D as py4godot_gpuparticlesattractor3d 
  import py4godot.classes.CopyTransformModifier3D as py4godot_copytransformmodifier3d 
  import py4godot.classes.Path3D as py4godot_path3d 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.Marker3D as py4godot_marker3d 
  import py4godot.classes.TabContainer as py4godot_tabcontainer 
  import py4godot.classes.DirectionalLight2D as py4godot_directionallight2d 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.TextServerExtension as py4godot_textserverextension 
  import py4godot.classes.VehicleBody3D as py4godot_vehiclebody3d 
  import py4godot.classes.SliderJoint3D as py4godot_sliderjoint3d 
  import py4godot.classes.CSGShape3D as py4godot_csgshape3d 
  import py4godot.classes.CPUParticles2D as py4godot_cpuparticles2d 
  import py4godot.classes.XRBodyModifier3D as py4godot_xrbodymodifier3d 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.OmniLight3D as py4godot_omnilight3d 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.RemoteTransform2D as py4godot_remotetransform2d 
  import py4godot.classes.Node as py4godot_node 
  import py4godot.classes.TileMap as py4godot_tilemap 
  import py4godot.classes.Sprite2D as py4godot_sprite2d 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.CSGPrimitive3D as py4godot_csgprimitive3d 
  import py4godot.classes.TextEdit as py4godot_textedit 
  import py4godot.classes.SkeletonModifier3D as py4godot_skeletonmodifier3d 
  import py4godot.classes.AnimatedSprite3D as py4godot_animatedsprite3d 
  import py4godot.classes.Font as py4godot_font 
  import py4godot.classes.Line2D as py4godot_line2d 
  import py4godot.classes.Skeleton3D as py4godot_skeleton3d 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.VehicleWheel3D as py4godot_vehiclewheel3d 
  import py4godot.classes.PhysicalBone3D as py4godot_physicalbone3d 
  import py4godot.classes.Node3D as py4godot_node3d 
  import py4godot.classes.GraphElement as py4godot_graphelement 
  import py4godot.classes.VisibleOnScreenEnabler3D as py4godot_visibleonscreenenabler3d 
  import py4godot.classes.CollisionShape2D as py4godot_collisionshape2d 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.SpringBoneSimulator3D as py4godot_springbonesimulator3d 
  import py4godot.classes.CanvasItem as py4godot_canvasitem 
  import py4godot.classes.CSGSphere3D as py4godot_csgsphere3d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.CollisionShape3D as py4godot_collisionshape3d 
  import py4godot.classes.SpringBoneCollision3D as py4godot_springbonecollision3d 
  import py4godot.classes.GraphNode as py4godot_graphnode 
  import py4godot.classes.EditorCommandPalette as py4godot_editorcommandpalette 
  import py4godot.classes.OpenXRHand as py4godot_openxrhand 
  import py4godot.classes.GPUParticlesCollisionBox3D as py4godot_gpuparticlescollisionbox3d 
  import py4godot.classes.OpenXRRenderModelManager as py4godot_openxrrendermodelmanager 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.GPUParticlesAttractorVectorField3D as py4godot_gpuparticlesattractorvectorfield3d 
  import py4godot.classes.XRHandModifier3D as py4godot_xrhandmodifier3d 
  import py4godot.classes.Label3D as py4godot_label3d 
  import py4godot.classes.GPUParticlesCollision3D as py4godot_gpuparticlescollision3d 
  import py4godot.classes.DampedSpringJoint2D as py4godot_dampedspringjoint2d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.Light3D as py4godot_light3d 
  import py4godot.classes.CollisionPolygon3D as py4godot_collisionpolygon3d 
  import py4godot.classes.TextServerAdvanced as py4godot_textserveradvanced 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.PhysicalBone2D as py4godot_physicalbone2d 
  import py4godot.classes.TextServerDummy as py4godot_textserverdummy 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.MultiplayerSpawner as py4godot_multiplayerspawner 
  import py4godot.classes.Joint2D as py4godot_joint2d 
  import py4godot.classes.NavigationAgent2D as py4godot_navigationagent2d 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.FoldableContainer as py4godot_foldablecontainer 
  import py4godot.classes.MultiMeshInstance2D as py4godot_multimeshinstance2d 
  import py4godot.classes.GPUParticlesCollisionHeightField3D as py4godot_gpuparticlescollisionheightfield3d 
  import py4godot.classes.XRNode3D as py4godot_xrnode3d 
  import py4godot.classes.ParallaxLayer as py4godot_parallaxlayer 
  import py4godot.classes.DirectionalLight3D as py4godot_directionallight3d 
  import py4godot.classes.Area3D as py4godot_area3d 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.RootMotionView as py4godot_rootmotionview 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.Camera2D as py4godot_camera2d 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.AudioStreamPlayer as py4godot_audiostreamplayer 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
import py4godot.classes.TreeItemTypedArray as py4godot_treeitemtypedarray 
import py4godot.classes.Object as py4godot_object 
from py4godot.wrappers.wrappers import CPPTreeItemWrapper

class TreeCellMode:
  CELL_MODE_STRING = 0
  CELL_MODE_CHECK = 1
  CELL_MODE_RANGE = 2
  CELL_MODE_ICON = 3
  CELL_MODE_CUSTOM = 4


class TreeItem(py4godot_object.Object):
  r'''
		A single item of a `Tree` control. It can contain other `TreeItem`s as children, which allows it to create a hierarchy. It can also contain text and buttons. `TreeItem` is not a `Node`, it is internal to the `Tree`.
		To create a `TreeItem`, use `Tree.create_item` or `TreeItem.create_child`. To remove a `TreeItem`, use `Object.free`.
		**Note:** The ID values used for buttons are 32-bit, unlike `int` which is always 64-bit. They go from `-2147483648` to `2147483647`.
	'''

  @staticmethod
  def constructor():
    class_ = TreeItem.construct_without_init()
    class_._ptr = constructor(850,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TreeItem.construct_without_init()
    class_._ptr = constructor(850,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTreeItemWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(850,0, ())


  def generate_wrapper(self):
    return CPPTreeItemWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = TreeItem.__new__(TreeItem)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TreeItem'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TreeItem.construct_without_init()
    cls._ptr = CPPTreeItemWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TreeItem.construct_without_init()
    cls._ptr = CPPTreeItemWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def collapsed(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_collapsed()
    return _ret
  @collapsed.setter
  def collapsed(self,  value:'bool'):
    self.set_collapsed(value)
  @property
  def visible(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_visible()
    return _ret
  @visible.setter
  def visible(self,  value:'bool'):
    self.set_visible(value)
  @property
  def disable_folding(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_folding_disabled()
    return _ret
  @disable_folding.setter
  def disable_folding(self,  value:'bool'):
    self.set_disable_folding(value)
  @property
  def custom_minimum_height(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_custom_minimum_height()
    return _ret
  @custom_minimum_height.setter
  def custom_minimum_height(self,  value:'int'):
    self.set_custom_minimum_height(value)
  @functools.native_method
  def set_cell_mode(self, column:'int'   , mode:'int'  ) -> None:
    r'''
				Sets the given column's cell mode to `mode`. This determines how the cell is displayed and edited.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(mode, (int, float)), 'mode must be int or float'








    self._ptr.call_with_return(49,tuple([column, mode]))

  @functools.native_method
  def get_cell_mode(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the column's cell mode.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(50,tuple([column]))
    return _ret


  @functools.native_method
  def set_auto_translate_mode(self, column:'int'   , mode:'int'  ) -> None:
    r'''
				Sets the given column's auto translate mode to `mode`.
				All columns use `constant Node.AUTO_TRANSLATE_MODE_INHERIT` by default, which uses the same auto translate mode as the `Tree` itself.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(mode, (int, float)), 'mode must be int or float'








    self._ptr.call_with_return(51,tuple([column, mode]))

  @functools.native_method
  def get_auto_translate_mode(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the column's auto translate mode.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(52,tuple([column]))
    return _ret


  @functools.native_method
  def set_edit_multiline(self, column:'int'   , multiline:'bool'   ) -> None:
    r'''
				If `multiline` is `true`, the given `column` is multiline editable.
				**Note:** This option only affects the type of control (`LineEdit` or `TextEdit`) that appears when editing the column. You can set multiline values with `set_text` even if the column is not multiline editable.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(multiline, bool), 'multiline must be bool'








    self._ptr.call_with_return(53,tuple([column, multiline]))

  @functools.native_method
  def is_edit_multiline(self, column:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given `column` is multiline editable.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(54,tuple([column]))
    return _ret


  @functools.native_method
  def set_checked(self, column:'int'   , checked:'bool'   ) -> None:
    r'''
				If `checked` is `true`, the given `column` is checked. Clears column's indeterminate status.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(checked, bool), 'checked must be bool'








    self._ptr.call_with_return(55,tuple([column, checked]))

  @functools.native_method
  def set_indeterminate(self, column:'int'   , indeterminate:'bool'   ) -> None:
    r'''
				If `indeterminate` is `true`, the given `column` is marked indeterminate.
				**Note:** If set `true` from `false`, then column is cleared of checked status.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(indeterminate, bool), 'indeterminate must be bool'








    self._ptr.call_with_return(56,tuple([column, indeterminate]))

  @functools.native_method
  def is_checked(self, column:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given `column` is checked.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([column]))
    return _ret


  @functools.native_method
  def is_indeterminate(self, column:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given `column` is indeterminate.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(58,tuple([column]))
    return _ret


  @functools.native_method
  def propagate_check(self, column:'int'   , emit_signal:'bool' =True  ) -> None:
    r'''
				Propagates this item's checked status to its children and parents for the given `column`. It is possible to process the items affected by this method call by connecting to `signal Tree.check_propagated_to_item`. The order that the items affected will be processed is as follows: the item invoking this method, children of that item, and finally parents of that item. If `emit_signal` is `false`, then `signal Tree.check_propagated_to_item` will not be emitted.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(emit_signal, bool), 'emit_signal must be bool'








    self._ptr.call_with_return(59,tuple([column, emit_signal]))

  @functools.native_method
  def set_text(self, column:'int'   , text:'str'   ) -> None:
    r'''
				Sets the given column's text value.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'






    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    self._ptr.call_with_return(60,tuple([column, py_string_text._ptr]))

  @functools.native_method
  def get_text(self, column:'int'   ) -> typing.Union[str]:
    r'''
				Returns the given column's text.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([column]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_description(self, column:'int'   , description:'str'   ) -> None:
    r'''
				Sets the given column's description for assistive apps.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not description is None)
    assert isinstance(description, (str, String)), 'description must be str or String'






    assert(isinstance(description, (str, String)))
    py_string_description = description if isinstance(description, StringName) else c_utils.py_string_to_string(description)

    self._ptr.call_with_return(62,tuple([column, py_string_description._ptr]))

  @functools.native_method
  def get_description(self, column:'int'   ) -> typing.Union[str]:
    r'''
				Returns the given column's description for assistive apps.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(63,tuple([column]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_text_direction(self, column:'int'   , direction:'int'  ) -> None:
    r'''
				Sets item's text base writing direction.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(direction, (int, float)), 'direction must be int or float'








    self._ptr.call_with_return(64,tuple([column, direction]))

  @functools.native_method
  def get_text_direction(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns item's text base writing direction.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(65,tuple([column]))
    return _ret


  @functools.native_method
  def set_autowrap_mode(self, column:'int'   , autowrap_mode:'int'  ) -> None:
    r'''
				Sets the autowrap mode in the given `column`. If set to something other than `constant TextServer.AUTOWRAP_OFF`, the text gets wrapped inside the cell's bounding rectangle.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(autowrap_mode, (int, float)), 'autowrap_mode must be int or float'








    self._ptr.call_with_return(66,tuple([column, autowrap_mode]))

  @functools.native_method
  def get_autowrap_mode(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the text autowrap mode in the given `column`. By default it is `constant TextServer.AUTOWRAP_OFF`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(67,tuple([column]))
    return _ret


  @functools.native_method
  def set_text_overrun_behavior(self, column:'int'   , overrun_behavior:'int'  ) -> None:
    r'''
				Sets the clipping behavior when the text exceeds the item's bounding rectangle in the given `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(overrun_behavior, (int, float)), 'overrun_behavior must be int or float'








    self._ptr.call_with_return(68,tuple([column, overrun_behavior]))

  @functools.native_method
  def get_text_overrun_behavior(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the clipping behavior when the text exceeds the item's bounding rectangle in the given `column`. By default it is `constant TextServer.OVERRUN_TRIM_ELLIPSIS`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(69,tuple([column]))
    return _ret


  @functools.native_method
  def set_structured_text_bidi_override(self, column:'int'   , parser:'int'  ) -> None:
    r'''
				Set BiDi algorithm override for the structured text. Has effect for cells that display text.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(parser, (int, float)), 'parser must be int or float'








    self._ptr.call_with_return(70,tuple([column, parser]))

  @functools.native_method
  def get_structured_text_bidi_override(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the BiDi algorithm override set for this cell.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(71,tuple([column]))
    return _ret


  @functools.native_method
  def set_structured_text_bidi_override_options(self, column:'int'   , args:'Array'   ) -> None:
    r'''
				Set additional options for BiDi override. Has effect for cells that display text.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not args is None)
    assert isinstance(args, Array), 'args must be Array'








    self._ptr.call_with_return(72,tuple([column, args._ptr]))

  @functools.native_method
  def get_structured_text_bidi_override_options(self, column:'int'   ) -> typing.Union['Array']:
    r'''
				Returns the additional BiDi options set for this cell.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(73,tuple([column]))
    return _ret


  @functools.native_method
  def set_language(self, column:'int'   , language:'str'   ) -> None:
    r'''
				Sets the language code of the given `column`'s text to `language`. This is used for line-breaking and text shaping algorithms. If `language` is empty, the current locale is used.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'






    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    self._ptr.call_with_return(74,tuple([column, py_string_language._ptr]))

  @functools.native_method
  def get_language(self, column:'int'   ) -> typing.Union[str]:
    r'''
				Returns item's text language code.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(75,tuple([column]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_suffix(self, column:'int'   , text:'str'   ) -> None:
    r'''
				Sets a string to be shown after a column's value (for example, a unit abbreviation).
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'






    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    self._ptr.call_with_return(76,tuple([column, py_string_text._ptr]))

  @functools.native_method
  def get_suffix(self, column:'int'   ) -> typing.Union[str]:
    r'''
				Gets the suffix string shown after the column value.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(77,tuple([column]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_icon(self, column:'int'   , texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets the given cell's icon `Texture2D`. If the cell is in `constant CELL_MODE_ICON` mode, the icon is displayed in the center of the cell. Otherwise, the icon is displayed before the cell's text. `constant CELL_MODE_RANGE` does not display an icon.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'








    self._ptr.call_with_return(78,tuple([column, texture._ptr]))

  @functools.native_method
  def get_icon(self, column:'int'   ) -> typing.Any:
    r'''
				Returns the given column's icon `Texture2D`. Error if no icon is set.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(79,tuple([column]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_icon_overlay(self, column:'int'   , texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets the given cell's icon overlay `Texture2D`. The cell has to be in `constant CELL_MODE_ICON` mode, and icon has to be set. Overlay is drawn on top of icon, in the bottom left corner.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'








    self._ptr.call_with_return(80,tuple([column, texture._ptr]))

  @functools.native_method
  def get_icon_overlay(self, column:'int'   ) -> typing.Any:
    r'''
				Returns the given column's icon overlay `Texture2D`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(81,tuple([column]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_icon_region(self, column:'int'   , region:'Rect2'   ) -> None:
    r'''
				Sets the given column's icon's texture region.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not region is None)
    assert isinstance(region, Rect2), 'region must be Rect2'








    self._ptr.call_with_return(82,tuple([column, region._ptr]))

  @functools.native_method
  def get_icon_region(self, column:'int'   ) -> typing.Union['Rect2']:
    r'''
				Returns the icon `Texture2D` region as `Rect2`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(83,tuple([column]))
    return _ret


  @functools.native_method
  def set_icon_max_width(self, column:'int'   , width:'int'   ) -> None:
    r'''
				Sets the maximum allowed width of the icon in the given `column`. This limit is applied on top of the default size of the icon and on top of `theme_item Tree.icon_max_width`. The height is adjusted according to the icon's ratio.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'








    self._ptr.call_with_return(84,tuple([column, width]))

  @functools.native_method
  def get_icon_max_width(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the maximum allowed width of the icon in the given `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([column]))
    return _ret


  @functools.native_method
  def set_icon_modulate(self, column:'int'   , modulate:'Color'   ) -> None:
    r'''
				Modulates the given column's icon with `modulate`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not modulate is None)
    assert isinstance(modulate, Color), 'modulate must be Color'








    self._ptr.call_with_return(86,tuple([column, modulate._ptr]))

  @functools.native_method
  def get_icon_modulate(self, column:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the `Color` modulating the column's icon.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([column]))
    return _ret


  @functools.native_method
  def set_range(self, column:'int'   , value:'float'   ) -> None:
    r'''
				Sets the value of a `constant CELL_MODE_RANGE` column.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(88,tuple([column, value]))

  @functools.native_method
  def get_range(self, column:'int'   ) -> typing.Union[float]:
    r'''
				Returns the value of a `constant CELL_MODE_RANGE` column.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([column]))
    return _ret


  @functools.native_method
  def set_range_config(self, column:'int'   , min:'float'   , max:'float'   , step:'float'   , expr:'bool' =False  ) -> None:
    r'''
				Sets the range of accepted values for a column. The column must be in the `constant CELL_MODE_RANGE` mode.
				If `expr` is `true`, the edit mode slider will use an exponential scale as with `Range.exp_edit`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(min, (int, float)), 'min must be int or float'
    assert isinstance(max, (int, float)), 'max must be int or float'
    assert isinstance(step, (int, float)), 'step must be int or float'
    assert isinstance(expr, bool), 'expr must be bool'











    self._ptr.call_with_return(90,tuple([column, min, max, step, expr]))

  @functools.native_method
  def get_range_config(self, column:'int'   ) -> typing.Union['Dictionary']:
    r'''
				Returns a dictionary containing the range parameters for a given column. The keys are "min", "max", "step", and "expr".
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([column]))
    return _ret


  @functools.native_method
  def set_metadata(self, column:'int'   , meta:'object'   ) -> None:
    r'''
				Sets the metadata value for the given column, which can be retrieved later using `get_metadata`. This can be used, for example, to store a reference to the original data.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    

    if not (type(meta).__name__ in py4godot.variant_types.core_types or isinstance(meta, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'meta': "
                f"{type(meta).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    self._ptr.call_with_return(92,tuple([column, meta]))

  @functools.native_method
  def get_metadata(self, column:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the metadata value that was set for the given column using `set_metadata`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = None
    _ret = self._ptr.call_with_return(93,tuple([column]))
    return _ret


  @functools.native_method
  def set_custom_draw(self, column:'int'   , object_:'py4godot_object.Object'   , callback:'object'   ) -> None:
    r'''
				Sets the given column's custom draw callback to the `callback` method on `object`.
				The method named `callback` should accept two arguments: the `TreeItem` that is drawn and its position and size as a `Rect2`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not callback is None)
    assert isinstance(callback, (str, StringName)), 'callback must be str or StringName'







    assert(isinstance(callback, (str, StringName)))
    py_stringname_callback = callback if isinstance(callback, StringName) else c_utils.py_string_to_string_name(callback)

    self._ptr.call_with_return(94,tuple([column, object_._ptr, py_stringname_callback._ptr]))

  @functools.native_method
  def set_custom_draw_callback(self, column:'int'   , callback:'Callable'   ) -> None:
    r'''
				Sets the given column's custom draw callback. Use an empty `Callable` (`code skip-lint`Callable()`) to clear the custom callback. The cell has to be in `constant CELL_MODE_CUSTOM` to use this feature.
				The `callback` should accept two arguments: the `TreeItem` that is drawn and its position and size as a `Rect2`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'








    self._ptr.call_with_return(95,tuple([column, callback._ptr]))

  @functools.native_method
  def get_custom_draw_callback(self, column:'int'   ) -> typing.Union['Callable']:
    r'''
				Returns the custom callback of column `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = Callable.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([column]))
    return _ret


  @functools.native_method
  def set_collapsed(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__collapsed = enable






    self._ptr.call_with_return(97,tuple([enable]))

  @functools.native_method
  def is_collapsed(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(98,tuple([]))

    return _ret


  @functools.native_method
  def set_collapsed_recursive(self, enable:'bool'   ) -> None:
    r'''
				Collapses or uncollapses this `TreeItem` and all the descendants of this item.
			'''

    assert isinstance(enable, bool), 'enable must be bool'







    self._ptr.call_with_return(99,tuple([enable]))

  @functools.native_method
  def is_any_collapsed(self, only_visible:'bool' =False  ) -> typing.Union[bool]:
    r'''
				Returns `true` if this `TreeItem`, or any of its descendants, is collapsed.
				If `only_visible` is `true` it ignores non-visible `TreeItem`s.
			'''

    assert isinstance(only_visible, bool), 'only_visible must be bool'







    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([only_visible]))
    return _ret


  @functools.native_method
  def set_visible(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__visible = enable






    self._ptr.call_with_return(101,tuple([enable]))

  @functools.native_method
  def is_visible(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([]))

    return _ret


  @functools.native_method
  def is_visible_in_tree(self) -> typing.Union[bool]:
    r'''
				Returns `true` if `visible` is `true` and all its ancestors are also visible.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([]))
    return _ret


  @functools.native_method
  def uncollapse_tree(self) -> None:
    r'''
				Uncollapses all `TreeItem`s necessary to reveal this `TreeItem`, i.e. all ancestor `TreeItem`s.
			'''




    self._ptr.call_with_return(104,tuple([]))

  @functools.native_method
  def set_custom_minimum_height(self, height:'int'   ) -> None:
    r''''''

    assert isinstance(height, (int, float)), 'height must be int or float'


    self.py__custom_minimum_height = height






    self._ptr.call_with_return(105,tuple([height]))

  @functools.native_method
  def get_custom_minimum_height(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(106,tuple([]))

    return _ret


  @functools.native_method
  def set_selectable(self, column:'int'   , selectable:'bool'   ) -> None:
    r'''
				If `selectable` is `true`, the given `column` is selectable.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(selectable, bool), 'selectable must be bool'








    self._ptr.call_with_return(107,tuple([column, selectable]))

  @functools.native_method
  def is_selectable(self, column:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given `column` is selectable.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(108,tuple([column]))
    return _ret


  @functools.native_method
  def is_selected(self, column:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given `column` is selected.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(109,tuple([column]))
    return _ret


  @functools.native_method
  def select(self, column:'int'   ) -> None:
    r'''
				Selects the given `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    self._ptr.call_with_return(110,tuple([column]))

  @functools.native_method
  def deselect(self, column:'int'   ) -> None:
    r'''
				Deselects the given column.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    self._ptr.call_with_return(111,tuple([column]))

  @functools.native_method
  def set_editable(self, column:'int'   , enabled:'bool'   ) -> None:
    r'''
				If `enabled` is `true`, the given `column` is editable.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(112,tuple([column, enabled]))

  @functools.native_method
  def is_editable(self, column:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given `column` is editable.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(113,tuple([column]))
    return _ret


  @functools.native_method
  def set_custom_color(self, column:'int'   , color:'Color'   ) -> None:
    r'''
				Sets the given column's custom color.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'








    self._ptr.call_with_return(114,tuple([column, color._ptr]))

  @functools.native_method
  def get_custom_color(self, column:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the custom color of column `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(115,tuple([column]))
    return _ret


  @functools.native_method
  def clear_custom_color(self, column:'int'   ) -> None:
    r'''
				Resets the color for the given column to default.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    self._ptr.call_with_return(116,tuple([column]))

  @functools.native_method
  def set_custom_font(self, column:'int'   , font:'py4godot_font.Font'   ) -> None:
    r'''
				Sets custom font used to draw text in the given `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'








    self._ptr.call_with_return(117,tuple([column, font._ptr]))

  @functools.native_method
  def get_custom_font(self, column:'int'   ) -> typing.Union['py4godot_systemfont.SystemFont','py4godot_fontfile.FontFile','py4godot_fontvariation.FontVariation','py4godot_font.Font']:
    r'''
				Returns custom font used to draw text in the column `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Font
    _ret._ptr = self._ptr.call_with_return(118,tuple([column]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_custom_font_size(self, column:'int'   , font_size:'int'   ) -> None:
    r'''
				Sets custom font size used to draw text in the given `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'








    self._ptr.call_with_return(119,tuple([column, font_size]))

  @functools.native_method
  def get_custom_font_size(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns custom font size used to draw text in the column `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(120,tuple([column]))
    return _ret


  @functools.native_method
  def set_custom_bg_color(self, column:'int'   , color:'Color'   , just_outline:'bool' =False  ) -> None:
    r'''
				Sets the given column's custom background color and whether to just use it as an outline.
				**Note:** If a custom `StyleBox` is set, the background color will be drawn behind it.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(just_outline, bool), 'just_outline must be bool'









    self._ptr.call_with_return(121,tuple([column, color._ptr, just_outline]))

  @functools.native_method
  def clear_custom_bg_color(self, column:'int'   ) -> None:
    r'''
				Resets the background color for the given column to default.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    self._ptr.call_with_return(122,tuple([column]))

  @functools.native_method
  def get_custom_bg_color(self, column:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the custom background color of column `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(123,tuple([column]))
    return _ret


  @functools.native_method
  def set_custom_as_button(self, column:'int'   , enable:'bool'   ) -> None:
    r'''
				Makes a cell with `constant CELL_MODE_CUSTOM` display as a non-flat button with a `StyleBox`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'








    self._ptr.call_with_return(124,tuple([column, enable]))

  @functools.native_method
  def is_custom_set_as_button(self, column:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the cell was made into a button with `set_custom_as_button`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(125,tuple([column]))
    return _ret


  @functools.native_method
  def clear_buttons(self) -> None:
    r'''
				Removes all buttons from all columns of this item.
			'''




    self._ptr.call_with_return(126,tuple([]))

  @functools.native_method
  def add_button(self, column:'int'   , button:'py4godot_texture2d.Texture2D'   , id:'int' =-1  , disabled:'bool' =False  , tooltip_text:'str' =""  , description:'str' =""  ) -> None:
    r'''
				Adds a button with `Texture2D` `button` to the end of the cell at column `column`. The `id` is used to identify the button in the according `signal Tree.button_clicked` signal and can be different from the buttons index. If not specified, the next available index is used, which may be retrieved by calling `get_button_count` immediately before this method. Optionally, the button can be `disabled` and have a `tooltip_text`. `description` is used as the button description for assistive apps.
			'''
    if tooltip_text is None:
      tooltip_text = String.new0()
    if description is None:
      description = String.new0()

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not button is None)
    assert isinstance(button, get_class('Texture2D')), 'button must be Texture2D'
    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(disabled, bool), 'disabled must be bool'









    assert(isinstance(tooltip_text, (str, String)))
    py_string_tooltip_text = tooltip_text if isinstance(tooltip_text, StringName) else c_utils.py_string_to_string(tooltip_text)
    assert(isinstance(description, (str, String)))
    py_string_description = description if isinstance(description, StringName) else c_utils.py_string_to_string(description)

    self._ptr.call_with_return(127,tuple([column, button._ptr, id, disabled, py_string_tooltip_text._ptr, py_string_description._ptr]))

  @functools.native_method
  def get_button_count(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the number of buttons in column `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(128,tuple([column]))
    return _ret


  @functools.native_method
  def get_button_tooltip_text(self, column:'int'   , button_index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the tooltip text for the button at index `button_index` in column `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(button_index, (int, float)), 'button_index must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(129,tuple([column, button_index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_button_id(self, column:'int'   , button_index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the ID for the button at index `button_index` in column `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(button_index, (int, float)), 'button_index must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(130,tuple([column, button_index]))
    return _ret


  @functools.native_method
  def get_button_by_id(self, column:'int'   , id:'int'   ) -> typing.Union[int]:
    r'''
				Returns the button index if there is a button with ID `id` in column `column`, otherwise returns -1.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(id, (int, float)), 'id must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(131,tuple([column, id]))
    return _ret


  @functools.native_method
  def get_button_color(self, column:'int'   , id:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the color of the button with ID `id` in column `column`. If the specified button does not exist, returns `constant Color.BLACK`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(id, (int, float)), 'id must be int or float'








    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(132,tuple([column, id]))
    return _ret


  @functools.native_method
  def get_button(self, column:'int'   , button_index:'int'   ) -> typing.Any:
    r'''
				Returns the `Texture2D` of the button at index `button_index` in column `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(button_index, (int, float)), 'button_index must be int or float'








    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(133,tuple([column, button_index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_button_tooltip_text(self, column:'int'   , button_index:'int'   , tooltip:'str'   ) -> None:
    r'''
				Sets the tooltip text for the button at index `button_index` in the given `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(button_index, (int, float)), 'button_index must be int or float'
    assert(not tooltip is None)
    assert isinstance(tooltip, (str, String)), 'tooltip must be str or String'







    assert(isinstance(tooltip, (str, String)))
    py_string_tooltip = tooltip if isinstance(tooltip, StringName) else c_utils.py_string_to_string(tooltip)

    self._ptr.call_with_return(134,tuple([column, button_index, py_string_tooltip._ptr]))

  @functools.native_method
  def set_button(self, column:'int'   , button_index:'int'   , button:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets the given column's button `Texture2D` at index `button_index` to `button`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(button_index, (int, float)), 'button_index must be int or float'
    assert(not button is None)
    assert isinstance(button, get_class('Texture2D')), 'button must be Texture2D'









    self._ptr.call_with_return(135,tuple([column, button_index, button._ptr]))

  @functools.native_method
  def erase_button(self, column:'int'   , button_index:'int'   ) -> None:
    r'''
				Removes the button at index `button_index` in column `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(button_index, (int, float)), 'button_index must be int or float'








    self._ptr.call_with_return(136,tuple([column, button_index]))

  @functools.native_method
  def set_button_description(self, column:'int'   , button_index:'int'   , description:'str'   ) -> None:
    r'''
				Sets the given column's button description at index `button_index` for assistive apps.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(button_index, (int, float)), 'button_index must be int or float'
    assert(not description is None)
    assert isinstance(description, (str, String)), 'description must be str or String'







    assert(isinstance(description, (str, String)))
    py_string_description = description if isinstance(description, StringName) else c_utils.py_string_to_string(description)

    self._ptr.call_with_return(137,tuple([column, button_index, py_string_description._ptr]))

  @functools.native_method
  def set_button_disabled(self, column:'int'   , button_index:'int'   , disabled:'bool'   ) -> None:
    r'''
				If `true`, disables the button at index `button_index` in the given `column`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(button_index, (int, float)), 'button_index must be int or float'
    assert isinstance(disabled, bool), 'disabled must be bool'









    self._ptr.call_with_return(138,tuple([column, button_index, disabled]))

  @functools.native_method
  def set_button_color(self, column:'int'   , button_index:'int'   , color:'Color'   ) -> None:
    r'''
				Sets the given column's button color at index `button_index` to `color`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(button_index, (int, float)), 'button_index must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'









    self._ptr.call_with_return(139,tuple([column, button_index, color._ptr]))

  @functools.native_method
  def is_button_disabled(self, column:'int'   , button_index:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the button at index `button_index` for the given `column` is disabled.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(button_index, (int, float)), 'button_index must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(140,tuple([column, button_index]))
    return _ret


  @functools.native_method
  def set_tooltip_text(self, column:'int'   , tooltip:'str'   ) -> None:
    r'''
				Sets the given column's tooltip text.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not tooltip is None)
    assert isinstance(tooltip, (str, String)), 'tooltip must be str or String'






    assert(isinstance(tooltip, (str, String)))
    py_string_tooltip = tooltip if isinstance(tooltip, StringName) else c_utils.py_string_to_string(tooltip)

    self._ptr.call_with_return(141,tuple([column, py_string_tooltip._ptr]))

  @functools.native_method
  def get_tooltip_text(self, column:'int'   ) -> typing.Union[str]:
    r'''
				Returns the given column's tooltip text.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(142,tuple([column]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_text_alignment(self, column:'int'   , text_alignment:'int'  ) -> None:
    r'''
				Sets the given column's text alignment to `text_alignment`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(text_alignment, (int, float)), 'text_alignment must be int or float'








    self._ptr.call_with_return(143,tuple([column, text_alignment]))

  @functools.native_method
  def get_text_alignment(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the given column's text alignment.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(144,tuple([column]))
    return _ret


  @functools.native_method
  def set_expand_right(self, column:'int'   , enable:'bool'   ) -> None:
    r'''
				If `enable` is `true`, the given `column` is expanded to the right.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'








    self._ptr.call_with_return(145,tuple([column, enable]))

  @functools.native_method
  def get_expand_right(self, column:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if `expand_right` is set.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(146,tuple([column]))
    return _ret


  @functools.native_method
  def set_disable_folding(self, disable:'bool'   ) -> None:
    r''''''

    assert isinstance(disable, bool), 'disable must be bool'


    self.py__disable_folding = disable






    self._ptr.call_with_return(147,tuple([disable]))

  @functools.native_method
  def is_folding_disabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(148,tuple([]))

    return _ret


  @functools.native_method
  def create_child(self, index:'int' =-1  ) -> typing.Union['typing.Self']:
    r'''
				Creates an item and adds it as a child.
				The new item will be inserted as position `index` (the default value `-1` means the last position), or it will be the last child if `index` is higher than the child count.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = TreeItem.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(149,tuple([index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def add_child(self, child:'TreeItem'   ) -> None:
    r'''
				Adds a previously unparented `TreeItem` as a direct child of this one. The `child` item must not be a part of any `Tree` or parented to any `TreeItem`. See also `remove_child`.
			'''

    assert(not child is None)
    assert isinstance(child, get_class('TreeItem')), 'child must be TreeItem'







    self._ptr.call_with_return(150,tuple([child._ptr]))

  @functools.native_method
  def remove_child(self, child:'TreeItem'   ) -> None:
    r'''
				Removes the given child `TreeItem` and all its children from the `Tree`. Note that it doesn't free the item from memory, so it can be reused later (see `add_child`). To completely remove a `TreeItem` use `Object.free`.
				**Note:** If you want to move a child from one `Tree` to another, then instead of removing and adding it manually you can use `move_before` or `move_after`.
			'''

    assert(not child is None)
    assert isinstance(child, get_class('TreeItem')), 'child must be TreeItem'







    self._ptr.call_with_return(151,tuple([child._ptr]))

  @functools.native_method
  def get_tree(self) -> typing.Union['py4godot_tree.Tree']:
    r'''
				Returns the `Tree` that owns this TreeItem.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Tree
    _ret._ptr = self._ptr.call_with_return(152,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_next(self) -> typing.Union['typing.Self']:
    r'''
				Returns the next sibling TreeItem in the tree or a `null` object if there is none.
			'''




    _ret = TreeItem.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(153,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_prev(self) -> typing.Union['typing.Self']:
    r'''
				Returns the previous sibling TreeItem in the tree or a `null` object if there is none.
			'''




    _ret = TreeItem.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(154,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_parent(self) -> typing.Union['typing.Self']:
    r'''
				Returns the parent TreeItem or a `null` object if there is none.
			'''




    _ret = TreeItem.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(155,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_first_child(self) -> typing.Union['typing.Self']:
    r'''
				Returns the TreeItem's first child.
			'''




    _ret = TreeItem.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(156,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_next_in_tree(self, wrap:'bool' =False  ) -> typing.Union['typing.Self']:
    r'''
				Returns the next TreeItem in the tree (in the context of a depth-first search) or a `null` object if there is none.
				If `wrap` is enabled, the method will wrap around to the first element in the tree when called on the last element, otherwise it returns `null`.
			'''

    assert isinstance(wrap, bool), 'wrap must be bool'







    _ret = TreeItem.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(157,tuple([wrap]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_prev_in_tree(self, wrap:'bool' =False  ) -> typing.Union['typing.Self']:
    r'''
				Returns the previous TreeItem in the tree (in the context of a depth-first search) or a `null` object if there is none.
				If `wrap` is enabled, the method will wrap around to the last element in the tree when called on the first visible element, otherwise it returns `null`.
			'''

    assert isinstance(wrap, bool), 'wrap must be bool'







    _ret = TreeItem.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(158,tuple([wrap]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_next_visible(self, wrap:'bool' =False  ) -> typing.Union['typing.Self']:
    r'''
				Returns the next visible TreeItem in the tree (in the context of a depth-first search) or a `null` object if there is none.
				If `wrap` is enabled, the method will wrap around to the first visible element in the tree when called on the last visible element, otherwise it returns `null`.
			'''

    assert isinstance(wrap, bool), 'wrap must be bool'







    _ret = TreeItem.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(159,tuple([wrap]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_prev_visible(self, wrap:'bool' =False  ) -> typing.Union['typing.Self']:
    r'''
				Returns the previous visible sibling TreeItem in the tree (in the context of a depth-first search) or a `null` object if there is none.
				If `wrap` is enabled, the method will wrap around to the last visible element in the tree when called on the first visible element, otherwise it returns `null`.
			'''

    assert isinstance(wrap, bool), 'wrap must be bool'







    _ret = TreeItem.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(160,tuple([wrap]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_child(self, index:'int'   ) -> typing.Union['typing.Self']:
    r'''
				Returns a child item by its `index` (see `get_child_count`). This method is often used for iterating all children of an item.
				Negative indices access the children from the last one.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = TreeItem.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(161,tuple([index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_child_count(self) -> typing.Union[int]:
    r'''
				Returns the number of child items.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(162,tuple([]))
    return _ret


  @functools.native_method
  def get_children(self) -> typing.Union['py4godot_treeitemtypedarray.TreeItemTypedArray']:
    r'''
				Returns an array of references to the item's children.
			'''




    _ret = py4godot_treeitemtypedarray.TreeItemTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(163,tuple([]))
    return _ret


  @functools.native_method
  def get_index(self) -> typing.Union[int]:
    r'''
				Returns the node's order in the tree. For example, if called on the first child item the position is `0`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(164,tuple([]))
    return _ret


  @functools.native_method
  def move_before(self, item:'TreeItem'   ) -> None:
    r'''
				Moves this TreeItem right before the given `item`.
				**Note:** You can't move to the root or move the root.
			'''

    assert(not item is None)
    assert isinstance(item, get_class('TreeItem')), 'item must be TreeItem'







    self._ptr.call_with_return(165,tuple([item._ptr]))

  @functools.native_method
  def move_after(self, item:'TreeItem'   ) -> None:
    r'''
				Moves this TreeItem right after the given `item`.
				**Note:** You can't move to the root or move the root.
			'''

    assert(not item is None)
    assert isinstance(item, get_class('TreeItem')), 'item must be TreeItem'







    self._ptr.call_with_return(166,tuple([item._ptr]))

  @functools.native_method
  def call_recursive(self, method:'object'   , *varargs) -> None:
    r'''
				Calls the `method` on the actual TreeItem and its children recursively. Pass parameters as a comma separated list.
			'''

    assert(not method is None)
    assert isinstance(method, (str, StringName)), 'method must be str or StringName'

    for arg in varargs:
      if not (type(arg).__name__ in py4godot.variant_types.core_types or isinstance(arg, classes.Object.Object)):
        raise ValueError(
            f"Unsupported type in varargs: {type(arg).__name__}. "
            "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
            "and built-in types int, float, and bool."
        )



    assert(isinstance(method, (str, StringName)))
    py_stringname_method = method if isinstance(method, StringName) else c_utils.py_string_to_string_name(method)

    self._ptr.call_with_return(167,tuple([py_stringname_method._ptr, *varargs]))


register_cast_function('TreeItem', TreeItem.cast)
register_class('TreeItem', TreeItem)
