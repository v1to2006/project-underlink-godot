# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ImageTextureLayered as py4godot_imagetexturelayered 
  import py4godot.classes.CompressedCubemap as py4godot_compressedcubemap 
  import py4godot.classes.CompressedCubemapArray as py4godot_compressedcubemaparray 
  import py4godot.classes.PlaceholderCubemapArray as py4godot_placeholdercubemaparray 
  import py4godot.classes.TextureLayered as py4godot_texturelayered 
  import py4godot.classes.TextureLayeredTypedArray as py4godot_texturelayeredtypedarray 
  import py4godot.classes.CompressedTexture2DArray as py4godot_compressedtexture2darray 
  import py4godot.classes.Texture2DArrayRD as py4godot_texture2darrayrd 
  import py4godot.classes.PlaceholderTexture2DArray as py4godot_placeholdertexture2darray 
  import py4godot.classes.TextureCubemapArrayRD as py4godot_texturecubemaparrayrd 
  import py4godot.classes.CubemapArray as py4godot_cubemaparray 
  import py4godot.classes.PlaceholderCubemap as py4godot_placeholdercubemap 
  import py4godot.classes.TextureLayeredRD as py4godot_texturelayeredrd 
  import py4godot.classes.Cubemap as py4godot_cubemap 
  import py4godot.classes.TextureCubemapRD as py4godot_texturecubemaprd 
  import py4godot.classes.PlaceholderTextureLayered as py4godot_placeholdertexturelayered 
  import py4godot.classes.Texture2DArray as py4godot_texture2darray 
  import py4godot.classes.CompressedTextureLayered as py4godot_compressedtexturelayered 
import py4godot.classes.Resource as py4godot_resource 
import py4godot.classes.TextureLayeredTypedArray as py4godot_texturelayeredtypedarray 
from py4godot.wrappers.wrappers import CPPLightmapGIDataWrapper

class ShadowmaskMode:
  SHADOWMASK_MODE_NONE = 0
  SHADOWMASK_MODE_REPLACE = 1
  SHADOWMASK_MODE_OVERLAY = 2


class LightmapGIData(py4godot_resource.Resource):
  r'''
		`LightmapGIData` contains baked lightmap and dynamic object probe data for `LightmapGI`. It is replaced every time lightmaps are baked in `LightmapGI`.
	'''

  @staticmethod
  def constructor():
    class_ = LightmapGIData.construct_without_init()
    class_._ptr = constructor(453,0, ())
    return class_
  @staticmethod
  def new():
    class_ = LightmapGIData.construct_without_init()
    class_._ptr = constructor(453,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPLightmapGIDataWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(453,0, ())


  def generate_wrapper(self):
    return CPPLightmapGIDataWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = LightmapGIData.__new__(LightmapGIData)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'LightmapGIData'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(89, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = LightmapGIData.construct_without_init()
    cls._ptr = CPPLightmapGIDataWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = LightmapGIData.construct_without_init()
    cls._ptr = CPPLightmapGIDataWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def lightmap_textures(self) -> typing.Union['py4godot_texturelayeredtypedarray.TextureLayeredTypedArray']:
    r''''''
    _ret = self. get_lightmap_textures()
    return _ret
  @lightmap_textures.setter
  def lightmap_textures(self, value:'Array'):
    self.set_lightmap_textures(value)
  @property
  def shadowmask_textures(self) -> typing.Union['py4godot_texturelayeredtypedarray.TextureLayeredTypedArray']:
    r''''''
    _ret = self. get_shadowmask_textures()
    return _ret
  @shadowmask_textures.setter
  def shadowmask_textures(self, value:'Array'):
    self.set_shadowmask_textures(value)
  @property
  def uses_spherical_harmonics(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_spherical_harmonics()
    return _ret
  @uses_spherical_harmonics.setter
  def uses_spherical_harmonics(self,  value:'bool'):
    self.set_uses_spherical_harmonics(value)
  @property
  def user_data(self) -> typing.Union['Array']:
    r''''''
    _ret = self. _get_user_data()
    return _ret
  @user_data.setter
  def user_data(self,  value:'Array'):
    self._set_user_data(value)
  @property
  def probe_data(self) -> typing.Union['Dictionary']:
    r''''''
    _ret = self. _get_probe_data()
    return _ret
  @probe_data.setter
  def probe_data(self,  value:'Dictionary'):
    self._set_probe_data(value)
  @property
  def light_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_light_texture()
    return _ret
  @light_texture.setter
  def light_texture(self,  value:'py4godot_object.Object'):
    self.set_light_texture(value)
  @property
  def light_textures(self) -> typing.Union['Array']:
    r''''''
    _ret = self. _get_light_textures_data()
    return _ret
  @light_textures.setter
  def light_textures(self,  value:'Array'):
    self._set_light_textures_data(value)
  @functools.native_method
  def set_lightmap_textures(self, light_textures:'py4godot_texturelayeredtypedarray.TextureLayeredTypedArray'   ) -> None:
    r''''''

    assert isinstance(light_textures, Array), 'light_textures must be Array'


    self.py__lightmap_textures = light_textures






    self._ptr.call_with_return(77,tuple([light_textures._ptr]))

  @functools.native_method
  def get_lightmap_textures(self) -> typing.Union['py4godot_texturelayeredtypedarray.TextureLayeredTypedArray']:
    r''''''




    _ret = py4godot_texturelayeredtypedarray.TextureLayeredTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([]))

    return _ret


  @functools.native_method
  def set_shadowmask_textures(self, shadowmask_textures:'py4godot_texturelayeredtypedarray.TextureLayeredTypedArray'   ) -> None:
    r''''''

    assert isinstance(shadowmask_textures, Array), 'shadowmask_textures must be Array'


    self.py__shadowmask_textures = shadowmask_textures






    self._ptr.call_with_return(79,tuple([shadowmask_textures._ptr]))

  @functools.native_method
  def get_shadowmask_textures(self) -> typing.Union['py4godot_texturelayeredtypedarray.TextureLayeredTypedArray']:
    r''''''




    _ret = py4godot_texturelayeredtypedarray.TextureLayeredTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))

    return _ret


  @functools.native_method
  def set_uses_spherical_harmonics(self, uses_spherical_harmonics:'bool'   ) -> None:
    r'''
				If `uses_spherical_harmonics` is `true`, tells the engine to treat the lightmap data as if it was baked with directional information.
				**Note:** Changing this value on already baked lightmaps will not cause them to be baked again. This means the material appearance will look incorrect until lightmaps are baked again, in which case the value set here is discarded as the entire `LightmapGIData` resource is replaced by the lightmapper.
			'''

    assert isinstance(uses_spherical_harmonics, bool), 'uses_spherical_harmonics must be bool'


    self.py__uses_spherical_harmonics = uses_spherical_harmonics






    self._ptr.call_with_return(81,tuple([uses_spherical_harmonics]))

  @functools.native_method
  def is_using_spherical_harmonics(self) -> typing.Union[bool]:
    r'''
				If `true`, lightmaps were baked with directional information. See also `LightmapGI.directional`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([]))

    return _ret


  @functools.native_method
  def add_user(self, path:'object'   , uv_scale:'Rect2'   , slice_index:'int'   , sub_instance:'int'   ) -> None:
    r'''
				Adds an object that is considered baked within this `LightmapGIData`.
			'''

    assert(not path is None)
    assert isinstance(path, (str, NodePath)), 'path must be str or NodePath'
    assert(not uv_scale is None)
    assert isinstance(uv_scale, Rect2), 'uv_scale must be Rect2'
    assert isinstance(slice_index, (int, float)), 'slice_index must be int or float'
    assert isinstance(sub_instance, (int, float)), 'sub_instance must be int or float'





    assert(isinstance(path, (str, NodePath)))
    py_nodepath_path = path if isinstance(path,NodePath) else NodePath.new2(path)




    self._ptr.call_with_return(83,tuple([py_nodepath_path._ptr, uv_scale._ptr, slice_index, sub_instance]))

  @functools.native_method
  def get_user_count(self) -> typing.Union[int]:
    r'''
				Returns the number of objects that are considered baked within this `LightmapGIData`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([]))
    return _ret


  @functools.native_method
  def get_user_path(self, user_idx:'int'   ) -> typing.Union['NodePath']:
    r'''
				Returns the `NodePath` of the baked object at index `user_idx`.
			'''

    assert isinstance(user_idx, (int, float)), 'user_idx must be int or float'







    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(85,tuple([user_idx]))
    return _ret


  @functools.native_method
  def clear_users(self) -> None:
    r'''
				Clear all objects that are considered baked within this `LightmapGIData`.
			'''




    self._ptr.call_with_return(86,tuple([]))

  @functools.native_method
  def set_light_texture(self, light_texture:'py4godot_texturelayered.TextureLayered'   ) -> None:
    r''''''

    assert(not light_texture is None)
    assert isinstance(light_texture, get_class('TextureLayered')), 'light_texture must be TextureLayered'


    self.py__light_texture = light_texture






    self._ptr.call_with_return(87,tuple([light_texture._ptr]))

  @functools.native_method
  def get_light_texture(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TextureLayered
    _ret._ptr = self._ptr.call_with_return(88,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('LightmapGIData', LightmapGIData.cast)
register_class('LightmapGIData', LightmapGIData)
