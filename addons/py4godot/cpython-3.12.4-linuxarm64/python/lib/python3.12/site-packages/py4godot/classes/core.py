# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
from py4godot.wrappers.wrappers import CPPStringWrapper


class String(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = String.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1032, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'str' ):
    assert(not from_ is None)
    assert isinstance(from_, (str, String)), 'from_ must be str or String'

    _class = String.construct_without_init()
    _class.constructed_from_python = True
    assert(isinstance(from_, (str, String)))
    py_string_from_ = from_ if isinstance(from_, StringName) else c_utils.py_string_to_string(from_)

    _class.py_string_from_ = py_string_from_
    _class._ptr = constructor(1032, 1, tuple([py_string_from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'StringName' ):
    assert(not from_ is None)
    assert isinstance(from_, (str, StringName)), 'from_ must be str or StringName'

    _class = String.construct_without_init()
    _class.constructed_from_python = True
    assert(isinstance(from_, (str, StringName)))
    py_stringname_from_ = from_ if isinstance(from_, StringName) else c_utils.py_string_to_string_name(from_)

    _class.py_stringname_from_ =py_stringname_from_
    _class._ptr = constructor(1032, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(from_:'NodePath' ):
    assert(not from_ is None)
    assert isinstance(from_, (str, NodePath)), 'from_ must be str or NodePath'

    _class = String.construct_without_init()
    _class.constructed_from_python = True
    assert(isinstance(from_, (str, NodePath)))
    py_nodepath_from_ = from_ if isinstance(from_,NodePath) else NodePath.new2(from_)

    _class.py_nodepath_from_ = py_nodepath_from_
    _class._ptr = constructor(1032, 3, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1032,0, ())

  def generate_wrapper(self):
    return CPPStringWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = String.__new__(String)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'String'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(110, ())
  def __str__(self):
    return utils.gd_string_to_py_string(self)


  @functools.native_method
  def casecmp_to(self, to:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'





    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)

    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([py_string_to._ptr]))
    return _ret


  @functools.native_method
  def nocasecmp_to(self, to:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'





    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)

    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([py_string_to._ptr]))
    return _ret


  @functools.native_method
  def naturalcasecmp_to(self, to:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'





    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)

    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([py_string_to._ptr]))
    return _ret


  @functools.native_method
  def naturalnocasecmp_to(self, to:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'





    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)

    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([py_string_to._ptr]))
    return _ret


  @functools.native_method
  def filecasecmp_to(self, to:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'





    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)

    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([py_string_to._ptr]))
    return _ret


  @functools.native_method
  def filenocasecmp_to(self, to:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'





    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)

    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([py_string_to._ptr]))
    return _ret


  @functools.native_method
  def length(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(6,tuple([]))
    return _ret


  @functools.native_method
  def substr(self, from_:'int'   , len_:'int' =-1  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(from_, (int, float)), 'from_ must be int or float'
    assert isinstance(len_, (int, float)), 'len_ must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([from_, len_]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_slice(self, delimiter:'str'   , slice:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not delimiter is None)
    assert isinstance(delimiter, (str, String)), 'delimiter must be str or String'
    assert isinstance(slice, (int, float)), 'slice must be int or float'





    assert(isinstance(delimiter, (str, String)))
    py_string_delimiter = delimiter if isinstance(delimiter, StringName) else c_utils.py_string_to_string(delimiter)


    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([py_string_delimiter._ptr, slice]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_slicec(self, delimiter:'int'   , slice:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(delimiter, (int, float)), 'delimiter must be int or float'
    assert isinstance(slice, (int, float)), 'slice must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(9,tuple([delimiter, slice]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_slice_count(self, delimiter:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not delimiter is None)
    assert isinstance(delimiter, (str, String)), 'delimiter must be str or String'





    assert(isinstance(delimiter, (str, String)))
    py_string_delimiter = delimiter if isinstance(delimiter, StringName) else c_utils.py_string_to_string(delimiter)

    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([py_string_delimiter._ptr]))
    return _ret


  @functools.native_method
  def find(self, what:'str'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)


    _ret = 0
    _ret = self._ptr.call_with_return(11,tuple([py_string_what._ptr, from_]))
    return _ret


  @functools.native_method
  def findn(self, what:'str'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)


    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([py_string_what._ptr, from_]))
    return _ret


  @functools.native_method
  def count(self, what:'str'   , from_:'int' =0  , to:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'
    assert isinstance(to, (int, float)), 'to must be int or float'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)



    _ret = 0
    _ret = self._ptr.call_with_return(13,tuple([py_string_what._ptr, from_, to]))
    return _ret


  @functools.native_method
  def countn(self, what:'str'   , from_:'int' =0  , to:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'
    assert isinstance(to, (int, float)), 'to must be int or float'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)



    _ret = 0
    _ret = self._ptr.call_with_return(14,tuple([py_string_what._ptr, from_, to]))
    return _ret


  @functools.native_method
  def rfind(self, what:'str'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)


    _ret = 0
    _ret = self._ptr.call_with_return(15,tuple([py_string_what._ptr, from_]))
    return _ret


  @functools.native_method
  def rfindn(self, what:'str'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)


    _ret = 0
    _ret = self._ptr.call_with_return(16,tuple([py_string_what._ptr, from_]))
    return _ret


  @functools.native_method
  def match(self, expr:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not expr is None)
    assert isinstance(expr, (str, String)), 'expr must be str or String'





    assert(isinstance(expr, (str, String)))
    py_string_expr = expr if isinstance(expr, StringName) else c_utils.py_string_to_string(expr)

    _ret = 0
    _ret = self._ptr.call_with_return(17,tuple([py_string_expr._ptr]))
    return _ret


  @functools.native_method
  def matchn(self, expr:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not expr is None)
    assert isinstance(expr, (str, String)), 'expr must be str or String'





    assert(isinstance(expr, (str, String)))
    py_string_expr = expr if isinstance(expr, StringName) else c_utils.py_string_to_string(expr)

    _ret = 0
    _ret = self._ptr.call_with_return(18,tuple([py_string_expr._ptr]))
    return _ret


  @functools.native_method
  def begins_with(self, text:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([py_string_text._ptr]))
    return _ret


  @functools.native_method
  def ends_with(self, text:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([py_string_text._ptr]))
    return _ret


  @functools.native_method
  def is_subsequence_of(self, text:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([py_string_text._ptr]))
    return _ret


  @functools.native_method
  def is_subsequence_ofn(self, text:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([py_string_text._ptr]))
    return _ret


  @functools.native_method
  def bigrams(self) -> typing.Union['PackedStringArray']:
    r''''''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(23,tuple([]))
    return _ret


  @functools.native_method
  def similarity(self, text:'str'   ) -> typing.Union[float]:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = 0
    _ret = self._ptr.call_with_return(24,tuple([py_string_text._ptr]))
    return _ret


  @functools.native_method
  def format(self, values:'object'   , placeholder:'str' ="{_}"  ) -> typing.Union['typing.Self']:
    r''''''
    if placeholder is None:
      placeholder = String.new0()

    

    if not (type(values).__name__ in py4godot.variant_types.core_types or isinstance(values, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'values': "
                f"{type(values).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(placeholder, (str, String)))
    py_string_placeholder = placeholder if isinstance(placeholder, StringName) else c_utils.py_string_to_string(placeholder)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(25,tuple([values, py_string_placeholder._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def replace(self, what:'str'   , forwhat:'str'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert(not forwhat is None)
    assert isinstance(forwhat, (str, String)), 'forwhat must be str or String'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)
    assert(isinstance(forwhat, (str, String)))
    py_string_forwhat = forwhat if isinstance(forwhat, StringName) else c_utils.py_string_to_string(forwhat)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(26,tuple([py_string_what._ptr, py_string_forwhat._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def replacen(self, what:'str'   , forwhat:'str'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert(not forwhat is None)
    assert isinstance(forwhat, (str, String)), 'forwhat must be str or String'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)
    assert(isinstance(forwhat, (str, String)))
    py_string_forwhat = forwhat if isinstance(forwhat, StringName) else c_utils.py_string_to_string(forwhat)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(27,tuple([py_string_what._ptr, py_string_forwhat._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def replace_char(self, key:'int'   , with_:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(key, (int, float)), 'key must be int or float'
    assert isinstance(with_, (int, float)), 'with_ must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(28,tuple([key, with_]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def replace_chars(self, keys:'str'   , with_:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not keys is None)
    assert isinstance(keys, (str, String)), 'keys must be str or String'
    assert isinstance(with_, (int, float)), 'with_ must be int or float'





    assert(isinstance(keys, (str, String)))
    py_string_keys = keys if isinstance(keys, StringName) else c_utils.py_string_to_string(keys)


    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(29,tuple([py_string_keys._ptr, with_]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def remove_char(self, what:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(what, (int, float)), 'what must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(30,tuple([what]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def remove_chars(self, chars:'str'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not chars is None)
    assert isinstance(chars, (str, String)), 'chars must be str or String'





    assert(isinstance(chars, (str, String)))
    py_string_chars = chars if isinstance(chars, StringName) else c_utils.py_string_to_string(chars)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(31,tuple([py_string_chars._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def repeat(self, count:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(count, (int, float)), 'count must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(32,tuple([count]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def reverse(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(33,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def insert(self, position:'int'   , what:'str'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'
    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'






    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(34,tuple([position, py_string_what._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def erase(self, position:'int'   , chars:'int' =1  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'
    assert isinstance(chars, (int, float)), 'chars must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(35,tuple([position, chars]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def capitalize(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(36,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def to_camel_case(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(37,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def to_pascal_case(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(38,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def to_snake_case(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(39,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def to_kebab_case(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(40,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def split(self, delimiter:'str' =""  , allow_empty:'bool' =True  , maxsplit:'int' =0  ) -> typing.Union['PackedStringArray']:
    r''''''
    if delimiter is None:
      delimiter = String.new0()

    assert isinstance(allow_empty, bool), 'allow_empty must be bool'
    assert isinstance(maxsplit, (int, float)), 'maxsplit must be int or float'





    assert(isinstance(delimiter, (str, String)))
    py_string_delimiter = delimiter if isinstance(delimiter, StringName) else c_utils.py_string_to_string(delimiter)



    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(41,tuple([py_string_delimiter._ptr, allow_empty, maxsplit]))
    return _ret


  @functools.native_method
  def rsplit(self, delimiter:'str' =""  , allow_empty:'bool' =True  , maxsplit:'int' =0  ) -> typing.Union['PackedStringArray']:
    r''''''
    if delimiter is None:
      delimiter = String.new0()

    assert isinstance(allow_empty, bool), 'allow_empty must be bool'
    assert isinstance(maxsplit, (int, float)), 'maxsplit must be int or float'





    assert(isinstance(delimiter, (str, String)))
    py_string_delimiter = delimiter if isinstance(delimiter, StringName) else c_utils.py_string_to_string(delimiter)



    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(42,tuple([py_string_delimiter._ptr, allow_empty, maxsplit]))
    return _ret


  @functools.native_method
  def split_floats(self, delimiter:'str'   , allow_empty:'bool' =True  ) -> typing.Union['PackedFloat64Array']:
    r''''''

    assert(not delimiter is None)
    assert isinstance(delimiter, (str, String)), 'delimiter must be str or String'
    assert isinstance(allow_empty, bool), 'allow_empty must be bool'





    assert(isinstance(delimiter, (str, String)))
    py_string_delimiter = delimiter if isinstance(delimiter, StringName) else c_utils.py_string_to_string(delimiter)


    _ret = PackedFloat64Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(43,tuple([py_string_delimiter._ptr, allow_empty]))
    return _ret


  @functools.native_method
  def join(self, parts:'PackedStringArray'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not parts is None)
    assert isinstance(parts, PackedStringArray), 'parts must be PackedStringArray'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(44,tuple([parts._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def to_upper(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(45,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def to_lower(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(46,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def left(self, length:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(47,tuple([length]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def right(self, length:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(48,tuple([length]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def strip_edges(self, left:'bool' =True  , right:'bool' =True  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(left, bool), 'left must be bool'
    assert isinstance(right, bool), 'right must be bool'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(49,tuple([left, right]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def strip_escapes(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(50,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def lstrip(self, chars:'str'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not chars is None)
    assert isinstance(chars, (str, String)), 'chars must be str or String'





    assert(isinstance(chars, (str, String)))
    py_string_chars = chars if isinstance(chars, StringName) else c_utils.py_string_to_string(chars)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(51,tuple([py_string_chars._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def rstrip(self, chars:'str'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not chars is None)
    assert isinstance(chars, (str, String)), 'chars must be str or String'





    assert(isinstance(chars, (str, String)))
    py_string_chars = chars if isinstance(chars, StringName) else c_utils.py_string_to_string(chars)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(52,tuple([py_string_chars._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_extension(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_basename(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def path_join(self, path:'str'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(55,tuple([py_string_path._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def unicode_at(self, at:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(at, (int, float)), 'at must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([at]))
    return _ret


  @functools.native_method
  def indent(self, prefix:'str'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not prefix is None)
    assert isinstance(prefix, (str, String)), 'prefix must be str or String'





    assert(isinstance(prefix, (str, String)))
    py_string_prefix = prefix if isinstance(prefix, StringName) else c_utils.py_string_to_string(prefix)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(57,tuple([py_string_prefix._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def dedent(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def hash(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(59,tuple([]))
    return _ret


  @functools.native_method
  def md5_text(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def sha1_text(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def sha256_text(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def md5_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(63,tuple([]))
    return _ret


  @functools.native_method
  def sha1_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(64,tuple([]))
    return _ret


  @functools.native_method
  def sha256_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(65,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([]))
    return _ret


  @functools.native_method
  def contains(self, what:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)

    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([py_string_what._ptr]))
    return _ret


  @functools.native_method
  def containsn(self, what:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)

    _ret = 0
    _ret = self._ptr.call_with_return(68,tuple([py_string_what._ptr]))
    return _ret


  @functools.native_method
  def is_absolute_path(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(69,tuple([]))
    return _ret


  @functools.native_method
  def is_relative_path(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(70,tuple([]))
    return _ret


  @functools.native_method
  def simplify_path(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(71,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_base_dir(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(72,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_file(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(73,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def xml_escape(self, escape_quotes:'bool' =False  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(escape_quotes, bool), 'escape_quotes must be bool'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(74,tuple([escape_quotes]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def xml_unescape(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(75,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def uri_encode(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(76,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def uri_decode(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(77,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def uri_file_decode(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def c_escape(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def c_unescape(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def json_escape(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def validate_node_name(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(82,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def validate_filename(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(83,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def is_valid_ascii_identifier(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([]))
    return _ret


  @functools.native_method
  def is_valid_unicode_identifier(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([]))
    return _ret


  @functools.native_method
  def is_valid_identifier(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def is_valid_int(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(87,tuple([]))
    return _ret


  @functools.native_method
  def is_valid_float(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([]))
    return _ret


  @functools.native_method
  def is_valid_hex_number(self, with_prefix:'bool' =False  ) -> typing.Union[bool]:
    r''''''

    assert isinstance(with_prefix, bool), 'with_prefix must be bool'







    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([with_prefix]))
    return _ret


  @functools.native_method
  def is_valid_html_color(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([]))
    return _ret


  @functools.native_method
  def is_valid_ip_address(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(91,tuple([]))
    return _ret


  @functools.native_method
  def is_valid_filename(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([]))
    return _ret


  @functools.native_method
  def to_int(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([]))
    return _ret


  @functools.native_method
  def to_float(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([]))
    return _ret


  @functools.native_method
  def hex_to_int(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(95,tuple([]))
    return _ret


  @functools.native_method
  def bin_to_int(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(96,tuple([]))
    return _ret


  @functools.native_method
  def lpad(self, min_length:'int'   , character:'str' =" "  ) -> typing.Union['typing.Self']:
    r''''''
    if character is None:
      character = String.new0()

    assert isinstance(min_length, (int, float)), 'min_length must be int or float'






    assert(isinstance(character, (str, String)))
    py_string_character = character if isinstance(character, StringName) else c_utils.py_string_to_string(character)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(97,tuple([min_length, py_string_character._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def rpad(self, min_length:'int'   , character:'str' =" "  ) -> typing.Union['typing.Self']:
    r''''''
    if character is None:
      character = String.new0()

    assert isinstance(min_length, (int, float)), 'min_length must be int or float'






    assert(isinstance(character, (str, String)))
    py_string_character = character if isinstance(character, StringName) else c_utils.py_string_to_string(character)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(98,tuple([min_length, py_string_character._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def pad_decimals(self, digits:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(digits, (int, float)), 'digits must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(99,tuple([digits]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def pad_zeros(self, digits:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(digits, (int, float)), 'digits must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(100,tuple([digits]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def trim_prefix(self, prefix:'str'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not prefix is None)
    assert isinstance(prefix, (str, String)), 'prefix must be str or String'





    assert(isinstance(prefix, (str, String)))
    py_string_prefix = prefix if isinstance(prefix, StringName) else c_utils.py_string_to_string(prefix)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(101,tuple([py_string_prefix._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def trim_suffix(self, suffix:'str'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not suffix is None)
    assert isinstance(suffix, (str, String)), 'suffix must be str or String'





    assert(isinstance(suffix, (str, String)))
    py_string_suffix = suffix if isinstance(suffix, StringName) else c_utils.py_string_to_string(suffix)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(102,tuple([py_string_suffix._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def to_ascii_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(103,tuple([]))
    return _ret


  @functools.native_method
  def to_utf8_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(104,tuple([]))
    return _ret


  @functools.native_method
  def to_utf16_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(105,tuple([]))
    return _ret


  @functools.native_method
  def to_utf32_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(106,tuple([]))
    return _ret


  @functools.native_method
  def to_wchar_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(107,tuple([]))
    return _ret


  @functools.native_method
  def to_multibyte_char_buffer(self, encoding:'str' =""  ) -> typing.Union['PackedByteArray']:
    r''''''
    if encoding is None:
      encoding = String.new0()






    assert(isinstance(encoding, (str, String)))
    py_string_encoding = encoding if isinstance(encoding, StringName) else c_utils.py_string_to_string(encoding)

    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(108,tuple([py_string_encoding._ptr]))
    return _ret


  @functools.native_method
  def hex_decode(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(109,tuple([]))
    return _ret


  @staticmethod
  def num_scientific(number:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(number, (int, float)), 'number must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = static_method(1032,0,tuple([number]))
    return utils.gd_string_to_py_string(_ret)


  @staticmethod
  def num(number:'float'   , decimals:'int' =-1  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(number, (int, float)), 'number must be int or float'
    assert isinstance(decimals, (int, float)), 'decimals must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = static_method(1032,1,tuple([number, decimals]))
    return utils.gd_string_to_py_string(_ret)


  @staticmethod
  def num_int64(number:'int'   , base:'int' =10  , capitalize_hex:'bool' =False  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(number, (int, float)), 'number must be int or float'
    assert isinstance(base, (int, float)), 'base must be int or float'
    assert isinstance(capitalize_hex, bool), 'capitalize_hex must be bool'









    _ret = String.construct_without_init()
    _ret._ptr = static_method(1032,2,tuple([number, base, capitalize_hex]))
    return utils.gd_string_to_py_string(_ret)


  @staticmethod
  def num_uint64(number:'int'   , base:'int' =10  , capitalize_hex:'bool' =False  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(number, (int, float)), 'number must be int or float'
    assert isinstance(base, (int, float)), 'base must be int or float'
    assert isinstance(capitalize_hex, bool), 'capitalize_hex must be bool'









    _ret = String.construct_without_init()
    _ret._ptr = static_method(1032,3,tuple([number, base, capitalize_hex]))
    return utils.gd_string_to_py_string(_ret)


  @staticmethod
  def chr(code:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(code, (int, float)), 'code must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = static_method(1032,4,tuple([code]))
    return utils.gd_string_to_py_string(_ret)


  @staticmethod
  def humanize_size(size:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = static_method(1032,5,tuple([size]))
    return utils.gd_string_to_py_string(_ret)


  def __eq__(self, other):
    if isinstance(other, String):
      _ret = False

      _ret= self._ptr.call_with_return(141, (other,))
      return _ret
    if isinstance(other, StringName):
      _ret = False

      _ret= self._ptr.call_with_return(141, (other,))
      return _ret

    _ret= self._ptr.call_with_return(141, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, String):
      _ret = False

      _ret= self._ptr.call_with_return(142, (other,))
      return _ret
    if isinstance(other, StringName):
      _ret = False

      _ret= self._ptr.call_with_return(142, (other,))
      return _ret

    _ret= self._ptr.call_with_return(142, (other,))
    return _ret
  def __mod__(self, other):
    if isinstance(other, bool):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, int):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, float):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, String):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Vector2):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Vector2i):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Rect2):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Rect2i):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Vector3):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Vector3i):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Transform2D):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Vector4):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Vector4i):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Plane):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Quaternion):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, AABB):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Basis):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Transform3D):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Projection):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Color):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, StringName):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, NodePath):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, RID):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Object):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Callable):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Signal):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Dictionary):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedByteArray):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedInt32Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedInt64Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedFloat32Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedFloat64Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedStringArray):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedVector2Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedVector3Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedColorArray):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedVector4Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret

    _ret= self._ptr.call_with_return(161, (other,))
    return _ret
  def __lt__(self, other):
    if isinstance(other, String):
      _ret = False

      _ret= self._ptr.call_with_return(119, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __le__(self, other):
    if isinstance(other, String):
      _ret = False

      _ret= self._ptr.call_with_return(120, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __gt__(self, other):
    if isinstance(other, String):
      _ret = False

      _ret= self._ptr.call_with_return(121, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __ge__(self, other):
    if isinstance(other, String):
      _ret = False

      _ret= self._ptr.call_with_return(122, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __add__(self, other):
    if isinstance(other, String):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(143, (other,))
      return _ret
    if isinstance(other, StringName):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(143, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPVector2Wrapper

class Axis:
  AXIS_X = 0
  AXIS_Y = 1


class Vector2(CoreType):
  r''''''
  ZERO:typing.ClassVar['Vector2'] # Vector2(0, 0)

  ONE:typing.ClassVar['Vector2'] # Vector2(1, 1)

  INF:typing.ClassVar['Vector2'] # Vector2(inf, inf)

  LEFT:typing.ClassVar['Vector2'] # Vector2(-1, 0)

  RIGHT:typing.ClassVar['Vector2'] # Vector2(1, 0)

  UP:typing.ClassVar['Vector2'] # Vector2(0, -1)

  DOWN:typing.ClassVar['Vector2'] # Vector2(0, 1)



  @staticmethod
  def new0():
    _class = Vector2.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1033, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Vector2' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector2), 'from_ must be Vector2'

    _class = Vector2.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1033, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Vector2i' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector2i), 'from_ must be Vector2i'

    _class = Vector2.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1033, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(x:'float' , y:'float' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'

    _class = Vector2.construct_without_init()
    _class.constructed_from_python = True





    _class._ptr = constructor(1033, 3, tuple([x, y]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1033,0, ())

  def generate_wrapper(self):
    return CPPVector2Wrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Vector2.__new__(Vector2)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Vector2'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(47, ())
  def __neg__(self):
    return self * -1


  @property
  def x(self) -> float:
    _ret = self._ptr.call_with_return(48, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_x(self) -> None:
    _ret = self._ptr.call_with_return(48, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @x.setter
  def x(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(49, tuple([value]))
  def set_x(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(49, tuple([value]))
  @property
  def y(self) -> float:
    _ret = self._ptr.call_with_return(50, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_y(self) -> None:
    _ret = self._ptr.call_with_return(50, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @y.setter
  def y(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(51, tuple([value]))
  def set_y(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(51, tuple([value]))
  @functools.native_method
  def angle(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def angle_to(self, to:'Vector2'   ) -> typing.Union[float]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector2), 'to must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def angle_to_point(self, to:'Vector2'   ) -> typing.Union[float]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector2), 'to must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def direction_to(self, to:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector2), 'to must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(3,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def distance_to(self, to:'Vector2'   ) -> typing.Union[float]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector2), 'to must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def distance_squared_to(self, to:'Vector2'   ) -> typing.Union[float]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector2), 'to must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(6,tuple([]))
    return _ret


  @functools.native_method
  def length_squared(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(7,tuple([]))
    return _ret


  @functools.native_method
  def limit_length(self, length:'float' =1.0  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([length]))
    return _ret


  @functools.native_method
  def normalized(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(9,tuple([]))
    return _ret


  @functools.native_method
  def is_normalized(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([]))
    return _ret


  @functools.native_method
  def is_equal_approx(self, to:'Vector2'   ) -> typing.Union[bool]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector2), 'to must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(11,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def is_zero_approx(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([]))
    return _ret


  @functools.native_method
  def is_finite(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(13,tuple([]))
    return _ret


  @functools.native_method
  def posmod(self, mod:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(mod, (int, float)), 'mod must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([mod]))
    return _ret


  @functools.native_method
  def posmodv(self, modv:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not modv is None)
    assert isinstance(modv, Vector2), 'modv must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([modv._ptr]))
    return _ret


  @functools.native_method
  def project(self, b:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not b is None)
    assert isinstance(b, Vector2), 'b must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16,tuple([b._ptr]))
    return _ret


  @functools.native_method
  def lerp(self, to:'Vector2'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector2), 'to must be Vector2'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(17,tuple([to._ptr, weight]))
    return _ret


  @functools.native_method
  def slerp(self, to:'Vector2'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector2), 'to must be Vector2'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18,tuple([to._ptr, weight]))
    return _ret


  @functools.native_method
  def cubic_interpolate(self, b:'Vector2'   , pre_a:'Vector2'   , post_b:'Vector2'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not b is None)
    assert isinstance(b, Vector2), 'b must be Vector2'
    assert(not pre_a is None)
    assert isinstance(pre_a, Vector2), 'pre_a must be Vector2'
    assert(not post_b is None)
    assert isinstance(post_b, Vector2), 'post_b must be Vector2'
    assert isinstance(weight, (int, float)), 'weight must be int or float'










    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(19,tuple([b._ptr, pre_a._ptr, post_b._ptr, weight]))
    return _ret


  @functools.native_method
  def cubic_interpolate_in_time(self, b:'Vector2'   , pre_a:'Vector2'   , post_b:'Vector2'   , weight:'float'   , b_t:'float'   , pre_a_t:'float'   , post_b_t:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not b is None)
    assert isinstance(b, Vector2), 'b must be Vector2'
    assert(not pre_a is None)
    assert isinstance(pre_a, Vector2), 'pre_a must be Vector2'
    assert(not post_b is None)
    assert isinstance(post_b, Vector2), 'post_b must be Vector2'
    assert isinstance(weight, (int, float)), 'weight must be int or float'
    assert isinstance(b_t, (int, float)), 'b_t must be int or float'
    assert isinstance(pre_a_t, (int, float)), 'pre_a_t must be int or float'
    assert isinstance(post_b_t, (int, float)), 'post_b_t must be int or float'













    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20,tuple([b._ptr, pre_a._ptr, post_b._ptr, weight, b_t, pre_a_t, post_b_t]))
    return _ret


  @functools.native_method
  def bezier_interpolate(self, control_1:'Vector2'   , control_2:'Vector2'   , end:'Vector2'   , t:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not control_1 is None)
    assert isinstance(control_1, Vector2), 'control_1 must be Vector2'
    assert(not control_2 is None)
    assert isinstance(control_2, Vector2), 'control_2 must be Vector2'
    assert(not end is None)
    assert isinstance(end, Vector2), 'end must be Vector2'
    assert isinstance(t, (int, float)), 't must be int or float'










    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(21,tuple([control_1._ptr, control_2._ptr, end._ptr, t]))
    return _ret


  @functools.native_method
  def bezier_derivative(self, control_1:'Vector2'   , control_2:'Vector2'   , end:'Vector2'   , t:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not control_1 is None)
    assert isinstance(control_1, Vector2), 'control_1 must be Vector2'
    assert(not control_2 is None)
    assert isinstance(control_2, Vector2), 'control_2 must be Vector2'
    assert(not end is None)
    assert isinstance(end, Vector2), 'end must be Vector2'
    assert isinstance(t, (int, float)), 't must be int or float'










    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22,tuple([control_1._ptr, control_2._ptr, end._ptr, t]))
    return _ret


  @functools.native_method
  def max_axis_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(23,tuple([]))
    return _ret


  @functools.native_method
  def min_axis_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(24,tuple([]))
    return _ret


  @functools.native_method
  def move_toward(self, to:'Vector2'   , delta:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector2), 'to must be Vector2'
    assert isinstance(delta, (int, float)), 'delta must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(25,tuple([to._ptr, delta]))
    return _ret


  @functools.native_method
  def rotated(self, angle:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(angle, (int, float)), 'angle must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(26,tuple([angle]))
    return _ret


  @functools.native_method
  def orthogonal(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(27,tuple([]))
    return _ret


  @functools.native_method
  def floor(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(28,tuple([]))
    return _ret


  @functools.native_method
  def ceil(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(29,tuple([]))
    return _ret


  @functools.native_method
  def round(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(30,tuple([]))
    return _ret


  @functools.native_method
  def aspect(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(31,tuple([]))
    return _ret


  @functools.native_method
  def dot(self, with_:'Vector2'   ) -> typing.Union[float]:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector2), 'with_ must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(32,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def slide(self, n:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not n is None)
    assert isinstance(n, Vector2), 'n must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(33,tuple([n._ptr]))
    return _ret


  @functools.native_method
  def bounce(self, n:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not n is None)
    assert isinstance(n, Vector2), 'n must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(34,tuple([n._ptr]))
    return _ret


  @functools.native_method
  def reflect(self, line:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not line is None)
    assert isinstance(line, Vector2), 'line must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(35,tuple([line._ptr]))
    return _ret


  @functools.native_method
  def cross(self, with_:'Vector2'   ) -> typing.Union[float]:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector2), 'with_ must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(36,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def abs(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(37,tuple([]))
    return _ret


  @functools.native_method
  def sign(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(38,tuple([]))
    return _ret


  @functools.native_method
  def clamp(self, min:'Vector2'   , max:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not min is None)
    assert isinstance(min, Vector2), 'min must be Vector2'
    assert(not max is None)
    assert isinstance(max, Vector2), 'max must be Vector2'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(39,tuple([min._ptr, max._ptr]))
    return _ret


  @functools.native_method
  def clampf(self, min:'float'   , max:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(min, (int, float)), 'min must be int or float'
    assert isinstance(max, (int, float)), 'max must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(40,tuple([min, max]))
    return _ret


  @functools.native_method
  def snapped(self, step:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not step is None)
    assert isinstance(step, Vector2), 'step must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(41,tuple([step._ptr]))
    return _ret


  @functools.native_method
  def snappedf(self, step:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(step, (int, float)), 'step must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(42,tuple([step]))
    return _ret


  @functools.native_method
  def min(self, with_:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector2), 'with_ must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(43,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def minf(self, with_:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(with_, (int, float)), 'with_ must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(44,tuple([with_]))
    return _ret


  @functools.native_method
  def max(self, with_:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector2), 'with_ must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(45,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def maxf(self, with_:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(with_, (int, float)), 'with_ must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(46,tuple([with_]))
    return _ret


  @staticmethod
  def from_angle(angle:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(angle, (int, float)), 'angle must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = static_method(1033,0,tuple([angle]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Vector2):
      _ret = False

      _ret= self._ptr.call_with_return(58, (other,))
      return _ret

    _ret= self._ptr.call_with_return(58, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Vector2):
      _ret = False

      _ret= self._ptr.call_with_return(59, (other,))
      return _ret

    _ret= self._ptr.call_with_return(59, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, int):
      _ret = Vector2()

      _ret._ptr = self._ptr.call_with_return(68, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Vector2()

      _ret._ptr = self._ptr.call_with_return(68, (other,))
      return _ret
    if isinstance(other, Vector2):
      _ret = Vector2()

      _ret._ptr = self._ptr.call_with_return(68, (other,))
      return _ret
    if isinstance(other, Transform2D):
      _ret = Vector2()

      _ret._ptr = self._ptr.call_with_return(68, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __truediv__(self, other):
    if isinstance(other, int):
      _ret = Vector2()

      _ret._ptr = self._ptr.call_with_return(67, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Vector2()

      _ret._ptr = self._ptr.call_with_return(67, (other,))
      return _ret
    if isinstance(other, Vector2):
      _ret = Vector2()

      _ret._ptr = self._ptr.call_with_return(67, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __lt__(self, other):
    if isinstance(other, Vector2):
      _ret = False

      _ret= self._ptr.call_with_return(60, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __le__(self, other):
    if isinstance(other, Vector2):
      _ret = False

      _ret= self._ptr.call_with_return(61, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __gt__(self, other):
    if isinstance(other, Vector2):
      _ret = False

      _ret= self._ptr.call_with_return(62, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __ge__(self, other):
    if isinstance(other, Vector2):
      _ret = False

      _ret= self._ptr.call_with_return(63, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __add__(self, other):
    if isinstance(other, Vector2):
      _ret = Vector2()

      _ret._ptr = self._ptr.call_with_return(64, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __sub__(self, other):
    if isinstance(other, Vector2):
      _ret = Vector2()

      _ret._ptr = self._ptr.call_with_return(65, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPVector2iWrapper

class Axis:
  AXIS_X = 0
  AXIS_Y = 1


class Vector2i(CoreType):
  r''''''
  ZERO:typing.ClassVar['Vector2i'] # Vector2i(0, 0)

  ONE:typing.ClassVar['Vector2i'] # Vector2i(1, 1)

  MIN:typing.ClassVar['Vector2i'] # Vector2i(-2147483648, -2147483648)

  MAX:typing.ClassVar['Vector2i'] # Vector2i(2147483647, 2147483647)

  LEFT:typing.ClassVar['Vector2i'] # Vector2i(-1, 0)

  RIGHT:typing.ClassVar['Vector2i'] # Vector2i(1, 0)

  UP:typing.ClassVar['Vector2i'] # Vector2i(0, -1)

  DOWN:typing.ClassVar['Vector2i'] # Vector2i(0, 1)



  @staticmethod
  def new0():
    _class = Vector2i.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1034, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Vector2i' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector2i), 'from_ must be Vector2i'

    _class = Vector2i.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1034, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Vector2' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector2), 'from_ must be Vector2'

    _class = Vector2i.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1034, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(x:'int' , y:'int' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'

    _class = Vector2i.construct_without_init()
    _class.constructed_from_python = True





    _class._ptr = constructor(1034, 3, tuple([x, y]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1034,0, ())

  def generate_wrapper(self):
    return CPPVector2iWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Vector2i.__new__(Vector2i)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Vector2i'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(17, ())


  @property
  def x(self) -> int:
    _ret = self._ptr.call_with_return(18, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_x(self) -> None:
    _ret = self._ptr.call_with_return(18, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @x.setter
  def x(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(19, tuple([value]))
  def set_x(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(19, tuple([value]))
  @property
  def y(self) -> int:
    _ret = self._ptr.call_with_return(20, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_y(self) -> None:
    _ret = self._ptr.call_with_return(20, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @y.setter
  def y(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(21, tuple([value]))
  def set_y(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(21, tuple([value]))
  @functools.native_method
  def aspect(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def max_axis_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def min_axis_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def distance_to(self, to:'Vector2i'   ) -> typing.Union[float]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector2i), 'to must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def distance_squared_to(self, to:'Vector2i'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector2i), 'to must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([]))
    return _ret


  @functools.native_method
  def length_squared(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(6,tuple([]))
    return _ret


  @functools.native_method
  def sign(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([]))
    return _ret


  @functools.native_method
  def abs(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([]))
    return _ret


  @functools.native_method
  def clamp(self, min:'Vector2i'   , max:'Vector2i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not min is None)
    assert isinstance(min, Vector2i), 'min must be Vector2i'
    assert(not max is None)
    assert isinstance(max, Vector2i), 'max must be Vector2i'








    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(9,tuple([min._ptr, max._ptr]))
    return _ret


  @functools.native_method
  def clampi(self, min:'int'   , max:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(min, (int, float)), 'min must be int or float'
    assert isinstance(max, (int, float)), 'max must be int or float'








    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(10,tuple([min, max]))
    return _ret


  @functools.native_method
  def snapped(self, step:'Vector2i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not step is None)
    assert isinstance(step, Vector2i), 'step must be Vector2i'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(11,tuple([step._ptr]))
    return _ret


  @functools.native_method
  def snappedi(self, step:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(step, (int, float)), 'step must be int or float'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(12,tuple([step]))
    return _ret


  @functools.native_method
  def min(self, with_:'Vector2i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector2i), 'with_ must be Vector2i'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(13,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def mini(self, with_:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(with_, (int, float)), 'with_ must be int or float'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([with_]))
    return _ret


  @functools.native_method
  def max(self, with_:'Vector2i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector2i), 'with_ must be Vector2i'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def maxi(self, with_:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(with_, (int, float)), 'with_ must be int or float'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16,tuple([with_]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Vector2i):
      _ret = False

      _ret= self._ptr.call_with_return(29, (other,))
      return _ret

    _ret= self._ptr.call_with_return(29, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Vector2i):
      _ret = False

      _ret= self._ptr.call_with_return(30, (other,))
      return _ret

    _ret= self._ptr.call_with_return(30, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, int):
      _ret = Vector2i()

      _ret._ptr = self._ptr.call_with_return(37, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Vector2()

      _ret._ptr = self._ptr.call_with_return(37, (other,))
      return _ret
    if isinstance(other, Vector2i):
      _ret = Vector2i()

      _ret._ptr = self._ptr.call_with_return(37, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __truediv__(self, other):
    if isinstance(other, int):
      _ret = Vector2i()

      _ret._ptr = self._ptr.call_with_return(38, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Vector2()

      _ret._ptr = self._ptr.call_with_return(38, (other,))
      return _ret
    if isinstance(other, Vector2i):
      _ret = Vector2i()

      _ret._ptr = self._ptr.call_with_return(38, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __mod__(self, other):
    if isinstance(other, int):
      _ret = Vector2i()

      _ret._ptr = self._ptr.call_with_return(39, (other,))
      return _ret
    if isinstance(other, Vector2i):
      _ret = Vector2i()

      _ret._ptr = self._ptr.call_with_return(39, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __lt__(self, other):
    if isinstance(other, Vector2i):
      _ret = False

      _ret= self._ptr.call_with_return(31, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __le__(self, other):
    if isinstance(other, Vector2i):
      _ret = False

      _ret= self._ptr.call_with_return(32, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __gt__(self, other):
    if isinstance(other, Vector2i):
      _ret = False

      _ret= self._ptr.call_with_return(33, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __ge__(self, other):
    if isinstance(other, Vector2i):
      _ret = False

      _ret= self._ptr.call_with_return(34, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __add__(self, other):
    if isinstance(other, Vector2i):
      _ret = Vector2i()

      _ret._ptr = self._ptr.call_with_return(35, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __sub__(self, other):
    if isinstance(other, Vector2i):
      _ret = Vector2i()

      _ret._ptr = self._ptr.call_with_return(36, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPRect2Wrapper


class Rect2(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = Rect2.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1035, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Rect2' ):
    assert(not from_ is None)
    assert isinstance(from_, Rect2), 'from_ must be Rect2'

    _class = Rect2.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1035, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Rect2i' ):
    assert(not from_ is None)
    assert isinstance(from_, Rect2i), 'from_ must be Rect2i'

    _class = Rect2.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1035, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(position:'Vector2' , size:'Vector2' ):
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'
    assert(not size is None)
    assert isinstance(size, Vector2), 'size must be Vector2'

    _class = Rect2.construct_without_init()
    _class.constructed_from_python = True



    _class.__position__ = position
    _class.__size__ = size
    _class._ptr = constructor(1035, 3, tuple([position._ptr, size._ptr]))
    return _class
  @staticmethod
  def new4(x:'float' , y:'float' , width:'float' , height:'float' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'

    _class = Rect2.construct_without_init()
    _class.constructed_from_python = True









    _class._ptr = constructor(1035, 4, tuple([x, y, width, height]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1035,0, ())

  def generate_wrapper(self):
    return CPPRect2Wrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Rect2.__new__(Rect2)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Rect2'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(16, ())


  @property
  def position(self) -> Vector2:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(17, tuple())
    return _ret
  def get_position(self) -> None:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(17, tuple())
    return _ret

  @position.setter
  def position(self, value: 'Vector2' ):
    assert isinstance(value, Vector2), 'value must be Vector2'
    self._ptr.call_with_return(18, tuple([value._ptr]))
  def set_position(self, value: 'Vector2' ):
    assert isinstance(value, Vector2), 'value must be Vector2'
    self._ptr.call_with_return(18, tuple([value._ptr]))
  @property
  def size(self) -> Vector2:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(19, tuple())
    return _ret
  def get_size(self) -> None:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(19, tuple())
    return _ret

  @size.setter
  def size(self, value: 'Vector2' ):
    assert isinstance(value, Vector2), 'value must be Vector2'
    self._ptr.call_with_return(20, tuple([value._ptr]))
  def set_size(self, value: 'Vector2' ):
    assert isinstance(value, Vector2), 'value must be Vector2'
    self._ptr.call_with_return(20, tuple([value._ptr]))
  @functools.native_method
  def get_center(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def get_area(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def has_area(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def has_point(self, point:'Vector2'   ) -> typing.Union[bool]:
    r''''''

    assert(not point is None)
    assert isinstance(point, Vector2), 'point must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([point._ptr]))
    return _ret


  @functools.native_method
  def is_equal_approx(self, rect:'Rect2'   ) -> typing.Union[bool]:
    r''''''

    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([rect._ptr]))
    return _ret


  @functools.native_method
  def is_finite(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([]))
    return _ret


  @functools.native_method
  def intersects(self, b:'Rect2'   , include_borders:'bool' =False  ) -> typing.Union[bool]:
    r''''''

    assert(not b is None)
    assert isinstance(b, Rect2), 'b must be Rect2'
    assert isinstance(include_borders, bool), 'include_borders must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(6,tuple([b._ptr, include_borders]))
    return _ret


  @functools.native_method
  def encloses(self, b:'Rect2'   ) -> typing.Union[bool]:
    r''''''

    assert(not b is None)
    assert isinstance(b, Rect2), 'b must be Rect2'







    _ret = 0
    _ret = self._ptr.call_with_return(7,tuple([b._ptr]))
    return _ret


  @functools.native_method
  def intersection(self, b:'Rect2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not b is None)
    assert isinstance(b, Rect2), 'b must be Rect2'







    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([b._ptr]))
    return _ret


  @functools.native_method
  def merge(self, b:'Rect2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not b is None)
    assert isinstance(b, Rect2), 'b must be Rect2'







    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(9,tuple([b._ptr]))
    return _ret


  @functools.native_method
  def expand(self, to:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector2), 'to must be Vector2'







    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(10,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def get_support(self, direction:'Vector2'   ) -> typing.Union['Vector2']:
    r''''''

    assert(not direction is None)
    assert isinstance(direction, Vector2), 'direction must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(11,tuple([direction._ptr]))
    return _ret


  @functools.native_method
  def grow(self, amount:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'







    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(12,tuple([amount]))
    return _ret


  @functools.native_method
  def grow_side(self, side:'int'   , amount:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(side, (int, float)), 'side must be int or float'
    assert isinstance(amount, (int, float)), 'amount must be int or float'








    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(13,tuple([side, amount]))
    return _ret


  @functools.native_method
  def grow_individual(self, left:'float'   , top:'float'   , right:'float'   , bottom:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(left, (int, float)), 'left must be int or float'
    assert isinstance(top, (int, float)), 'top must be int or float'
    assert isinstance(right, (int, float)), 'right must be int or float'
    assert isinstance(bottom, (int, float)), 'bottom must be int or float'










    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([left, top, right, bottom]))
    return _ret


  @functools.native_method
  def abs(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Rect2):
      _ret = False

      _ret= self._ptr.call_with_return(25, (other,))
      return _ret

    _ret= self._ptr.call_with_return(25, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Rect2):
      _ret = False

      _ret= self._ptr.call_with_return(26, (other,))
      return _ret

    _ret= self._ptr.call_with_return(26, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, Transform2D):
      _ret = Rect2()

      _ret._ptr = self._ptr.call_with_return(27, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPRect2iWrapper


class Rect2i(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = Rect2i.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1036, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Rect2i' ):
    assert(not from_ is None)
    assert isinstance(from_, Rect2i), 'from_ must be Rect2i'

    _class = Rect2i.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1036, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Rect2' ):
    assert(not from_ is None)
    assert isinstance(from_, Rect2), 'from_ must be Rect2'

    _class = Rect2i.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1036, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(position:'Vector2i' , size:'Vector2i' ):
    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'

    _class = Rect2i.construct_without_init()
    _class.constructed_from_python = True



    _class.__position__ = position
    _class.__size__ = size
    _class._ptr = constructor(1036, 3, tuple([position._ptr, size._ptr]))
    return _class
  @staticmethod
  def new4(x:'int' , y:'int' , width:'int' , height:'int' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'

    _class = Rect2i.construct_without_init()
    _class.constructed_from_python = True









    _class._ptr = constructor(1036, 4, tuple([x, y, width, height]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1036,0, ())

  def generate_wrapper(self):
    return CPPRect2iWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Rect2i.__new__(Rect2i)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Rect2i'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(13, ())


  @property
  def position(self) -> Vector2i:
    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14, tuple())
    return _ret
  def get_position(self) -> None:
    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14, tuple())
    return _ret

  @position.setter
  def position(self, value: 'Vector2i' ):
    assert isinstance(value, Vector2i), 'value must be Vector2i'
    self._ptr.call_with_return(15, tuple([value._ptr]))
  def set_position(self, value: 'Vector2i' ):
    assert isinstance(value, Vector2i), 'value must be Vector2i'
    self._ptr.call_with_return(15, tuple([value._ptr]))
  @property
  def size(self) -> Vector2i:
    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16, tuple())
    return _ret
  def get_size(self) -> None:
    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16, tuple())
    return _ret

  @size.setter
  def size(self, value: 'Vector2i' ):
    assert isinstance(value, Vector2i), 'value must be Vector2i'
    self._ptr.call_with_return(17, tuple([value._ptr]))
  def set_size(self, value: 'Vector2i' ):
    assert isinstance(value, Vector2i), 'value must be Vector2i'
    self._ptr.call_with_return(17, tuple([value._ptr]))
  @functools.native_method
  def get_center(self) -> typing.Union['Vector2i']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def get_area(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def has_area(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def has_point(self, point:'Vector2i'   ) -> typing.Union[bool]:
    r''''''

    assert(not point is None)
    assert isinstance(point, Vector2i), 'point must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([point._ptr]))
    return _ret


  @functools.native_method
  def intersects(self, b:'Rect2i'   ) -> typing.Union[bool]:
    r''''''

    assert(not b is None)
    assert isinstance(b, Rect2i), 'b must be Rect2i'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([b._ptr]))
    return _ret


  @functools.native_method
  def encloses(self, b:'Rect2i'   ) -> typing.Union[bool]:
    r''''''

    assert(not b is None)
    assert isinstance(b, Rect2i), 'b must be Rect2i'







    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([b._ptr]))
    return _ret


  @functools.native_method
  def intersection(self, b:'Rect2i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not b is None)
    assert isinstance(b, Rect2i), 'b must be Rect2i'







    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(6,tuple([b._ptr]))
    return _ret


  @functools.native_method
  def merge(self, b:'Rect2i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not b is None)
    assert isinstance(b, Rect2i), 'b must be Rect2i'







    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([b._ptr]))
    return _ret


  @functools.native_method
  def expand(self, to:'Vector2i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector2i), 'to must be Vector2i'







    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def grow(self, amount:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'







    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(9,tuple([amount]))
    return _ret


  @functools.native_method
  def grow_side(self, side:'int'   , amount:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(side, (int, float)), 'side must be int or float'
    assert isinstance(amount, (int, float)), 'amount must be int or float'








    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(10,tuple([side, amount]))
    return _ret


  @functools.native_method
  def grow_individual(self, left:'int'   , top:'int'   , right:'int'   , bottom:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(left, (int, float)), 'left must be int or float'
    assert isinstance(top, (int, float)), 'top must be int or float'
    assert isinstance(right, (int, float)), 'right must be int or float'
    assert isinstance(bottom, (int, float)), 'bottom must be int or float'










    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(11,tuple([left, top, right, bottom]))
    return _ret


  @functools.native_method
  def abs(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(12,tuple([]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Rect2i):
      _ret = False

      _ret= self._ptr.call_with_return(22, (other,))
      return _ret

    _ret= self._ptr.call_with_return(22, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Rect2i):
      _ret = False

      _ret= self._ptr.call_with_return(23, (other,))
      return _ret

    _ret= self._ptr.call_with_return(23, (other,))
    return _ret

from py4godot.wrappers.wrappers import CPPVector3Wrapper

class Axis:
  AXIS_X = 0
  AXIS_Y = 1
  AXIS_Z = 2


class Vector3(CoreType):
  r''''''
  ZERO:typing.ClassVar['Vector3'] # Vector3(0, 0, 0)

  ONE:typing.ClassVar['Vector3'] # Vector3(1, 1, 1)

  INF:typing.ClassVar['Vector3'] # Vector3(inf, inf, inf)

  LEFT:typing.ClassVar['Vector3'] # Vector3(-1, 0, 0)

  RIGHT:typing.ClassVar['Vector3'] # Vector3(1, 0, 0)

  UP:typing.ClassVar['Vector3'] # Vector3(0, 1, 0)

  DOWN:typing.ClassVar['Vector3'] # Vector3(0, -1, 0)

  FORWARD:typing.ClassVar['Vector3'] # Vector3(0, 0, -1)

  BACK:typing.ClassVar['Vector3'] # Vector3(0, 0, 1)

  MODEL_LEFT:typing.ClassVar['Vector3'] # Vector3(1, 0, 0)

  MODEL_RIGHT:typing.ClassVar['Vector3'] # Vector3(-1, 0, 0)

  MODEL_TOP:typing.ClassVar['Vector3'] # Vector3(0, 1, 0)

  MODEL_BOTTOM:typing.ClassVar['Vector3'] # Vector3(0, -1, 0)

  MODEL_FRONT:typing.ClassVar['Vector3'] # Vector3(0, 0, 1)

  MODEL_REAR:typing.ClassVar['Vector3'] # Vector3(0, 0, -1)



  @staticmethod
  def new0():
    _class = Vector3.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1037, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Vector3' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector3), 'from_ must be Vector3'

    _class = Vector3.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1037, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Vector3i' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector3i), 'from_ must be Vector3i'

    _class = Vector3.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1037, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(x:'float' , y:'float' , z:'float' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(z, (int, float)), 'z must be int or float'

    _class = Vector3.construct_without_init()
    _class.constructed_from_python = True







    _class._ptr = constructor(1037, 3, tuple([x, y, z]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1037,0, ())

  def generate_wrapper(self):
    return CPPVector3Wrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Vector3.__new__(Vector3)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Vector3'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(47, ())
  def __neg__(self):
    return self * -1


  @property
  def x(self) -> float:
    _ret = self._ptr.call_with_return(48, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_x(self) -> None:
    _ret = self._ptr.call_with_return(48, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @x.setter
  def x(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(49, tuple([value]))
  def set_x(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(49, tuple([value]))
  @property
  def y(self) -> float:
    _ret = self._ptr.call_with_return(50, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_y(self) -> None:
    _ret = self._ptr.call_with_return(50, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @y.setter
  def y(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(51, tuple([value]))
  def set_y(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(51, tuple([value]))
  @property
  def z(self) -> float:
    _ret = self._ptr.call_with_return(52, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_z(self) -> None:
    _ret = self._ptr.call_with_return(52, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @z.setter
  def z(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(53, tuple([value]))
  def set_z(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(53, tuple([value]))
  @functools.native_method
  def min_axis_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def max_axis_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def angle_to(self, to:'Vector3'   ) -> typing.Union[float]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def signed_angle_to(self, to:'Vector3'   , axis:'Vector3'   ) -> typing.Union[float]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'
    assert(not axis is None)
    assert isinstance(axis, Vector3), 'axis must be Vector3'








    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([to._ptr, axis._ptr]))
    return _ret


  @functools.native_method
  def direction_to(self, to:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(4,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def distance_to(self, to:'Vector3'   ) -> typing.Union[float]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def distance_squared_to(self, to:'Vector3'   ) -> typing.Union[float]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(6,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(7,tuple([]))
    return _ret


  @functools.native_method
  def length_squared(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([]))
    return _ret


  @functools.native_method
  def limit_length(self, length:'float' =1.0  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(9,tuple([length]))
    return _ret


  @functools.native_method
  def normalized(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(10,tuple([]))
    return _ret


  @functools.native_method
  def is_normalized(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(11,tuple([]))
    return _ret


  @functools.native_method
  def is_equal_approx(self, to:'Vector3'   ) -> typing.Union[bool]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def is_zero_approx(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(13,tuple([]))
    return _ret


  @functools.native_method
  def is_finite(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(14,tuple([]))
    return _ret


  @functools.native_method
  def inverse(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([]))
    return _ret


  @functools.native_method
  def clamp(self, min:'Vector3'   , max:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not min is None)
    assert isinstance(min, Vector3), 'min must be Vector3'
    assert(not max is None)
    assert isinstance(max, Vector3), 'max must be Vector3'








    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16,tuple([min._ptr, max._ptr]))
    return _ret


  @functools.native_method
  def clampf(self, min:'float'   , max:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(min, (int, float)), 'min must be int or float'
    assert isinstance(max, (int, float)), 'max must be int or float'








    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(17,tuple([min, max]))
    return _ret


  @functools.native_method
  def snapped(self, step:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not step is None)
    assert isinstance(step, Vector3), 'step must be Vector3'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18,tuple([step._ptr]))
    return _ret


  @functools.native_method
  def snappedf(self, step:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(step, (int, float)), 'step must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(19,tuple([step]))
    return _ret


  @functools.native_method
  def rotated(self, axis:'Vector3'   , angle:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not axis is None)
    assert isinstance(axis, Vector3), 'axis must be Vector3'
    assert isinstance(angle, (int, float)), 'angle must be int or float'








    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20,tuple([axis._ptr, angle]))
    return _ret


  @functools.native_method
  def lerp(self, to:'Vector3'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(21,tuple([to._ptr, weight]))
    return _ret


  @functools.native_method
  def slerp(self, to:'Vector3'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22,tuple([to._ptr, weight]))
    return _ret


  @functools.native_method
  def cubic_interpolate(self, b:'Vector3'   , pre_a:'Vector3'   , post_b:'Vector3'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not b is None)
    assert isinstance(b, Vector3), 'b must be Vector3'
    assert(not pre_a is None)
    assert isinstance(pre_a, Vector3), 'pre_a must be Vector3'
    assert(not post_b is None)
    assert isinstance(post_b, Vector3), 'post_b must be Vector3'
    assert isinstance(weight, (int, float)), 'weight must be int or float'










    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(23,tuple([b._ptr, pre_a._ptr, post_b._ptr, weight]))
    return _ret


  @functools.native_method
  def cubic_interpolate_in_time(self, b:'Vector3'   , pre_a:'Vector3'   , post_b:'Vector3'   , weight:'float'   , b_t:'float'   , pre_a_t:'float'   , post_b_t:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not b is None)
    assert isinstance(b, Vector3), 'b must be Vector3'
    assert(not pre_a is None)
    assert isinstance(pre_a, Vector3), 'pre_a must be Vector3'
    assert(not post_b is None)
    assert isinstance(post_b, Vector3), 'post_b must be Vector3'
    assert isinstance(weight, (int, float)), 'weight must be int or float'
    assert isinstance(b_t, (int, float)), 'b_t must be int or float'
    assert isinstance(pre_a_t, (int, float)), 'pre_a_t must be int or float'
    assert isinstance(post_b_t, (int, float)), 'post_b_t must be int or float'













    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(24,tuple([b._ptr, pre_a._ptr, post_b._ptr, weight, b_t, pre_a_t, post_b_t]))
    return _ret


  @functools.native_method
  def bezier_interpolate(self, control_1:'Vector3'   , control_2:'Vector3'   , end:'Vector3'   , t:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not control_1 is None)
    assert isinstance(control_1, Vector3), 'control_1 must be Vector3'
    assert(not control_2 is None)
    assert isinstance(control_2, Vector3), 'control_2 must be Vector3'
    assert(not end is None)
    assert isinstance(end, Vector3), 'end must be Vector3'
    assert isinstance(t, (int, float)), 't must be int or float'










    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(25,tuple([control_1._ptr, control_2._ptr, end._ptr, t]))
    return _ret


  @functools.native_method
  def bezier_derivative(self, control_1:'Vector3'   , control_2:'Vector3'   , end:'Vector3'   , t:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not control_1 is None)
    assert isinstance(control_1, Vector3), 'control_1 must be Vector3'
    assert(not control_2 is None)
    assert isinstance(control_2, Vector3), 'control_2 must be Vector3'
    assert(not end is None)
    assert isinstance(end, Vector3), 'end must be Vector3'
    assert isinstance(t, (int, float)), 't must be int or float'










    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(26,tuple([control_1._ptr, control_2._ptr, end._ptr, t]))
    return _ret


  @functools.native_method
  def move_toward(self, to:'Vector3'   , delta:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'
    assert isinstance(delta, (int, float)), 'delta must be int or float'








    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(27,tuple([to._ptr, delta]))
    return _ret


  @functools.native_method
  def dot(self, with_:'Vector3'   ) -> typing.Union[float]:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector3), 'with_ must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(28,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def cross(self, with_:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector3), 'with_ must be Vector3'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(29,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def outer(self, with_:'Vector3'   ) -> typing.Union['Basis']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector3), 'with_ must be Vector3'







    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(30,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def abs(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(31,tuple([]))
    return _ret


  @functools.native_method
  def floor(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(32,tuple([]))
    return _ret


  @functools.native_method
  def ceil(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(33,tuple([]))
    return _ret


  @functools.native_method
  def round(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(34,tuple([]))
    return _ret


  @functools.native_method
  def posmod(self, mod:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(mod, (int, float)), 'mod must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(35,tuple([mod]))
    return _ret


  @functools.native_method
  def posmodv(self, modv:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not modv is None)
    assert isinstance(modv, Vector3), 'modv must be Vector3'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(36,tuple([modv._ptr]))
    return _ret


  @functools.native_method
  def project(self, b:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not b is None)
    assert isinstance(b, Vector3), 'b must be Vector3'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(37,tuple([b._ptr]))
    return _ret


  @functools.native_method
  def slide(self, n:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not n is None)
    assert isinstance(n, Vector3), 'n must be Vector3'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(38,tuple([n._ptr]))
    return _ret


  @functools.native_method
  def bounce(self, n:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not n is None)
    assert isinstance(n, Vector3), 'n must be Vector3'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(39,tuple([n._ptr]))
    return _ret


  @functools.native_method
  def reflect(self, n:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not n is None)
    assert isinstance(n, Vector3), 'n must be Vector3'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(40,tuple([n._ptr]))
    return _ret


  @functools.native_method
  def sign(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(41,tuple([]))
    return _ret


  @functools.native_method
  def octahedron_encode(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(42,tuple([]))
    return _ret


  @functools.native_method
  def min(self, with_:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector3), 'with_ must be Vector3'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(43,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def minf(self, with_:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(with_, (int, float)), 'with_ must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(44,tuple([with_]))
    return _ret


  @functools.native_method
  def max(self, with_:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector3), 'with_ must be Vector3'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(45,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def maxf(self, with_:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(with_, (int, float)), 'with_ must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(46,tuple([with_]))
    return _ret


  @staticmethod
  def octahedron_decode(uv:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not uv is None)
    assert isinstance(uv, Vector2), 'uv must be Vector2'







    _ret = Vector3.construct_without_init()
    _ret._ptr = static_method(1037,0,tuple([uv._ptr]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Vector3):
      _ret = False

      _ret= self._ptr.call_with_return(60, (other,))
      return _ret

    _ret= self._ptr.call_with_return(60, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Vector3):
      _ret = False

      _ret= self._ptr.call_with_return(61, (other,))
      return _ret

    _ret= self._ptr.call_with_return(61, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, int):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(72, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(72, (other,))
      return _ret
    if isinstance(other, Vector3):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(72, (other,))
      return _ret
    if isinstance(other, Quaternion):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(72, (other,))
      return _ret
    if isinstance(other, Basis):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(72, (other,))
      return _ret
    if isinstance(other, Transform3D):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(72, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __truediv__(self, other):
    if isinstance(other, int):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(69, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(69, (other,))
      return _ret
    if isinstance(other, Vector3):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(69, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __lt__(self, other):
    if isinstance(other, Vector3):
      _ret = False

      _ret= self._ptr.call_with_return(62, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __le__(self, other):
    if isinstance(other, Vector3):
      _ret = False

      _ret= self._ptr.call_with_return(63, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __gt__(self, other):
    if isinstance(other, Vector3):
      _ret = False

      _ret= self._ptr.call_with_return(64, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __ge__(self, other):
    if isinstance(other, Vector3):
      _ret = False

      _ret= self._ptr.call_with_return(65, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __add__(self, other):
    if isinstance(other, Vector3):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(66, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __sub__(self, other):
    if isinstance(other, Vector3):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(67, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPVector3iWrapper

class Axis:
  AXIS_X = 0
  AXIS_Y = 1
  AXIS_Z = 2


class Vector3i(CoreType):
  r''''''
  ZERO:typing.ClassVar['Vector3i'] # Vector3i(0, 0, 0)

  ONE:typing.ClassVar['Vector3i'] # Vector3i(1, 1, 1)

  MIN:typing.ClassVar['Vector3i'] # Vector3i(-2147483648, -2147483648, -2147483648)

  MAX:typing.ClassVar['Vector3i'] # Vector3i(2147483647, 2147483647, 2147483647)

  LEFT:typing.ClassVar['Vector3i'] # Vector3i(-1, 0, 0)

  RIGHT:typing.ClassVar['Vector3i'] # Vector3i(1, 0, 0)

  UP:typing.ClassVar['Vector3i'] # Vector3i(0, 1, 0)

  DOWN:typing.ClassVar['Vector3i'] # Vector3i(0, -1, 0)

  FORWARD:typing.ClassVar['Vector3i'] # Vector3i(0, 0, -1)

  BACK:typing.ClassVar['Vector3i'] # Vector3i(0, 0, 1)



  @staticmethod
  def new0():
    _class = Vector3i.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1038, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Vector3i' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector3i), 'from_ must be Vector3i'

    _class = Vector3i.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1038, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Vector3' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector3), 'from_ must be Vector3'

    _class = Vector3i.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1038, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(x:'int' , y:'int' , z:'int' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(z, (int, float)), 'z must be int or float'

    _class = Vector3i.construct_without_init()
    _class.constructed_from_python = True







    _class._ptr = constructor(1038, 3, tuple([x, y, z]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1038,0, ())

  def generate_wrapper(self):
    return CPPVector3iWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Vector3i.__new__(Vector3i)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Vector3i'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(16, ())


  @property
  def x(self) -> int:
    _ret = self._ptr.call_with_return(17, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_x(self) -> None:
    _ret = self._ptr.call_with_return(17, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @x.setter
  def x(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(18, tuple([value]))
  def set_x(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(18, tuple([value]))
  @property
  def y(self) -> int:
    _ret = self._ptr.call_with_return(19, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_y(self) -> None:
    _ret = self._ptr.call_with_return(19, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @y.setter
  def y(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(20, tuple([value]))
  def set_y(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(20, tuple([value]))
  @property
  def z(self) -> int:
    _ret = self._ptr.call_with_return(21, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_z(self) -> None:
    _ret = self._ptr.call_with_return(21, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @z.setter
  def z(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(22, tuple([value]))
  def set_z(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(22, tuple([value]))
  @functools.native_method
  def min_axis_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def max_axis_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def distance_to(self, to:'Vector3i'   ) -> typing.Union[float]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector3i), 'to must be Vector3i'







    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def distance_squared_to(self, to:'Vector3i'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector3i), 'to must be Vector3i'







    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([]))
    return _ret


  @functools.native_method
  def length_squared(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([]))
    return _ret


  @functools.native_method
  def sign(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector3i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(6,tuple([]))
    return _ret


  @functools.native_method
  def abs(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector3i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([]))
    return _ret


  @functools.native_method
  def clamp(self, min:'Vector3i'   , max:'Vector3i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not min is None)
    assert isinstance(min, Vector3i), 'min must be Vector3i'
    assert(not max is None)
    assert isinstance(max, Vector3i), 'max must be Vector3i'








    _ret = Vector3i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([min._ptr, max._ptr]))
    return _ret


  @functools.native_method
  def clampi(self, min:'int'   , max:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(min, (int, float)), 'min must be int or float'
    assert isinstance(max, (int, float)), 'max must be int or float'








    _ret = Vector3i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(9,tuple([min, max]))
    return _ret


  @functools.native_method
  def snapped(self, step:'Vector3i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not step is None)
    assert isinstance(step, Vector3i), 'step must be Vector3i'







    _ret = Vector3i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(10,tuple([step._ptr]))
    return _ret


  @functools.native_method
  def snappedi(self, step:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(step, (int, float)), 'step must be int or float'







    _ret = Vector3i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(11,tuple([step]))
    return _ret


  @functools.native_method
  def min(self, with_:'Vector3i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector3i), 'with_ must be Vector3i'







    _ret = Vector3i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(12,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def mini(self, with_:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(with_, (int, float)), 'with_ must be int or float'







    _ret = Vector3i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(13,tuple([with_]))
    return _ret


  @functools.native_method
  def max(self, with_:'Vector3i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector3i), 'with_ must be Vector3i'







    _ret = Vector3i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def maxi(self, with_:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(with_, (int, float)), 'with_ must be int or float'







    _ret = Vector3i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([with_]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Vector3i):
      _ret = False

      _ret= self._ptr.call_with_return(30, (other,))
      return _ret

    _ret= self._ptr.call_with_return(30, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Vector3i):
      _ret = False

      _ret= self._ptr.call_with_return(31, (other,))
      return _ret

    _ret= self._ptr.call_with_return(31, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, int):
      _ret = Vector3i()

      _ret._ptr = self._ptr.call_with_return(38, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(38, (other,))
      return _ret
    if isinstance(other, Vector3i):
      _ret = Vector3i()

      _ret._ptr = self._ptr.call_with_return(38, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __truediv__(self, other):
    if isinstance(other, int):
      _ret = Vector3i()

      _ret._ptr = self._ptr.call_with_return(39, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(39, (other,))
      return _ret
    if isinstance(other, Vector3i):
      _ret = Vector3i()

      _ret._ptr = self._ptr.call_with_return(39, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __mod__(self, other):
    if isinstance(other, int):
      _ret = Vector3i()

      _ret._ptr = self._ptr.call_with_return(40, (other,))
      return _ret
    if isinstance(other, Vector3i):
      _ret = Vector3i()

      _ret._ptr = self._ptr.call_with_return(40, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __lt__(self, other):
    if isinstance(other, Vector3i):
      _ret = False

      _ret= self._ptr.call_with_return(32, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __le__(self, other):
    if isinstance(other, Vector3i):
      _ret = False

      _ret= self._ptr.call_with_return(33, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __gt__(self, other):
    if isinstance(other, Vector3i):
      _ret = False

      _ret= self._ptr.call_with_return(34, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __ge__(self, other):
    if isinstance(other, Vector3i):
      _ret = False

      _ret= self._ptr.call_with_return(35, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __add__(self, other):
    if isinstance(other, Vector3i):
      _ret = Vector3i()

      _ret._ptr = self._ptr.call_with_return(36, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __sub__(self, other):
    if isinstance(other, Vector3i):
      _ret = Vector3i()

      _ret._ptr = self._ptr.call_with_return(37, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPTransform2DWrapper


class Transform2D(CoreType):
  r''''''
  IDENTITY:typing.ClassVar['Transform2D'] # Transform2D(1, 0, 0, 1, 0, 0)

  FLIP_X:typing.ClassVar['Transform2D'] # Transform2D(-1, 0, 0, 1, 0, 0)

  FLIP_Y:typing.ClassVar['Transform2D'] # Transform2D(1, 0, 0, -1, 0, 0)



  @staticmethod
  def new0():
    _class = Transform2D.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1039, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Transform2D' ):
    assert(not from_ is None)
    assert isinstance(from_, Transform2D), 'from_ must be Transform2D'

    _class = Transform2D.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1039, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(rotation:'float' , position:'Vector2' ):
    assert isinstance(rotation, (int, float)), 'rotation must be int or float'
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'

    _class = Transform2D.construct_without_init()
    _class.constructed_from_python = True




    _class.__position__ = position
    _class._ptr = constructor(1039, 2, tuple([rotation, position._ptr]))
    return _class
  @staticmethod
  def new3(rotation:'float' , scale:'Vector2' , skew:'float' , position:'Vector2' ):
    assert isinstance(rotation, (int, float)), 'rotation must be int or float'
    assert(not scale is None)
    assert isinstance(scale, Vector2), 'scale must be Vector2'
    assert isinstance(skew, (int, float)), 'skew must be int or float'
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'

    _class = Transform2D.construct_without_init()
    _class.constructed_from_python = True






    _class.__scale__ = scale

    _class.__position__ = position
    _class._ptr = constructor(1039, 3, tuple([rotation, scale._ptr, skew, position._ptr]))
    return _class
  @staticmethod
  def new4(x_axis:'Vector2' , y_axis:'Vector2' , origin:'Vector2' ):
    assert(not x_axis is None)
    assert isinstance(x_axis, Vector2), 'x_axis must be Vector2'
    assert(not y_axis is None)
    assert isinstance(y_axis, Vector2), 'y_axis must be Vector2'
    assert(not origin is None)
    assert isinstance(origin, Vector2), 'origin must be Vector2'

    _class = Transform2D.construct_without_init()
    _class.constructed_from_python = True




    _class.__x_axis__ = x_axis
    _class.__y_axis__ = y_axis
    _class.__origin__ = origin
    _class._ptr = constructor(1039, 4, tuple([x_axis._ptr, y_axis._ptr, origin._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1039,0, ())

  def generate_wrapper(self):
    return CPPTransform2DWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Transform2D.__new__(Transform2D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Transform2D'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(21, ())


  @property
  def x(self) -> Vector2:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22, tuple())
    return _ret
  def get_x(self) -> None:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22, tuple())
    return _ret

  @x.setter
  def x(self, value: 'Vector2' ):
    assert isinstance(value, Vector2), 'value must be Vector2'
    self._ptr.call_with_return(23, tuple([value._ptr]))
  def set_x(self, value: 'Vector2' ):
    assert isinstance(value, Vector2), 'value must be Vector2'
    self._ptr.call_with_return(23, tuple([value._ptr]))
  @property
  def y(self) -> Vector2:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(24, tuple())
    return _ret
  def get_y(self) -> None:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(24, tuple())
    return _ret

  @y.setter
  def y(self, value: 'Vector2' ):
    assert isinstance(value, Vector2), 'value must be Vector2'
    self._ptr.call_with_return(25, tuple([value._ptr]))
  def set_y(self, value: 'Vector2' ):
    assert isinstance(value, Vector2), 'value must be Vector2'
    self._ptr.call_with_return(25, tuple([value._ptr]))
  @property
  def origin(self) -> Vector2:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(26, tuple())
    return _ret
  def get_origin(self) -> None:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(26, tuple())
    return _ret

  @origin.setter
  def origin(self, value: 'Vector2' ):
    assert isinstance(value, Vector2), 'value must be Vector2'
    self._ptr.call_with_return(27, tuple([value._ptr]))
  def set_origin(self, value: 'Vector2' ):
    assert isinstance(value, Vector2), 'value must be Vector2'
    self._ptr.call_with_return(27, tuple([value._ptr]))
  @functools.native_method
  def inverse(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def affine_inverse(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def get_rotation(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def get_origin(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def get_scale(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(4,tuple([]))
    return _ret


  @functools.native_method
  def get_skew(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([]))
    return _ret


  @functools.native_method
  def orthonormalized(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(6,tuple([]))
    return _ret


  @functools.native_method
  def rotated(self, angle:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(angle, (int, float)), 'angle must be int or float'







    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([angle]))
    return _ret


  @functools.native_method
  def rotated_local(self, angle:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(angle, (int, float)), 'angle must be int or float'







    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([angle]))
    return _ret


  @functools.native_method
  def scaled(self, scale:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not scale is None)
    assert isinstance(scale, Vector2), 'scale must be Vector2'







    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(9,tuple([scale._ptr]))
    return _ret


  @functools.native_method
  def scaled_local(self, scale:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not scale is None)
    assert isinstance(scale, Vector2), 'scale must be Vector2'







    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(10,tuple([scale._ptr]))
    return _ret


  @functools.native_method
  def translated(self, offset:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'







    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(11,tuple([offset._ptr]))
    return _ret


  @functools.native_method
  def translated_local(self, offset:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'







    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(12,tuple([offset._ptr]))
    return _ret


  @functools.native_method
  def determinant(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(13,tuple([]))
    return _ret


  @functools.native_method
  def basis_xform(self, v:'Vector2'   ) -> typing.Union['Vector2']:
    r''''''

    assert(not v is None)
    assert isinstance(v, Vector2), 'v must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([v._ptr]))
    return _ret


  @functools.native_method
  def basis_xform_inv(self, v:'Vector2'   ) -> typing.Union['Vector2']:
    r''''''

    assert(not v is None)
    assert isinstance(v, Vector2), 'v must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([v._ptr]))
    return _ret


  @functools.native_method
  def interpolate_with(self, xform:'Transform2D'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not xform is None)
    assert isinstance(xform, Transform2D), 'xform must be Transform2D'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16,tuple([xform._ptr, weight]))
    return _ret


  @functools.native_method
  def is_conformal(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(17,tuple([]))
    return _ret


  @functools.native_method
  def is_equal_approx(self, xform:'Transform2D'   ) -> typing.Union[bool]:
    r''''''

    assert(not xform is None)
    assert isinstance(xform, Transform2D), 'xform must be Transform2D'







    _ret = 0
    _ret = self._ptr.call_with_return(18,tuple([xform._ptr]))
    return _ret


  @functools.native_method
  def is_finite(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([]))
    return _ret


  @functools.native_method
  def looking_at(self, target:'Vector2' = None  ) -> typing.Union['typing.Self']:
    r''''''
    if target is None:
      target = Vector2.new0()








    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20,tuple([target._ptr]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Transform2D):
      _ret = False

      _ret= self._ptr.call_with_return(36, (other,))
      return _ret

    _ret= self._ptr.call_with_return(36, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Transform2D):
      _ret = False

      _ret= self._ptr.call_with_return(37, (other,))
      return _ret

    _ret= self._ptr.call_with_return(37, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, int):
      _ret = Transform2D()

      _ret._ptr = self._ptr.call_with_return(39, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Transform2D()

      _ret._ptr = self._ptr.call_with_return(39, (other,))
      return _ret
    if isinstance(other, Vector2):
      _ret = Vector2()

      _ret._ptr = self._ptr.call_with_return(39, (other,))
      return _ret
    if isinstance(other, Rect2):
      _ret = Rect2()

      _ret._ptr = self._ptr.call_with_return(39, (other,))
      return _ret
    if isinstance(other, Transform2D):
      _ret = Transform2D()

      _ret._ptr = self._ptr.call_with_return(39, (other,))
      return _ret
    if isinstance(other, PackedVector2Array):
      _ret = PackedVector2Array()

      _ret._ptr = self._ptr.call_with_return(39, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __truediv__(self, other):
    if isinstance(other, int):
      _ret = Transform2D()

      _ret._ptr = self._ptr.call_with_return(33, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Transform2D()

      _ret._ptr = self._ptr.call_with_return(33, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPVector4Wrapper

class Axis:
  AXIS_X = 0
  AXIS_Y = 1
  AXIS_Z = 2
  AXIS_W = 3


class Vector4(CoreType):
  r''''''
  ZERO:typing.ClassVar['Vector4'] # Vector4(0, 0, 0, 0)

  ONE:typing.ClassVar['Vector4'] # Vector4(1, 1, 1, 1)

  INF:typing.ClassVar['Vector4'] # Vector4(inf, inf, inf, inf)



  @staticmethod
  def new0():
    _class = Vector4.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1040, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Vector4' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector4), 'from_ must be Vector4'

    _class = Vector4.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1040, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Vector4i' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector4i), 'from_ must be Vector4i'

    _class = Vector4.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1040, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(x:'float' , y:'float' , z:'float' , w:'float' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(z, (int, float)), 'z must be int or float'
    assert isinstance(w, (int, float)), 'w must be int or float'

    _class = Vector4.construct_without_init()
    _class.constructed_from_python = True









    _class._ptr = constructor(1040, 3, tuple([x, y, z, w]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1040,0, ())

  def generate_wrapper(self):
    return CPPVector4Wrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Vector4.__new__(Vector4)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Vector4'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(32, ())


  @property
  def x(self) -> float:
    _ret = self._ptr.call_with_return(33, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_x(self) -> None:
    _ret = self._ptr.call_with_return(33, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @x.setter
  def x(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(34, tuple([value]))
  def set_x(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(34, tuple([value]))
  @property
  def y(self) -> float:
    _ret = self._ptr.call_with_return(35, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_y(self) -> None:
    _ret = self._ptr.call_with_return(35, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @y.setter
  def y(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(36, tuple([value]))
  def set_y(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(36, tuple([value]))
  @property
  def z(self) -> float:
    _ret = self._ptr.call_with_return(37, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_z(self) -> None:
    _ret = self._ptr.call_with_return(37, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @z.setter
  def z(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(38, tuple([value]))
  def set_z(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(38, tuple([value]))
  @property
  def w(self) -> float:
    _ret = self._ptr.call_with_return(39, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_w(self) -> None:
    _ret = self._ptr.call_with_return(39, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @w.setter
  def w(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(40, tuple([value]))
  def set_w(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(40, tuple([value]))
  @functools.native_method
  def min_axis_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def max_axis_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def length_squared(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def abs(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(4,tuple([]))
    return _ret


  @functools.native_method
  def sign(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(5,tuple([]))
    return _ret


  @functools.native_method
  def floor(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(6,tuple([]))
    return _ret


  @functools.native_method
  def ceil(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([]))
    return _ret


  @functools.native_method
  def round(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([]))
    return _ret


  @functools.native_method
  def lerp(self, to:'Vector4'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector4), 'to must be Vector4'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(9,tuple([to._ptr, weight]))
    return _ret


  @functools.native_method
  def cubic_interpolate(self, b:'Vector4'   , pre_a:'Vector4'   , post_b:'Vector4'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not b is None)
    assert isinstance(b, Vector4), 'b must be Vector4'
    assert(not pre_a is None)
    assert isinstance(pre_a, Vector4), 'pre_a must be Vector4'
    assert(not post_b is None)
    assert isinstance(post_b, Vector4), 'post_b must be Vector4'
    assert isinstance(weight, (int, float)), 'weight must be int or float'










    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(10,tuple([b._ptr, pre_a._ptr, post_b._ptr, weight]))
    return _ret


  @functools.native_method
  def cubic_interpolate_in_time(self, b:'Vector4'   , pre_a:'Vector4'   , post_b:'Vector4'   , weight:'float'   , b_t:'float'   , pre_a_t:'float'   , post_b_t:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not b is None)
    assert isinstance(b, Vector4), 'b must be Vector4'
    assert(not pre_a is None)
    assert isinstance(pre_a, Vector4), 'pre_a must be Vector4'
    assert(not post_b is None)
    assert isinstance(post_b, Vector4), 'post_b must be Vector4'
    assert isinstance(weight, (int, float)), 'weight must be int or float'
    assert isinstance(b_t, (int, float)), 'b_t must be int or float'
    assert isinstance(pre_a_t, (int, float)), 'pre_a_t must be int or float'
    assert isinstance(post_b_t, (int, float)), 'post_b_t must be int or float'













    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(11,tuple([b._ptr, pre_a._ptr, post_b._ptr, weight, b_t, pre_a_t, post_b_t]))
    return _ret


  @functools.native_method
  def posmod(self, mod:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(mod, (int, float)), 'mod must be int or float'







    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(12,tuple([mod]))
    return _ret


  @functools.native_method
  def posmodv(self, modv:'Vector4'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not modv is None)
    assert isinstance(modv, Vector4), 'modv must be Vector4'







    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(13,tuple([modv._ptr]))
    return _ret


  @functools.native_method
  def snapped(self, step:'Vector4'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not step is None)
    assert isinstance(step, Vector4), 'step must be Vector4'







    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([step._ptr]))
    return _ret


  @functools.native_method
  def snappedf(self, step:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(step, (int, float)), 'step must be int or float'







    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([step]))
    return _ret


  @functools.native_method
  def clamp(self, min:'Vector4'   , max:'Vector4'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not min is None)
    assert isinstance(min, Vector4), 'min must be Vector4'
    assert(not max is None)
    assert isinstance(max, Vector4), 'max must be Vector4'








    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16,tuple([min._ptr, max._ptr]))
    return _ret


  @functools.native_method
  def clampf(self, min:'float'   , max:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(min, (int, float)), 'min must be int or float'
    assert isinstance(max, (int, float)), 'max must be int or float'








    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(17,tuple([min, max]))
    return _ret


  @functools.native_method
  def normalized(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18,tuple([]))
    return _ret


  @functools.native_method
  def is_normalized(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([]))
    return _ret


  @functools.native_method
  def direction_to(self, to:'Vector4'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector4), 'to must be Vector4'







    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def distance_to(self, to:'Vector4'   ) -> typing.Union[float]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector4), 'to must be Vector4'







    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def distance_squared_to(self, to:'Vector4'   ) -> typing.Union[float]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector4), 'to must be Vector4'







    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def dot(self, with_:'Vector4'   ) -> typing.Union[float]:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector4), 'with_ must be Vector4'







    _ret = 0
    _ret = self._ptr.call_with_return(23,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def inverse(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(24,tuple([]))
    return _ret


  @functools.native_method
  def is_equal_approx(self, to:'Vector4'   ) -> typing.Union[bool]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector4), 'to must be Vector4'







    _ret = 0
    _ret = self._ptr.call_with_return(25,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def is_zero_approx(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(26,tuple([]))
    return _ret


  @functools.native_method
  def is_finite(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(27,tuple([]))
    return _ret


  @functools.native_method
  def min(self, with_:'Vector4'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector4), 'with_ must be Vector4'







    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(28,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def minf(self, with_:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(with_, (int, float)), 'with_ must be int or float'







    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(29,tuple([with_]))
    return _ret


  @functools.native_method
  def max(self, with_:'Vector4'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector4), 'with_ must be Vector4'







    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(30,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def maxf(self, with_:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(with_, (int, float)), 'with_ must be int or float'







    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(31,tuple([with_]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Vector4):
      _ret = False

      _ret= self._ptr.call_with_return(47, (other,))
      return _ret

    _ret= self._ptr.call_with_return(47, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Vector4):
      _ret = False

      _ret= self._ptr.call_with_return(48, (other,))
      return _ret

    _ret= self._ptr.call_with_return(48, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, int):
      _ret = Vector4()

      _ret._ptr = self._ptr.call_with_return(57, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Vector4()

      _ret._ptr = self._ptr.call_with_return(57, (other,))
      return _ret
    if isinstance(other, Vector4):
      _ret = Vector4()

      _ret._ptr = self._ptr.call_with_return(57, (other,))
      return _ret
    if isinstance(other, Projection):
      _ret = Vector4()

      _ret._ptr = self._ptr.call_with_return(57, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __truediv__(self, other):
    if isinstance(other, int):
      _ret = Vector4()

      _ret._ptr = self._ptr.call_with_return(56, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Vector4()

      _ret._ptr = self._ptr.call_with_return(56, (other,))
      return _ret
    if isinstance(other, Vector4):
      _ret = Vector4()

      _ret._ptr = self._ptr.call_with_return(56, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __lt__(self, other):
    if isinstance(other, Vector4):
      _ret = False

      _ret= self._ptr.call_with_return(49, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __le__(self, other):
    if isinstance(other, Vector4):
      _ret = False

      _ret= self._ptr.call_with_return(50, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __gt__(self, other):
    if isinstance(other, Vector4):
      _ret = False

      _ret= self._ptr.call_with_return(51, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __ge__(self, other):
    if isinstance(other, Vector4):
      _ret = False

      _ret= self._ptr.call_with_return(52, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __add__(self, other):
    if isinstance(other, Vector4):
      _ret = Vector4()

      _ret._ptr = self._ptr.call_with_return(53, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __sub__(self, other):
    if isinstance(other, Vector4):
      _ret = Vector4()

      _ret._ptr = self._ptr.call_with_return(54, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPVector4iWrapper

class Axis:
  AXIS_X = 0
  AXIS_Y = 1
  AXIS_Z = 2
  AXIS_W = 3


class Vector4i(CoreType):
  r''''''
  ZERO:typing.ClassVar['Vector4i'] # Vector4i(0, 0, 0, 0)

  ONE:typing.ClassVar['Vector4i'] # Vector4i(1, 1, 1, 1)

  MIN:typing.ClassVar['Vector4i'] # Vector4i(-2147483648, -2147483648, -2147483648, -2147483648)

  MAX:typing.ClassVar['Vector4i'] # Vector4i(2147483647, 2147483647, 2147483647, 2147483647)



  @staticmethod
  def new0():
    _class = Vector4i.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1041, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Vector4i' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector4i), 'from_ must be Vector4i'

    _class = Vector4i.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1041, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Vector4' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector4), 'from_ must be Vector4'

    _class = Vector4i.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1041, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(x:'int' , y:'int' , z:'int' , w:'int' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(z, (int, float)), 'z must be int or float'
    assert isinstance(w, (int, float)), 'w must be int or float'

    _class = Vector4i.construct_without_init()
    _class.constructed_from_python = True









    _class._ptr = constructor(1041, 3, tuple([x, y, z, w]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1041,0, ())

  def generate_wrapper(self):
    return CPPVector4iWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Vector4i.__new__(Vector4i)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Vector4i'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(16, ())


  @property
  def x(self) -> int:
    _ret = self._ptr.call_with_return(17, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_x(self) -> None:
    _ret = self._ptr.call_with_return(17, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @x.setter
  def x(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(18, tuple([value]))
  def set_x(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(18, tuple([value]))
  @property
  def y(self) -> int:
    _ret = self._ptr.call_with_return(19, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_y(self) -> None:
    _ret = self._ptr.call_with_return(19, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @y.setter
  def y(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(20, tuple([value]))
  def set_y(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(20, tuple([value]))
  @property
  def z(self) -> int:
    _ret = self._ptr.call_with_return(21, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_z(self) -> None:
    _ret = self._ptr.call_with_return(21, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @z.setter
  def z(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(22, tuple([value]))
  def set_z(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(22, tuple([value]))
  @property
  def w(self) -> int:
    _ret = self._ptr.call_with_return(23, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_w(self) -> None:
    _ret = self._ptr.call_with_return(23, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @w.setter
  def w(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(24, tuple([value]))
  def set_w(self, value: 'int' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(24, tuple([value]))
  @functools.native_method
  def min_axis_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def max_axis_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def length_squared(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def sign(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector4i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(4,tuple([]))
    return _ret


  @functools.native_method
  def abs(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Vector4i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(5,tuple([]))
    return _ret


  @functools.native_method
  def clamp(self, min:'Vector4i'   , max:'Vector4i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not min is None)
    assert isinstance(min, Vector4i), 'min must be Vector4i'
    assert(not max is None)
    assert isinstance(max, Vector4i), 'max must be Vector4i'








    _ret = Vector4i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(6,tuple([min._ptr, max._ptr]))
    return _ret


  @functools.native_method
  def clampi(self, min:'int'   , max:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(min, (int, float)), 'min must be int or float'
    assert isinstance(max, (int, float)), 'max must be int or float'








    _ret = Vector4i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([min, max]))
    return _ret


  @functools.native_method
  def snapped(self, step:'Vector4i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not step is None)
    assert isinstance(step, Vector4i), 'step must be Vector4i'







    _ret = Vector4i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([step._ptr]))
    return _ret


  @functools.native_method
  def snappedi(self, step:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(step, (int, float)), 'step must be int or float'







    _ret = Vector4i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(9,tuple([step]))
    return _ret


  @functools.native_method
  def min(self, with_:'Vector4i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector4i), 'with_ must be Vector4i'







    _ret = Vector4i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(10,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def mini(self, with_:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(with_, (int, float)), 'with_ must be int or float'







    _ret = Vector4i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(11,tuple([with_]))
    return _ret


  @functools.native_method
  def max(self, with_:'Vector4i'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector4i), 'with_ must be Vector4i'







    _ret = Vector4i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(12,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def maxi(self, with_:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(with_, (int, float)), 'with_ must be int or float'







    _ret = Vector4i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(13,tuple([with_]))
    return _ret


  @functools.native_method
  def distance_to(self, to:'Vector4i'   ) -> typing.Union[float]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector4i), 'to must be Vector4i'







    _ret = 0
    _ret = self._ptr.call_with_return(14,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def distance_squared_to(self, to:'Vector4i'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Vector4i), 'to must be Vector4i'







    _ret = 0
    _ret = self._ptr.call_with_return(15,tuple([to._ptr]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Vector4i):
      _ret = False

      _ret= self._ptr.call_with_return(32, (other,))
      return _ret

    _ret= self._ptr.call_with_return(32, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Vector4i):
      _ret = False

      _ret= self._ptr.call_with_return(33, (other,))
      return _ret

    _ret= self._ptr.call_with_return(33, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, int):
      _ret = Vector4i()

      _ret._ptr = self._ptr.call_with_return(40, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Vector4()

      _ret._ptr = self._ptr.call_with_return(40, (other,))
      return _ret
    if isinstance(other, Vector4i):
      _ret = Vector4i()

      _ret._ptr = self._ptr.call_with_return(40, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __truediv__(self, other):
    if isinstance(other, int):
      _ret = Vector4i()

      _ret._ptr = self._ptr.call_with_return(41, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Vector4()

      _ret._ptr = self._ptr.call_with_return(41, (other,))
      return _ret
    if isinstance(other, Vector4i):
      _ret = Vector4i()

      _ret._ptr = self._ptr.call_with_return(41, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __mod__(self, other):
    if isinstance(other, int):
      _ret = Vector4i()

      _ret._ptr = self._ptr.call_with_return(42, (other,))
      return _ret
    if isinstance(other, Vector4i):
      _ret = Vector4i()

      _ret._ptr = self._ptr.call_with_return(42, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __lt__(self, other):
    if isinstance(other, Vector4i):
      _ret = False

      _ret= self._ptr.call_with_return(34, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __le__(self, other):
    if isinstance(other, Vector4i):
      _ret = False

      _ret= self._ptr.call_with_return(35, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __gt__(self, other):
    if isinstance(other, Vector4i):
      _ret = False

      _ret= self._ptr.call_with_return(36, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __ge__(self, other):
    if isinstance(other, Vector4i):
      _ret = False

      _ret= self._ptr.call_with_return(37, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __add__(self, other):
    if isinstance(other, Vector4i):
      _ret = Vector4i()

      _ret._ptr = self._ptr.call_with_return(38, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __sub__(self, other):
    if isinstance(other, Vector4i):
      _ret = Vector4i()

      _ret._ptr = self._ptr.call_with_return(39, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPPlaneWrapper


class Plane(CoreType):
  r''''''
  PLANE_YZ:typing.ClassVar['Plane'] # Plane(1, 0, 0, 0)

  PLANE_XZ:typing.ClassVar['Plane'] # Plane(0, 1, 0, 0)

  PLANE_XY:typing.ClassVar['Plane'] # Plane(0, 0, 1, 0)



  @staticmethod
  def new0():
    _class = Plane.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1042, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Plane' ):
    assert(not from_ is None)
    assert isinstance(from_, Plane), 'from_ must be Plane'

    _class = Plane.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1042, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(normal:'Vector3' ):
    assert(not normal is None)
    assert isinstance(normal, Vector3), 'normal must be Vector3'

    _class = Plane.construct_without_init()
    _class.constructed_from_python = True


    _class.__normal__ = normal
    _class._ptr = constructor(1042, 2, tuple([normal._ptr]))
    return _class
  @staticmethod
  def new3(normal:'Vector3' , d:'float' ):
    assert(not normal is None)
    assert isinstance(normal, Vector3), 'normal must be Vector3'
    assert isinstance(d, (int, float)), 'd must be int or float'

    _class = Plane.construct_without_init()
    _class.constructed_from_python = True



    _class.__normal__ = normal

    _class._ptr = constructor(1042, 3, tuple([normal._ptr, d]))
    return _class
  @staticmethod
  def new4(normal:'Vector3' , point:'Vector3' ):
    assert(not normal is None)
    assert isinstance(normal, Vector3), 'normal must be Vector3'
    assert(not point is None)
    assert isinstance(point, Vector3), 'point must be Vector3'

    _class = Plane.construct_without_init()
    _class.constructed_from_python = True



    _class.__normal__ = normal
    _class.__point__ = point
    _class._ptr = constructor(1042, 4, tuple([normal._ptr, point._ptr]))
    return _class
  @staticmethod
  def new5(point1:'Vector3' , point2:'Vector3' , point3:'Vector3' ):
    assert(not point1 is None)
    assert isinstance(point1, Vector3), 'point1 must be Vector3'
    assert(not point2 is None)
    assert isinstance(point2, Vector3), 'point2 must be Vector3'
    assert(not point3 is None)
    assert isinstance(point3, Vector3), 'point3 must be Vector3'

    _class = Plane.construct_without_init()
    _class.constructed_from_python = True




    _class.__point1__ = point1
    _class.__point2__ = point2
    _class.__point3__ = point3
    _class._ptr = constructor(1042, 5, tuple([point1._ptr, point2._ptr, point3._ptr]))
    return _class
  @staticmethod
  def new6(a:'float' , b:'float' , c:'float' , d:'float' ):
    assert isinstance(a, (int, float)), 'a must be int or float'
    assert isinstance(b, (int, float)), 'b must be int or float'
    assert isinstance(c, (int, float)), 'c must be int or float'
    assert isinstance(d, (int, float)), 'd must be int or float'

    _class = Plane.construct_without_init()
    _class.constructed_from_python = True









    _class._ptr = constructor(1042, 6, tuple([a, b, c, d]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1042,0, ())

  def generate_wrapper(self):
    return CPPPlaneWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Plane.__new__(Plane)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Plane'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(11, ())


  @property
  def normal(self) -> Vector3:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20, tuple())
    return _ret
  def get_normal(self) -> None:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20, tuple())
    return _ret

  @normal.setter
  def normal(self, value: 'Vector3' ):
    assert isinstance(value, Vector3), 'value must be Vector3'
    self._ptr.call_with_return(21, tuple([value._ptr]))
  def set_normal(self, value: 'Vector3' ):
    assert isinstance(value, Vector3), 'value must be Vector3'
    self._ptr.call_with_return(21, tuple([value._ptr]))
  @property
  def d(self) -> float:
    _ret = self._ptr.call_with_return(18, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_d(self) -> None:
    _ret = self._ptr.call_with_return(18, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @d.setter
  def d(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(19, tuple([value]))
  def set_d(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(19, tuple([value]))
  @functools.native_method
  def normalized(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Plane.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def get_center(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def is_equal_approx(self, to_plane:'Plane'   ) -> typing.Union[bool]:
    r''''''

    assert(not to_plane is None)
    assert isinstance(to_plane, Plane), 'to_plane must be Plane'







    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([to_plane._ptr]))
    return _ret


  @functools.native_method
  def is_finite(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def is_point_over(self, point:'Vector3'   ) -> typing.Union[bool]:
    r''''''

    assert(not point is None)
    assert isinstance(point, Vector3), 'point must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([point._ptr]))
    return _ret


  @functools.native_method
  def distance_to(self, point:'Vector3'   ) -> typing.Union[float]:
    r''''''

    assert(not point is None)
    assert isinstance(point, Vector3), 'point must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([point._ptr]))
    return _ret


  @functools.native_method
  def has_point(self, point:'Vector3'   , tolerance:'float' =1e-05  ) -> typing.Union[bool]:
    r''''''

    assert(not point is None)
    assert isinstance(point, Vector3), 'point must be Vector3'
    assert isinstance(tolerance, (int, float)), 'tolerance must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(6,tuple([point._ptr, tolerance]))
    return _ret


  @functools.native_method
  def project(self, point:'Vector3'   ) -> typing.Union['Vector3']:
    r''''''

    assert(not point is None)
    assert isinstance(point, Vector3), 'point must be Vector3'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([point._ptr]))
    return _ret


  @functools.native_method
  def intersect_3(self, b:'Plane'   , c:'Plane'   ) -> typing.Union[typing.Any]:
    r''''''

    assert(not b is None)
    assert isinstance(b, Plane), 'b must be Plane'
    assert(not c is None)
    assert isinstance(c, Plane), 'c must be Plane'








    _ret = None
    _ret = self._ptr.call_with_return(8,tuple([b._ptr, c._ptr]))
    return _ret


  @functools.native_method
  def intersects_ray(self, from_:'Vector3'   , dir:'Vector3'   ) -> typing.Union[typing.Any]:
    r''''''

    assert(not from_ is None)
    assert isinstance(from_, Vector3), 'from_ must be Vector3'
    assert(not dir is None)
    assert isinstance(dir, Vector3), 'dir must be Vector3'








    _ret = None
    _ret = self._ptr.call_with_return(9,tuple([from_._ptr, dir._ptr]))
    return _ret


  @functools.native_method
  def intersects_segment(self, from_:'Vector3'   , to:'Vector3'   ) -> typing.Union[typing.Any]:
    r''''''

    assert(not from_ is None)
    assert isinstance(from_, Vector3), 'from_ must be Vector3'
    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'








    _ret = None
    _ret = self._ptr.call_with_return(10,tuple([from_._ptr, to._ptr]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Plane):
      _ret = False

      _ret= self._ptr.call_with_return(24, (other,))
      return _ret

    _ret= self._ptr.call_with_return(24, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Plane):
      _ret = False

      _ret= self._ptr.call_with_return(25, (other,))
      return _ret

    _ret= self._ptr.call_with_return(25, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, Transform3D):
      _ret = Plane()

      _ret._ptr = self._ptr.call_with_return(26, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPQuaternionWrapper


class Quaternion(CoreType):
  r''''''
  IDENTITY:typing.ClassVar['Quaternion'] # Quaternion(0, 0, 0, 1)



  @staticmethod
  def new0():
    _class = Quaternion.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1043, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Quaternion' ):
    assert(not from_ is None)
    assert isinstance(from_, Quaternion), 'from_ must be Quaternion'

    _class = Quaternion.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1043, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Basis' ):
    assert(not from_ is None)
    assert isinstance(from_, Basis), 'from_ must be Basis'

    _class = Quaternion.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1043, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(axis:'Vector3' , angle:'float' ):
    assert(not axis is None)
    assert isinstance(axis, Vector3), 'axis must be Vector3'
    assert isinstance(angle, (int, float)), 'angle must be int or float'

    _class = Quaternion.construct_without_init()
    _class.constructed_from_python = True



    _class.__axis__ = axis

    _class._ptr = constructor(1043, 3, tuple([axis._ptr, angle]))
    return _class
  @staticmethod
  def new4(arc_from:'Vector3' , arc_to:'Vector3' ):
    assert(not arc_from is None)
    assert isinstance(arc_from, Vector3), 'arc_from must be Vector3'
    assert(not arc_to is None)
    assert isinstance(arc_to, Vector3), 'arc_to must be Vector3'

    _class = Quaternion.construct_without_init()
    _class.constructed_from_python = True



    _class.__arc_from__ = arc_from
    _class.__arc_to__ = arc_to
    _class._ptr = constructor(1043, 4, tuple([arc_from._ptr, arc_to._ptr]))
    return _class
  @staticmethod
  def new5(x:'float' , y:'float' , z:'float' , w:'float' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(z, (int, float)), 'z must be int or float'
    assert isinstance(w, (int, float)), 'w must be int or float'

    _class = Quaternion.construct_without_init()
    _class.constructed_from_python = True









    _class._ptr = constructor(1043, 5, tuple([x, y, z, w]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1043,0, ())

  def generate_wrapper(self):
    return CPPQuaternionWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Quaternion.__new__(Quaternion)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Quaternion'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(18, ())


  @property
  def x(self) -> float:
    _ret = self._ptr.call_with_return(19, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_x(self) -> None:
    _ret = self._ptr.call_with_return(19, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @x.setter
  def x(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(20, tuple([value]))
  def set_x(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(20, tuple([value]))
  @property
  def y(self) -> float:
    _ret = self._ptr.call_with_return(21, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_y(self) -> None:
    _ret = self._ptr.call_with_return(21, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @y.setter
  def y(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(22, tuple([value]))
  def set_y(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(22, tuple([value]))
  @property
  def z(self) -> float:
    _ret = self._ptr.call_with_return(23, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_z(self) -> None:
    _ret = self._ptr.call_with_return(23, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @z.setter
  def z(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(24, tuple([value]))
  def set_z(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(24, tuple([value]))
  @property
  def w(self) -> float:
    _ret = self._ptr.call_with_return(25, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_w(self) -> None:
    _ret = self._ptr.call_with_return(25, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @w.setter
  def w(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(26, tuple([value]))
  def set_w(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(26, tuple([value]))
  @functools.native_method
  def length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def length_squared(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def normalized(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def is_normalized(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def is_equal_approx(self, to:'Quaternion'   ) -> typing.Union[bool]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Quaternion), 'to must be Quaternion'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def is_finite(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([]))
    return _ret


  @functools.native_method
  def inverse(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(6,tuple([]))
    return _ret


  @functools.native_method
  def log(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([]))
    return _ret


  @functools.native_method
  def exp(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([]))
    return _ret


  @functools.native_method
  def angle_to(self, to:'Quaternion'   ) -> typing.Union[float]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Quaternion), 'to must be Quaternion'







    _ret = 0
    _ret = self._ptr.call_with_return(9,tuple([to._ptr]))
    return _ret


  @functools.native_method
  def dot(self, with_:'Quaternion'   ) -> typing.Union[float]:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Quaternion), 'with_ must be Quaternion'







    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def slerp(self, to:'Quaternion'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Quaternion), 'to must be Quaternion'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(11,tuple([to._ptr, weight]))
    return _ret


  @functools.native_method
  def slerpni(self, to:'Quaternion'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Quaternion), 'to must be Quaternion'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(12,tuple([to._ptr, weight]))
    return _ret


  @functools.native_method
  def spherical_cubic_interpolate(self, b:'Quaternion'   , pre_a:'Quaternion'   , post_b:'Quaternion'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not b is None)
    assert isinstance(b, Quaternion), 'b must be Quaternion'
    assert(not pre_a is None)
    assert isinstance(pre_a, Quaternion), 'pre_a must be Quaternion'
    assert(not post_b is None)
    assert isinstance(post_b, Quaternion), 'post_b must be Quaternion'
    assert isinstance(weight, (int, float)), 'weight must be int or float'










    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(13,tuple([b._ptr, pre_a._ptr, post_b._ptr, weight]))
    return _ret


  @functools.native_method
  def spherical_cubic_interpolate_in_time(self, b:'Quaternion'   , pre_a:'Quaternion'   , post_b:'Quaternion'   , weight:'float'   , b_t:'float'   , pre_a_t:'float'   , post_b_t:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not b is None)
    assert isinstance(b, Quaternion), 'b must be Quaternion'
    assert(not pre_a is None)
    assert isinstance(pre_a, Quaternion), 'pre_a must be Quaternion'
    assert(not post_b is None)
    assert isinstance(post_b, Quaternion), 'post_b must be Quaternion'
    assert isinstance(weight, (int, float)), 'weight must be int or float'
    assert isinstance(b_t, (int, float)), 'b_t must be int or float'
    assert isinstance(pre_a_t, (int, float)), 'pre_a_t must be int or float'
    assert isinstance(post_b_t, (int, float)), 'post_b_t must be int or float'













    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([b._ptr, pre_a._ptr, post_b._ptr, weight, b_t, pre_a_t, post_b_t]))
    return _ret


  @functools.native_method
  def get_euler(self, order:'int' =2  ) -> typing.Union['Vector3']:
    r''''''

    assert isinstance(order, (int, float)), 'order must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([order]))
    return _ret


  @staticmethod
  def from_euler(euler:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not euler is None)
    assert isinstance(euler, Vector3), 'euler must be Vector3'







    _ret = Quaternion.construct_without_init()
    _ret._ptr = static_method(1043,0,tuple([euler._ptr]))
    return _ret


  @functools.native_method
  def get_axis(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16,tuple([]))
    return _ret


  @functools.native_method
  def get_angle(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(17,tuple([]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Quaternion):
      _ret = False

      _ret= self._ptr.call_with_return(34, (other,))
      return _ret

    _ret= self._ptr.call_with_return(34, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Quaternion):
      _ret = False

      _ret= self._ptr.call_with_return(35, (other,))
      return _ret

    _ret= self._ptr.call_with_return(35, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, int):
      _ret = Quaternion()

      _ret._ptr = self._ptr.call_with_return(38, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Quaternion()

      _ret._ptr = self._ptr.call_with_return(38, (other,))
      return _ret
    if isinstance(other, Vector3):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(38, (other,))
      return _ret
    if isinstance(other, Quaternion):
      _ret = Quaternion()

      _ret._ptr = self._ptr.call_with_return(38, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __truediv__(self, other):
    if isinstance(other, int):
      _ret = Quaternion()

      _ret._ptr = self._ptr.call_with_return(32, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Quaternion()

      _ret._ptr = self._ptr.call_with_return(32, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __add__(self, other):
    if isinstance(other, Quaternion):
      _ret = Quaternion()

      _ret._ptr = self._ptr.call_with_return(36, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __sub__(self, other):
    if isinstance(other, Quaternion):
      _ret = Quaternion()

      _ret._ptr = self._ptr.call_with_return(37, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPAABBWrapper


class AABB(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = AABB.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1044, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'AABB' ):
    assert(not from_ is None)
    assert isinstance(from_, AABB), 'from_ must be AABB'

    _class = AABB.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1044, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(position:'Vector3' , size:'Vector3' ):
    assert(not position is None)
    assert isinstance(position, Vector3), 'position must be Vector3'
    assert(not size is None)
    assert isinstance(size, Vector3), 'size must be Vector3'

    _class = AABB.construct_without_init()
    _class.constructed_from_python = True



    _class.__position__ = position
    _class.__size__ = size
    _class._ptr = constructor(1044, 2, tuple([position._ptr, size._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1044,0, ())

  def generate_wrapper(self):
    return CPPAABBWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = AABB.__new__(AABB)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AABB'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(25, ())


  @property
  def position(self) -> Vector3:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(26, tuple())
    return _ret
  def get_position(self) -> None:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(26, tuple())
    return _ret

  @position.setter
  def position(self, value: 'Vector3' ):
    assert isinstance(value, Vector3), 'value must be Vector3'
    self._ptr.call_with_return(27, tuple([value._ptr]))
  def set_position(self, value: 'Vector3' ):
    assert isinstance(value, Vector3), 'value must be Vector3'
    self._ptr.call_with_return(27, tuple([value._ptr]))
  @property
  def size(self) -> Vector3:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(28, tuple())
    return _ret
  def get_size(self) -> None:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(28, tuple())
    return _ret

  @size.setter
  def size(self, value: 'Vector3' ):
    assert isinstance(value, Vector3), 'value must be Vector3'
    self._ptr.call_with_return(29, tuple([value._ptr]))
  def set_size(self, value: 'Vector3' ):
    assert isinstance(value, Vector3), 'value must be Vector3'
    self._ptr.call_with_return(29, tuple([value._ptr]))
  @functools.native_method
  def abs(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def get_center(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def get_volume(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def has_volume(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def has_surface(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([]))
    return _ret


  @functools.native_method
  def has_point(self, point:'Vector3'   ) -> typing.Union[bool]:
    r''''''

    assert(not point is None)
    assert isinstance(point, Vector3), 'point must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([point._ptr]))
    return _ret


  @functools.native_method
  def is_equal_approx(self, aabb:'AABB'   ) -> typing.Union[bool]:
    r''''''

    assert(not aabb is None)
    assert isinstance(aabb, AABB), 'aabb must be AABB'







    _ret = 0
    _ret = self._ptr.call_with_return(6,tuple([aabb._ptr]))
    return _ret


  @functools.native_method
  def is_finite(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(7,tuple([]))
    return _ret


  @functools.native_method
  def intersects(self, with_:'AABB'   ) -> typing.Union[bool]:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, AABB), 'with_ must be AABB'







    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def encloses(self, with_:'AABB'   ) -> typing.Union[bool]:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, AABB), 'with_ must be AABB'







    _ret = 0
    _ret = self._ptr.call_with_return(9,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def intersects_plane(self, plane:'Plane'   ) -> typing.Union[bool]:
    r''''''

    assert(not plane is None)
    assert isinstance(plane, Plane), 'plane must be Plane'







    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([plane._ptr]))
    return _ret


  @functools.native_method
  def intersection(self, with_:'AABB'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, AABB), 'with_ must be AABB'







    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(11,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def merge(self, with_:'AABB'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, AABB), 'with_ must be AABB'







    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(12,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def expand(self, to_point:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to_point is None)
    assert isinstance(to_point, Vector3), 'to_point must be Vector3'







    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(13,tuple([to_point._ptr]))
    return _ret


  @functools.native_method
  def grow(self, by:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(by, (int, float)), 'by must be int or float'







    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([by]))
    return _ret


  @functools.native_method
  def get_support(self, direction:'Vector3'   ) -> typing.Union['Vector3']:
    r''''''

    assert(not direction is None)
    assert isinstance(direction, Vector3), 'direction must be Vector3'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([direction._ptr]))
    return _ret


  @functools.native_method
  def get_longest_axis(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16,tuple([]))
    return _ret


  @functools.native_method
  def get_longest_axis_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(17,tuple([]))
    return _ret


  @functools.native_method
  def get_longest_axis_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(18,tuple([]))
    return _ret


  @functools.native_method
  def get_shortest_axis(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(19,tuple([]))
    return _ret


  @functools.native_method
  def get_shortest_axis_index(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([]))
    return _ret


  @functools.native_method
  def get_shortest_axis_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([]))
    return _ret


  @functools.native_method
  def get_endpoint(self, idx:'int'   ) -> typing.Union['Vector3']:
    r''''''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22,tuple([idx]))
    return _ret


  @functools.native_method
  def intersects_segment(self, from_:'Vector3'   , to:'Vector3'   ) -> typing.Union[typing.Any]:
    r''''''

    assert(not from_ is None)
    assert isinstance(from_, Vector3), 'from_ must be Vector3'
    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'








    _ret = None
    _ret = self._ptr.call_with_return(23,tuple([from_._ptr, to._ptr]))
    return _ret


  @functools.native_method
  def intersects_ray(self, from_:'Vector3'   , dir:'Vector3'   ) -> typing.Union[typing.Any]:
    r''''''

    assert(not from_ is None)
    assert isinstance(from_, Vector3), 'from_ must be Vector3'
    assert(not dir is None)
    assert isinstance(dir, Vector3), 'dir must be Vector3'








    _ret = None
    _ret = self._ptr.call_with_return(24,tuple([from_._ptr, dir._ptr]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, AABB):
      _ret = False

      _ret= self._ptr.call_with_return(34, (other,))
      return _ret

    _ret= self._ptr.call_with_return(34, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, AABB):
      _ret = False

      _ret= self._ptr.call_with_return(35, (other,))
      return _ret

    _ret= self._ptr.call_with_return(35, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, Transform3D):
      _ret = AABB()

      _ret._ptr = self._ptr.call_with_return(36, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPBasisWrapper


class Basis(CoreType):
  r''''''
  IDENTITY:typing.ClassVar['Basis'] # Basis(1, 0, 0, 0, 1, 0, 0, 0, 1)

  FLIP_X:typing.ClassVar['Basis'] # Basis(-1, 0, 0, 0, 1, 0, 0, 0, 1)

  FLIP_Y:typing.ClassVar['Basis'] # Basis(1, 0, 0, 0, -1, 0, 0, 0, 1)

  FLIP_Z:typing.ClassVar['Basis'] # Basis(1, 0, 0, 0, 1, 0, 0, 0, -1)



  @staticmethod
  def new0():
    _class = Basis.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1045, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Basis' ):
    assert(not from_ is None)
    assert isinstance(from_, Basis), 'from_ must be Basis'

    _class = Basis.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1045, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Quaternion' ):
    assert(not from_ is None)
    assert isinstance(from_, Quaternion), 'from_ must be Quaternion'

    _class = Basis.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1045, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(axis:'Vector3' , angle:'float' ):
    assert(not axis is None)
    assert isinstance(axis, Vector3), 'axis must be Vector3'
    assert isinstance(angle, (int, float)), 'angle must be int or float'

    _class = Basis.construct_without_init()
    _class.constructed_from_python = True



    _class.__axis__ = axis

    _class._ptr = constructor(1045, 3, tuple([axis._ptr, angle]))
    return _class
  @staticmethod
  def new4(x_axis:'Vector3' , y_axis:'Vector3' , z_axis:'Vector3' ):
    assert(not x_axis is None)
    assert isinstance(x_axis, Vector3), 'x_axis must be Vector3'
    assert(not y_axis is None)
    assert isinstance(y_axis, Vector3), 'y_axis must be Vector3'
    assert(not z_axis is None)
    assert isinstance(z_axis, Vector3), 'z_axis must be Vector3'

    _class = Basis.construct_without_init()
    _class.constructed_from_python = True




    _class.__x_axis__ = x_axis
    _class.__y_axis__ = y_axis
    _class.__z_axis__ = z_axis
    _class._ptr = constructor(1045, 4, tuple([x_axis._ptr, y_axis._ptr, z_axis._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1045,0, ())

  def generate_wrapper(self):
    return CPPBasisWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Basis.__new__(Basis)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Basis'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(17, ())


  @property
  def x(self) -> Vector3:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18, tuple())
    return _ret
  def get_x(self) -> None:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18, tuple())
    return _ret

  @x.setter
  def x(self, value: 'Vector3' ):
    assert isinstance(value, Vector3), 'value must be Vector3'
    self._ptr.call_with_return(19, tuple([value._ptr]))
  def set_x(self, value: 'Vector3' ):
    assert isinstance(value, Vector3), 'value must be Vector3'
    self._ptr.call_with_return(19, tuple([value._ptr]))
  @property
  def y(self) -> Vector3:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20, tuple())
    return _ret
  def get_y(self) -> None:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20, tuple())
    return _ret

  @y.setter
  def y(self, value: 'Vector3' ):
    assert isinstance(value, Vector3), 'value must be Vector3'
    self._ptr.call_with_return(21, tuple([value._ptr]))
  def set_y(self, value: 'Vector3' ):
    assert isinstance(value, Vector3), 'value must be Vector3'
    self._ptr.call_with_return(21, tuple([value._ptr]))
  @property
  def z(self) -> Vector3:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22, tuple())
    return _ret
  def get_z(self) -> None:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22, tuple())
    return _ret

  @z.setter
  def z(self, value: 'Vector3' ):
    assert isinstance(value, Vector3), 'value must be Vector3'
    self._ptr.call_with_return(23, tuple([value._ptr]))
  def set_z(self, value: 'Vector3' ):
    assert isinstance(value, Vector3), 'value must be Vector3'
    self._ptr.call_with_return(23, tuple([value._ptr]))
  @functools.native_method
  def inverse(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def transposed(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def orthonormalized(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def determinant(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def rotated(self, axis:'Vector3'   , angle:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not axis is None)
    assert isinstance(axis, Vector3), 'axis must be Vector3'
    assert isinstance(angle, (int, float)), 'angle must be int or float'








    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(4,tuple([axis._ptr, angle]))
    return _ret


  @functools.native_method
  def scaled(self, scale:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not scale is None)
    assert isinstance(scale, Vector3), 'scale must be Vector3'







    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(5,tuple([scale._ptr]))
    return _ret


  @functools.native_method
  def scaled_local(self, scale:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not scale is None)
    assert isinstance(scale, Vector3), 'scale must be Vector3'







    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(6,tuple([scale._ptr]))
    return _ret


  @functools.native_method
  def get_scale(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([]))
    return _ret


  @functools.native_method
  def get_euler(self, order:'int' =2  ) -> typing.Union['Vector3']:
    r''''''

    assert isinstance(order, (int, float)), 'order must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([order]))
    return _ret


  @functools.native_method
  def tdotx(self, with_:'Vector3'   ) -> typing.Union[float]:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector3), 'with_ must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(9,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def tdoty(self, with_:'Vector3'   ) -> typing.Union[float]:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector3), 'with_ must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def tdotz(self, with_:'Vector3'   ) -> typing.Union[float]:
    r''''''

    assert(not with_ is None)
    assert isinstance(with_, Vector3), 'with_ must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(11,tuple([with_._ptr]))
    return _ret


  @functools.native_method
  def slerp(self, to:'Basis'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Basis), 'to must be Basis'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(12,tuple([to._ptr, weight]))
    return _ret


  @functools.native_method
  def is_conformal(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(13,tuple([]))
    return _ret


  @functools.native_method
  def is_equal_approx(self, b:'Basis'   ) -> typing.Union[bool]:
    r''''''

    assert(not b is None)
    assert isinstance(b, Basis), 'b must be Basis'







    _ret = 0
    _ret = self._ptr.call_with_return(14,tuple([b._ptr]))
    return _ret


  @functools.native_method
  def is_finite(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(15,tuple([]))
    return _ret


  @functools.native_method
  def get_rotation_quaternion(self) -> typing.Union['Quaternion']:
    r''''''




    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16,tuple([]))
    return _ret


  @staticmethod
  def looking_at(target:'Vector3'   , up:'Vector3' = None  , use_model_front:'bool' =False  ) -> typing.Union['typing.Self']:
    r''''''
    if up is None:
      up = Vector3.new0()

    assert(not target is None)
    assert isinstance(target, Vector3), 'target must be Vector3'
    assert isinstance(use_model_front, bool), 'use_model_front must be bool'









    _ret = Basis.construct_without_init()
    _ret._ptr = static_method(1045,0,tuple([target._ptr, up._ptr, use_model_front]))
    return _ret


  @staticmethod
  def from_scale(scale:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not scale is None)
    assert isinstance(scale, Vector3), 'scale must be Vector3'







    _ret = Basis.construct_without_init()
    _ret._ptr = static_method(1045,1,tuple([scale._ptr]))
    return _ret


  @staticmethod
  def from_euler(euler:'Vector3'   , order:'int' =2  ) -> typing.Union['typing.Self']:
    r''''''

    assert(not euler is None)
    assert isinstance(euler, Vector3), 'euler must be Vector3'
    assert isinstance(order, (int, float)), 'order must be int or float'








    _ret = Basis.construct_without_init()
    _ret._ptr = static_method(1045,2,tuple([euler._ptr, order]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Basis):
      _ret = False

      _ret= self._ptr.call_with_return(31, (other,))
      return _ret

    _ret= self._ptr.call_with_return(31, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Basis):
      _ret = False

      _ret= self._ptr.call_with_return(32, (other,))
      return _ret

    _ret= self._ptr.call_with_return(32, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, int):
      _ret = Basis()

      _ret._ptr = self._ptr.call_with_return(33, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Basis()

      _ret._ptr = self._ptr.call_with_return(33, (other,))
      return _ret
    if isinstance(other, Vector3):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(33, (other,))
      return _ret
    if isinstance(other, Basis):
      _ret = Basis()

      _ret._ptr = self._ptr.call_with_return(33, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __truediv__(self, other):
    if isinstance(other, int):
      _ret = Basis()

      _ret._ptr = self._ptr.call_with_return(29, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Basis()

      _ret._ptr = self._ptr.call_with_return(29, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPTransform3DWrapper


class Transform3D(CoreType):
  r''''''
  IDENTITY:typing.ClassVar['Transform3D'] # Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0)

  FLIP_X:typing.ClassVar['Transform3D'] # Transform3D(-1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0)

  FLIP_Y:typing.ClassVar['Transform3D'] # Transform3D(1, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0)

  FLIP_Z:typing.ClassVar['Transform3D'] # Transform3D(1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0)



  @staticmethod
  def new0():
    _class = Transform3D.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1046, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Transform3D' ):
    assert(not from_ is None)
    assert isinstance(from_, Transform3D), 'from_ must be Transform3D'

    _class = Transform3D.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1046, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(basis:'Basis' , origin:'Vector3' ):
    assert(not basis is None)
    assert isinstance(basis, Basis), 'basis must be Basis'
    assert(not origin is None)
    assert isinstance(origin, Vector3), 'origin must be Vector3'

    _class = Transform3D.construct_without_init()
    _class.constructed_from_python = True



    _class.__basis__ = basis
    _class.__origin__ = origin
    _class._ptr = constructor(1046, 2, tuple([basis._ptr, origin._ptr]))
    return _class
  @staticmethod
  def new3(x_axis:'Vector3' , y_axis:'Vector3' , z_axis:'Vector3' , origin:'Vector3' ):
    assert(not x_axis is None)
    assert isinstance(x_axis, Vector3), 'x_axis must be Vector3'
    assert(not y_axis is None)
    assert isinstance(y_axis, Vector3), 'y_axis must be Vector3'
    assert(not z_axis is None)
    assert isinstance(z_axis, Vector3), 'z_axis must be Vector3'
    assert(not origin is None)
    assert isinstance(origin, Vector3), 'origin must be Vector3'

    _class = Transform3D.construct_without_init()
    _class.constructed_from_python = True





    _class.__x_axis__ = x_axis
    _class.__y_axis__ = y_axis
    _class.__z_axis__ = z_axis
    _class.__origin__ = origin
    _class._ptr = constructor(1046, 3, tuple([x_axis._ptr, y_axis._ptr, z_axis._ptr, origin._ptr]))
    return _class
  @staticmethod
  def new4(from_:'Projection' ):
    assert(not from_ is None)
    assert isinstance(from_, Projection), 'from_ must be Projection'

    _class = Transform3D.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1046, 4, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1046,0, ())

  def generate_wrapper(self):
    return CPPTransform3DWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Transform3D.__new__(Transform3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Transform3D'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(13, ())


  @property
  def basis(self) -> Basis:
    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14, tuple())
    return _ret
  def get_basis(self) -> None:
    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14, tuple())
    return _ret

  @basis.setter
  def basis(self, value: 'Basis' ):
    assert isinstance(value, Basis), 'value must be Basis'
    self._ptr.call_with_return(15, tuple([value._ptr]))
  def set_basis(self, value: 'Basis' ):
    assert isinstance(value, Basis), 'value must be Basis'
    self._ptr.call_with_return(15, tuple([value._ptr]))
  @property
  def origin(self) -> Vector3:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16, tuple())
    return _ret
  def get_origin(self) -> None:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16, tuple())
    return _ret

  @origin.setter
  def origin(self, value: 'Vector3' ):
    assert isinstance(value, Vector3), 'value must be Vector3'
    self._ptr.call_with_return(17, tuple([value._ptr]))
  def set_origin(self, value: 'Vector3' ):
    assert isinstance(value, Vector3), 'value must be Vector3'
    self._ptr.call_with_return(17, tuple([value._ptr]))
  @functools.native_method
  def inverse(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def affine_inverse(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def orthonormalized(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def rotated(self, axis:'Vector3'   , angle:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not axis is None)
    assert isinstance(axis, Vector3), 'axis must be Vector3'
    assert isinstance(angle, (int, float)), 'angle must be int or float'








    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(3,tuple([axis._ptr, angle]))
    return _ret


  @functools.native_method
  def rotated_local(self, axis:'Vector3'   , angle:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not axis is None)
    assert isinstance(axis, Vector3), 'axis must be Vector3'
    assert isinstance(angle, (int, float)), 'angle must be int or float'








    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(4,tuple([axis._ptr, angle]))
    return _ret


  @functools.native_method
  def scaled(self, scale:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not scale is None)
    assert isinstance(scale, Vector3), 'scale must be Vector3'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(5,tuple([scale._ptr]))
    return _ret


  @functools.native_method
  def scaled_local(self, scale:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not scale is None)
    assert isinstance(scale, Vector3), 'scale must be Vector3'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(6,tuple([scale._ptr]))
    return _ret


  @functools.native_method
  def translated(self, offset:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector3), 'offset must be Vector3'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([offset._ptr]))
    return _ret


  @functools.native_method
  def translated_local(self, offset:'Vector3'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector3), 'offset must be Vector3'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([offset._ptr]))
    return _ret


  @functools.native_method
  def looking_at(self, target:'Vector3'   , up:'Vector3' = None  , use_model_front:'bool' =False  ) -> typing.Union['typing.Self']:
    r''''''
    if up is None:
      up = Vector3.new0()

    assert(not target is None)
    assert isinstance(target, Vector3), 'target must be Vector3'
    assert isinstance(use_model_front, bool), 'use_model_front must be bool'









    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(9,tuple([target._ptr, up._ptr, use_model_front]))
    return _ret


  @functools.native_method
  def interpolate_with(self, xform:'Transform3D'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not xform is None)
    assert isinstance(xform, Transform3D), 'xform must be Transform3D'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(10,tuple([xform._ptr, weight]))
    return _ret


  @functools.native_method
  def is_equal_approx(self, xform:'Transform3D'   ) -> typing.Union[bool]:
    r''''''

    assert(not xform is None)
    assert isinstance(xform, Transform3D), 'xform must be Transform3D'







    _ret = 0
    _ret = self._ptr.call_with_return(11,tuple([xform._ptr]))
    return _ret


  @functools.native_method
  def is_finite(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Transform3D):
      _ret = False

      _ret= self._ptr.call_with_return(27, (other,))
      return _ret

    _ret= self._ptr.call_with_return(27, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Transform3D):
      _ret = False

      _ret= self._ptr.call_with_return(28, (other,))
      return _ret

    _ret= self._ptr.call_with_return(28, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, int):
      _ret = Transform3D()

      _ret._ptr = self._ptr.call_with_return(30, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Transform3D()

      _ret._ptr = self._ptr.call_with_return(30, (other,))
      return _ret
    if isinstance(other, Vector3):
      _ret = Vector3()

      _ret._ptr = self._ptr.call_with_return(30, (other,))
      return _ret
    if isinstance(other, Plane):
      _ret = Plane()

      _ret._ptr = self._ptr.call_with_return(30, (other,))
      return _ret
    if isinstance(other, AABB):
      _ret = AABB()

      _ret._ptr = self._ptr.call_with_return(30, (other,))
      return _ret
    if isinstance(other, Transform3D):
      _ret = Transform3D()

      _ret._ptr = self._ptr.call_with_return(30, (other,))
      return _ret
    if isinstance(other, PackedVector3Array):
      _ret = PackedVector3Array()

      _ret._ptr = self._ptr.call_with_return(30, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __truediv__(self, other):
    if isinstance(other, int):
      _ret = Transform3D()

      _ret._ptr = self._ptr.call_with_return(23, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Transform3D()

      _ret._ptr = self._ptr.call_with_return(23, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPProjectionWrapper

class Planes:
  PLANE_NEAR = 0
  PLANE_FAR = 1
  PLANE_LEFT = 2
  PLANE_TOP = 3
  PLANE_RIGHT = 4
  PLANE_BOTTOM = 5


class Projection(CoreType):
  r''''''
  IDENTITY:typing.ClassVar['Projection'] # Projection(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)

  ZERO:typing.ClassVar['Projection'] # Projection(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)



  @staticmethod
  def new0():
    _class = Projection.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1047, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Projection' ):
    assert(not from_ is None)
    assert isinstance(from_, Projection), 'from_ must be Projection'

    _class = Projection.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1047, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Transform3D' ):
    assert(not from_ is None)
    assert isinstance(from_, Transform3D), 'from_ must be Transform3D'

    _class = Projection.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1047, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(x_axis:'Vector4' , y_axis:'Vector4' , z_axis:'Vector4' , w_axis:'Vector4' ):
    assert(not x_axis is None)
    assert isinstance(x_axis, Vector4), 'x_axis must be Vector4'
    assert(not y_axis is None)
    assert isinstance(y_axis, Vector4), 'y_axis must be Vector4'
    assert(not z_axis is None)
    assert isinstance(z_axis, Vector4), 'z_axis must be Vector4'
    assert(not w_axis is None)
    assert isinstance(w_axis, Vector4), 'w_axis must be Vector4'

    _class = Projection.construct_without_init()
    _class.constructed_from_python = True





    _class.__x_axis__ = x_axis
    _class.__y_axis__ = y_axis
    _class.__z_axis__ = z_axis
    _class.__w_axis__ = w_axis
    _class._ptr = constructor(1047, 3, tuple([x_axis._ptr, y_axis._ptr, z_axis._ptr, w_axis._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1047,0, ())

  def generate_wrapper(self):
    return CPPProjectionWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Projection.__new__(Projection)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Projection'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(15, ())


  @property
  def x(self) -> Vector4:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16, tuple())
    return _ret
  def get_x(self) -> None:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16, tuple())
    return _ret

  @x.setter
  def x(self, value: 'Vector4' ):
    assert isinstance(value, Vector4), 'value must be Vector4'
    self._ptr.call_with_return(17, tuple([value._ptr]))
  def set_x(self, value: 'Vector4' ):
    assert isinstance(value, Vector4), 'value must be Vector4'
    self._ptr.call_with_return(17, tuple([value._ptr]))
  @property
  def y(self) -> Vector4:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18, tuple())
    return _ret
  def get_y(self) -> None:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18, tuple())
    return _ret

  @y.setter
  def y(self, value: 'Vector4' ):
    assert isinstance(value, Vector4), 'value must be Vector4'
    self._ptr.call_with_return(19, tuple([value._ptr]))
  def set_y(self, value: 'Vector4' ):
    assert isinstance(value, Vector4), 'value must be Vector4'
    self._ptr.call_with_return(19, tuple([value._ptr]))
  @property
  def z(self) -> Vector4:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20, tuple())
    return _ret
  def get_z(self) -> None:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20, tuple())
    return _ret

  @z.setter
  def z(self, value: 'Vector4' ):
    assert isinstance(value, Vector4), 'value must be Vector4'
    self._ptr.call_with_return(21, tuple([value._ptr]))
  def set_z(self, value: 'Vector4' ):
    assert isinstance(value, Vector4), 'value must be Vector4'
    self._ptr.call_with_return(21, tuple([value._ptr]))
  @property
  def w(self) -> Vector4:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22, tuple())
    return _ret
  def get_w(self) -> None:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22, tuple())
    return _ret

  @w.setter
  def w(self, value: 'Vector4' ):
    assert isinstance(value, Vector4), 'value must be Vector4'
    self._ptr.call_with_return(23, tuple([value._ptr]))
  def set_w(self, value: 'Vector4' ):
    assert isinstance(value, Vector4), 'value must be Vector4'
    self._ptr.call_with_return(23, tuple([value._ptr]))
  @staticmethod
  def create_depth_correction(flip_y:'bool'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(flip_y, bool), 'flip_y must be bool'







    _ret = Projection.construct_without_init()
    _ret._ptr = static_method(1047,0,tuple([flip_y]))
    return _ret


  @staticmethod
  def create_light_atlas_rect(rect:'Rect2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not rect is None)
    assert isinstance(rect, Rect2), 'rect must be Rect2'







    _ret = Projection.construct_without_init()
    _ret._ptr = static_method(1047,1,tuple([rect._ptr]))
    return _ret


  @staticmethod
  def create_perspective(fovy:'float'   , aspect:'float'   , z_near:'float'   , z_far:'float'   , flip_fov:'bool' =False  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(fovy, (int, float)), 'fovy must be int or float'
    assert isinstance(aspect, (int, float)), 'aspect must be int or float'
    assert isinstance(z_near, (int, float)), 'z_near must be int or float'
    assert isinstance(z_far, (int, float)), 'z_far must be int or float'
    assert isinstance(flip_fov, bool), 'flip_fov must be bool'











    _ret = Projection.construct_without_init()
    _ret._ptr = static_method(1047,2,tuple([fovy, aspect, z_near, z_far, flip_fov]))
    return _ret


  @staticmethod
  def create_perspective_hmd(fovy:'float'   , aspect:'float'   , z_near:'float'   , z_far:'float'   , flip_fov:'bool'   , eye:'int'   , intraocular_dist:'float'   , convergence_dist:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(fovy, (int, float)), 'fovy must be int or float'
    assert isinstance(aspect, (int, float)), 'aspect must be int or float'
    assert isinstance(z_near, (int, float)), 'z_near must be int or float'
    assert isinstance(z_far, (int, float)), 'z_far must be int or float'
    assert isinstance(flip_fov, bool), 'flip_fov must be bool'
    assert isinstance(eye, (int, float)), 'eye must be int or float'
    assert isinstance(intraocular_dist, (int, float)), 'intraocular_dist must be int or float'
    assert isinstance(convergence_dist, (int, float)), 'convergence_dist must be int or float'














    _ret = Projection.construct_without_init()
    _ret._ptr = static_method(1047,3,tuple([fovy, aspect, z_near, z_far, flip_fov, eye, intraocular_dist, convergence_dist]))
    return _ret


  @staticmethod
  def create_for_hmd(eye:'int'   , aspect:'float'   , intraocular_dist:'float'   , display_width:'float'   , display_to_lens:'float'   , oversample:'float'   , z_near:'float'   , z_far:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(eye, (int, float)), 'eye must be int or float'
    assert isinstance(aspect, (int, float)), 'aspect must be int or float'
    assert isinstance(intraocular_dist, (int, float)), 'intraocular_dist must be int or float'
    assert isinstance(display_width, (int, float)), 'display_width must be int or float'
    assert isinstance(display_to_lens, (int, float)), 'display_to_lens must be int or float'
    assert isinstance(oversample, (int, float)), 'oversample must be int or float'
    assert isinstance(z_near, (int, float)), 'z_near must be int or float'
    assert isinstance(z_far, (int, float)), 'z_far must be int or float'














    _ret = Projection.construct_without_init()
    _ret._ptr = static_method(1047,4,tuple([eye, aspect, intraocular_dist, display_width, display_to_lens, oversample, z_near, z_far]))
    return _ret


  @staticmethod
  def create_orthogonal(left:'float'   , right:'float'   , bottom:'float'   , top:'float'   , z_near:'float'   , z_far:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(left, (int, float)), 'left must be int or float'
    assert isinstance(right, (int, float)), 'right must be int or float'
    assert isinstance(bottom, (int, float)), 'bottom must be int or float'
    assert isinstance(top, (int, float)), 'top must be int or float'
    assert isinstance(z_near, (int, float)), 'z_near must be int or float'
    assert isinstance(z_far, (int, float)), 'z_far must be int or float'












    _ret = Projection.construct_without_init()
    _ret._ptr = static_method(1047,5,tuple([left, right, bottom, top, z_near, z_far]))
    return _ret


  @staticmethod
  def create_orthogonal_aspect(size:'float'   , aspect:'float'   , z_near:'float'   , z_far:'float'   , flip_fov:'bool' =False  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(aspect, (int, float)), 'aspect must be int or float'
    assert isinstance(z_near, (int, float)), 'z_near must be int or float'
    assert isinstance(z_far, (int, float)), 'z_far must be int or float'
    assert isinstance(flip_fov, bool), 'flip_fov must be bool'











    _ret = Projection.construct_without_init()
    _ret._ptr = static_method(1047,6,tuple([size, aspect, z_near, z_far, flip_fov]))
    return _ret


  @staticmethod
  def create_frustum(left:'float'   , right:'float'   , bottom:'float'   , top:'float'   , z_near:'float'   , z_far:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(left, (int, float)), 'left must be int or float'
    assert isinstance(right, (int, float)), 'right must be int or float'
    assert isinstance(bottom, (int, float)), 'bottom must be int or float'
    assert isinstance(top, (int, float)), 'top must be int or float'
    assert isinstance(z_near, (int, float)), 'z_near must be int or float'
    assert isinstance(z_far, (int, float)), 'z_far must be int or float'












    _ret = Projection.construct_without_init()
    _ret._ptr = static_method(1047,7,tuple([left, right, bottom, top, z_near, z_far]))
    return _ret


  @staticmethod
  def create_frustum_aspect(size:'float'   , aspect:'float'   , offset:'Vector2'   , z_near:'float'   , z_far:'float'   , flip_fov:'bool' =False  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(aspect, (int, float)), 'aspect must be int or float'
    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'
    assert isinstance(z_near, (int, float)), 'z_near must be int or float'
    assert isinstance(z_far, (int, float)), 'z_far must be int or float'
    assert isinstance(flip_fov, bool), 'flip_fov must be bool'












    _ret = Projection.construct_without_init()
    _ret._ptr = static_method(1047,8,tuple([size, aspect, offset._ptr, z_near, z_far, flip_fov]))
    return _ret


  @staticmethod
  def create_fit_aabb(aabb:'AABB'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not aabb is None)
    assert isinstance(aabb, AABB), 'aabb must be AABB'







    _ret = Projection.construct_without_init()
    _ret._ptr = static_method(1047,9,tuple([aabb._ptr]))
    return _ret


  @functools.native_method
  def determinant(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def perspective_znear_adjusted(self, new_znear:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(new_znear, (int, float)), 'new_znear must be int or float'







    _ret = Projection.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(1,tuple([new_znear]))
    return _ret


  @functools.native_method
  def get_projection_plane(self, plane:'int'   ) -> typing.Union['Plane']:
    r''''''

    assert isinstance(plane, (int, float)), 'plane must be int or float'







    _ret = Plane.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(2,tuple([plane]))
    return _ret


  @functools.native_method
  def flipped_y(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Projection.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def jitter_offseted(self, offset:'Vector2'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'







    _ret = Projection.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(4,tuple([offset._ptr]))
    return _ret


  @staticmethod
  def get_fovy(fovx:'float'   , aspect:'float'   ) -> typing.Union[float]:
    r''''''

    assert isinstance(fovx, (int, float)), 'fovx must be int or float'
    assert isinstance(aspect, (int, float)), 'aspect must be int or float'








    _ret = 0
    _ret = static_method(1047,10,tuple([fovx, aspect]))
    return _ret


  @functools.native_method
  def get_z_far(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([]))
    return _ret


  @functools.native_method
  def get_z_near(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(6,tuple([]))
    return _ret


  @functools.native_method
  def get_aspect(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(7,tuple([]))
    return _ret


  @functools.native_method
  def get_fov(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([]))
    return _ret


  @functools.native_method
  def is_orthogonal(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(9,tuple([]))
    return _ret


  @functools.native_method
  def get_viewport_half_extents(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(10,tuple([]))
    return _ret


  @functools.native_method
  def get_far_plane_half_extents(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(11,tuple([]))
    return _ret


  @functools.native_method
  def inverse(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Projection.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(12,tuple([]))
    return _ret


  @functools.native_method
  def get_pixels_per_meter(self, for_pixel_width:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(for_pixel_width, (int, float)), 'for_pixel_width must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(13,tuple([for_pixel_width]))
    return _ret


  @functools.native_method
  def get_lod_multiplier(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(14,tuple([]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Projection):
      _ret = False

      _ret= self._ptr.call_with_return(27, (other,))
      return _ret

    _ret= self._ptr.call_with_return(27, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Projection):
      _ret = False

      _ret= self._ptr.call_with_return(28, (other,))
      return _ret

    _ret= self._ptr.call_with_return(28, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, Vector4):
      _ret = Vector4()

      _ret._ptr = self._ptr.call_with_return(29, (other,))
      return _ret
    if isinstance(other, Projection):
      _ret = Projection()

      _ret._ptr = self._ptr.call_with_return(29, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPColorWrapper


class Color(CoreType):
  r''''''
  ALICE_BLUE:typing.ClassVar['Color'] # Color(0.9411765, 0.972549, 1, 1)

  ANTIQUE_WHITE:typing.ClassVar['Color'] # Color(0.98039216, 0.92156863, 0.84313726, 1)

  AQUA:typing.ClassVar['Color'] # Color(0, 1, 1, 1)

  AQUAMARINE:typing.ClassVar['Color'] # Color(0.49803922, 1, 0.83137256, 1)

  AZURE:typing.ClassVar['Color'] # Color(0.9411765, 1, 1, 1)

  BEIGE:typing.ClassVar['Color'] # Color(0.9607843, 0.9607843, 0.8627451, 1)

  BISQUE:typing.ClassVar['Color'] # Color(1, 0.89411765, 0.76862746, 1)

  BLACK:typing.ClassVar['Color'] # Color(0, 0, 0, 1)

  BLANCHED_ALMOND:typing.ClassVar['Color'] # Color(1, 0.92156863, 0.8039216, 1)

  BLUE:typing.ClassVar['Color'] # Color(0, 0, 1, 1)

  BLUE_VIOLET:typing.ClassVar['Color'] # Color(0.5411765, 0.16862746, 0.8862745, 1)

  BROWN:typing.ClassVar['Color'] # Color(0.64705884, 0.16470589, 0.16470589, 1)

  BURLYWOOD:typing.ClassVar['Color'] # Color(0.87058824, 0.72156864, 0.5294118, 1)

  CADET_BLUE:typing.ClassVar['Color'] # Color(0.37254903, 0.61960787, 0.627451, 1)

  CHARTREUSE:typing.ClassVar['Color'] # Color(0.49803922, 1, 0, 1)

  CHOCOLATE:typing.ClassVar['Color'] # Color(0.8235294, 0.4117647, 0.11764706, 1)

  CORAL:typing.ClassVar['Color'] # Color(1, 0.49803922, 0.3137255, 1)

  CORNFLOWER_BLUE:typing.ClassVar['Color'] # Color(0.39215687, 0.58431375, 0.92941177, 1)

  CORNSILK:typing.ClassVar['Color'] # Color(1, 0.972549, 0.8627451, 1)

  CRIMSON:typing.ClassVar['Color'] # Color(0.8627451, 0.078431375, 0.23529412, 1)

  CYAN:typing.ClassVar['Color'] # Color(0, 1, 1, 1)

  DARK_BLUE:typing.ClassVar['Color'] # Color(0, 0, 0.54509807, 1)

  DARK_CYAN:typing.ClassVar['Color'] # Color(0, 0.54509807, 0.54509807, 1)

  DARK_GOLDENROD:typing.ClassVar['Color'] # Color(0.72156864, 0.5254902, 0.043137256, 1)

  DARK_GRAY:typing.ClassVar['Color'] # Color(0.6627451, 0.6627451, 0.6627451, 1)

  DARK_GREEN:typing.ClassVar['Color'] # Color(0, 0.39215687, 0, 1)

  DARK_KHAKI:typing.ClassVar['Color'] # Color(0.7411765, 0.7176471, 0.41960785, 1)

  DARK_MAGENTA:typing.ClassVar['Color'] # Color(0.54509807, 0, 0.54509807, 1)

  DARK_OLIVE_GREEN:typing.ClassVar['Color'] # Color(0.33333334, 0.41960785, 0.18431373, 1)

  DARK_ORANGE:typing.ClassVar['Color'] # Color(1, 0.54901963, 0, 1)

  DARK_ORCHID:typing.ClassVar['Color'] # Color(0.6, 0.19607843, 0.8, 1)

  DARK_RED:typing.ClassVar['Color'] # Color(0.54509807, 0, 0, 1)

  DARK_SALMON:typing.ClassVar['Color'] # Color(0.9137255, 0.5882353, 0.47843137, 1)

  DARK_SEA_GREEN:typing.ClassVar['Color'] # Color(0.56078434, 0.7372549, 0.56078434, 1)

  DARK_SLATE_BLUE:typing.ClassVar['Color'] # Color(0.28235295, 0.23921569, 0.54509807, 1)

  DARK_SLATE_GRAY:typing.ClassVar['Color'] # Color(0.18431373, 0.30980393, 0.30980393, 1)

  DARK_TURQUOISE:typing.ClassVar['Color'] # Color(0, 0.80784315, 0.81960785, 1)

  DARK_VIOLET:typing.ClassVar['Color'] # Color(0.5803922, 0, 0.827451, 1)

  DEEP_PINK:typing.ClassVar['Color'] # Color(1, 0.078431375, 0.5764706, 1)

  DEEP_SKY_BLUE:typing.ClassVar['Color'] # Color(0, 0.7490196, 1, 1)

  DIM_GRAY:typing.ClassVar['Color'] # Color(0.4117647, 0.4117647, 0.4117647, 1)

  DODGER_BLUE:typing.ClassVar['Color'] # Color(0.11764706, 0.5647059, 1, 1)

  FIREBRICK:typing.ClassVar['Color'] # Color(0.69803923, 0.13333334, 0.13333334, 1)

  FLORAL_WHITE:typing.ClassVar['Color'] # Color(1, 0.98039216, 0.9411765, 1)

  FOREST_GREEN:typing.ClassVar['Color'] # Color(0.13333334, 0.54509807, 0.13333334, 1)

  FUCHSIA:typing.ClassVar['Color'] # Color(1, 0, 1, 1)

  GAINSBORO:typing.ClassVar['Color'] # Color(0.8627451, 0.8627451, 0.8627451, 1)

  GHOST_WHITE:typing.ClassVar['Color'] # Color(0.972549, 0.972549, 1, 1)

  GOLD:typing.ClassVar['Color'] # Color(1, 0.84313726, 0, 1)

  GOLDENROD:typing.ClassVar['Color'] # Color(0.85490197, 0.64705884, 0.1254902, 1)

  GRAY:typing.ClassVar['Color'] # Color(0.74509805, 0.74509805, 0.74509805, 1)

  GREEN:typing.ClassVar['Color'] # Color(0, 1, 0, 1)

  GREEN_YELLOW:typing.ClassVar['Color'] # Color(0.6784314, 1, 0.18431373, 1)

  HONEYDEW:typing.ClassVar['Color'] # Color(0.9411765, 1, 0.9411765, 1)

  HOT_PINK:typing.ClassVar['Color'] # Color(1, 0.4117647, 0.7058824, 1)

  INDIAN_RED:typing.ClassVar['Color'] # Color(0.8039216, 0.36078432, 0.36078432, 1)

  INDIGO:typing.ClassVar['Color'] # Color(0.29411766, 0, 0.50980395, 1)

  IVORY:typing.ClassVar['Color'] # Color(1, 1, 0.9411765, 1)

  KHAKI:typing.ClassVar['Color'] # Color(0.9411765, 0.9019608, 0.54901963, 1)

  LAVENDER:typing.ClassVar['Color'] # Color(0.9019608, 0.9019608, 0.98039216, 1)

  LAVENDER_BLUSH:typing.ClassVar['Color'] # Color(1, 0.9411765, 0.9607843, 1)

  LAWN_GREEN:typing.ClassVar['Color'] # Color(0.4862745, 0.9882353, 0, 1)

  LEMON_CHIFFON:typing.ClassVar['Color'] # Color(1, 0.98039216, 0.8039216, 1)

  LIGHT_BLUE:typing.ClassVar['Color'] # Color(0.6784314, 0.84705883, 0.9019608, 1)

  LIGHT_CORAL:typing.ClassVar['Color'] # Color(0.9411765, 0.5019608, 0.5019608, 1)

  LIGHT_CYAN:typing.ClassVar['Color'] # Color(0.8784314, 1, 1, 1)

  LIGHT_GOLDENROD:typing.ClassVar['Color'] # Color(0.98039216, 0.98039216, 0.8235294, 1)

  LIGHT_GRAY:typing.ClassVar['Color'] # Color(0.827451, 0.827451, 0.827451, 1)

  LIGHT_GREEN:typing.ClassVar['Color'] # Color(0.5647059, 0.93333334, 0.5647059, 1)

  LIGHT_PINK:typing.ClassVar['Color'] # Color(1, 0.7137255, 0.75686276, 1)

  LIGHT_SALMON:typing.ClassVar['Color'] # Color(1, 0.627451, 0.47843137, 1)

  LIGHT_SEA_GREEN:typing.ClassVar['Color'] # Color(0.1254902, 0.69803923, 0.6666667, 1)

  LIGHT_SKY_BLUE:typing.ClassVar['Color'] # Color(0.5294118, 0.80784315, 0.98039216, 1)

  LIGHT_SLATE_GRAY:typing.ClassVar['Color'] # Color(0.46666667, 0.53333336, 0.6, 1)

  LIGHT_STEEL_BLUE:typing.ClassVar['Color'] # Color(0.6901961, 0.76862746, 0.87058824, 1)

  LIGHT_YELLOW:typing.ClassVar['Color'] # Color(1, 1, 0.8784314, 1)

  LIME:typing.ClassVar['Color'] # Color(0, 1, 0, 1)

  LIME_GREEN:typing.ClassVar['Color'] # Color(0.19607843, 0.8039216, 0.19607843, 1)

  LINEN:typing.ClassVar['Color'] # Color(0.98039216, 0.9411765, 0.9019608, 1)

  MAGENTA:typing.ClassVar['Color'] # Color(1, 0, 1, 1)

  MAROON:typing.ClassVar['Color'] # Color(0.6901961, 0.1882353, 0.3764706, 1)

  MEDIUM_AQUAMARINE:typing.ClassVar['Color'] # Color(0.4, 0.8039216, 0.6666667, 1)

  MEDIUM_BLUE:typing.ClassVar['Color'] # Color(0, 0, 0.8039216, 1)

  MEDIUM_ORCHID:typing.ClassVar['Color'] # Color(0.7294118, 0.33333334, 0.827451, 1)

  MEDIUM_PURPLE:typing.ClassVar['Color'] # Color(0.5764706, 0.4392157, 0.85882354, 1)

  MEDIUM_SEA_GREEN:typing.ClassVar['Color'] # Color(0.23529412, 0.7019608, 0.44313726, 1)

  MEDIUM_SLATE_BLUE:typing.ClassVar['Color'] # Color(0.48235294, 0.40784314, 0.93333334, 1)

  MEDIUM_SPRING_GREEN:typing.ClassVar['Color'] # Color(0, 0.98039216, 0.6039216, 1)

  MEDIUM_TURQUOISE:typing.ClassVar['Color'] # Color(0.28235295, 0.81960785, 0.8, 1)

  MEDIUM_VIOLET_RED:typing.ClassVar['Color'] # Color(0.78039217, 0.08235294, 0.52156866, 1)

  MIDNIGHT_BLUE:typing.ClassVar['Color'] # Color(0.09803922, 0.09803922, 0.4392157, 1)

  MINT_CREAM:typing.ClassVar['Color'] # Color(0.9607843, 1, 0.98039216, 1)

  MISTY_ROSE:typing.ClassVar['Color'] # Color(1, 0.89411765, 0.88235295, 1)

  MOCCASIN:typing.ClassVar['Color'] # Color(1, 0.89411765, 0.70980394, 1)

  NAVAJO_WHITE:typing.ClassVar['Color'] # Color(1, 0.87058824, 0.6784314, 1)

  NAVY_BLUE:typing.ClassVar['Color'] # Color(0, 0, 0.5019608, 1)

  OLD_LACE:typing.ClassVar['Color'] # Color(0.99215686, 0.9607843, 0.9019608, 1)

  OLIVE:typing.ClassVar['Color'] # Color(0.5019608, 0.5019608, 0, 1)

  OLIVE_DRAB:typing.ClassVar['Color'] # Color(0.41960785, 0.5568628, 0.13725491, 1)

  ORANGE:typing.ClassVar['Color'] # Color(1, 0.64705884, 0, 1)

  ORANGE_RED:typing.ClassVar['Color'] # Color(1, 0.27058825, 0, 1)

  ORCHID:typing.ClassVar['Color'] # Color(0.85490197, 0.4392157, 0.8392157, 1)

  PALE_GOLDENROD:typing.ClassVar['Color'] # Color(0.93333334, 0.9098039, 0.6666667, 1)

  PALE_GREEN:typing.ClassVar['Color'] # Color(0.59607846, 0.9843137, 0.59607846, 1)

  PALE_TURQUOISE:typing.ClassVar['Color'] # Color(0.6862745, 0.93333334, 0.93333334, 1)

  PALE_VIOLET_RED:typing.ClassVar['Color'] # Color(0.85882354, 0.4392157, 0.5764706, 1)

  PAPAYA_WHIP:typing.ClassVar['Color'] # Color(1, 0.9372549, 0.8352941, 1)

  PEACH_PUFF:typing.ClassVar['Color'] # Color(1, 0.85490197, 0.7254902, 1)

  PERU:typing.ClassVar['Color'] # Color(0.8039216, 0.52156866, 0.24705882, 1)

  PINK:typing.ClassVar['Color'] # Color(1, 0.7529412, 0.79607844, 1)

  PLUM:typing.ClassVar['Color'] # Color(0.8666667, 0.627451, 0.8666667, 1)

  POWDER_BLUE:typing.ClassVar['Color'] # Color(0.6901961, 0.8784314, 0.9019608, 1)

  PURPLE:typing.ClassVar['Color'] # Color(0.627451, 0.1254902, 0.9411765, 1)

  REBECCA_PURPLE:typing.ClassVar['Color'] # Color(0.4, 0.2, 0.6, 1)

  RED:typing.ClassVar['Color'] # Color(1, 0, 0, 1)

  ROSY_BROWN:typing.ClassVar['Color'] # Color(0.7372549, 0.56078434, 0.56078434, 1)

  ROYAL_BLUE:typing.ClassVar['Color'] # Color(0.25490198, 0.4117647, 0.88235295, 1)

  SADDLE_BROWN:typing.ClassVar['Color'] # Color(0.54509807, 0.27058825, 0.07450981, 1)

  SALMON:typing.ClassVar['Color'] # Color(0.98039216, 0.5019608, 0.44705883, 1)

  SANDY_BROWN:typing.ClassVar['Color'] # Color(0.95686275, 0.6431373, 0.3764706, 1)

  SEA_GREEN:typing.ClassVar['Color'] # Color(0.18039216, 0.54509807, 0.34117648, 1)

  SEASHELL:typing.ClassVar['Color'] # Color(1, 0.9607843, 0.93333334, 1)

  SIENNA:typing.ClassVar['Color'] # Color(0.627451, 0.32156864, 0.1764706, 1)

  SILVER:typing.ClassVar['Color'] # Color(0.7529412, 0.7529412, 0.7529412, 1)

  SKY_BLUE:typing.ClassVar['Color'] # Color(0.5294118, 0.80784315, 0.92156863, 1)

  SLATE_BLUE:typing.ClassVar['Color'] # Color(0.41568628, 0.3529412, 0.8039216, 1)

  SLATE_GRAY:typing.ClassVar['Color'] # Color(0.4392157, 0.5019608, 0.5647059, 1)

  SNOW:typing.ClassVar['Color'] # Color(1, 0.98039216, 0.98039216, 1)

  SPRING_GREEN:typing.ClassVar['Color'] # Color(0, 1, 0.49803922, 1)

  STEEL_BLUE:typing.ClassVar['Color'] # Color(0.27450982, 0.50980395, 0.7058824, 1)

  TAN:typing.ClassVar['Color'] # Color(0.8235294, 0.7058824, 0.54901963, 1)

  TEAL:typing.ClassVar['Color'] # Color(0, 0.5019608, 0.5019608, 1)

  THISTLE:typing.ClassVar['Color'] # Color(0.84705883, 0.7490196, 0.84705883, 1)

  TOMATO:typing.ClassVar['Color'] # Color(1, 0.3882353, 0.2784314, 1)

  TRANSPARENT:typing.ClassVar['Color'] # Color(1, 1, 1, 0)

  TURQUOISE:typing.ClassVar['Color'] # Color(0.2509804, 0.8784314, 0.8156863, 1)

  VIOLET:typing.ClassVar['Color'] # Color(0.93333334, 0.50980395, 0.93333334, 1)

  WEB_GRAY:typing.ClassVar['Color'] # Color(0.5019608, 0.5019608, 0.5019608, 1)

  WEB_GREEN:typing.ClassVar['Color'] # Color(0, 0.5019608, 0, 1)

  WEB_MAROON:typing.ClassVar['Color'] # Color(0.5019608, 0, 0, 1)

  WEB_PURPLE:typing.ClassVar['Color'] # Color(0.5019608, 0, 0.5019608, 1)

  WHEAT:typing.ClassVar['Color'] # Color(0.9607843, 0.87058824, 0.7019608, 1)

  WHITE:typing.ClassVar['Color'] # Color(1, 1, 1, 1)

  WHITE_SMOKE:typing.ClassVar['Color'] # Color(0.9607843, 0.9607843, 0.9607843, 1)

  YELLOW:typing.ClassVar['Color'] # Color(1, 1, 0, 1)

  YELLOW_GREEN:typing.ClassVar['Color'] # Color(0.6039216, 0.8039216, 0.19607843, 1)



  @staticmethod
  def new0():
    _class = Color.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1048, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Color' ):
    assert(not from_ is None)
    assert isinstance(from_, Color), 'from_ must be Color'

    _class = Color.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1048, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Color' , alpha:'float' ):
    assert(not from_ is None)
    assert isinstance(from_, Color), 'from_ must be Color'
    assert isinstance(alpha, (int, float)), 'alpha must be int or float'

    _class = Color.construct_without_init()
    _class.constructed_from_python = True



    _class.__from___ = from_

    _class._ptr = constructor(1048, 2, tuple([from_._ptr, alpha]))
    return _class
  @staticmethod
  def new3(r:'float' , g:'float' , b:'float' ):
    assert isinstance(r, (int, float)), 'r must be int or float'
    assert isinstance(g, (int, float)), 'g must be int or float'
    assert isinstance(b, (int, float)), 'b must be int or float'

    _class = Color.construct_without_init()
    _class.constructed_from_python = True







    _class._ptr = constructor(1048, 3, tuple([r, g, b]))
    return _class
  @staticmethod
  def new4(r:'float' , g:'float' , b:'float' , a:'float' ):
    assert isinstance(r, (int, float)), 'r must be int or float'
    assert isinstance(g, (int, float)), 'g must be int or float'
    assert isinstance(b, (int, float)), 'b must be int or float'
    assert isinstance(a, (int, float)), 'a must be int or float'

    _class = Color.construct_without_init()
    _class.constructed_from_python = True









    _class._ptr = constructor(1048, 4, tuple([r, g, b, a]))
    return _class
  @staticmethod
  def new5(code:'str' ):
    assert(not code is None)
    assert isinstance(code, (str, String)), 'code must be str or String'

    _class = Color.construct_without_init()
    _class.constructed_from_python = True
    assert(isinstance(code, (str, String)))
    py_string_code = code if isinstance(code, StringName) else c_utils.py_string_to_string(code)

    _class.py_string_code = py_string_code
    _class._ptr = constructor(1048, 5, tuple([py_string_code._ptr]))
    return _class
  @staticmethod
  def new6(code:'str' , alpha:'float' ):
    assert(not code is None)
    assert isinstance(code, (str, String)), 'code must be str or String'
    assert isinstance(alpha, (int, float)), 'alpha must be int or float'

    _class = Color.construct_without_init()
    _class.constructed_from_python = True
    assert(isinstance(code, (str, String)))
    py_string_code = code if isinstance(code, StringName) else c_utils.py_string_to_string(code)


    _class.py_string_code = py_string_code

    _class._ptr = constructor(1048, 6, tuple([py_string_code._ptr, alpha]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1048,0, ())

  def generate_wrapper(self):
    return CPPColorWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Color.__new__(Color)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Color'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(17, ())


  @property
  def r(self) -> float:
    _ret = self._ptr.call_with_return(18, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_r(self) -> None:
    _ret = self._ptr.call_with_return(18, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @r.setter
  def r(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(19, tuple([value]))
  def set_r(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(19, tuple([value]))
  @property
  def g(self) -> float:
    _ret = self._ptr.call_with_return(20, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_g(self) -> None:
    _ret = self._ptr.call_with_return(20, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @g.setter
  def g(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(21, tuple([value]))
  def set_g(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(21, tuple([value]))
  @property
  def b(self) -> float:
    _ret = self._ptr.call_with_return(22, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_b(self) -> None:
    _ret = self._ptr.call_with_return(22, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @b.setter
  def b(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(23, tuple([value]))
  def set_b(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(23, tuple([value]))
  @property
  def a(self) -> float:
    _ret = self._ptr.call_with_return(24, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_a(self) -> None:
    _ret = self._ptr.call_with_return(24, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @a.setter
  def a(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(25, tuple([value]))
  def set_a(self, value: 'float' ):
    assert isinstance(value, (int, float)), 'value must be int or float'
    self._ptr.call_with_return(25, tuple([value]))
  @functools.native_method
  def to_argb32(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def to_abgr32(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def to_rgba32(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def to_argb64(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def to_abgr64(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([]))
    return _ret


  @functools.native_method
  def to_rgba64(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([]))
    return _ret


  @functools.native_method
  def to_html(self, with_alpha:'bool' =True  ) -> typing.Union[str]:
    r''''''

    assert isinstance(with_alpha, bool), 'with_alpha must be bool'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(6,tuple([with_alpha]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def clamp(self, min:'Color' = None  , max:'Color' = None  ) -> typing.Union['typing.Self']:
    r''''''
    if min is None:
      min = Color.new0()
    if max is None:
      max = Color.new0()









    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([min._ptr, max._ptr]))
    return _ret


  @functools.native_method
  def inverted(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([]))
    return _ret


  @functools.native_method
  def lerp(self, to:'Color'   , weight:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not to is None)
    assert isinstance(to, Color), 'to must be Color'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(9,tuple([to._ptr, weight]))
    return _ret


  @functools.native_method
  def lightened(self, amount:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(10,tuple([amount]))
    return _ret


  @functools.native_method
  def darkened(self, amount:'float'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(11,tuple([amount]))
    return _ret


  @functools.native_method
  def blend(self, over:'Color'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not over is None)
    assert isinstance(over, Color), 'over must be Color'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(12,tuple([over._ptr]))
    return _ret


  @functools.native_method
  def get_luminance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(13,tuple([]))
    return _ret


  @functools.native_method
  def srgb_to_linear(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([]))
    return _ret


  @functools.native_method
  def linear_to_srgb(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([]))
    return _ret


  @functools.native_method
  def is_equal_approx(self, to:'Color'   ) -> typing.Union[bool]:
    r''''''

    assert(not to is None)
    assert isinstance(to, Color), 'to must be Color'







    _ret = 0
    _ret = self._ptr.call_with_return(16,tuple([to._ptr]))
    return _ret


  @staticmethod
  def hex(hex:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(hex, (int, float)), 'hex must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = static_method(1048,0,tuple([hex]))
    return _ret


  @staticmethod
  def hex64(hex:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(hex, (int, float)), 'hex must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = static_method(1048,1,tuple([hex]))
    return _ret


  @staticmethod
  def html(rgba:'str'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not rgba is None)
    assert isinstance(rgba, (str, String)), 'rgba must be str or String'





    assert(isinstance(rgba, (str, String)))
    py_string_rgba = rgba if isinstance(rgba, StringName) else c_utils.py_string_to_string(rgba)

    _ret = Color.construct_without_init()
    _ret._ptr = static_method(1048,2,tuple([py_string_rgba._ptr]))
    return _ret


  @staticmethod
  def html_is_valid(color:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not color is None)
    assert isinstance(color, (str, String)), 'color must be str or String'





    assert(isinstance(color, (str, String)))
    py_string_color = color if isinstance(color, StringName) else c_utils.py_string_to_string(color)

    _ret = 0
    _ret = static_method(1048,3,tuple([py_string_color._ptr]))
    return _ret


  @staticmethod
  def from_string(str:'str'   , default:'Color'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not str is None)
    assert isinstance(str, (str, String)), 'str must be str or String'
    assert(not default is None)
    assert isinstance(default, Color), 'default must be Color'





    assert(isinstance(str, (str, String)))
    py_string_str = str if isinstance(str, StringName) else c_utils.py_string_to_string(str)


    _ret = Color.construct_without_init()
    _ret._ptr = static_method(1048,4,tuple([py_string_str._ptr, default._ptr]))
    return _ret


  @staticmethod
  def from_hsv(h:'float'   , s:'float'   , v:'float'   , alpha:'float' =1.0  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(h, (int, float)), 'h must be int or float'
    assert isinstance(s, (int, float)), 's must be int or float'
    assert isinstance(v, (int, float)), 'v must be int or float'
    assert isinstance(alpha, (int, float)), 'alpha must be int or float'










    _ret = Color.construct_without_init()
    _ret._ptr = static_method(1048,5,tuple([h, s, v, alpha]))
    return _ret


  @staticmethod
  def from_ok_hsl(h:'float'   , s:'float'   , l:'float'   , alpha:'float' =1.0  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(h, (int, float)), 'h must be int or float'
    assert isinstance(s, (int, float)), 's must be int or float'
    assert isinstance(l, (int, float)), 'l must be int or float'
    assert isinstance(alpha, (int, float)), 'alpha must be int or float'










    _ret = Color.construct_without_init()
    _ret._ptr = static_method(1048,6,tuple([h, s, l, alpha]))
    return _ret


  @staticmethod
  def from_rgbe9995(rgbe:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(rgbe, (int, float)), 'rgbe must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = static_method(1048,7,tuple([rgbe]))
    return _ret


  @staticmethod
  def from_rgba8(r8:'int'   , g8:'int'   , b8:'int'   , a8:'int' =255  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(r8, (int, float)), 'r8 must be int or float'
    assert isinstance(g8, (int, float)), 'g8 must be int or float'
    assert isinstance(b8, (int, float)), 'b8 must be int or float'
    assert isinstance(a8, (int, float)), 'a8 must be int or float'










    _ret = Color.construct_without_init()
    _ret._ptr = static_method(1048,8,tuple([r8, g8, b8, a8]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Color):
      _ret = False

      _ret= self._ptr.call_with_return(52, (other,))
      return _ret

    _ret= self._ptr.call_with_return(52, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Color):
      _ret = False

      _ret= self._ptr.call_with_return(53, (other,))
      return _ret

    _ret= self._ptr.call_with_return(53, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, int):
      _ret = Color()

      _ret._ptr = self._ptr.call_with_return(56, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Color()

      _ret._ptr = self._ptr.call_with_return(56, (other,))
      return _ret
    if isinstance(other, Color):
      _ret = Color()

      _ret._ptr = self._ptr.call_with_return(56, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __truediv__(self, other):
    if isinstance(other, int):
      _ret = Color()

      _ret._ptr = self._ptr.call_with_return(57, (other,))
      return _ret
    if isinstance(other, float):
      _ret = Color()

      _ret._ptr = self._ptr.call_with_return(57, (other,))
      return _ret
    if isinstance(other, Color):
      _ret = Color()

      _ret._ptr = self._ptr.call_with_return(57, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __add__(self, other):
    if isinstance(other, Color):
      _ret = Color()

      _ret._ptr = self._ptr.call_with_return(54, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __sub__(self, other):
    if isinstance(other, Color):
      _ret = Color()

      _ret._ptr = self._ptr.call_with_return(55, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPStringNameWrapper


class StringName(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = StringName.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1049, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'object' ):
    assert(not from_ is None)
    assert isinstance(from_, (str, StringName)), 'from_ must be str or StringName'

    _class = StringName.construct_without_init()
    _class.constructed_from_python = True
    assert(isinstance(from_, (str, StringName)))
    py_stringname_from_ = from_ if isinstance(from_, StringName) else c_utils.py_string_to_string_name(from_)

    _class.py_stringname_from_ =py_stringname_from_
    _class._ptr = constructor(1049, 1, tuple([py_stringname_from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'str' ):
    assert(not from_ is None)
    assert isinstance(from_, (str, String)), 'from_ must be str or String'

    _class = StringName.construct_without_init()
    _class.constructed_from_python = True
    assert(isinstance(from_, (str, String)))
    py_string_from_ = from_ if isinstance(from_, StringName) else c_utils.py_string_to_string(from_)

    _class.py_string_from_ = py_string_from_
    _class._ptr = constructor(1049, 2, tuple([py_string_from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1049,0, ())

  def generate_wrapper(self):
    return CPPStringNameWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = StringName.__new__(StringName)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'StringName'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(110, ())
  def __str__(self):
    return utils.gd_string_name_to_py_string(self)


  @functools.native_method
  def casecmp_to(self, to:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'





    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)

    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([py_string_to._ptr]))
    return _ret


  @functools.native_method
  def nocasecmp_to(self, to:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'





    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)

    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([py_string_to._ptr]))
    return _ret


  @functools.native_method
  def naturalcasecmp_to(self, to:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'





    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)

    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([py_string_to._ptr]))
    return _ret


  @functools.native_method
  def naturalnocasecmp_to(self, to:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'





    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)

    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([py_string_to._ptr]))
    return _ret


  @functools.native_method
  def filecasecmp_to(self, to:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'





    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)

    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([py_string_to._ptr]))
    return _ret


  @functools.native_method
  def filenocasecmp_to(self, to:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'





    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)

    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([py_string_to._ptr]))
    return _ret


  @functools.native_method
  def length(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(6,tuple([]))
    return _ret


  @functools.native_method
  def substr(self, from_:'int'   , len_:'int' =-1  ) -> typing.Union[str]:
    r''''''

    assert isinstance(from_, (int, float)), 'from_ must be int or float'
    assert isinstance(len_, (int, float)), 'len_ must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([from_, len_]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_slice(self, delimiter:'str'   , slice:'int'   ) -> typing.Union[str]:
    r''''''

    assert(not delimiter is None)
    assert isinstance(delimiter, (str, String)), 'delimiter must be str or String'
    assert isinstance(slice, (int, float)), 'slice must be int or float'





    assert(isinstance(delimiter, (str, String)))
    py_string_delimiter = delimiter if isinstance(delimiter, StringName) else c_utils.py_string_to_string(delimiter)


    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([py_string_delimiter._ptr, slice]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_slicec(self, delimiter:'int'   , slice:'int'   ) -> typing.Union[str]:
    r''''''

    assert isinstance(delimiter, (int, float)), 'delimiter must be int or float'
    assert isinstance(slice, (int, float)), 'slice must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(9,tuple([delimiter, slice]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_slice_count(self, delimiter:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not delimiter is None)
    assert isinstance(delimiter, (str, String)), 'delimiter must be str or String'





    assert(isinstance(delimiter, (str, String)))
    py_string_delimiter = delimiter if isinstance(delimiter, StringName) else c_utils.py_string_to_string(delimiter)

    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([py_string_delimiter._ptr]))
    return _ret


  @functools.native_method
  def find(self, what:'str'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)


    _ret = 0
    _ret = self._ptr.call_with_return(11,tuple([py_string_what._ptr, from_]))
    return _ret


  @functools.native_method
  def findn(self, what:'str'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)


    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([py_string_what._ptr, from_]))
    return _ret


  @functools.native_method
  def count(self, what:'str'   , from_:'int' =0  , to:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'
    assert isinstance(to, (int, float)), 'to must be int or float'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)



    _ret = 0
    _ret = self._ptr.call_with_return(13,tuple([py_string_what._ptr, from_, to]))
    return _ret


  @functools.native_method
  def countn(self, what:'str'   , from_:'int' =0  , to:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'
    assert isinstance(to, (int, float)), 'to must be int or float'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)



    _ret = 0
    _ret = self._ptr.call_with_return(14,tuple([py_string_what._ptr, from_, to]))
    return _ret


  @functools.native_method
  def rfind(self, what:'str'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)


    _ret = 0
    _ret = self._ptr.call_with_return(15,tuple([py_string_what._ptr, from_]))
    return _ret


  @functools.native_method
  def rfindn(self, what:'str'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)


    _ret = 0
    _ret = self._ptr.call_with_return(16,tuple([py_string_what._ptr, from_]))
    return _ret


  @functools.native_method
  def match(self, expr:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not expr is None)
    assert isinstance(expr, (str, String)), 'expr must be str or String'





    assert(isinstance(expr, (str, String)))
    py_string_expr = expr if isinstance(expr, StringName) else c_utils.py_string_to_string(expr)

    _ret = 0
    _ret = self._ptr.call_with_return(17,tuple([py_string_expr._ptr]))
    return _ret


  @functools.native_method
  def matchn(self, expr:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not expr is None)
    assert isinstance(expr, (str, String)), 'expr must be str or String'





    assert(isinstance(expr, (str, String)))
    py_string_expr = expr if isinstance(expr, StringName) else c_utils.py_string_to_string(expr)

    _ret = 0
    _ret = self._ptr.call_with_return(18,tuple([py_string_expr._ptr]))
    return _ret


  @functools.native_method
  def begins_with(self, text:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([py_string_text._ptr]))
    return _ret


  @functools.native_method
  def ends_with(self, text:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([py_string_text._ptr]))
    return _ret


  @functools.native_method
  def is_subsequence_of(self, text:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([py_string_text._ptr]))
    return _ret


  @functools.native_method
  def is_subsequence_ofn(self, text:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([py_string_text._ptr]))
    return _ret


  @functools.native_method
  def bigrams(self) -> typing.Union['PackedStringArray']:
    r''''''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(23,tuple([]))
    return _ret


  @functools.native_method
  def similarity(self, text:'str'   ) -> typing.Union[float]:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = 0
    _ret = self._ptr.call_with_return(24,tuple([py_string_text._ptr]))
    return _ret


  @functools.native_method
  def format(self, values:'object'   , placeholder:'str' ="{_}"  ) -> typing.Union[str]:
    r''''''
    if placeholder is None:
      placeholder = String.new0()

    

    if not (type(values).__name__ in py4godot.variant_types.core_types or isinstance(values, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'values': "
                f"{type(values).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(placeholder, (str, String)))
    py_string_placeholder = placeholder if isinstance(placeholder, StringName) else c_utils.py_string_to_string(placeholder)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(25,tuple([values, py_string_placeholder._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def replace(self, what:'str'   , forwhat:'str'   ) -> typing.Union[str]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert(not forwhat is None)
    assert isinstance(forwhat, (str, String)), 'forwhat must be str or String'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)
    assert(isinstance(forwhat, (str, String)))
    py_string_forwhat = forwhat if isinstance(forwhat, StringName) else c_utils.py_string_to_string(forwhat)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(26,tuple([py_string_what._ptr, py_string_forwhat._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def replacen(self, what:'str'   , forwhat:'str'   ) -> typing.Union[str]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'
    assert(not forwhat is None)
    assert isinstance(forwhat, (str, String)), 'forwhat must be str or String'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)
    assert(isinstance(forwhat, (str, String)))
    py_string_forwhat = forwhat if isinstance(forwhat, StringName) else c_utils.py_string_to_string(forwhat)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(27,tuple([py_string_what._ptr, py_string_forwhat._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def replace_char(self, key:'int'   , with_:'int'   ) -> typing.Union[str]:
    r''''''

    assert isinstance(key, (int, float)), 'key must be int or float'
    assert isinstance(with_, (int, float)), 'with_ must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(28,tuple([key, with_]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def replace_chars(self, keys:'str'   , with_:'int'   ) -> typing.Union[str]:
    r''''''

    assert(not keys is None)
    assert isinstance(keys, (str, String)), 'keys must be str or String'
    assert isinstance(with_, (int, float)), 'with_ must be int or float'





    assert(isinstance(keys, (str, String)))
    py_string_keys = keys if isinstance(keys, StringName) else c_utils.py_string_to_string(keys)


    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(29,tuple([py_string_keys._ptr, with_]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def remove_char(self, what:'int'   ) -> typing.Union[str]:
    r''''''

    assert isinstance(what, (int, float)), 'what must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(30,tuple([what]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def remove_chars(self, chars:'str'   ) -> typing.Union[str]:
    r''''''

    assert(not chars is None)
    assert isinstance(chars, (str, String)), 'chars must be str or String'





    assert(isinstance(chars, (str, String)))
    py_string_chars = chars if isinstance(chars, StringName) else c_utils.py_string_to_string(chars)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(31,tuple([py_string_chars._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def repeat(self, count:'int'   ) -> typing.Union[str]:
    r''''''

    assert isinstance(count, (int, float)), 'count must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(32,tuple([count]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def reverse(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(33,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def insert(self, position:'int'   , what:'str'   ) -> typing.Union[str]:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'
    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'






    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(34,tuple([position, py_string_what._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def erase(self, position:'int'   , chars:'int' =1  ) -> typing.Union[str]:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'
    assert isinstance(chars, (int, float)), 'chars must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(35,tuple([position, chars]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def capitalize(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(36,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def to_camel_case(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(37,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def to_pascal_case(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(38,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def to_snake_case(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(39,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def to_kebab_case(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(40,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def split(self, delimiter:'str' =""  , allow_empty:'bool' =True  , maxsplit:'int' =0  ) -> typing.Union['PackedStringArray']:
    r''''''
    if delimiter is None:
      delimiter = String.new0()

    assert isinstance(allow_empty, bool), 'allow_empty must be bool'
    assert isinstance(maxsplit, (int, float)), 'maxsplit must be int or float'





    assert(isinstance(delimiter, (str, String)))
    py_string_delimiter = delimiter if isinstance(delimiter, StringName) else c_utils.py_string_to_string(delimiter)



    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(41,tuple([py_string_delimiter._ptr, allow_empty, maxsplit]))
    return _ret


  @functools.native_method
  def rsplit(self, delimiter:'str' =""  , allow_empty:'bool' =True  , maxsplit:'int' =0  ) -> typing.Union['PackedStringArray']:
    r''''''
    if delimiter is None:
      delimiter = String.new0()

    assert isinstance(allow_empty, bool), 'allow_empty must be bool'
    assert isinstance(maxsplit, (int, float)), 'maxsplit must be int or float'





    assert(isinstance(delimiter, (str, String)))
    py_string_delimiter = delimiter if isinstance(delimiter, StringName) else c_utils.py_string_to_string(delimiter)



    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(42,tuple([py_string_delimiter._ptr, allow_empty, maxsplit]))
    return _ret


  @functools.native_method
  def split_floats(self, delimiter:'str'   , allow_empty:'bool' =True  ) -> typing.Union['PackedFloat64Array']:
    r''''''

    assert(not delimiter is None)
    assert isinstance(delimiter, (str, String)), 'delimiter must be str or String'
    assert isinstance(allow_empty, bool), 'allow_empty must be bool'





    assert(isinstance(delimiter, (str, String)))
    py_string_delimiter = delimiter if isinstance(delimiter, StringName) else c_utils.py_string_to_string(delimiter)


    _ret = PackedFloat64Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(43,tuple([py_string_delimiter._ptr, allow_empty]))
    return _ret


  @functools.native_method
  def join(self, parts:'PackedStringArray'   ) -> typing.Union[str]:
    r''''''

    assert(not parts is None)
    assert isinstance(parts, PackedStringArray), 'parts must be PackedStringArray'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(44,tuple([parts._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def to_upper(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(45,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def to_lower(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(46,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def left(self, length:'int'   ) -> typing.Union[str]:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(47,tuple([length]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def right(self, length:'int'   ) -> typing.Union[str]:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(48,tuple([length]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def strip_edges(self, left:'bool' =True  , right:'bool' =True  ) -> typing.Union[str]:
    r''''''

    assert isinstance(left, bool), 'left must be bool'
    assert isinstance(right, bool), 'right must be bool'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(49,tuple([left, right]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def strip_escapes(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(50,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def lstrip(self, chars:'str'   ) -> typing.Union[str]:
    r''''''

    assert(not chars is None)
    assert isinstance(chars, (str, String)), 'chars must be str or String'





    assert(isinstance(chars, (str, String)))
    py_string_chars = chars if isinstance(chars, StringName) else c_utils.py_string_to_string(chars)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(51,tuple([py_string_chars._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def rstrip(self, chars:'str'   ) -> typing.Union[str]:
    r''''''

    assert(not chars is None)
    assert isinstance(chars, (str, String)), 'chars must be str or String'





    assert(isinstance(chars, (str, String)))
    py_string_chars = chars if isinstance(chars, StringName) else c_utils.py_string_to_string(chars)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(52,tuple([py_string_chars._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_extension(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_basename(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def path_join(self, path:'str'   ) -> typing.Union[str]:
    r''''''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(55,tuple([py_string_path._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def unicode_at(self, at:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(at, (int, float)), 'at must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([at]))
    return _ret


  @functools.native_method
  def indent(self, prefix:'str'   ) -> typing.Union[str]:
    r''''''

    assert(not prefix is None)
    assert isinstance(prefix, (str, String)), 'prefix must be str or String'





    assert(isinstance(prefix, (str, String)))
    py_string_prefix = prefix if isinstance(prefix, StringName) else c_utils.py_string_to_string(prefix)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(57,tuple([py_string_prefix._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def dedent(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def md5_text(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(59,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def sha1_text(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def sha256_text(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def md5_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([]))
    return _ret


  @functools.native_method
  def sha1_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(63,tuple([]))
    return _ret


  @functools.native_method
  def sha256_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(64,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(65,tuple([]))
    return _ret


  @functools.native_method
  def contains(self, what:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)

    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([py_string_what._ptr]))
    return _ret


  @functools.native_method
  def containsn(self, what:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not what is None)
    assert isinstance(what, (str, String)), 'what must be str or String'





    assert(isinstance(what, (str, String)))
    py_string_what = what if isinstance(what, StringName) else c_utils.py_string_to_string(what)

    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([py_string_what._ptr]))
    return _ret


  @functools.native_method
  def is_absolute_path(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(68,tuple([]))
    return _ret


  @functools.native_method
  def is_relative_path(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(69,tuple([]))
    return _ret


  @functools.native_method
  def simplify_path(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(70,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_base_dir(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(71,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_file(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(72,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def xml_escape(self, escape_quotes:'bool' =False  ) -> typing.Union[str]:
    r''''''

    assert isinstance(escape_quotes, bool), 'escape_quotes must be bool'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(73,tuple([escape_quotes]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def xml_unescape(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(74,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def uri_encode(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(75,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def uri_decode(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(76,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def uri_file_decode(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(77,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def c_escape(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def c_unescape(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def json_escape(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def validate_node_name(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def validate_filename(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(82,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def is_valid_ascii_identifier(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(83,tuple([]))
    return _ret


  @functools.native_method
  def is_valid_unicode_identifier(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([]))
    return _ret


  @functools.native_method
  def is_valid_identifier(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([]))
    return _ret


  @functools.native_method
  def is_valid_int(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def is_valid_float(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(87,tuple([]))
    return _ret


  @functools.native_method
  def is_valid_hex_number(self, with_prefix:'bool' =False  ) -> typing.Union[bool]:
    r''''''

    assert isinstance(with_prefix, bool), 'with_prefix must be bool'







    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([with_prefix]))
    return _ret


  @functools.native_method
  def is_valid_html_color(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([]))
    return _ret


  @functools.native_method
  def is_valid_ip_address(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([]))
    return _ret


  @functools.native_method
  def is_valid_filename(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(91,tuple([]))
    return _ret


  @functools.native_method
  def to_int(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([]))
    return _ret


  @functools.native_method
  def to_float(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([]))
    return _ret


  @functools.native_method
  def hex_to_int(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([]))
    return _ret


  @functools.native_method
  def bin_to_int(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(95,tuple([]))
    return _ret


  @functools.native_method
  def lpad(self, min_length:'int'   , character:'str' =" "  ) -> typing.Union[str]:
    r''''''
    if character is None:
      character = String.new0()

    assert isinstance(min_length, (int, float)), 'min_length must be int or float'






    assert(isinstance(character, (str, String)))
    py_string_character = character if isinstance(character, StringName) else c_utils.py_string_to_string(character)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([min_length, py_string_character._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def rpad(self, min_length:'int'   , character:'str' =" "  ) -> typing.Union[str]:
    r''''''
    if character is None:
      character = String.new0()

    assert isinstance(min_length, (int, float)), 'min_length must be int or float'






    assert(isinstance(character, (str, String)))
    py_string_character = character if isinstance(character, StringName) else c_utils.py_string_to_string(character)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(97,tuple([min_length, py_string_character._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def pad_decimals(self, digits:'int'   ) -> typing.Union[str]:
    r''''''

    assert isinstance(digits, (int, float)), 'digits must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(98,tuple([digits]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def pad_zeros(self, digits:'int'   ) -> typing.Union[str]:
    r''''''

    assert isinstance(digits, (int, float)), 'digits must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(99,tuple([digits]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def trim_prefix(self, prefix:'str'   ) -> typing.Union[str]:
    r''''''

    assert(not prefix is None)
    assert isinstance(prefix, (str, String)), 'prefix must be str or String'





    assert(isinstance(prefix, (str, String)))
    py_string_prefix = prefix if isinstance(prefix, StringName) else c_utils.py_string_to_string(prefix)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(100,tuple([py_string_prefix._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def trim_suffix(self, suffix:'str'   ) -> typing.Union[str]:
    r''''''

    assert(not suffix is None)
    assert isinstance(suffix, (str, String)), 'suffix must be str or String'





    assert(isinstance(suffix, (str, String)))
    py_string_suffix = suffix if isinstance(suffix, StringName) else c_utils.py_string_to_string(suffix)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(101,tuple([py_string_suffix._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def to_ascii_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(102,tuple([]))
    return _ret


  @functools.native_method
  def to_utf8_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(103,tuple([]))
    return _ret


  @functools.native_method
  def to_utf16_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(104,tuple([]))
    return _ret


  @functools.native_method
  def to_utf32_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(105,tuple([]))
    return _ret


  @functools.native_method
  def to_wchar_buffer(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(106,tuple([]))
    return _ret


  @functools.native_method
  def to_multibyte_char_buffer(self, encoding:'str' =""  ) -> typing.Union['PackedByteArray']:
    r''''''
    if encoding is None:
      encoding = String.new0()






    assert(isinstance(encoding, (str, String)))
    py_string_encoding = encoding if isinstance(encoding, StringName) else c_utils.py_string_to_string(encoding)

    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(107,tuple([py_string_encoding._ptr]))
    return _ret


  @functools.native_method
  def hex_decode(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(108,tuple([]))
    return _ret


  @functools.native_method
  def hash(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(109,tuple([]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, String):
      _ret = False

      _ret= self._ptr.call_with_return(137, (other,))
      return _ret
    if isinstance(other, StringName):
      _ret = False

      _ret= self._ptr.call_with_return(137, (other,))
      return _ret

    _ret= self._ptr.call_with_return(137, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, String):
      _ret = False

      _ret= self._ptr.call_with_return(138, (other,))
      return _ret
    if isinstance(other, StringName):
      _ret = False

      _ret= self._ptr.call_with_return(138, (other,))
      return _ret

    _ret= self._ptr.call_with_return(138, (other,))
    return _ret
  def __mod__(self, other):
    if isinstance(other, bool):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, int):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, float):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, String):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Vector2):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Vector2i):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Rect2):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Rect2i):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Vector3):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Vector3i):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Transform2D):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Vector4):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Vector4i):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Plane):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Quaternion):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, AABB):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Basis):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Transform3D):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Projection):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Color):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, StringName):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, NodePath):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, RID):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Object):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Callable):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Signal):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Dictionary):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedByteArray):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedInt32Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedInt64Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedFloat32Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedFloat64Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedStringArray):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedVector2Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedVector3Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedColorArray):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret
    if isinstance(other, PackedVector4Array):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(161, (other,))
      return _ret

    _ret= self._ptr.call_with_return(161, (other,))
    return _ret
  def __add__(self, other):
    if isinstance(other, String):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(143, (other,))
      return _ret
    if isinstance(other, StringName):
      _ret = String()

      _ret._ptr = self._ptr.call_with_return(143, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __lt__(self, other):
    if isinstance(other, StringName):
      _ret = False

      _ret= self._ptr.call_with_return(139, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __le__(self, other):
    if isinstance(other, StringName):
      _ret = False

      _ret= self._ptr.call_with_return(140, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __gt__(self, other):
    if isinstance(other, StringName):
      _ret = False

      _ret= self._ptr.call_with_return(141, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __ge__(self, other):
    if isinstance(other, StringName):
      _ret = False

      _ret= self._ptr.call_with_return(142, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPNodePathWrapper


class NodePath(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = NodePath.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1050, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'object' ):
    assert(not from_ is None)
    assert isinstance(from_, (str, NodePath)), 'from_ must be str or NodePath'

    _class = NodePath.construct_without_init()
    _class.constructed_from_python = True
    assert(isinstance(from_, (str, NodePath)))
    py_nodepath_from_ = from_ if isinstance(from_,NodePath) else NodePath.new2(from_)

    _class.py_nodepath_from_ = py_nodepath_from_
    _class._ptr = constructor(1050, 1, tuple([py_nodepath_from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'str' ):
    assert(not from_ is None)
    assert isinstance(from_, (str, String)), 'from_ must be str or String'

    _class = NodePath.construct_without_init()
    _class.constructed_from_python = True
    assert(isinstance(from_, (str, String)))
    py_string_from_ = from_ if isinstance(from_, StringName) else c_utils.py_string_to_string(from_)

    _class.py_string_from_ = py_string_from_
    _class._ptr = constructor(1050, 2, tuple([py_string_from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1050,0, ())

  def generate_wrapper(self):
    return CPPNodePathWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = NodePath.__new__(NodePath)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'NodePath'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(11, ())


  @functools.native_method
  def is_absolute(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def get_name_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def get_name(self, idx:'int'   ) -> typing.Union['StringName']:
    r''''''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(2,tuple([idx]))
    return str(_ret)


  @functools.native_method
  def get_subname_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def hash(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([]))
    return _ret


  @functools.native_method
  def get_subname(self, idx:'int'   ) -> typing.Union['StringName']:
    r''''''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(5,tuple([idx]))
    return str(_ret)


  @functools.native_method
  def get_concatenated_names(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(6,tuple([]))
    return str(_ret)


  @functools.native_method
  def get_concatenated_subnames(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([]))
    return str(_ret)


  @functools.native_method
  def slice(self, begin:'int'   , end:'int' =2147483647  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'








    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(8,tuple([begin, end]))
    return _ret


  @functools.native_method
  def get_as_property_path(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(9,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, NodePath):
      _ret = False

      _ret= self._ptr.call_with_return(14, (other,))
      return _ret

    _ret= self._ptr.call_with_return(14, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, NodePath):
      _ret = False

      _ret= self._ptr.call_with_return(15, (other,))
      return _ret

    _ret= self._ptr.call_with_return(15, (other,))
    return _ret

from py4godot.wrappers.wrappers import CPPRIDWrapper


class RID(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = RID.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1051, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'RID' ):
    assert(not from_ is None)
    assert isinstance(from_, RID), 'from_ must be RID'

    _class = RID.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1051, 1, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1051,0, ())

  def generate_wrapper(self):
    return CPPRIDWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = RID.__new__(RID)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'RID'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(2, ())


  @functools.native_method
  def is_valid(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def get_id(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, RID):
      _ret = False

      _ret= self._ptr.call_with_return(5, (other,))
      return _ret

    _ret= self._ptr.call_with_return(5, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, RID):
      _ret = False

      _ret= self._ptr.call_with_return(6, (other,))
      return _ret

    _ret= self._ptr.call_with_return(6, (other,))
    return _ret
  def __lt__(self, other):
    if isinstance(other, RID):
      _ret = False

      _ret= self._ptr.call_with_return(7, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __le__(self, other):
    if isinstance(other, RID):
      _ret = False

      _ret= self._ptr.call_with_return(8, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __gt__(self, other):
    if isinstance(other, RID):
      _ret = False

      _ret= self._ptr.call_with_return(9, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __ge__(self, other):
    if isinstance(other, RID):
      _ret = False

      _ret= self._ptr.call_with_return(10, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPCallableWrapper


class Callable(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = Callable.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1052, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Callable' ):
    assert(not from_ is None)
    assert isinstance(from_, Callable), 'from_ must be Callable'

    _class = Callable.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1052, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(object_:'Object' , method:'object' ):
    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not method is None)
    assert isinstance(method, (str, StringName)), 'method must be str or StringName'

    _class = Callable.construct_without_init()
    _class.constructed_from_python = True

    assert(isinstance(method, (str, StringName)))
    py_stringname_method = method if isinstance(method, StringName) else c_utils.py_string_to_string_name(method)


    _class.py_stringname_method =py_stringname_method
    _class._ptr = constructor(1052, 2, tuple([object_._ptr, py_stringname_method._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1052,0, ())

  def generate_wrapper(self):
    return CPPCallableWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Callable.__new__(Callable)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Callable'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(20, ())


  @staticmethod
  def create(variant:'object'   , method:'object'   ) -> typing.Union['typing.Self']:
    r''''''

    
    assert(not method is None)
    assert isinstance(method, (str, StringName)), 'method must be str or StringName'

    if not (type(variant).__name__ in py4godot.variant_types.core_types or isinstance(variant, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'variant': "
                f"{type(variant).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(method, (str, StringName)))
    py_stringname_method = method if isinstance(method, StringName) else c_utils.py_string_to_string_name(method)

    _ret = Callable.construct_without_init()
    _ret._ptr = static_method(1052,0,tuple([variant, py_stringname_method._ptr]))
    return _ret


  @functools.native_method
  def callv(self, arguments:'Array'   ) -> typing.Union[typing.Any]:
    r''''''

    assert(not arguments is None)
    assert isinstance(arguments, Array), 'arguments must be Array'







    _ret = None
    _ret = self._ptr.call_with_return(0,tuple([arguments._ptr]))
    return _ret


  @functools.native_method
  def is_null(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def is_custom(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def is_standard(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def is_valid(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([]))
    return _ret


  @functools.native_method
  def get_object(self) -> object:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Object
    _ret._ptr = self._ptr.call_with_return(5,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_object_id(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(6,tuple([]))
    return _ret


  @functools.native_method
  def get_method(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([]))
    return str(_ret)


  @functools.native_method
  def get_argument_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([]))
    return _ret


  @functools.native_method
  def get_bound_arguments_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(9,tuple([]))
    return _ret


  @functools.native_method
  def get_bound_arguments(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(10,tuple([]))
    return _ret


  @functools.native_method
  def get_unbound_arguments_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(11,tuple([]))
    return _ret


  @functools.native_method
  def hash(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([]))
    return _ret


  @functools.native_method
  def bindv(self, arguments:'Array'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not arguments is None)
    assert isinstance(arguments, Array), 'arguments must be Array'







    _ret = Callable.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(13,tuple([arguments._ptr]))
    return _ret


  @functools.native_method
  def unbind(self, argcount:'int'   ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(argcount, (int, float)), 'argcount must be int or float'







    _ret = Callable.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([argcount]))
    return _ret


  @functools.native_method
  def call(self, *varargs) -> typing.Union[typing.Any]:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(15,tuple([*varargs]))
    return _ret


  @functools.native_method
  def call_deferred(self, *varargs) -> None:
    r''''''

    for arg in varargs:
      if isinstance(arg, CoreType):
        arg.shouldBeDeleted = not arg.constructed_from_python




    self._ptr.call_with_return(16,tuple([*varargs]))

  @functools.native_method
  def rpc(self, *varargs) -> None:
    r''''''




    self._ptr.call_with_return(17,tuple([*varargs]))

  @functools.native_method
  def rpc_id(self, peer_id:'int'   , *varargs) -> None:
    r''''''

    assert isinstance(peer_id, (int, float)), 'peer_id must be int or float'

    for arg in varargs:
      if not (type(arg).__name__ in py4godot.variant_types.core_types or isinstance(arg, classes.Object.Object)):
        raise ValueError(
            f"Unsupported type in varargs: {type(arg).__name__}. "
            "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
            "and built-in types int, float, and bool."
        )





    self._ptr.call_with_return(18,tuple([peer_id, *varargs]))

  @functools.native_method
  def bind(self, *varargs) -> typing.Union['typing.Self']:
    r''''''




    _ret = Callable.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(19,tuple([*varargs]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Callable):
      _ret = False

      _ret= self._ptr.call_with_return(23, (other,))
      return _ret

    _ret= self._ptr.call_with_return(23, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Callable):
      _ret = False

      _ret= self._ptr.call_with_return(24, (other,))
      return _ret

    _ret= self._ptr.call_with_return(24, (other,))
    return _ret

from py4godot.wrappers.wrappers import CPPSignalWrapper


class Signal(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = Signal.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1053, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Signal' ):
    assert(not from_ is None)
    assert isinstance(from_, Signal), 'from_ must be Signal'

    _class = Signal.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1053, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(object_:'Object' , signal:'object' ):
    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not signal is None)
    assert isinstance(signal, (str, StringName)), 'signal must be str or StringName'

    _class = Signal.construct_without_init()
    _class.constructed_from_python = True

    assert(isinstance(signal, (str, StringName)))
    py_stringname_signal = signal if isinstance(signal, StringName) else c_utils.py_string_to_string_name(signal)


    _class.py_stringname_signal =py_stringname_signal
    _class._ptr = constructor(1053, 2, tuple([object_._ptr, py_stringname_signal._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1053,0, ())

  def generate_wrapper(self):
    return CPPSignalWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Signal.__new__(Signal)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Signal'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(10, ())


  @functools.native_method
  def is_null(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def get_object(self) -> object:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Object
    _ret._ptr = self._ptr.call_with_return(1,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_object_id(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def get_name(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(3,tuple([]))
    return str(_ret)


  @functools.native_method
  def connect(self, callable:'Callable'   , flags:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'
    assert isinstance(flags, (int, float)), 'flags must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([callable._ptr, flags]))
    return _ret


  @functools.native_method
  def disconnect(self, callable:'Callable'   ) -> None:
    r''''''

    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'







    self._ptr.call_with_return(5,tuple([callable._ptr]))

  @functools.native_method
  def is_connected(self, callable:'Callable'   ) -> typing.Union[bool]:
    r''''''

    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'







    _ret = 0
    _ret = self._ptr.call_with_return(6,tuple([callable._ptr]))
    return _ret


  @functools.native_method
  def get_connections(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(7,tuple([]))
    return _ret


  @functools.native_method
  def has_connections(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([]))
    return _ret


  @functools.native_method
  def emit(self, *varargs) -> None:
    r''''''




    self._ptr.call_with_return(9,tuple([*varargs]))

  def __eq__(self, other):
    if isinstance(other, Signal):
      _ret = False

      _ret= self._ptr.call_with_return(13, (other,))
      return _ret

    _ret= self._ptr.call_with_return(13, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Signal):
      _ret = False

      _ret= self._ptr.call_with_return(14, (other,))
      return _ret

    _ret= self._ptr.call_with_return(14, (other,))
    return _ret

from py4godot.wrappers.wrappers import CPPDictionaryWrapper


class Dictionary(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = Dictionary.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1054, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Dictionary' ):
    assert(not from_ is None)
    assert isinstance(from_, Dictionary), 'from_ must be Dictionary'

    _class = Dictionary.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1054, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(base:'Dictionary' , key_type:'int' , key_class_name:'object' , key_script:'object' , value_type:'int' , value_class_name:'object' , value_script:'object' ):
    assert(not base is None)
    assert isinstance(base, Dictionary), 'base must be Dictionary'
    assert isinstance(key_type, (int, float)), 'key_type must be int or float'
    assert(not key_class_name is None)
    assert isinstance(key_class_name, (str, StringName)), 'key_class_name must be str or StringName'
    
    assert isinstance(value_type, (int, float)), 'value_type must be int or float'
    assert(not value_class_name is None)
    assert isinstance(value_class_name, (str, StringName)), 'value_class_name must be str or StringName'
    

    _class = Dictionary.construct_without_init()
    _class.constructed_from_python = True


    assert(isinstance(key_class_name, (str, StringName)))
    py_stringname_key_class_name = key_class_name if isinstance(key_class_name, StringName) else c_utils.py_string_to_string_name(key_class_name)


    assert(isinstance(value_class_name, (str, StringName)))
    py_stringname_value_class_name = value_class_name if isinstance(value_class_name, StringName) else c_utils.py_string_to_string_name(value_class_name)


    _class.__base__ = base

    _class.py_stringname_key_class_name =py_stringname_key_class_name


    _class.py_stringname_value_class_name =py_stringname_value_class_name

    _class._ptr = constructor(1054, 2, tuple([base._ptr, key_type, py_stringname_key_class_name._ptr, key_script, value_type, py_stringname_value_class_name._ptr, value_script]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1054,0, ())

  def generate_wrapper(self):
    return CPPDictionaryWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Dictionary.__new__(Dictionary)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Dictionary'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(34, ())
  def __setitem__(self, key, value):
    self._ptr.call_with_return(40, (key, value))

  def __getitem__(self,  key):
    if not self.has(key):
      raise KeyError(f"Key '{key}' not found")
    pyobject = self._ptr.call_with_return(39, (key,))
    return pyobject

  @functools.native_method
  def size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(2,tuple([]))

  @functools.native_method
  def assign(self, dictionary:'Dictionary'   ) -> None:
    r''''''

    assert(not dictionary is None)
    assert isinstance(dictionary, Dictionary), 'dictionary must be Dictionary'







    self._ptr.call_with_return(3,tuple([dictionary._ptr]))

  @functools.native_method
  def sort(self) -> None:
    r''''''




    self._ptr.call_with_return(4,tuple([]))

  @functools.native_method
  def merge(self, dictionary:'Dictionary'   , overwrite:'bool' =False  ) -> None:
    r''''''

    assert(not dictionary is None)
    assert isinstance(dictionary, Dictionary), 'dictionary must be Dictionary'
    assert isinstance(overwrite, bool), 'overwrite must be bool'








    self._ptr.call_with_return(5,tuple([dictionary._ptr, overwrite]))

  @functools.native_method
  def merged(self, dictionary:'Dictionary'   , overwrite:'bool' =False  ) -> typing.Union['typing.Self']:
    r''''''

    assert(not dictionary is None)
    assert isinstance(dictionary, Dictionary), 'dictionary must be Dictionary'
    assert isinstance(overwrite, bool), 'overwrite must be bool'








    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(6,tuple([dictionary._ptr, overwrite]))
    return _ret


  @functools.native_method
  def has(self, key:'object'   ) -> typing.Union[bool]:
    r''''''

    

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    _ret = 0
    _ret = self._ptr.call_with_return(7,tuple([key]))
    return _ret


  @functools.native_method
  def has_all(self, keys:'Array'   ) -> typing.Union[bool]:
    r''''''

    assert(not keys is None)
    assert isinstance(keys, Array), 'keys must be Array'







    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([keys._ptr]))
    return _ret


  @functools.native_method
  def find_key(self, value:'object'   ) -> typing.Union[typing.Any]:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    _ret = None
    _ret = self._ptr.call_with_return(9,tuple([value]))
    return _ret


  @functools.native_method
  def erase(self, key:'object'   ) -> typing.Union[bool]:
    r''''''

    

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([key]))
    return _ret


  @functools.native_method
  def hash(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(11,tuple([]))
    return _ret


  @functools.native_method
  def keys(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(12,tuple([]))
    return _ret


  @functools.native_method
  def values(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(13,tuple([]))
    return _ret


  @functools.native_method
  def duplicate(self, deep:'bool' =False  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(deep, bool), 'deep must be bool'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([deep]))
    return _ret


  @functools.native_method
  def duplicate_deep(self, deep_subresources_mode:'int' =1  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(deep_subresources_mode, (int, float)), 'deep_subresources_mode must be int or float'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([deep_subresources_mode]))
    return _ret


  @functools.native_method
  def get(self, key:'object'   , default:'object' =None  ) -> typing.Union[typing.Any]:
    r''''''


    
    

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )
    if not (type(default).__name__ in py4godot.variant_types.core_types or isinstance(default, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'default': "
                f"{type(default).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = None
    _ret = self._ptr.call_with_return(16,tuple([key, default]))
    return _ret


  @functools.native_method
  def get_or_add(self, key:'object'   , default:'object' =None  ) -> typing.Union[typing.Any]:
    r''''''


    
    

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )
    if not (type(default).__name__ in py4godot.variant_types.core_types or isinstance(default, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'default': "
                f"{type(default).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = None
    _ret = self._ptr.call_with_return(17,tuple([key, default]))
    return _ret


  @functools.native_method
  def set(self, key:'object'   , value:'object'   ) -> typing.Union[bool]:
    r''''''

    
    

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )
    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = 0
    _ret = self._ptr.call_with_return(18,tuple([key, value]))
    return _ret


  @functools.native_method
  def is_typed(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([]))
    return _ret


  @functools.native_method
  def is_typed_key(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([]))
    return _ret


  @functools.native_method
  def is_typed_value(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([]))
    return _ret


  @functools.native_method
  def is_same_typed(self, dictionary:'Dictionary'   ) -> typing.Union[bool]:
    r''''''

    assert(not dictionary is None)
    assert isinstance(dictionary, Dictionary), 'dictionary must be Dictionary'







    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([dictionary._ptr]))
    return _ret


  @functools.native_method
  def is_same_typed_key(self, dictionary:'Dictionary'   ) -> typing.Union[bool]:
    r''''''

    assert(not dictionary is None)
    assert isinstance(dictionary, Dictionary), 'dictionary must be Dictionary'







    _ret = 0
    _ret = self._ptr.call_with_return(23,tuple([dictionary._ptr]))
    return _ret


  @functools.native_method
  def is_same_typed_value(self, dictionary:'Dictionary'   ) -> typing.Union[bool]:
    r''''''

    assert(not dictionary is None)
    assert isinstance(dictionary, Dictionary), 'dictionary must be Dictionary'







    _ret = 0
    _ret = self._ptr.call_with_return(24,tuple([dictionary._ptr]))
    return _ret


  @functools.native_method
  def get_typed_key_builtin(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(25,tuple([]))
    return _ret


  @functools.native_method
  def get_typed_value_builtin(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(26,tuple([]))
    return _ret


  @functools.native_method
  def get_typed_key_class_name(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(27,tuple([]))
    return str(_ret)


  @functools.native_method
  def get_typed_value_class_name(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(28,tuple([]))
    return str(_ret)


  @functools.native_method
  def get_typed_key_script(self) -> typing.Union[typing.Any]:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(29,tuple([]))
    return _ret


  @functools.native_method
  def get_typed_value_script(self) -> typing.Union[typing.Any]:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(30,tuple([]))
    return _ret


  @functools.native_method
  def make_read_only(self) -> None:
    r''''''




    self._ptr.call_with_return(31,tuple([]))

  @functools.native_method
  def is_read_only(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(32,tuple([]))
    return _ret


  @functools.native_method
  def recursive_equal(self, dictionary:'Dictionary'   , recursion_count:'int'   ) -> typing.Union[bool]:
    r''''''

    assert(not dictionary is None)
    assert isinstance(dictionary, Dictionary), 'dictionary must be Dictionary'
    assert isinstance(recursion_count, (int, float)), 'recursion_count must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(33,tuple([dictionary._ptr, recursion_count]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Dictionary):
      _ret = False

      _ret= self._ptr.call_with_return(37, (other,))
      return _ret

    _ret= self._ptr.call_with_return(37, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Dictionary):
      _ret = False

      _ret= self._ptr.call_with_return(38, (other,))
      return _ret

    _ret= self._ptr.call_with_return(38, (other,))
    return _ret

from py4godot.wrappers.wrappers import CPPArrayWrapper


class Array(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = Array.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1055, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1055, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(base:'Array' , type:'int' , class_name:'object' , script:'object' ):
    assert(not base is None)
    assert isinstance(base, Array), 'base must be Array'
    assert isinstance(type, (int, float)), 'type must be int or float'
    assert(not class_name is None)
    assert isinstance(class_name, (str, StringName)), 'class_name must be str or StringName'
    

    _class = Array.construct_without_init()
    _class.constructed_from_python = True


    assert(isinstance(class_name, (str, StringName)))
    py_stringname_class_name = class_name if isinstance(class_name, StringName) else c_utils.py_string_to_string_name(class_name)


    _class.__base__ = base

    _class.py_stringname_class_name =py_stringname_class_name

    _class._ptr = constructor(1055, 2, tuple([base._ptr, type, py_stringname_class_name._ptr, script]))
    return _class
  @staticmethod
  def new3(from_:'PackedByteArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedByteArray), 'from_ must be PackedByteArray'

    _class = Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1055, 3, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new4(from_:'PackedInt32Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedInt32Array), 'from_ must be PackedInt32Array'

    _class = Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1055, 4, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new5(from_:'PackedInt64Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedInt64Array), 'from_ must be PackedInt64Array'

    _class = Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1055, 5, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new6(from_:'PackedFloat32Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedFloat32Array), 'from_ must be PackedFloat32Array'

    _class = Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1055, 6, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new7(from_:'PackedFloat64Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedFloat64Array), 'from_ must be PackedFloat64Array'

    _class = Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1055, 7, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new8(from_:'PackedStringArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedStringArray), 'from_ must be PackedStringArray'

    _class = Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1055, 8, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new9(from_:'PackedVector2Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector2Array), 'from_ must be PackedVector2Array'

    _class = Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1055, 9, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new10(from_:'PackedVector3Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector3Array), 'from_ must be PackedVector3Array'

    _class = Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1055, 10, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new11(from_:'PackedColorArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedColorArray), 'from_ must be PackedColorArray'

    _class = Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1055, 11, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new12(from_:'PackedVector4Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector4Array), 'from_ must be PackedVector4Array'

    _class = Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1055, 12, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1055,0, ())

  def generate_wrapper(self):
    return CPPArrayWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = Array.__new__(Array)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(51, ())
  def __setitem__(self,  index, value):
    self._ptr.call_with_return(62, (index, value))

  def __getitem__(self,  index):

    if index < 0:
      raise KeyError(f"Index '{index}' invalid")
    pyobject = self._ptr.call_with_return(61, (index,))
    return pyobject
  def __iter__(self):
    self._index = 0
    return self
  def __next__(self):
    if self._index >= self.size():
      raise StopIteration()
    val = self[self._index]
    self._index += 1
    return val


  @staticmethod
  def from_list(values):
    result = Array.new0()
    for value in values:
      result.push_back(value)
    return result

  def to_list(self):
    return [value for value in self]


  @functools.native_method
  def size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(2,tuple([]))

  @functools.native_method
  def hash(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def assign(self, array:'Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, Array), 'array must be Array'







    self._ptr.call_with_return(4,tuple([array._ptr]))

  @functools.native_method
  def get(self, index:'int'   ) -> typing.Union[typing.Any]:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = None
    _ret = self._ptr.call_with_return(5,tuple([index]))
    return _ret


  @functools.native_method
  def set(self, index:'int'   , value:'object'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    self._ptr.call_with_return(6,tuple([index, value]))

  @functools.native_method
  def push_back(self, value:'object'   ) -> None:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    self._ptr.call_with_return(7,tuple([value]))

  @functools.native_method
  def push_front(self, value:'object'   ) -> None:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    self._ptr.call_with_return(8,tuple([value]))

  @functools.native_method
  def append(self, value:'object'   ) -> None:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    self._ptr.call_with_return(9,tuple([value]))

  @functools.native_method
  def append_array(self, array:'Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, Array), 'array must be Array'







    self._ptr.call_with_return(10,tuple([array._ptr]))

  @functools.native_method
  def resize(self, size:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(11,tuple([size]))
    return _ret


  @functools.native_method
  def insert(self, position:'int'   , value:'object'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([position, value]))
    return _ret


  @functools.native_method
  def remove_at(self, position:'int'   ) -> None:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'







    self._ptr.call_with_return(13,tuple([position]))

  @functools.native_method
  def fill(self, value:'object'   ) -> None:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    self._ptr.call_with_return(14,tuple([value]))

  @functools.native_method
  def erase(self, value:'object'   ) -> None:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    self._ptr.call_with_return(15,tuple([value]))

  @functools.native_method
  def front(self) -> typing.Union[typing.Any]:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(16,tuple([]))
    return _ret


  @functools.native_method
  def back(self) -> typing.Union[typing.Any]:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(17,tuple([]))
    return _ret


  @functools.native_method
  def pick_random(self) -> typing.Union[typing.Any]:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(18,tuple([]))
    return _ret


  @functools.native_method
  def find(self, what:'object'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    
    assert isinstance(from_, (int, float)), 'from_ must be int or float'

    if not (type(what).__name__ in py4godot.variant_types.core_types or isinstance(what, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'what': "
                f"{type(what).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([what, from_]))
    return _ret


  @functools.native_method
  def find_custom(self, method:'Callable'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([method._ptr, from_]))
    return _ret


  @functools.native_method
  def rfind(self, what:'object'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    
    assert isinstance(from_, (int, float)), 'from_ must be int or float'

    if not (type(what).__name__ in py4godot.variant_types.core_types or isinstance(what, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'what': "
                f"{type(what).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([what, from_]))
    return _ret


  @functools.native_method
  def rfind_custom(self, method:'Callable'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([method._ptr, from_]))
    return _ret


  @functools.native_method
  def count(self, value:'object'   ) -> typing.Union[int]:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    _ret = 0
    _ret = self._ptr.call_with_return(23,tuple([value]))
    return _ret


  @functools.native_method
  def has(self, value:'object'   ) -> typing.Union[bool]:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    _ret = 0
    _ret = self._ptr.call_with_return(24,tuple([value]))
    return _ret


  @functools.native_method
  def pop_back(self) -> typing.Union[typing.Any]:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(25,tuple([]))
    return _ret


  @functools.native_method
  def pop_front(self) -> typing.Union[typing.Any]:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(26,tuple([]))
    return _ret


  @functools.native_method
  def pop_at(self, position:'int'   ) -> typing.Union[typing.Any]:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'







    _ret = None
    _ret = self._ptr.call_with_return(27,tuple([position]))
    return _ret


  @functools.native_method
  def sort(self) -> None:
    r''''''




    self._ptr.call_with_return(28,tuple([]))

  @functools.native_method
  def sort_custom(self, func:'Callable'   ) -> None:
    r''''''

    assert(not func is None)
    assert isinstance(func, Callable), 'func must be Callable'







    self._ptr.call_with_return(29,tuple([func._ptr]))

  @functools.native_method
  def shuffle(self) -> None:
    r''''''




    self._ptr.call_with_return(30,tuple([]))

  @functools.native_method
  def bsearch(self, value:'object'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    
    assert isinstance(before, bool), 'before must be bool'

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = 0
    _ret = self._ptr.call_with_return(31,tuple([value, before]))
    return _ret


  @functools.native_method
  def bsearch_custom(self, value:'object'   , func:'Callable'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    
    assert(not func is None)
    assert isinstance(func, Callable), 'func must be Callable'
    assert isinstance(before, bool), 'before must be bool'

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    _ret = 0
    _ret = self._ptr.call_with_return(32,tuple([value, func._ptr, before]))
    return _ret


  @functools.native_method
  def reverse(self) -> None:
    r''''''




    self._ptr.call_with_return(33,tuple([]))

  @functools.native_method
  def duplicate(self, deep:'bool' =False  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(deep, bool), 'deep must be bool'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(34,tuple([deep]))
    return _ret


  @functools.native_method
  def duplicate_deep(self, deep_subresources_mode:'int' =1  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(deep_subresources_mode, (int, float)), 'deep_subresources_mode must be int or float'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(35,tuple([deep_subresources_mode]))
    return _ret


  @functools.native_method
  def slice(self, begin:'int'   , end:'int' =2147483647  , step:'int' =1  , deep:'bool' =False  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'
    assert isinstance(step, (int, float)), 'step must be int or float'
    assert isinstance(deep, bool), 'deep must be bool'










    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(36,tuple([begin, end, step, deep]))
    return _ret


  @functools.native_method
  def filter(self, method:'Callable'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(37,tuple([method._ptr]))
    return _ret


  @functools.native_method
  def map(self, method:'Callable'   ) -> typing.Union['typing.Self']:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(38,tuple([method._ptr]))
    return _ret


  @functools.native_method
  def reduce(self, method:'Callable'   , accum:'object' =None  ) -> typing.Union[typing.Any]:
    r''''''


    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'
    

    if not (type(accum).__name__ in py4godot.variant_types.core_types or isinstance(accum, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'accum': "
                f"{type(accum).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = None
    _ret = self._ptr.call_with_return(39,tuple([method._ptr, accum]))
    return _ret


  @functools.native_method
  def any(self, method:'Callable'   ) -> typing.Union[bool]:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'







    _ret = 0
    _ret = self._ptr.call_with_return(40,tuple([method._ptr]))
    return _ret


  @functools.native_method
  def all(self, method:'Callable'   ) -> typing.Union[bool]:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'







    _ret = 0
    _ret = self._ptr.call_with_return(41,tuple([method._ptr]))
    return _ret


  @functools.native_method
  def max(self) -> typing.Union[typing.Any]:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(42,tuple([]))
    return _ret


  @functools.native_method
  def min(self) -> typing.Union[typing.Any]:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(43,tuple([]))
    return _ret


  @functools.native_method
  def is_typed(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(44,tuple([]))
    return _ret


  @functools.native_method
  def is_same_typed(self, array:'Array'   ) -> typing.Union[bool]:
    r''''''

    assert(not array is None)
    assert isinstance(array, Array), 'array must be Array'







    _ret = 0
    _ret = self._ptr.call_with_return(45,tuple([array._ptr]))
    return _ret


  @functools.native_method
  def get_typed_builtin(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(46,tuple([]))
    return _ret


  @functools.native_method
  def get_typed_class_name(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(47,tuple([]))
    return str(_ret)


  @functools.native_method
  def get_typed_script(self) -> typing.Union[typing.Any]:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(48,tuple([]))
    return _ret


  @functools.native_method
  def make_read_only(self) -> None:
    r''''''




    self._ptr.call_with_return(49,tuple([]))

  @functools.native_method
  def is_read_only(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(50,tuple([]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, Array):
      _ret = False

      _ret= self._ptr.call_with_return(54, (other,))
      return _ret

    _ret= self._ptr.call_with_return(54, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, Array):
      _ret = False

      _ret= self._ptr.call_with_return(55, (other,))
      return _ret

    _ret= self._ptr.call_with_return(55, (other,))
    return _ret
  def __lt__(self, other):
    if isinstance(other, Array):
      _ret = False

      _ret= self._ptr.call_with_return(56, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __le__(self, other):
    if isinstance(other, Array):
      _ret = False

      _ret= self._ptr.call_with_return(57, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __gt__(self, other):
    if isinstance(other, Array):
      _ret = False

      _ret= self._ptr.call_with_return(58, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __ge__(self, other):
    if isinstance(other, Array):
      _ret = False

      _ret= self._ptr.call_with_return(59, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __add__(self, other):
    if isinstance(other, Array):
      _ret = Array()

      _ret._ptr = self._ptr.call_with_return(60, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPPackedByteArrayWrapper


class PackedByteArray(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = PackedByteArray.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1056, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedByteArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedByteArray), 'from_ must be PackedByteArray'

    _class = PackedByteArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1056, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = PackedByteArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1056, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1056,0, ())

  def generate_wrapper(self):
    return CPPPackedByteArrayWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = PackedByteArray.__new__(PackedByteArray)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedByteArray'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(69, ())
  def __setitem__(self,  index, value):
    self._ptr.call_with_return(76, (index, value))

  def __getitem__(self,  index):

    if index < 0:
      raise KeyError(f"Index '{index}' invalid")
    pyobject = self._ptr.call_with_return(75, (index,))
    return pyobject
  def __iter__(self):
    self._index = 0
    return self
  def __next__(self):
    if self._index >= self.size():
      raise StopIteration()
    val = self[self._index]
    self._index += 1
    return val


  @staticmethod
  def from_list(values):
    result = PackedByteArray.new0()
    for value in values:
      result.push_back(value)
    return result


  def to_list(self):
    return list(self.get_memory_view())
  def get_memory_view(self):
    return self._ptr.call_with_return(77,())
  @staticmethod
  def from_memory_view(memory_view):
    array = PackedByteArray.construct_without_init()
    array._ptr = (static_method(1056,0, (memory_view,)))
    return array


  @functools.native_method
  def get(self, index:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([index]))
    return _ret


  @functools.native_method
  def set(self, index:'int'   , value:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(1,tuple([index, value]))

  @functools.native_method
  def size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def push_back(self, value:'int'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([value]))
    return _ret


  @functools.native_method
  def append(self, value:'int'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([value]))
    return _ret


  @functools.native_method
  def append_array(self, array:'PackedByteArray'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, PackedByteArray), 'array must be PackedByteArray'







    self._ptr.call_with_return(6,tuple([array._ptr]))

  @functools.native_method
  def remove_at(self, index:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(7,tuple([index]))

  @functools.native_method
  def insert(self, at_index:'int'   , value:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(at_index, (int, float)), 'at_index must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([at_index, value]))
    return _ret


  @functools.native_method
  def fill(self, value:'int'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    self._ptr.call_with_return(9,tuple([value]))

  @functools.native_method
  def resize(self, new_size:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(new_size, (int, float)), 'new_size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([new_size]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(11,tuple([]))

  @functools.native_method
  def has(self, value:'int'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([value]))
    return _ret


  @functools.native_method
  def reverse(self) -> None:
    r''''''




    self._ptr.call_with_return(13,tuple([]))

  @functools.native_method
  def slice(self, begin:'int'   , end:'int' =2147483647  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'








    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([begin, end]))
    return _ret


  @functools.native_method
  def sort(self) -> None:
    r''''''




    self._ptr.call_with_return(15,tuple([]))

  @functools.native_method
  def bsearch(self, value:'int'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(before, bool), 'before must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(16,tuple([value, before]))
    return _ret


  @functools.native_method
  def duplicate(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(17,tuple([]))
    return _ret


  @functools.native_method
  def find(self, value:'int'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(18,tuple([value, from_]))
    return _ret


  @functools.native_method
  def rfind(self, value:'int'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([value, from_]))
    return _ret


  @functools.native_method
  def count(self, value:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([value]))
    return _ret


  @functools.native_method
  def erase(self, value:'int'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([value]))
    return _ret


  @functools.native_method
  def get_string_from_ascii(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_string_from_utf8(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(23,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_string_from_utf16(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(24,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_string_from_utf32(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(25,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_string_from_wchar(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(26,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_string_from_multibyte_char(self, encoding:'str' =""  ) -> typing.Union[str]:
    r''''''
    if encoding is None:
      encoding = String.new0()






    assert(isinstance(encoding, (str, String)))
    py_string_encoding = encoding if isinstance(encoding, StringName) else c_utils.py_string_to_string(encoding)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(27,tuple([py_string_encoding._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def hex_encode(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(28,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def compress(self, compression_mode:'int' =0  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(compression_mode, (int, float)), 'compression_mode must be int or float'







    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(29,tuple([compression_mode]))
    return _ret


  @functools.native_method
  def decompress(self, buffer_size:'int'   , compression_mode:'int' =0  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(buffer_size, (int, float)), 'buffer_size must be int or float'
    assert isinstance(compression_mode, (int, float)), 'compression_mode must be int or float'








    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(30,tuple([buffer_size, compression_mode]))
    return _ret


  @functools.native_method
  def decompress_dynamic(self, max_output_size:'int'   , compression_mode:'int' =0  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(max_output_size, (int, float)), 'max_output_size must be int or float'
    assert isinstance(compression_mode, (int, float)), 'compression_mode must be int or float'








    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(31,tuple([max_output_size, compression_mode]))
    return _ret


  @functools.native_method
  def decode_u8(self, byte_offset:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(32,tuple([byte_offset]))
    return _ret


  @functools.native_method
  def decode_s8(self, byte_offset:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(33,tuple([byte_offset]))
    return _ret


  @functools.native_method
  def decode_u16(self, byte_offset:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(34,tuple([byte_offset]))
    return _ret


  @functools.native_method
  def decode_s16(self, byte_offset:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(35,tuple([byte_offset]))
    return _ret


  @functools.native_method
  def decode_u32(self, byte_offset:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(36,tuple([byte_offset]))
    return _ret


  @functools.native_method
  def decode_s32(self, byte_offset:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(37,tuple([byte_offset]))
    return _ret


  @functools.native_method
  def decode_u64(self, byte_offset:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(38,tuple([byte_offset]))
    return _ret


  @functools.native_method
  def decode_s64(self, byte_offset:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(39,tuple([byte_offset]))
    return _ret


  @functools.native_method
  def decode_half(self, byte_offset:'int'   ) -> typing.Union[float]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(40,tuple([byte_offset]))
    return _ret


  @functools.native_method
  def decode_float(self, byte_offset:'int'   ) -> typing.Union[float]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(41,tuple([byte_offset]))
    return _ret


  @functools.native_method
  def decode_double(self, byte_offset:'int'   ) -> typing.Union[float]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(42,tuple([byte_offset]))
    return _ret


  @functools.native_method
  def has_encoded_var(self, byte_offset:'int'   , allow_objects:'bool' =False  ) -> typing.Union[bool]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    assert isinstance(allow_objects, bool), 'allow_objects must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(43,tuple([byte_offset, allow_objects]))
    return _ret


  @functools.native_method
  def decode_var(self, byte_offset:'int'   , allow_objects:'bool' =False  ) -> typing.Union[typing.Any]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    assert isinstance(allow_objects, bool), 'allow_objects must be bool'








    _ret = None
    _ret = self._ptr.call_with_return(44,tuple([byte_offset, allow_objects]))
    return _ret


  @functools.native_method
  def decode_var_size(self, byte_offset:'int'   , allow_objects:'bool' =False  ) -> typing.Union[int]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    assert isinstance(allow_objects, bool), 'allow_objects must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(45,tuple([byte_offset, allow_objects]))
    return _ret


  @functools.native_method
  def to_int32_array(self) -> typing.Union['PackedInt32Array']:
    r''''''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(46,tuple([]))
    return _ret


  @functools.native_method
  def to_int64_array(self) -> typing.Union['PackedInt64Array']:
    r''''''




    _ret = PackedInt64Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(47,tuple([]))
    return _ret


  @functools.native_method
  def to_float32_array(self) -> typing.Union['PackedFloat32Array']:
    r''''''




    _ret = PackedFloat32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(48,tuple([]))
    return _ret


  @functools.native_method
  def to_float64_array(self) -> typing.Union['PackedFloat64Array']:
    r''''''




    _ret = PackedFloat64Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(49,tuple([]))
    return _ret


  @functools.native_method
  def to_vector2_array(self) -> typing.Union['PackedVector2Array']:
    r''''''




    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(50,tuple([]))
    return _ret


  @functools.native_method
  def to_vector3_array(self) -> typing.Union['PackedVector3Array']:
    r''''''




    _ret = PackedVector3Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(51,tuple([]))
    return _ret


  @functools.native_method
  def to_vector4_array(self) -> typing.Union['PackedVector4Array']:
    r''''''




    _ret = PackedVector4Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(52,tuple([]))
    return _ret


  @functools.native_method
  def to_color_array(self) -> typing.Union['PackedColorArray']:
    r''''''




    _ret = PackedColorArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([]))
    return _ret


  @functools.native_method
  def bswap16(self, offset:'int' =0  , count:'int' =-1  ) -> None:
    r''''''

    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert isinstance(count, (int, float)), 'count must be int or float'








    self._ptr.call_with_return(54,tuple([offset, count]))

  @functools.native_method
  def bswap32(self, offset:'int' =0  , count:'int' =-1  ) -> None:
    r''''''

    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert isinstance(count, (int, float)), 'count must be int or float'








    self._ptr.call_with_return(55,tuple([offset, count]))

  @functools.native_method
  def bswap64(self, offset:'int' =0  , count:'int' =-1  ) -> None:
    r''''''

    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert isinstance(count, (int, float)), 'count must be int or float'








    self._ptr.call_with_return(56,tuple([offset, count]))

  @functools.native_method
  def encode_u8(self, byte_offset:'int'   , value:'int'   ) -> None:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(57,tuple([byte_offset, value]))

  @functools.native_method
  def encode_s8(self, byte_offset:'int'   , value:'int'   ) -> None:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(58,tuple([byte_offset, value]))

  @functools.native_method
  def encode_u16(self, byte_offset:'int'   , value:'int'   ) -> None:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(59,tuple([byte_offset, value]))

  @functools.native_method
  def encode_s16(self, byte_offset:'int'   , value:'int'   ) -> None:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(60,tuple([byte_offset, value]))

  @functools.native_method
  def encode_u32(self, byte_offset:'int'   , value:'int'   ) -> None:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(61,tuple([byte_offset, value]))

  @functools.native_method
  def encode_s32(self, byte_offset:'int'   , value:'int'   ) -> None:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(62,tuple([byte_offset, value]))

  @functools.native_method
  def encode_u64(self, byte_offset:'int'   , value:'int'   ) -> None:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(63,tuple([byte_offset, value]))

  @functools.native_method
  def encode_s64(self, byte_offset:'int'   , value:'int'   ) -> None:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(64,tuple([byte_offset, value]))

  @functools.native_method
  def encode_half(self, byte_offset:'int'   , value:'float'   ) -> None:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(65,tuple([byte_offset, value]))

  @functools.native_method
  def encode_float(self, byte_offset:'int'   , value:'float'   ) -> None:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(66,tuple([byte_offset, value]))

  @functools.native_method
  def encode_double(self, byte_offset:'int'   , value:'float'   ) -> None:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(67,tuple([byte_offset, value]))

  @functools.native_method
  def encode_var(self, byte_offset:'int'   , value:'object'   , allow_objects:'bool' =False  ) -> typing.Union[int]:
    r''''''

    assert isinstance(byte_offset, (int, float)), 'byte_offset must be int or float'
    
    assert isinstance(allow_objects, bool), 'allow_objects must be bool'

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    _ret = 0
    _ret = self._ptr.call_with_return(68,tuple([byte_offset, value, allow_objects]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, PackedByteArray):
      _ret = False

      _ret= self._ptr.call_with_return(72, (other,))
      return _ret

    _ret= self._ptr.call_with_return(72, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, PackedByteArray):
      _ret = False

      _ret= self._ptr.call_with_return(73, (other,))
      return _ret

    _ret= self._ptr.call_with_return(73, (other,))
    return _ret
  def __add__(self, other):
    if isinstance(other, PackedByteArray):
      _ret = PackedByteArray()

      _ret._ptr = self._ptr.call_with_return(74, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPPackedInt32ArrayWrapper


class PackedInt32Array(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = PackedInt32Array.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1057, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedInt32Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedInt32Array), 'from_ must be PackedInt32Array'

    _class = PackedInt32Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1057, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = PackedInt32Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1057, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1057,0, ())

  def generate_wrapper(self):
    return CPPPackedInt32ArrayWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = PackedInt32Array.__new__(PackedInt32Array)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedInt32Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())
  def __setitem__(self,  index, value):
    self._ptr.call_with_return(30, (index, value))

  def __getitem__(self,  index):

    if index < 0:
      raise KeyError(f"Index '{index}' invalid")
    pyobject = self._ptr.call_with_return(29, (index,))
    return pyobject
  def __iter__(self):
    self._index = 0
    return self
  def __next__(self):
    if self._index >= self.size():
      raise StopIteration()
    val = self[self._index]
    self._index += 1
    return val


  @staticmethod
  def from_list(values):
    result = PackedInt32Array.new0()
    for value in values:
      result.push_back(value)
    return result


  def to_list(self):
    return list(self.get_memory_view())
  def get_memory_view(self):
    return self._ptr.call_with_return(31,())
  @staticmethod
  def from_memory_view(memory_view):
    array = PackedInt32Array.construct_without_init()
    array._ptr = (static_method(1057,0, (memory_view,)))
    return array


  @functools.native_method
  def get(self, index:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([index]))
    return _ret


  @functools.native_method
  def set(self, index:'int'   , value:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(1,tuple([index, value]))

  @functools.native_method
  def size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def push_back(self, value:'int'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([value]))
    return _ret


  @functools.native_method
  def append(self, value:'int'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([value]))
    return _ret


  @functools.native_method
  def append_array(self, array:'PackedInt32Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, PackedInt32Array), 'array must be PackedInt32Array'







    self._ptr.call_with_return(6,tuple([array._ptr]))

  @functools.native_method
  def remove_at(self, index:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(7,tuple([index]))

  @functools.native_method
  def insert(self, at_index:'int'   , value:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(at_index, (int, float)), 'at_index must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([at_index, value]))
    return _ret


  @functools.native_method
  def fill(self, value:'int'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    self._ptr.call_with_return(9,tuple([value]))

  @functools.native_method
  def resize(self, new_size:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(new_size, (int, float)), 'new_size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([new_size]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(11,tuple([]))

  @functools.native_method
  def has(self, value:'int'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([value]))
    return _ret


  @functools.native_method
  def reverse(self) -> None:
    r''''''




    self._ptr.call_with_return(13,tuple([]))

  @functools.native_method
  def slice(self, begin:'int'   , end:'int' =2147483647  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'








    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([begin, end]))
    return _ret


  @functools.native_method
  def to_byte_array(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([]))
    return _ret


  @functools.native_method
  def sort(self) -> None:
    r''''''




    self._ptr.call_with_return(16,tuple([]))

  @functools.native_method
  def bsearch(self, value:'int'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(before, bool), 'before must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(17,tuple([value, before]))
    return _ret


  @functools.native_method
  def duplicate(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18,tuple([]))
    return _ret


  @functools.native_method
  def find(self, value:'int'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([value, from_]))
    return _ret


  @functools.native_method
  def rfind(self, value:'int'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([value, from_]))
    return _ret


  @functools.native_method
  def count(self, value:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([value]))
    return _ret


  @functools.native_method
  def erase(self, value:'int'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([value]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, PackedInt32Array):
      _ret = False

      _ret= self._ptr.call_with_return(26, (other,))
      return _ret

    _ret= self._ptr.call_with_return(26, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, PackedInt32Array):
      _ret = False

      _ret= self._ptr.call_with_return(27, (other,))
      return _ret

    _ret= self._ptr.call_with_return(27, (other,))
    return _ret
  def __add__(self, other):
    if isinstance(other, PackedInt32Array):
      _ret = PackedInt32Array()

      _ret._ptr = self._ptr.call_with_return(28, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPPackedInt64ArrayWrapper


class PackedInt64Array(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = PackedInt64Array.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1058, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedInt64Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedInt64Array), 'from_ must be PackedInt64Array'

    _class = PackedInt64Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1058, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = PackedInt64Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1058, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1058,0, ())

  def generate_wrapper(self):
    return CPPPackedInt64ArrayWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = PackedInt64Array.__new__(PackedInt64Array)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedInt64Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())
  def __setitem__(self,  index, value):
    self._ptr.call_with_return(30, (index, value))

  def __getitem__(self,  index):

    if index < 0:
      raise KeyError(f"Index '{index}' invalid")
    pyobject = self._ptr.call_with_return(29, (index,))
    return pyobject
  def __iter__(self):
    self._index = 0
    return self
  def __next__(self):
    if self._index >= self.size():
      raise StopIteration()
    val = self[self._index]
    self._index += 1
    return val


  @staticmethod
  def from_list(values):
    result = PackedInt64Array.new0()
    for value in values:
      result.push_back(value)
    return result


  def to_list(self):
    return list(self.get_memory_view())
  def get_memory_view(self):
    return self._ptr.call_with_return(31,())
  @staticmethod
  def from_memory_view(memory_view):
    array = PackedInt64Array.construct_without_init()
    array._ptr = (static_method(1058,0, (memory_view,)))
    return array


  @functools.native_method
  def get(self, index:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([index]))
    return _ret


  @functools.native_method
  def set(self, index:'int'   , value:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(1,tuple([index, value]))

  @functools.native_method
  def size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def push_back(self, value:'int'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([value]))
    return _ret


  @functools.native_method
  def append(self, value:'int'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([value]))
    return _ret


  @functools.native_method
  def append_array(self, array:'PackedInt64Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, PackedInt64Array), 'array must be PackedInt64Array'







    self._ptr.call_with_return(6,tuple([array._ptr]))

  @functools.native_method
  def remove_at(self, index:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(7,tuple([index]))

  @functools.native_method
  def insert(self, at_index:'int'   , value:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(at_index, (int, float)), 'at_index must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([at_index, value]))
    return _ret


  @functools.native_method
  def fill(self, value:'int'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    self._ptr.call_with_return(9,tuple([value]))

  @functools.native_method
  def resize(self, new_size:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(new_size, (int, float)), 'new_size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([new_size]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(11,tuple([]))

  @functools.native_method
  def has(self, value:'int'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([value]))
    return _ret


  @functools.native_method
  def reverse(self) -> None:
    r''''''




    self._ptr.call_with_return(13,tuple([]))

  @functools.native_method
  def slice(self, begin:'int'   , end:'int' =2147483647  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'








    _ret = PackedInt64Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([begin, end]))
    return _ret


  @functools.native_method
  def to_byte_array(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([]))
    return _ret


  @functools.native_method
  def sort(self) -> None:
    r''''''




    self._ptr.call_with_return(16,tuple([]))

  @functools.native_method
  def bsearch(self, value:'int'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(before, bool), 'before must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(17,tuple([value, before]))
    return _ret


  @functools.native_method
  def duplicate(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = PackedInt64Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18,tuple([]))
    return _ret


  @functools.native_method
  def find(self, value:'int'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([value, from_]))
    return _ret


  @functools.native_method
  def rfind(self, value:'int'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([value, from_]))
    return _ret


  @functools.native_method
  def count(self, value:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([value]))
    return _ret


  @functools.native_method
  def erase(self, value:'int'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([value]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, PackedInt64Array):
      _ret = False

      _ret= self._ptr.call_with_return(26, (other,))
      return _ret

    _ret= self._ptr.call_with_return(26, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, PackedInt64Array):
      _ret = False

      _ret= self._ptr.call_with_return(27, (other,))
      return _ret

    _ret= self._ptr.call_with_return(27, (other,))
    return _ret
  def __add__(self, other):
    if isinstance(other, PackedInt64Array):
      _ret = PackedInt64Array()

      _ret._ptr = self._ptr.call_with_return(28, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPPackedFloat32ArrayWrapper


class PackedFloat32Array(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = PackedFloat32Array.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1059, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedFloat32Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedFloat32Array), 'from_ must be PackedFloat32Array'

    _class = PackedFloat32Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1059, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = PackedFloat32Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1059, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1059,0, ())

  def generate_wrapper(self):
    return CPPPackedFloat32ArrayWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = PackedFloat32Array.__new__(PackedFloat32Array)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedFloat32Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())
  def __setitem__(self,  index, value):
    self._ptr.call_with_return(30, (index, value))

  def __getitem__(self,  index):

    if index < 0:
      raise KeyError(f"Index '{index}' invalid")
    pyobject = self._ptr.call_with_return(29, (index,))
    return pyobject
  def __iter__(self):
    self._index = 0
    return self
  def __next__(self):
    if self._index >= self.size():
      raise StopIteration()
    val = self[self._index]
    self._index += 1
    return val


  @staticmethod
  def from_list(values):
    result = PackedFloat32Array.new0()
    for value in values:
      result.push_back(value)
    return result


  def to_list(self):
    return list(self.get_memory_view())
  def get_memory_view(self):
    return self._ptr.call_with_return(31,())
  @staticmethod
  def from_memory_view(memory_view):
    array = PackedFloat32Array.construct_without_init()
    array._ptr = (static_method(1059,0, (memory_view,)))
    return array


  @functools.native_method
  def get(self, index:'int'   ) -> typing.Union[float]:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([index]))
    return _ret


  @functools.native_method
  def set(self, index:'int'   , value:'float'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(1,tuple([index, value]))

  @functools.native_method
  def size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def push_back(self, value:'float'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([value]))
    return _ret


  @functools.native_method
  def append(self, value:'float'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([value]))
    return _ret


  @functools.native_method
  def append_array(self, array:'PackedFloat32Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, PackedFloat32Array), 'array must be PackedFloat32Array'







    self._ptr.call_with_return(6,tuple([array._ptr]))

  @functools.native_method
  def remove_at(self, index:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(7,tuple([index]))

  @functools.native_method
  def insert(self, at_index:'int'   , value:'float'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(at_index, (int, float)), 'at_index must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([at_index, value]))
    return _ret


  @functools.native_method
  def fill(self, value:'float'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    self._ptr.call_with_return(9,tuple([value]))

  @functools.native_method
  def resize(self, new_size:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(new_size, (int, float)), 'new_size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([new_size]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(11,tuple([]))

  @functools.native_method
  def has(self, value:'float'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([value]))
    return _ret


  @functools.native_method
  def reverse(self) -> None:
    r''''''




    self._ptr.call_with_return(13,tuple([]))

  @functools.native_method
  def slice(self, begin:'int'   , end:'int' =2147483647  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'








    _ret = PackedFloat32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([begin, end]))
    return _ret


  @functools.native_method
  def to_byte_array(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([]))
    return _ret


  @functools.native_method
  def sort(self) -> None:
    r''''''




    self._ptr.call_with_return(16,tuple([]))

  @functools.native_method
  def bsearch(self, value:'float'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(before, bool), 'before must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(17,tuple([value, before]))
    return _ret


  @functools.native_method
  def duplicate(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = PackedFloat32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18,tuple([]))
    return _ret


  @functools.native_method
  def find(self, value:'float'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([value, from_]))
    return _ret


  @functools.native_method
  def rfind(self, value:'float'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([value, from_]))
    return _ret


  @functools.native_method
  def count(self, value:'float'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([value]))
    return _ret


  @functools.native_method
  def erase(self, value:'float'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([value]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, PackedFloat32Array):
      _ret = False

      _ret= self._ptr.call_with_return(26, (other,))
      return _ret

    _ret= self._ptr.call_with_return(26, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, PackedFloat32Array):
      _ret = False

      _ret= self._ptr.call_with_return(27, (other,))
      return _ret

    _ret= self._ptr.call_with_return(27, (other,))
    return _ret
  def __add__(self, other):
    if isinstance(other, PackedFloat32Array):
      _ret = PackedFloat32Array()

      _ret._ptr = self._ptr.call_with_return(28, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPPackedFloat64ArrayWrapper


class PackedFloat64Array(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = PackedFloat64Array.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1060, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedFloat64Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedFloat64Array), 'from_ must be PackedFloat64Array'

    _class = PackedFloat64Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1060, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = PackedFloat64Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1060, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1060,0, ())

  def generate_wrapper(self):
    return CPPPackedFloat64ArrayWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = PackedFloat64Array.__new__(PackedFloat64Array)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedFloat64Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())
  def __setitem__(self,  index, value):
    self._ptr.call_with_return(30, (index, value))

  def __getitem__(self,  index):

    if index < 0:
      raise KeyError(f"Index '{index}' invalid")
    pyobject = self._ptr.call_with_return(29, (index,))
    return pyobject
  def __iter__(self):
    self._index = 0
    return self
  def __next__(self):
    if self._index >= self.size():
      raise StopIteration()
    val = self[self._index]
    self._index += 1
    return val


  @staticmethod
  def from_list(values):
    result = PackedFloat64Array.new0()
    for value in values:
      result.push_back(value)
    return result


  def to_list(self):
    return list(self.get_memory_view())
  def get_memory_view(self):
    return self._ptr.call_with_return(31,())
  @staticmethod
  def from_memory_view(memory_view):
    array = PackedFloat64Array.construct_without_init()
    array._ptr = (static_method(1060,0, (memory_view,)))
    return array


  @functools.native_method
  def get(self, index:'int'   ) -> typing.Union[float]:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([index]))
    return _ret


  @functools.native_method
  def set(self, index:'int'   , value:'float'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(1,tuple([index, value]))

  @functools.native_method
  def size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def push_back(self, value:'float'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([value]))
    return _ret


  @functools.native_method
  def append(self, value:'float'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([value]))
    return _ret


  @functools.native_method
  def append_array(self, array:'PackedFloat64Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, PackedFloat64Array), 'array must be PackedFloat64Array'







    self._ptr.call_with_return(6,tuple([array._ptr]))

  @functools.native_method
  def remove_at(self, index:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(7,tuple([index]))

  @functools.native_method
  def insert(self, at_index:'int'   , value:'float'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(at_index, (int, float)), 'at_index must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([at_index, value]))
    return _ret


  @functools.native_method
  def fill(self, value:'float'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    self._ptr.call_with_return(9,tuple([value]))

  @functools.native_method
  def resize(self, new_size:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(new_size, (int, float)), 'new_size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([new_size]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(11,tuple([]))

  @functools.native_method
  def has(self, value:'float'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([value]))
    return _ret


  @functools.native_method
  def reverse(self) -> None:
    r''''''




    self._ptr.call_with_return(13,tuple([]))

  @functools.native_method
  def slice(self, begin:'int'   , end:'int' =2147483647  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'








    _ret = PackedFloat64Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([begin, end]))
    return _ret


  @functools.native_method
  def to_byte_array(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([]))
    return _ret


  @functools.native_method
  def sort(self) -> None:
    r''''''




    self._ptr.call_with_return(16,tuple([]))

  @functools.native_method
  def bsearch(self, value:'float'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(before, bool), 'before must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(17,tuple([value, before]))
    return _ret


  @functools.native_method
  def duplicate(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = PackedFloat64Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18,tuple([]))
    return _ret


  @functools.native_method
  def find(self, value:'float'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([value, from_]))
    return _ret


  @functools.native_method
  def rfind(self, value:'float'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([value, from_]))
    return _ret


  @functools.native_method
  def count(self, value:'float'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([value]))
    return _ret


  @functools.native_method
  def erase(self, value:'float'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([value]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, PackedFloat64Array):
      _ret = False

      _ret= self._ptr.call_with_return(26, (other,))
      return _ret

    _ret= self._ptr.call_with_return(26, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, PackedFloat64Array):
      _ret = False

      _ret= self._ptr.call_with_return(27, (other,))
      return _ret

    _ret= self._ptr.call_with_return(27, (other,))
    return _ret
  def __add__(self, other):
    if isinstance(other, PackedFloat64Array):
      _ret = PackedFloat64Array()

      _ret._ptr = self._ptr.call_with_return(28, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPPackedStringArrayWrapper


class PackedStringArray(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = PackedStringArray.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1061, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedStringArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedStringArray), 'from_ must be PackedStringArray'

    _class = PackedStringArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1061, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = PackedStringArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1061, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1061,0, ())

  def generate_wrapper(self):
    return CPPPackedStringArrayWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = PackedStringArray.__new__(PackedStringArray)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedStringArray'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())
  def __setitem__(self,  index, value):
    self._ptr.call_with_return(30, (index, value))

  def __getitem__(self,  index):

    if index < 0:
      raise KeyError(f"Index '{index}' invalid")
    pyobject = self._ptr.call_with_return(29, (index,))
    return pyobject
  def __iter__(self):
    self._index = 0
    return self
  def __next__(self):
    if self._index >= self.size():
      raise StopIteration()
    val = self[self._index]
    self._index += 1
    return val


  @staticmethod
  def from_list(values):
    result = PackedStringArray.new0()
    for value in values:
      result.push_back(value)
    return result

  def to_list(self):
    return [value for value in self]


  @functools.native_method
  def get(self, index:'int'   ) -> typing.Union[str]:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(0,tuple([index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set(self, index:'int'   , value:'str'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not value is None)
    assert isinstance(value, (str, String)), 'value must be str or String'






    assert(isinstance(value, (str, String)))
    py_string_value = value if isinstance(value, StringName) else c_utils.py_string_to_string(value)

    self._ptr.call_with_return(1,tuple([index, py_string_value._ptr]))

  @functools.native_method
  def size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def push_back(self, value:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, (str, String)), 'value must be str or String'





    assert(isinstance(value, (str, String)))
    py_string_value = value if isinstance(value, StringName) else c_utils.py_string_to_string(value)

    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([py_string_value._ptr]))
    return _ret


  @functools.native_method
  def append(self, value:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, (str, String)), 'value must be str or String'





    assert(isinstance(value, (str, String)))
    py_string_value = value if isinstance(value, StringName) else c_utils.py_string_to_string(value)

    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([py_string_value._ptr]))
    return _ret


  @functools.native_method
  def append_array(self, array:'PackedStringArray'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, PackedStringArray), 'array must be PackedStringArray'







    self._ptr.call_with_return(6,tuple([array._ptr]))

  @functools.native_method
  def remove_at(self, index:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(7,tuple([index]))

  @functools.native_method
  def insert(self, at_index:'int'   , value:'str'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(at_index, (int, float)), 'at_index must be int or float'
    assert(not value is None)
    assert isinstance(value, (str, String)), 'value must be str or String'






    assert(isinstance(value, (str, String)))
    py_string_value = value if isinstance(value, StringName) else c_utils.py_string_to_string(value)

    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([at_index, py_string_value._ptr]))
    return _ret


  @functools.native_method
  def fill(self, value:'str'   ) -> None:
    r''''''

    assert(not value is None)
    assert isinstance(value, (str, String)), 'value must be str or String'





    assert(isinstance(value, (str, String)))
    py_string_value = value if isinstance(value, StringName) else c_utils.py_string_to_string(value)

    self._ptr.call_with_return(9,tuple([py_string_value._ptr]))

  @functools.native_method
  def resize(self, new_size:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(new_size, (int, float)), 'new_size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([new_size]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(11,tuple([]))

  @functools.native_method
  def has(self, value:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, (str, String)), 'value must be str or String'





    assert(isinstance(value, (str, String)))
    py_string_value = value if isinstance(value, StringName) else c_utils.py_string_to_string(value)

    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([py_string_value._ptr]))
    return _ret


  @functools.native_method
  def reverse(self) -> None:
    r''''''




    self._ptr.call_with_return(13,tuple([]))

  @functools.native_method
  def slice(self, begin:'int'   , end:'int' =2147483647  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'








    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([begin, end]))
    return _ret


  @functools.native_method
  def to_byte_array(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([]))
    return _ret


  @functools.native_method
  def sort(self) -> None:
    r''''''




    self._ptr.call_with_return(16,tuple([]))

  @functools.native_method
  def bsearch(self, value:'str'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, (str, String)), 'value must be str or String'
    assert isinstance(before, bool), 'before must be bool'





    assert(isinstance(value, (str, String)))
    py_string_value = value if isinstance(value, StringName) else c_utils.py_string_to_string(value)


    _ret = 0
    _ret = self._ptr.call_with_return(17,tuple([py_string_value._ptr, before]))
    return _ret


  @functools.native_method
  def duplicate(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18,tuple([]))
    return _ret


  @functools.native_method
  def find(self, value:'str'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, (str, String)), 'value must be str or String'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'





    assert(isinstance(value, (str, String)))
    py_string_value = value if isinstance(value, StringName) else c_utils.py_string_to_string(value)


    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([py_string_value._ptr, from_]))
    return _ret


  @functools.native_method
  def rfind(self, value:'str'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, (str, String)), 'value must be str or String'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'





    assert(isinstance(value, (str, String)))
    py_string_value = value if isinstance(value, StringName) else c_utils.py_string_to_string(value)


    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([py_string_value._ptr, from_]))
    return _ret


  @functools.native_method
  def count(self, value:'str'   ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, (str, String)), 'value must be str or String'





    assert(isinstance(value, (str, String)))
    py_string_value = value if isinstance(value, StringName) else c_utils.py_string_to_string(value)

    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([py_string_value._ptr]))
    return _ret


  @functools.native_method
  def erase(self, value:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, (str, String)), 'value must be str or String'





    assert(isinstance(value, (str, String)))
    py_string_value = value if isinstance(value, StringName) else c_utils.py_string_to_string(value)

    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([py_string_value._ptr]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, PackedStringArray):
      _ret = False

      _ret= self._ptr.call_with_return(26, (other,))
      return _ret

    _ret= self._ptr.call_with_return(26, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, PackedStringArray):
      _ret = False

      _ret= self._ptr.call_with_return(27, (other,))
      return _ret

    _ret= self._ptr.call_with_return(27, (other,))
    return _ret
  def __add__(self, other):
    if isinstance(other, PackedStringArray):
      _ret = PackedStringArray()

      _ret._ptr = self._ptr.call_with_return(28, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPPackedVector2ArrayWrapper


class PackedVector2Array(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = PackedVector2Array.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1062, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedVector2Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector2Array), 'from_ must be PackedVector2Array'

    _class = PackedVector2Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1062, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = PackedVector2Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1062, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1062,0, ())

  def generate_wrapper(self):
    return CPPPackedVector2ArrayWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = PackedVector2Array.__new__(PackedVector2Array)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedVector2Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())
  def __setitem__(self,  index, value):
    self._ptr.call_with_return(31, (index, value))

  def __getitem__(self,  index):

    if index < 0:
      raise KeyError(f"Index '{index}' invalid")
    pyobject = self._ptr.call_with_return(30, (index,))
    return pyobject
  def __iter__(self):
    self._index = 0
    return self
  def __next__(self):
    if self._index >= self.size():
      raise StopIteration()
    val = self[self._index]
    self._index += 1
    return val


  @staticmethod
  def from_list(values):
    result = PackedVector2Array.new0()
    for value in values:
      result.push_back(value)
    return result

  def to_list(self):
    return [value for value in self]


  @functools.native_method
  def get(self, index:'int'   ) -> typing.Union['Vector2']:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(0,tuple([index]))
    return _ret


  @functools.native_method
  def set(self, index:'int'   , value:'Vector2'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not value is None)
    assert isinstance(value, Vector2), 'value must be Vector2'








    self._ptr.call_with_return(1,tuple([index, value._ptr]))

  @functools.native_method
  def size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def push_back(self, value:'Vector2'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector2), 'value must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def append(self, value:'Vector2'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector2), 'value must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def append_array(self, array:'PackedVector2Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, PackedVector2Array), 'array must be PackedVector2Array'







    self._ptr.call_with_return(6,tuple([array._ptr]))

  @functools.native_method
  def remove_at(self, index:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(7,tuple([index]))

  @functools.native_method
  def insert(self, at_index:'int'   , value:'Vector2'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(at_index, (int, float)), 'at_index must be int or float'
    assert(not value is None)
    assert isinstance(value, Vector2), 'value must be Vector2'








    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([at_index, value._ptr]))
    return _ret


  @functools.native_method
  def fill(self, value:'Vector2'   ) -> None:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector2), 'value must be Vector2'







    self._ptr.call_with_return(9,tuple([value._ptr]))

  @functools.native_method
  def resize(self, new_size:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(new_size, (int, float)), 'new_size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([new_size]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(11,tuple([]))

  @functools.native_method
  def has(self, value:'Vector2'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector2), 'value must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def reverse(self) -> None:
    r''''''




    self._ptr.call_with_return(13,tuple([]))

  @functools.native_method
  def slice(self, begin:'int'   , end:'int' =2147483647  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'








    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([begin, end]))
    return _ret


  @functools.native_method
  def to_byte_array(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([]))
    return _ret


  @functools.native_method
  def sort(self) -> None:
    r''''''




    self._ptr.call_with_return(16,tuple([]))

  @functools.native_method
  def bsearch(self, value:'Vector2'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector2), 'value must be Vector2'
    assert isinstance(before, bool), 'before must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(17,tuple([value._ptr, before]))
    return _ret


  @functools.native_method
  def duplicate(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18,tuple([]))
    return _ret


  @functools.native_method
  def find(self, value:'Vector2'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector2), 'value must be Vector2'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([value._ptr, from_]))
    return _ret


  @functools.native_method
  def rfind(self, value:'Vector2'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector2), 'value must be Vector2'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([value._ptr, from_]))
    return _ret


  @functools.native_method
  def count(self, value:'Vector2'   ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector2), 'value must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def erase(self, value:'Vector2'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector2), 'value must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([value._ptr]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, PackedVector2Array):
      _ret = False

      _ret= self._ptr.call_with_return(27, (other,))
      return _ret

    _ret= self._ptr.call_with_return(27, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, PackedVector2Array):
      _ret = False

      _ret= self._ptr.call_with_return(28, (other,))
      return _ret

    _ret= self._ptr.call_with_return(28, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, Transform2D):
      _ret = PackedVector2Array()

      _ret._ptr = self._ptr.call_with_return(26, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __add__(self, other):
    if isinstance(other, PackedVector2Array):
      _ret = PackedVector2Array()

      _ret._ptr = self._ptr.call_with_return(29, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPPackedVector3ArrayWrapper


class PackedVector3Array(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = PackedVector3Array.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1063, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedVector3Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector3Array), 'from_ must be PackedVector3Array'

    _class = PackedVector3Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1063, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = PackedVector3Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1063, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1063,0, ())

  def generate_wrapper(self):
    return CPPPackedVector3ArrayWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = PackedVector3Array.__new__(PackedVector3Array)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedVector3Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())
  def __setitem__(self,  index, value):
    self._ptr.call_with_return(31, (index, value))

  def __getitem__(self,  index):

    if index < 0:
      raise KeyError(f"Index '{index}' invalid")
    pyobject = self._ptr.call_with_return(30, (index,))
    return pyobject
  def __iter__(self):
    self._index = 0
    return self
  def __next__(self):
    if self._index >= self.size():
      raise StopIteration()
    val = self[self._index]
    self._index += 1
    return val


  @staticmethod
  def from_list(values):
    result = PackedVector3Array.new0()
    for value in values:
      result.push_back(value)
    return result

  def to_list(self):
    return [value for value in self]


  @functools.native_method
  def get(self, index:'int'   ) -> typing.Union['Vector3']:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(0,tuple([index]))
    return _ret


  @functools.native_method
  def set(self, index:'int'   , value:'Vector3'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not value is None)
    assert isinstance(value, Vector3), 'value must be Vector3'








    self._ptr.call_with_return(1,tuple([index, value._ptr]))

  @functools.native_method
  def size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def push_back(self, value:'Vector3'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector3), 'value must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def append(self, value:'Vector3'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector3), 'value must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def append_array(self, array:'PackedVector3Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, PackedVector3Array), 'array must be PackedVector3Array'







    self._ptr.call_with_return(6,tuple([array._ptr]))

  @functools.native_method
  def remove_at(self, index:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(7,tuple([index]))

  @functools.native_method
  def insert(self, at_index:'int'   , value:'Vector3'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(at_index, (int, float)), 'at_index must be int or float'
    assert(not value is None)
    assert isinstance(value, Vector3), 'value must be Vector3'








    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([at_index, value._ptr]))
    return _ret


  @functools.native_method
  def fill(self, value:'Vector3'   ) -> None:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector3), 'value must be Vector3'







    self._ptr.call_with_return(9,tuple([value._ptr]))

  @functools.native_method
  def resize(self, new_size:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(new_size, (int, float)), 'new_size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([new_size]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(11,tuple([]))

  @functools.native_method
  def has(self, value:'Vector3'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector3), 'value must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def reverse(self) -> None:
    r''''''




    self._ptr.call_with_return(13,tuple([]))

  @functools.native_method
  def slice(self, begin:'int'   , end:'int' =2147483647  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'








    _ret = PackedVector3Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([begin, end]))
    return _ret


  @functools.native_method
  def to_byte_array(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([]))
    return _ret


  @functools.native_method
  def sort(self) -> None:
    r''''''




    self._ptr.call_with_return(16,tuple([]))

  @functools.native_method
  def bsearch(self, value:'Vector3'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector3), 'value must be Vector3'
    assert isinstance(before, bool), 'before must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(17,tuple([value._ptr, before]))
    return _ret


  @functools.native_method
  def duplicate(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = PackedVector3Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18,tuple([]))
    return _ret


  @functools.native_method
  def find(self, value:'Vector3'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector3), 'value must be Vector3'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([value._ptr, from_]))
    return _ret


  @functools.native_method
  def rfind(self, value:'Vector3'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector3), 'value must be Vector3'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([value._ptr, from_]))
    return _ret


  @functools.native_method
  def count(self, value:'Vector3'   ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector3), 'value must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def erase(self, value:'Vector3'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector3), 'value must be Vector3'







    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([value._ptr]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, PackedVector3Array):
      _ret = False

      _ret= self._ptr.call_with_return(27, (other,))
      return _ret

    _ret= self._ptr.call_with_return(27, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, PackedVector3Array):
      _ret = False

      _ret= self._ptr.call_with_return(28, (other,))
      return _ret

    _ret= self._ptr.call_with_return(28, (other,))
    return _ret
  def __mul__(self, other):
    if isinstance(other, Transform3D):
      _ret = PackedVector3Array()

      _ret._ptr = self._ptr.call_with_return(26, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")

  def __add__(self, other):
    if isinstance(other, PackedVector3Array):
      _ret = PackedVector3Array()

      _ret._ptr = self._ptr.call_with_return(29, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPPackedColorArrayWrapper


class PackedColorArray(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = PackedColorArray.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1064, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedColorArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedColorArray), 'from_ must be PackedColorArray'

    _class = PackedColorArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1064, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = PackedColorArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1064, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1064,0, ())

  def generate_wrapper(self):
    return CPPPackedColorArrayWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = PackedColorArray.__new__(PackedColorArray)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedColorArray'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())
  def __setitem__(self,  index, value):
    self._ptr.call_with_return(30, (index, value))

  def __getitem__(self,  index):

    if index < 0:
      raise KeyError(f"Index '{index}' invalid")
    pyobject = self._ptr.call_with_return(29, (index,))
    return pyobject
  def __iter__(self):
    self._index = 0
    return self
  def __next__(self):
    if self._index >= self.size():
      raise StopIteration()
    val = self[self._index]
    self._index += 1
    return val


  @staticmethod
  def from_list(values):
    result = PackedColorArray.new0()
    for value in values:
      result.push_back(value)
    return result

  def to_list(self):
    return [value for value in self]


  @functools.native_method
  def get(self, index:'int'   ) -> typing.Union['Color']:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(0,tuple([index]))
    return _ret


  @functools.native_method
  def set(self, index:'int'   , value:'Color'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not value is None)
    assert isinstance(value, Color), 'value must be Color'








    self._ptr.call_with_return(1,tuple([index, value._ptr]))

  @functools.native_method
  def size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def push_back(self, value:'Color'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Color), 'value must be Color'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def append(self, value:'Color'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Color), 'value must be Color'







    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def append_array(self, array:'PackedColorArray'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, PackedColorArray), 'array must be PackedColorArray'







    self._ptr.call_with_return(6,tuple([array._ptr]))

  @functools.native_method
  def remove_at(self, index:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(7,tuple([index]))

  @functools.native_method
  def insert(self, at_index:'int'   , value:'Color'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(at_index, (int, float)), 'at_index must be int or float'
    assert(not value is None)
    assert isinstance(value, Color), 'value must be Color'








    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([at_index, value._ptr]))
    return _ret


  @functools.native_method
  def fill(self, value:'Color'   ) -> None:
    r''''''

    assert(not value is None)
    assert isinstance(value, Color), 'value must be Color'







    self._ptr.call_with_return(9,tuple([value._ptr]))

  @functools.native_method
  def resize(self, new_size:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(new_size, (int, float)), 'new_size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([new_size]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(11,tuple([]))

  @functools.native_method
  def has(self, value:'Color'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Color), 'value must be Color'







    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def reverse(self) -> None:
    r''''''




    self._ptr.call_with_return(13,tuple([]))

  @functools.native_method
  def slice(self, begin:'int'   , end:'int' =2147483647  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'








    _ret = PackedColorArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([begin, end]))
    return _ret


  @functools.native_method
  def to_byte_array(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([]))
    return _ret


  @functools.native_method
  def sort(self) -> None:
    r''''''




    self._ptr.call_with_return(16,tuple([]))

  @functools.native_method
  def bsearch(self, value:'Color'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Color), 'value must be Color'
    assert isinstance(before, bool), 'before must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(17,tuple([value._ptr, before]))
    return _ret


  @functools.native_method
  def duplicate(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = PackedColorArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18,tuple([]))
    return _ret


  @functools.native_method
  def find(self, value:'Color'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Color), 'value must be Color'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([value._ptr, from_]))
    return _ret


  @functools.native_method
  def rfind(self, value:'Color'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Color), 'value must be Color'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([value._ptr, from_]))
    return _ret


  @functools.native_method
  def count(self, value:'Color'   ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Color), 'value must be Color'







    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def erase(self, value:'Color'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Color), 'value must be Color'







    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([value._ptr]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, PackedColorArray):
      _ret = False

      _ret= self._ptr.call_with_return(26, (other,))
      return _ret

    _ret= self._ptr.call_with_return(26, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, PackedColorArray):
      _ret = False

      _ret= self._ptr.call_with_return(27, (other,))
      return _ret

    _ret= self._ptr.call_with_return(27, (other,))
    return _ret
  def __add__(self, other):
    if isinstance(other, PackedColorArray):
      _ret = PackedColorArray()

      _ret._ptr = self._ptr.call_with_return(28, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


from py4godot.wrappers.wrappers import CPPPackedVector4ArrayWrapper


class PackedVector4Array(CoreType):
  r''''''



  @staticmethod
  def new0():
    _class = PackedVector4Array.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(1065, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedVector4Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector4Array), 'from_ must be PackedVector4Array'

    _class = PackedVector4Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1065, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = PackedVector4Array.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(1065, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(1065,0, ())

  def generate_wrapper(self):
    return CPPPackedVector4ArrayWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = PackedVector4Array.__new__(PackedVector4Array)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedVector4Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())
  def __setitem__(self,  index, value):
    self._ptr.call_with_return(30, (index, value))

  def __getitem__(self,  index):

    if index < 0:
      raise KeyError(f"Index '{index}' invalid")
    pyobject = self._ptr.call_with_return(29, (index,))
    return pyobject
  def __iter__(self):
    self._index = 0
    return self
  def __next__(self):
    if self._index >= self.size():
      raise StopIteration()
    val = self[self._index]
    self._index += 1
    return val


  @staticmethod
  def from_list(values):
    result = PackedVector4Array.new0()
    for value in values:
      result.push_back(value)
    return result

  def to_list(self):
    return [value for value in self]


  @functools.native_method
  def get(self, index:'int'   ) -> typing.Union['Vector4']:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(0,tuple([index]))
    return _ret


  @functools.native_method
  def set(self, index:'int'   , value:'Vector4'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not value is None)
    assert isinstance(value, Vector4), 'value must be Vector4'








    self._ptr.call_with_return(1,tuple([index, value._ptr]))

  @functools.native_method
  def size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(2,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def push_back(self, value:'Vector4'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector4), 'value must be Vector4'







    _ret = 0
    _ret = self._ptr.call_with_return(4,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def append(self, value:'Vector4'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector4), 'value must be Vector4'







    _ret = 0
    _ret = self._ptr.call_with_return(5,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def append_array(self, array:'PackedVector4Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, PackedVector4Array), 'array must be PackedVector4Array'







    self._ptr.call_with_return(6,tuple([array._ptr]))

  @functools.native_method
  def remove_at(self, index:'int'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(7,tuple([index]))

  @functools.native_method
  def insert(self, at_index:'int'   , value:'Vector4'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(at_index, (int, float)), 'at_index must be int or float'
    assert(not value is None)
    assert isinstance(value, Vector4), 'value must be Vector4'








    _ret = 0
    _ret = self._ptr.call_with_return(8,tuple([at_index, value._ptr]))
    return _ret


  @functools.native_method
  def fill(self, value:'Vector4'   ) -> None:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector4), 'value must be Vector4'







    self._ptr.call_with_return(9,tuple([value._ptr]))

  @functools.native_method
  def resize(self, new_size:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(new_size, (int, float)), 'new_size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(10,tuple([new_size]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(11,tuple([]))

  @functools.native_method
  def has(self, value:'Vector4'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector4), 'value must be Vector4'







    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def reverse(self) -> None:
    r''''''




    self._ptr.call_with_return(13,tuple([]))

  @functools.native_method
  def slice(self, begin:'int'   , end:'int' =2147483647  ) -> typing.Union['typing.Self']:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'








    _ret = PackedVector4Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14,tuple([begin, end]))
    return _ret


  @functools.native_method
  def to_byte_array(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(15,tuple([]))
    return _ret


  @functools.native_method
  def sort(self) -> None:
    r''''''




    self._ptr.call_with_return(16,tuple([]))

  @functools.native_method
  def bsearch(self, value:'Vector4'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector4), 'value must be Vector4'
    assert isinstance(before, bool), 'before must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(17,tuple([value._ptr, before]))
    return _ret


  @functools.native_method
  def duplicate(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = PackedVector4Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18,tuple([]))
    return _ret


  @functools.native_method
  def find(self, value:'Vector4'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector4), 'value must be Vector4'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([value._ptr, from_]))
    return _ret


  @functools.native_method
  def rfind(self, value:'Vector4'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector4), 'value must be Vector4'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([value._ptr, from_]))
    return _ret


  @functools.native_method
  def count(self, value:'Vector4'   ) -> typing.Union[int]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector4), 'value must be Vector4'







    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([value._ptr]))
    return _ret


  @functools.native_method
  def erase(self, value:'Vector4'   ) -> typing.Union[bool]:
    r''''''

    assert(not value is None)
    assert isinstance(value, Vector4), 'value must be Vector4'







    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([value._ptr]))
    return _ret


  def __eq__(self, other):
    if isinstance(other, PackedVector4Array):
      _ret = False

      _ret= self._ptr.call_with_return(26, (other,))
      return _ret

    _ret= self._ptr.call_with_return(26, (other,))
    return _ret
  def __ne__(self, other):
    if isinstance(other, PackedVector4Array):
      _ret = False

      _ret= self._ptr.call_with_return(27, (other,))
      return _ret

    _ret= self._ptr.call_with_return(27, (other,))
    return _ret
  def __add__(self, other):
    if isinstance(other, PackedVector4Array):
      _ret = PackedVector4Array()

      _ret._ptr = self._ptr.call_with_return(28, (other,))
      return _ret
    raise TypeError(f"This operator does not support '{type(other)}'")


core_classes = {Vector4,Projection,PackedFloat32Array,Color,Dictionary,PackedVector3Array,Vector4i,Plane,Callable,String,PackedStringArray,Quaternion,Vector2,PackedVector2Array,PackedColorArray,Vector3i,Signal,NodePath,Transform3D,Vector2i,StringName,Basis,PackedVector4Array,AABB,Transform2D,PackedByteArray,PackedInt32Array,Vector3,Array,RID,Rect2i,PackedFloat64Array,PackedInt64Array,Rect2,}
