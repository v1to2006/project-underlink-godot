# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.TextServerAdvanced as py4godot_textserveradvanced 
  import py4godot.classes.Font as py4godot_font 
  import py4godot.classes.TextServerDummy as py4godot_textserverdummy 
  import py4godot.classes.TextServer as py4godot_textserver 
  import py4godot.classes.TextServerExtension as py4godot_textserverextension 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPTextLineWrapper


class TextLine(py4godot_refcounted.RefCounted):
  r'''
		Abstraction over `TextServer` for handling a single line of text.
	'''

  @staticmethod
  def constructor():
    class_ = TextLine.construct_without_init()
    class_._ptr = constructor(809,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TextLine.construct_without_init()
    class_._ptr = constructor(809,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTextLineWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(809,0, ())


  def generate_wrapper(self):
    return CPPTextLineWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = TextLine.__new__(TextLine)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TextLine'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(90, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TextLine.construct_without_init()
    cls._ptr = CPPTextLineWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TextLine.construct_without_init()
    cls._ptr = CPPTextLineWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def direction(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_direction()
    return _ret
  @direction.setter
  def direction(self,  value:'int'):
    self.set_direction(value)
  @property
  def orientation(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_orientation()
    return _ret
  @orientation.setter
  def orientation(self,  value:'int'):
    self.set_orientation(value)
  @property
  def preserve_invalid(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_preserve_invalid()
    return _ret
  @preserve_invalid.setter
  def preserve_invalid(self,  value:'bool'):
    self.set_preserve_invalid(value)
  @property
  def preserve_control(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_preserve_control()
    return _ret
  @preserve_control.setter
  def preserve_control(self,  value:'bool'):
    self.set_preserve_control(value)
  @property
  def width(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_width()
    return _ret
  @width.setter
  def width(self,  value:'float'):
    self.set_width(value)
  @property
  def alignment(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_horizontal_alignment()
    return _ret
  @alignment.setter
  def alignment(self,  value:'int'):
    self.set_horizontal_alignment(value)
  @property
  def flags(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_flags()
    return _ret
  @flags.setter
  def flags(self,  value:'int'):
    self.set_flags(value)
  @property
  def text_overrun_behavior(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_text_overrun_behavior()
    return _ret
  @text_overrun_behavior.setter
  def text_overrun_behavior(self,  value:'int'):
    self.set_text_overrun_behavior(value)
  @property
  def ellipsis_char(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_ellipsis_char()
    return _ret
  @ellipsis_char.setter
  def ellipsis_char(self,  value:'str'):
    self.set_ellipsis_char(value)
  @functools.native_method
  def clear(self) -> None:
    r'''
				Clears text line (removes text and inline objects).
			'''




    self._ptr.call_with_return(53,tuple([]))

  @functools.native_method
  def set_direction(self, direction:'int'  ) -> None:
    r''''''

    assert isinstance(direction, (int, float)), 'direction must be int or float'


    self.py__direction = direction






    self._ptr.call_with_return(54,tuple([direction]))

  @functools.native_method
  def get_direction(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(55,tuple([]))

    return _ret


  @functools.native_method
  def get_inferred_direction(self) -> typing.Union[int]:
    r'''
				Returns the text writing direction inferred by the BiDi algorithm.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(56,tuple([]))
    return _ret


  @functools.native_method
  def set_orientation(self, orientation:'int'  ) -> None:
    r''''''

    assert isinstance(orientation, (int, float)), 'orientation must be int or float'


    self.py__orientation = orientation






    self._ptr.call_with_return(57,tuple([orientation]))

  @functools.native_method
  def get_orientation(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(58,tuple([]))

    return _ret


  @functools.native_method
  def set_preserve_invalid(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__preserve_invalid = enabled






    self._ptr.call_with_return(59,tuple([enabled]))

  @functools.native_method
  def get_preserve_invalid(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(60,tuple([]))

    return _ret


  @functools.native_method
  def set_preserve_control(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__preserve_control = enabled






    self._ptr.call_with_return(61,tuple([enabled]))

  @functools.native_method
  def get_preserve_control(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(62,tuple([]))

    return _ret


  @functools.native_method
  def set_bidi_override(self, override:'Array'   ) -> None:
    r'''
				Overrides BiDi for the structured text.
				Override ranges should cover full source text without overlaps. BiDi algorithm will be used on each range separately.
			'''

    assert(not override is None)
    assert isinstance(override, Array), 'override must be Array'







    self._ptr.call_with_return(63,tuple([override._ptr]))

  @functools.native_method
  def add_string(self, text:'str'   , font:'py4godot_font.Font'   , font_size:'int'   , language:'str' =""  , meta:'object' =None  ) -> typing.Union[bool]:
    r'''
				Adds text span and font to draw it.
			'''
    if language is None:
      language = String.new0()


    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    

    if not (type(meta).__name__ in py4godot.variant_types.core_types or isinstance(meta, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'meta': "
                f"{type(meta).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)


    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)


    _ret = 0
    _ret = self._ptr.call_with_return(64,tuple([py_string_text._ptr, font._ptr, font_size, py_string_language._ptr, meta]))
    return _ret


  @functools.native_method
  def add_object(self, key:'object'   , size:'Vector2'   , inline_align:'int'  =5, length:'int' =1  , baseline:'float' =0.0  ) -> typing.Union[bool]:
    r'''
				Adds inline object to the text buffer, `key` must be unique. In the text, object is represented as `length` object replacement characters.
			'''


    
    assert(not size is None)
    assert isinstance(size, Vector2), 'size must be Vector2'
    assert isinstance(inline_align, (int, float)), 'inline_align must be int or float'
    assert isinstance(length, (int, float)), 'length must be int or float'
    assert isinstance(baseline, (int, float)), 'baseline must be int or float'

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )










    _ret = 0
    _ret = self._ptr.call_with_return(65,tuple([key, size._ptr, inline_align, length, baseline]))
    return _ret


  @functools.native_method
  def resize_object(self, key:'object'   , size:'Vector2'   , inline_align:'int'  =5, baseline:'float' =0.0  ) -> typing.Union[bool]:
    r'''
				Sets new size and alignment of embedded object.
			'''


    
    assert(not size is None)
    assert isinstance(size, Vector2), 'size must be Vector2'
    assert isinstance(inline_align, (int, float)), 'inline_align must be int or float'
    assert isinstance(baseline, (int, float)), 'baseline must be int or float'

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )









    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([key, size._ptr, inline_align, baseline]))
    return _ret


  @functools.native_method
  def set_width(self, width:'float'   ) -> None:
    r''''''

    assert isinstance(width, (int, float)), 'width must be int or float'


    self.py__width = width






    self._ptr.call_with_return(67,tuple([width]))

  @functools.native_method
  def get_width(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(68,tuple([]))

    return _ret


  @functools.native_method
  def set_horizontal_alignment(self, alignment:'int'  ) -> None:
    r''''''

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'


    self.py__alignment = alignment






    self._ptr.call_with_return(69,tuple([alignment]))

  @functools.native_method
  def get_horizontal_alignment(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(70,tuple([]))

    return _ret


  @functools.native_method
  def tab_align(self, tab_stops:'PackedFloat32Array'   ) -> None:
    r'''
				Aligns text to the given tab-stops.
			'''

    assert(not tab_stops is None)
    assert isinstance(tab_stops, PackedFloat32Array), 'tab_stops must be PackedFloat32Array'







    self._ptr.call_with_return(71,tuple([tab_stops._ptr]))

  @functools.native_method
  def set_flags(self, flags:'int'   ) -> None:
    r''''''

    assert isinstance(flags, (int, float)), 'flags must be int or float'


    self.py__flags = flags






    self._ptr.call_with_return(72,tuple([flags]))

  @functools.native_method
  def get_flags(self) -> typing.Union[int]:
    r''''''




    _ret
    _ret = self._ptr.call_with_return(73,tuple([]))

    return _ret


  @functools.native_method
  def set_text_overrun_behavior(self, overrun_behavior:'int'  ) -> None:
    r''''''

    assert isinstance(overrun_behavior, (int, float)), 'overrun_behavior must be int or float'


    self.py__text_overrun_behavior = overrun_behavior






    self._ptr.call_with_return(74,tuple([overrun_behavior]))

  @functools.native_method
  def get_text_overrun_behavior(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(75,tuple([]))

    return _ret


  @functools.native_method
  def set_ellipsis_char(self, char:'str'   ) -> None:
    r''''''

    assert(not char is None)
    assert isinstance(char, (str, String)), 'char must be str or String'


    self.py__ellipsis_char = char



    assert(isinstance(char, (str, String)))
    py_string_char = char if isinstance(char, StringName) else c_utils.py_string_to_string(char)

    py__string_char = utils.py_string_to_string(char)
    py__string_char.shouldBeDeleted = False


    self._ptr.call_with_return(76,tuple([py__string_char._ptr]))

  @functools.native_method
  def get_ellipsis_char(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(77,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_objects(self) -> typing.Union['Array']:
    r'''
				Returns array of inline objects.
			'''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([]))
    return _ret


  @functools.native_method
  def get_object_rect(self, key:'object'   ) -> typing.Union['Rect2']:
    r'''
				Returns bounding rectangle of the inline object.
			'''

    

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([key]))
    return _ret


  @functools.native_method
  def get_size(self) -> typing.Union['Vector2']:
    r'''
				Returns size of the bounding box of the text.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))
    return _ret


  @functools.native_method
  def get_rid(self) -> typing.Union['RID']:
    r'''
				Returns TextServer buffer RID.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([]))
    return _ret


  @functools.native_method
  def get_line_ascent(self) -> typing.Union[float]:
    r'''
				Returns the text ascent (number of pixels above the baseline for horizontal layout or to the left of baseline for vertical).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([]))
    return _ret


  @functools.native_method
  def get_line_descent(self) -> typing.Union[float]:
    r'''
				Returns the text descent (number of pixels below the baseline for horizontal layout or to the right of baseline for vertical).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(83,tuple([]))
    return _ret


  @functools.native_method
  def get_line_width(self) -> typing.Union[float]:
    r'''
				Returns width (for horizontal layout) or height (for vertical) of the text.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([]))
    return _ret


  @functools.native_method
  def get_line_underline_position(self) -> typing.Union[float]:
    r'''
				Returns pixel offset of the underline below the baseline.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([]))
    return _ret


  @functools.native_method
  def get_line_underline_thickness(self) -> typing.Union[float]:
    r'''
				Returns thickness of the underline.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def draw(self, canvas:'RID'   , pos:'Vector2'   , color:'Color' = None  , oversampling:'float' =0.0  ) -> None:
    r'''
				Draw text into a canvas item at a given position, with `color`. `pos` specifies the top left corner of the bounding box. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''
    if color is None:
      color = Color.new0()

    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'










    self._ptr.call_with_return(87,tuple([canvas._ptr, pos._ptr, color._ptr, oversampling]))

  @functools.native_method
  def draw_outline(self, canvas:'RID'   , pos:'Vector2'   , outline_size:'int' =1  , color:'Color' = None  , oversampling:'float' =0.0  ) -> None:
    r'''
				Draw text into a canvas item at a given position, with `color`. `pos` specifies the top left corner of the bounding box. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''
    if color is None:
      color = Color.new0()

    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(outline_size, (int, float)), 'outline_size must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'











    self._ptr.call_with_return(88,tuple([canvas._ptr, pos._ptr, outline_size, color._ptr, oversampling]))

  @functools.native_method
  def hit_test(self, coords:'float'   ) -> typing.Union[int]:
    r'''
				Returns caret character offset at the specified pixel offset at the baseline. This function always returns a valid position.
			'''

    assert isinstance(coords, (int, float)), 'coords must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([coords]))
    return _ret



register_cast_function('TextLine', TextLine.cast)
register_class('TextLine', TextLine)
