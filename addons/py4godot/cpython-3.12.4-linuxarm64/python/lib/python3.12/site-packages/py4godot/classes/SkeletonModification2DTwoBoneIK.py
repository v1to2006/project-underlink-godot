# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.SkeletonModification2D as py4godot_skeletonmodification2d 
from py4godot.wrappers.wrappers import CPPSkeletonModification2DTwoBoneIKWrapper


class SkeletonModification2DTwoBoneIK(py4godot_skeletonmodification2d.SkeletonModification2D):
  r'''
		This `SkeletonModification2D` uses an algorithm typically called TwoBoneIK. This algorithm works by leveraging the law of cosines and the lengths of the bones to figure out what rotation the bones currently have, and what rotation they need to make a complete triangle, where the first bone, the second bone, and the target form the three vertices of the triangle. Because the algorithm works by making a triangle, it can only operate on two bones.
		TwoBoneIK is great for arms, legs, and really any joints that can be represented by just two bones that bend to reach a target. This solver is more lightweight than `SkeletonModification2DFABRIK`, but gives similar, natural looking results.
	'''

  @staticmethod
  def constructor():
    class_ = SkeletonModification2DTwoBoneIK.construct_without_init()
    class_._ptr = constructor(756,0, ())
    return class_
  @staticmethod
  def new():
    class_ = SkeletonModification2DTwoBoneIK.construct_without_init()
    class_._ptr = constructor(756,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPSkeletonModification2DTwoBoneIKWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(756,0, ())


  def generate_wrapper(self):
    return CPPSkeletonModification2DTwoBoneIKWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = SkeletonModification2DTwoBoneIK.__new__(SkeletonModification2DTwoBoneIK)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'SkeletonModification2DTwoBoneIK'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(106, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = SkeletonModification2DTwoBoneIK.construct_without_init()
    cls._ptr = CPPSkeletonModification2DTwoBoneIKWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = SkeletonModification2DTwoBoneIK.construct_without_init()
    cls._ptr = CPPSkeletonModification2DTwoBoneIKWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def target_nodepath(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_target_node()
    return _ret
  @target_nodepath.setter
  def target_nodepath(self,  value:'object'):
    self.set_target_node(value)
  @property
  def target_minimum_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_target_minimum_distance()
    return _ret
  @target_minimum_distance.setter
  def target_minimum_distance(self,  value:'float'):
    self.set_target_minimum_distance(value)
  @property
  def target_maximum_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_target_maximum_distance()
    return _ret
  @target_maximum_distance.setter
  def target_maximum_distance(self,  value:'float'):
    self.set_target_maximum_distance(value)
  @property
  def flip_bend_direction(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flip_bend_direction()
    return _ret
  @flip_bend_direction.setter
  def flip_bend_direction(self,  value:'bool'):
    self.set_flip_bend_direction(value)
  @functools.native_method
  def set_target_node(self, target_nodepath:'object'   ) -> None:
    r''''''

    assert(not target_nodepath is None)
    assert isinstance(target_nodepath, (str, NodePath)), 'target_nodepath must be str or NodePath'


    self.py__target_nodepath = target_nodepath



    assert(isinstance(target_nodepath, (str, NodePath)))
    py_nodepath_target_nodepath = target_nodepath if isinstance(target_nodepath,NodePath) else NodePath.new2(target_nodepath)


    self._ptr.call_with_return(90,tuple([py_nodepath_target_nodepath._ptr]))

  @functools.native_method
  def get_target_node(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([]))

    return _ret


  @functools.native_method
  def set_target_minimum_distance(self, minimum_distance:'float'   ) -> None:
    r''''''

    assert isinstance(minimum_distance, (int, float)), 'minimum_distance must be int or float'


    self.py__target_minimum_distance = minimum_distance






    self._ptr.call_with_return(92,tuple([minimum_distance]))

  @functools.native_method
  def get_target_minimum_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([]))

    return _ret


  @functools.native_method
  def set_target_maximum_distance(self, maximum_distance:'float'   ) -> None:
    r''''''

    assert isinstance(maximum_distance, (int, float)), 'maximum_distance must be int or float'


    self.py__target_maximum_distance = maximum_distance






    self._ptr.call_with_return(94,tuple([maximum_distance]))

  @functools.native_method
  def get_target_maximum_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(95,tuple([]))

    return _ret


  @functools.native_method
  def set_flip_bend_direction(self, flip_direction:'bool'   ) -> None:
    r''''''

    assert isinstance(flip_direction, bool), 'flip_direction must be bool'


    self.py__flip_bend_direction = flip_direction






    self._ptr.call_with_return(96,tuple([flip_direction]))

  @functools.native_method
  def get_flip_bend_direction(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([]))

    return _ret


  @functools.native_method
  def set_joint_one_bone2d_node(self, bone2d_node:'object'   ) -> None:
    r'''
				Sets the `Bone2D` node that is being used as the first bone in the TwoBoneIK modification.
			'''

    assert(not bone2d_node is None)
    assert isinstance(bone2d_node, (str, NodePath)), 'bone2d_node must be str or NodePath'





    assert(isinstance(bone2d_node, (str, NodePath)))
    py_nodepath_bone2d_node = bone2d_node if isinstance(bone2d_node,NodePath) else NodePath.new2(bone2d_node)

    self._ptr.call_with_return(98,tuple([py_nodepath_bone2d_node._ptr]))

  @functools.native_method
  def get_joint_one_bone2d_node(self) -> typing.Union['NodePath']:
    r'''
				Returns the `Bone2D` node that is being used as the first bone in the TwoBoneIK modification.
			'''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(99,tuple([]))
    return _ret


  @functools.native_method
  def set_joint_one_bone_idx(self, bone_idx:'int'   ) -> None:
    r'''
				Sets the index of the `Bone2D` node that is being used as the first bone in the TwoBoneIK modification.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    self._ptr.call_with_return(100,tuple([bone_idx]))

  @functools.native_method
  def get_joint_one_bone_idx(self) -> typing.Union[int]:
    r'''
				Returns the index of the `Bone2D` node that is being used as the first bone in the TwoBoneIK modification.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(101,tuple([]))
    return _ret


  @functools.native_method
  def set_joint_two_bone2d_node(self, bone2d_node:'object'   ) -> None:
    r'''
				Sets the `Bone2D` node that is being used as the second bone in the TwoBoneIK modification.
			'''

    assert(not bone2d_node is None)
    assert isinstance(bone2d_node, (str, NodePath)), 'bone2d_node must be str or NodePath'





    assert(isinstance(bone2d_node, (str, NodePath)))
    py_nodepath_bone2d_node = bone2d_node if isinstance(bone2d_node,NodePath) else NodePath.new2(bone2d_node)

    self._ptr.call_with_return(102,tuple([py_nodepath_bone2d_node._ptr]))

  @functools.native_method
  def get_joint_two_bone2d_node(self) -> typing.Union['NodePath']:
    r'''
				Returns the `Bone2D` node that is being used as the second bone in the TwoBoneIK modification.
			'''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(103,tuple([]))
    return _ret


  @functools.native_method
  def set_joint_two_bone_idx(self, bone_idx:'int'   ) -> None:
    r'''
				Sets the index of the `Bone2D` node that is being used as the second bone in the TwoBoneIK modification.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    self._ptr.call_with_return(104,tuple([bone_idx]))

  @functools.native_method
  def get_joint_two_bone_idx(self) -> typing.Union[int]:
    r'''
				Returns the index of the `Bone2D` node that is being used as the second bone in the TwoBoneIK modification.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(105,tuple([]))
    return _ret



register_cast_function('SkeletonModification2DTwoBoneIK', SkeletonModification2DTwoBoneIK.cast)
register_class('SkeletonModification2DTwoBoneIK', SkeletonModification2DTwoBoneIK)
