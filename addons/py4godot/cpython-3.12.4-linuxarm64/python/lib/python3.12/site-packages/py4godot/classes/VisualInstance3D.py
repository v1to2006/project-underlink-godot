# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Node3D as py4godot_node3d 
from py4godot.wrappers.wrappers import CPPVisualInstance3DWrapper


class VisualInstance3D(py4godot_node3d.Node3D):
  r'''
		The `VisualInstance3D` is used to connect a resource to a visual representation. All visual 3D nodes inherit from the `VisualInstance3D`. In general, you should not access the `VisualInstance3D` properties directly as they are accessed and managed by the nodes that inherit from `VisualInstance3D`. `VisualInstance3D` is the node representation of the `RenderingServer` instance.
	'''

  @staticmethod
  def constructor():
    class_ = VisualInstance3D.construct_without_init()
    class_._ptr = constructor(878,0, ())
    return class_
  @staticmethod
  def new():
    class_ = VisualInstance3D.construct_without_init()
    class_._ptr = constructor(878,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPVisualInstance3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(878,0, ())


  def generate_wrapper(self):
    return CPPVisualInstance3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = VisualInstance3D.__new__(VisualInstance3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'VisualInstance3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = VisualInstance3D.construct_without_init()
    cls._ptr = CPPVisualInstance3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = VisualInstance3D.construct_without_init()
    cls._ptr = CPPVisualInstance3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def layers(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_layer_mask()
    return _ret
  @layers.setter
  def layers(self,  value:'int'):
    self.set_layer_mask(value)
  @property
  def sorting_offset(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_sorting_offset()
    return _ret
  @sorting_offset.setter
  def sorting_offset(self,  value:'float'):
    self.set_sorting_offset(value)
  @property
  def sorting_use_aabb_center(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_sorting_use_aabb_center()
    return _ret
  @sorting_use_aabb_center.setter
  def sorting_use_aabb_center(self,  value:'bool'):
    self.set_sorting_use_aabb_center(value)
  @functools.native_method
  def _get_aabb(self) -> typing.Union['AABB']:
    r'''
'''




    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(251,tuple([]))
    return _ret


  @functools.native_method
  def set_base(self, base:'RID'   ) -> None:
    r'''
				Sets the resource that is instantiated by this `VisualInstance3D`, which changes how the engine handles the `VisualInstance3D` under the hood. Equivalent to `RenderingServer.instance_set_base`.
			'''

    assert(not base is None)
    assert isinstance(base, RID), 'base must be RID'







    self._ptr.call_with_return(252,tuple([base._ptr]))

  @functools.native_method
  def get_base(self) -> typing.Union['RID']:
    r'''
				Returns the RID of the resource associated with this `VisualInstance3D`. For example, if the Node is a `MeshInstance3D`, this will return the RID of the associated `Mesh`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(253,tuple([]))
    return _ret


  @functools.native_method
  def get_instance(self) -> typing.Union['RID']:
    r'''
				Returns the RID of this instance. This RID is the same as the RID returned by `RenderingServer.instance_create`. This RID is needed if you want to call `RenderingServer` functions directly on this `VisualInstance3D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(254,tuple([]))
    return _ret


  @functools.native_method
  def set_layer_mask(self, mask:'int'   ) -> None:
    r''''''

    assert isinstance(mask, (int, float)), 'mask must be int or float'


    self.py__layers = mask






    self._ptr.call_with_return(255,tuple([mask]))

  @functools.native_method
  def get_layer_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(256,tuple([]))

    return _ret


  @functools.native_method
  def set_layer_mask_value(self, layer_number:'int'   , value:'bool'   ) -> None:
    r'''
				Based on `value`, enables or disables the specified layer in the `layers`, given a `layer_number` between 1 and 20.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'








    self._ptr.call_with_return(257,tuple([layer_number, value]))

  @functools.native_method
  def get_layer_mask_value(self, layer_number:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether or not the specified layer of the `layers` is enabled, given a `layer_number` between 1 and 20.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(258,tuple([layer_number]))
    return _ret


  @functools.native_method
  def set_sorting_offset(self, offset:'float'   ) -> None:
    r''''''

    assert isinstance(offset, (int, float)), 'offset must be int or float'


    self.py__sorting_offset = offset






    self._ptr.call_with_return(259,tuple([offset]))

  @functools.native_method
  def get_sorting_offset(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(260,tuple([]))

    return _ret


  @functools.native_method
  def set_sorting_use_aabb_center(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__sorting_use_aabb_center = enabled






    self._ptr.call_with_return(261,tuple([enabled]))

  @functools.native_method
  def is_sorting_use_aabb_center(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(262,tuple([]))

    return _ret


  @functools.native_method
  def get_aabb(self) -> typing.Union['AABB']:
    r'''
				Returns the `AABB` (also known as the bounding box) for this `VisualInstance3D`.
			'''




    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(263,tuple([]))
    return _ret



register_cast_function('VisualInstance3D', VisualInstance3D.cast)
register_class('VisualInstance3D', VisualInstance3D)
