# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.AudioStreamMicrophone as py4godot_audiostreammicrophone 
  import py4godot.classes.AudioStreamPolyphonic as py4godot_audiostreampolyphonic 
  import py4godot.classes.AudioStreamOggVorbis as py4godot_audiostreamoggvorbis 
  import py4godot.classes.AudioStreamInteractive as py4godot_audiostreaminteractive 
  import py4godot.classes.AudioStreamSynchronized as py4godot_audiostreamsynchronized 
  import py4godot.classes.AudioStreamMP3 as py4godot_audiostreammp3 
  import py4godot.classes.AudioStreamWAV as py4godot_audiostreamwav 
  import py4godot.classes.AudioStreamGenerator as py4godot_audiostreamgenerator 
  import py4godot.classes.AudioStreamPlaylist as py4godot_audiostreamplaylist 
import py4godot.classes.AudioStream as py4godot_audiostream 
from py4godot.wrappers.wrappers import CPPAudioStreamRandomizerWrapper

class PlaybackMode:
  PLAYBACK_RANDOM_NO_REPEATS = 0
  PLAYBACK_RANDOM = 1
  PLAYBACK_SEQUENTIAL = 2


class AudioStreamRandomizer(py4godot_audiostream.AudioStream):
  r'''
		Picks a random AudioStream from the pool, depending on the playback mode, and applies random pitch shifting and volume shifting during playback.
	'''

  @staticmethod
  def constructor():
    class_ = AudioStreamRandomizer.construct_without_init()
    class_._ptr = constructor(159,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AudioStreamRandomizer.construct_without_init()
    class_._ptr = constructor(159,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAudioStreamRandomizerWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(159,0, ())


  def generate_wrapper(self):
    return CPPAudioStreamRandomizerWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = AudioStreamRandomizer.__new__(AudioStreamRandomizer)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AudioStreamRandomizer'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(108, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AudioStreamRandomizer.construct_without_init()
    cls._ptr = CPPAudioStreamRandomizerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AudioStreamRandomizer.construct_without_init()
    cls._ptr = CPPAudioStreamRandomizerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def playback_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_playback_mode()
    return _ret
  @playback_mode.setter
  def playback_mode(self,  value:'int'):
    self.set_playback_mode(value)
  @property
  def random_pitch(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_random_pitch()
    return _ret
  @random_pitch.setter
  def random_pitch(self,  value:'float'):
    self.set_random_pitch(value)
  @property
  def random_volume_offset_db(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_random_volume_offset_db()
    return _ret
  @random_volume_offset_db.setter
  def random_volume_offset_db(self,  value:'float'):
    self.set_random_volume_offset_db(value)
  @property
  def streams_count(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_streams_count()
    return _ret
  @streams_count.setter
  def streams_count(self,  value:'int'):
    self.set_streams_count(value)
  @functools.native_method
  def add_stream(self, index:'int'   , stream:'py4godot_audiostream.AudioStream'   , weight:'float' =1.0  ) -> None:
    r'''
				Insert a stream at the specified index. If the index is less than zero, the insertion occurs at the end of the underlying pool.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not stream is None)
    assert isinstance(stream, get_class('AudioStream')), 'stream must be AudioStream'
    assert isinstance(weight, (int, float)), 'weight must be int or float'









    self._ptr.call_with_return(93,tuple([index, stream._ptr, weight]))

  @functools.native_method
  def move_stream(self, index_from:'int'   , index_to:'int'   ) -> None:
    r'''
				Move a stream from one index to another.
			'''

    assert isinstance(index_from, (int, float)), 'index_from must be int or float'
    assert isinstance(index_to, (int, float)), 'index_to must be int or float'








    self._ptr.call_with_return(94,tuple([index_from, index_to]))

  @functools.native_method
  def remove_stream(self, index:'int'   ) -> None:
    r'''
				Remove the stream at the specified index.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(95,tuple([index]))

  @functools.native_method
  def set_stream(self, index:'int'   , stream:'py4godot_audiostream.AudioStream'   ) -> None:
    r'''
				Set the AudioStream at the specified index.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not stream is None)
    assert isinstance(stream, get_class('AudioStream')), 'stream must be AudioStream'








    self._ptr.call_with_return(96,tuple([index, stream._ptr]))

  @functools.native_method
  def get_stream(self, index:'int'   ) -> typing.Any:
    r'''
				Returns the stream at the specified index.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioStream
    _ret._ptr = self._ptr.call_with_return(97,tuple([index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_stream_probability_weight(self, index:'int'   , weight:'float'   ) -> None:
    r'''
				Set the probability weight of the stream at the specified index. The higher this value, the more likely that the randomizer will choose this stream during random playback modes.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    self._ptr.call_with_return(98,tuple([index, weight]))

  @functools.native_method
  def get_stream_probability_weight(self, index:'int'   ) -> typing.Union[float]:
    r'''
				Returns the probability weight associated with the stream at the given index.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([index]))
    return _ret


  @functools.native_method
  def set_streams_count(self, count:'int'   ) -> None:
    r''''''

    assert isinstance(count, (int, float)), 'count must be int or float'


    self.py__streams_count = count






    self._ptr.call_with_return(100,tuple([count]))

  @functools.native_method
  def get_streams_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(101,tuple([]))

    return _ret


  @functools.native_method
  def set_random_pitch(self, scale:'float'   ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'


    self.py__random_pitch = scale






    self._ptr.call_with_return(102,tuple([scale]))

  @functools.native_method
  def get_random_pitch(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([]))

    return _ret


  @functools.native_method
  def set_random_volume_offset_db(self, db_offset:'float'   ) -> None:
    r''''''

    assert isinstance(db_offset, (int, float)), 'db_offset must be int or float'


    self.py__random_volume_offset_db = db_offset






    self._ptr.call_with_return(104,tuple([db_offset]))

  @functools.native_method
  def get_random_volume_offset_db(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(105,tuple([]))

    return _ret


  @functools.native_method
  def set_playback_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__playback_mode = mode






    self._ptr.call_with_return(106,tuple([mode]))

  @functools.native_method
  def get_playback_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(107,tuple([]))

    return _ret



register_cast_function('AudioStreamRandomizer', AudioStreamRandomizer.cast)
register_class('AudioStreamRandomizer', AudioStreamRandomizer)
