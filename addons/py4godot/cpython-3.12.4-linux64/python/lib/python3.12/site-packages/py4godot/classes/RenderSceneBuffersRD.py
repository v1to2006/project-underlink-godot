# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.RenderingServer as py4godot_renderingserver 
  import py4godot.classes.RenderingDevice as py4godot_renderingdevice 
  import py4godot.classes.RDTextureFormat as py4godot_rdtextureformat 
  import py4godot.classes.RDTextureView as py4godot_rdtextureview 
import py4godot.classes.RenderSceneBuffers as py4godot_renderscenebuffers 
from py4godot.wrappers.wrappers import CPPRenderSceneBuffersRDWrapper


class RenderSceneBuffersRD(py4godot_renderscenebuffers.RenderSceneBuffers):
  r'''
		This object manages all 3D rendering buffers for the rendering device based renderers. An instance of this object is created for every viewport that has 3D rendering enabled. See also `RenderSceneBuffers`.
		All buffers are organized in **contexts**. The default context is called **render_buffers** and can contain amongst others the color buffer, depth buffer, velocity buffers, VRS density map and MSAA variants of these buffers.
		Buffers are only guaranteed to exist during rendering of the viewport.
		**Note:** This is an internal rendering server object. Do not instantiate this class from a script.
	'''

  @staticmethod
  def constructor():
    class_ = RenderSceneBuffersRD.construct_without_init()
    class_._ptr = constructor(679,0, ())
    return class_
  @staticmethod
  def new():
    class_ = RenderSceneBuffersRD.construct_without_init()
    class_._ptr = constructor(679,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPRenderSceneBuffersRDWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(679,0, ())


  def generate_wrapper(self):
    return CPPRenderSceneBuffersRDWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = RenderSceneBuffersRD.__new__(RenderSceneBuffersRD)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'RenderSceneBuffersRD'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(81, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = RenderSceneBuffersRD.construct_without_init()
    cls._ptr = CPPRenderSceneBuffersRDWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = RenderSceneBuffersRD.construct_without_init()
    cls._ptr = CPPRenderSceneBuffersRDWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def has_texture(self, context:'object'   , name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if a cached texture exists for this name.
			'''

    assert(not context is None)
    assert isinstance(context, (str, StringName)), 'context must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(54,tuple([py_stringname_context._ptr, py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def create_texture(self, context:'object'   , name:'object'   , data_format:'int'  , usage_bits:'int'   , texture_samples:'int'  , size:'Vector2i'   , layers:'int'   , mipmaps:'int'   , unique:'bool'   , discardable:'bool'   ) -> typing.Union['RID']:
    r'''
				Create a new texture with the given definition and cache this under the given name. Will return the existing texture if it already exists.
			'''

    assert(not context is None)
    assert isinstance(context, (str, StringName)), 'context must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(data_format, (int, float)), 'data_format must be int or float'
    assert isinstance(usage_bits, (int, float)), 'usage_bits must be int or float'
    assert isinstance(texture_samples, (int, float)), 'texture_samples must be int or float'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(layers, (int, float)), 'layers must be int or float'
    assert isinstance(mipmaps, (int, float)), 'mipmaps must be int or float'
    assert isinstance(unique, bool), 'unique must be bool'
    assert isinstance(discardable, bool), 'discardable must be bool'





    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)









    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(55,tuple([py_stringname_context._ptr, py_stringname_name._ptr, data_format, usage_bits, texture_samples, size._ptr, layers, mipmaps, unique, discardable]))
    return _ret


  @functools.native_method
  def create_texture_from_format(self, context:'object'   , name:'object'   , format:'py4godot_rdtextureformat.RDTextureFormat'   , view:'py4godot_rdtextureview.RDTextureView'   , unique:'bool'   ) -> typing.Union['RID']:
    r'''
				Create a new texture using the given format and view and cache this under the given name. Will return the existing texture if it already exists.
			'''

    assert(not context is None)
    assert isinstance(context, (str, StringName)), 'context must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not format is None)
    assert isinstance(format, get_class('RDTextureFormat')), 'format must be RDTextureFormat'
    assert(not view is None)
    assert isinstance(view, get_class('RDTextureView')), 'view must be RDTextureView'
    assert isinstance(unique, bool), 'unique must be bool'





    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(56,tuple([py_stringname_context._ptr, py_stringname_name._ptr, format._ptr, view._ptr, unique]))
    return _ret


  @functools.native_method
  def create_texture_view(self, context:'object'   , name:'object'   , view_name:'object'   , view:'py4godot_rdtextureview.RDTextureView'   ) -> typing.Union['RID']:
    r'''
				Create a new texture view for an existing texture and cache this under the given `view_name`. Will return the existing texture view if it already exists. Will error if the source texture doesn't exist.
			'''

    assert(not context is None)
    assert isinstance(context, (str, StringName)), 'context must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not view_name is None)
    assert isinstance(view_name, (str, StringName)), 'view_name must be str or StringName'
    assert(not view is None)
    assert isinstance(view, get_class('RDTextureView')), 'view must be RDTextureView'





    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(view_name, (str, StringName)))
    py_stringname_view_name = view_name if isinstance(view_name, StringName) else c_utils.py_string_to_string_name(view_name)


    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(57,tuple([py_stringname_context._ptr, py_stringname_name._ptr, py_stringname_view_name._ptr, view._ptr]))
    return _ret


  @functools.native_method
  def get_texture(self, context:'object'   , name:'object'   ) -> typing.Union['RID']:
    r'''
				Returns a cached texture with this name.
			'''

    assert(not context is None)
    assert isinstance(context, (str, StringName)), 'context must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([py_stringname_context._ptr, py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def get_texture_format(self, context:'object'   , name:'object'   ) -> typing.Union['py4godot_rdtextureformat.RDTextureFormat']:
    r'''
				Returns the texture format information with which a cached texture was created.
			'''

    assert(not context is None)
    assert isinstance(context, (str, StringName)), 'context must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: RDTextureFormat
    _ret._ptr = self._ptr.call_with_return(59,tuple([py_stringname_context._ptr, py_stringname_name._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_texture_slice(self, context:'object'   , name:'object'   , layer:'int'   , mipmap:'int'   , layers:'int'   , mipmaps:'int'   ) -> typing.Union['RID']:
    r'''
				Returns a specific slice (layer or mipmap) for a cached texture.
			'''

    assert(not context is None)
    assert isinstance(context, (str, StringName)), 'context must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(mipmap, (int, float)), 'mipmap must be int or float'
    assert isinstance(layers, (int, float)), 'layers must be int or float'
    assert isinstance(mipmaps, (int, float)), 'mipmaps must be int or float'





    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)





    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([py_stringname_context._ptr, py_stringname_name._ptr, layer, mipmap, layers, mipmaps]))
    return _ret


  @functools.native_method
  def get_texture_slice_view(self, context:'object'   , name:'object'   , layer:'int'   , mipmap:'int'   , layers:'int'   , mipmaps:'int'   , view:'py4godot_rdtextureview.RDTextureView'   ) -> typing.Union['RID']:
    r'''
				Returns a specific view of a slice (layer or mipmap) for a cached texture.
			'''

    assert(not context is None)
    assert isinstance(context, (str, StringName)), 'context must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(mipmap, (int, float)), 'mipmap must be int or float'
    assert isinstance(layers, (int, float)), 'layers must be int or float'
    assert isinstance(mipmaps, (int, float)), 'mipmaps must be int or float'
    assert(not view is None)
    assert isinstance(view, get_class('RDTextureView')), 'view must be RDTextureView'





    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)






    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([py_stringname_context._ptr, py_stringname_name._ptr, layer, mipmap, layers, mipmaps, view._ptr]))
    return _ret


  @functools.native_method
  def get_texture_slice_size(self, context:'object'   , name:'object'   , mipmap:'int'   ) -> typing.Union['Vector2i']:
    r'''
				Returns the texture size of a given slice of a cached texture.
			'''

    assert(not context is None)
    assert isinstance(context, (str, StringName)), 'context must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(mipmap, (int, float)), 'mipmap must be int or float'





    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([py_stringname_context._ptr, py_stringname_name._ptr, mipmap]))
    return _ret


  @functools.native_method
  def clear_context(self, context:'object'   ) -> None:
    r'''
				Frees all buffers related to this context.
			'''

    assert(not context is None)
    assert isinstance(context, (str, StringName)), 'context must be str or StringName'





    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    self._ptr.call_with_return(63,tuple([py_stringname_context._ptr]))

  @functools.native_method
  def get_color_texture(self, msaa:'bool' =False  ) -> typing.Union['RID']:
    r'''
				Returns the color texture we are rendering 3D content to. If multiview is used this will be a texture array with all views.
				If `msaa` is `true` and MSAA is enabled, this returns the MSAA variant of the buffer.
			'''

    assert isinstance(msaa, bool), 'msaa must be bool'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(64,tuple([msaa]))
    return _ret


  @functools.native_method
  def get_color_layer(self, layer:'int'   , msaa:'bool' =False  ) -> typing.Union['RID']:
    r'''
				Returns the specified layer from the color texture we are rendering 3D content to.
				If `msaa` is `true` and MSAA is enabled, this returns the MSAA variant of the buffer.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(msaa, bool), 'msaa must be bool'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(65,tuple([layer, msaa]))
    return _ret


  @functools.native_method
  def get_depth_texture(self, msaa:'bool' =False  ) -> typing.Union['RID']:
    r'''
				Returns the depth texture we are rendering 3D content to. If multiview is used this will be a texture array with all views.
				If `msaa` is `true` and MSAA is enabled, this returns the MSAA variant of the buffer.
			'''

    assert isinstance(msaa, bool), 'msaa must be bool'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(66,tuple([msaa]))
    return _ret


  @functools.native_method
  def get_depth_layer(self, layer:'int'   , msaa:'bool' =False  ) -> typing.Union['RID']:
    r'''
				Returns the specified layer from the depth texture we are rendering 3D content to.
				If `msaa` is `true` and MSAA is enabled, this returns the MSAA variant of the buffer.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(msaa, bool), 'msaa must be bool'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(67,tuple([layer, msaa]))
    return _ret


  @functools.native_method
  def get_velocity_texture(self, msaa:'bool' =False  ) -> typing.Union['RID']:
    r'''
				Returns the velocity texture we are rendering 3D content to. If multiview is used this will be a texture array with all views.
				If `msaa` is **true** and MSAA is enabled, this returns the MSAA variant of the buffer.
			'''

    assert isinstance(msaa, bool), 'msaa must be bool'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(68,tuple([msaa]))
    return _ret


  @functools.native_method
  def get_velocity_layer(self, layer:'int'   , msaa:'bool' =False  ) -> typing.Union['RID']:
    r'''
				Returns the specified layer from the velocity texture we are rendering 3D content to.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(msaa, bool), 'msaa must be bool'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(69,tuple([layer, msaa]))
    return _ret


  @functools.native_method
  def get_render_target(self) -> typing.Union['RID']:
    r'''
				Returns the render target associated with this buffers object.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(70,tuple([]))
    return _ret


  @functools.native_method
  def get_view_count(self) -> typing.Union[int]:
    r'''
				Returns the view count for the associated viewport.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(71,tuple([]))
    return _ret


  @functools.native_method
  def get_internal_size(self) -> typing.Union['Vector2i']:
    r'''
				Returns the internal size of the render buffer (size before upscaling) with which textures are created by default.
			'''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(72,tuple([]))
    return _ret


  @functools.native_method
  def get_target_size(self) -> typing.Union['Vector2i']:
    r'''
				Returns the target size of the render buffer (size after upscaling).
			'''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(73,tuple([]))
    return _ret


  @functools.native_method
  def get_scaling_3d_mode(self) -> typing.Union[int]:
    r'''
				Returns the scaling mode used for upscaling.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(74,tuple([]))
    return _ret


  @functools.native_method
  def get_fsr_sharpness(self) -> typing.Union[float]:
    r'''
				Returns the FSR sharpness value used while rendering the 3D content (if `get_scaling_3d_mode` is an FSR mode).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(75,tuple([]))
    return _ret


  @functools.native_method
  def get_msaa_3d(self) -> typing.Union[int]:
    r'''
				Returns the applied 3D MSAA mode for this viewport.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(76,tuple([]))
    return _ret


  @functools.native_method
  def get_texture_samples(self) -> typing.Union[int]:
    r'''
				Returns the number of MSAA samples used.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(77,tuple([]))
    return _ret


  @functools.native_method
  def get_screen_space_aa(self) -> typing.Union[int]:
    r'''
				Returns the screen-space antialiasing method applied.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(78,tuple([]))
    return _ret


  @functools.native_method
  def get_use_taa(self) -> typing.Union[bool]:
    r'''
				Returns `true` if TAA is enabled.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(79,tuple([]))
    return _ret


  @functools.native_method
  def get_use_debanding(self) -> typing.Union[bool]:
    r'''
				Returns `true` if debanding is enabled.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(80,tuple([]))
    return _ret



register_cast_function('RenderSceneBuffersRD', RenderSceneBuffersRD.cast)
register_class('RenderSceneBuffersRD', RenderSceneBuffersRD)
