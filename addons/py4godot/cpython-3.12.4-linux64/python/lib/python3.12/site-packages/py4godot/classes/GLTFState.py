# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.GrooveJoint2D as py4godot_groovejoint2d 
  import py4godot.classes.Marker2D as py4godot_marker2d 
  import py4godot.classes.Tree as py4godot_tree 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.WorldEnvironment as py4godot_worldenvironment 
  import py4godot.classes.MaterialTypedArray as py4godot_materialtypedarray 
  import py4godot.classes.ShapeCast2D as py4godot_shapecast2d 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.SpriteBase3D as py4godot_spritebase3d 
  import py4godot.classes.AnimationMixer as py4godot_animationmixer 
  import py4godot.classes.EditorPlugin as py4godot_editorplugin 
  import py4godot.classes.GLTFLightTypedArray as py4godot_gltflighttypedarray 
  import py4godot.classes.GPUParticles3D as py4godot_gpuparticles3d 
  import py4godot.classes.OpenXRCompositionLayer as py4godot_openxrcompositionlayer 
  import py4godot.classes.Texture2DTypedArray as py4godot_texture2dtypedarray 
  import py4godot.classes.RichTextLabel as py4godot_richtextlabel 
  import py4godot.classes.CollisionObject3D as py4godot_collisionobject3d 
  import py4godot.classes.LightmapProbe as py4godot_lightmapprobe 
  import py4godot.classes.ParallaxBackground as py4godot_parallaxbackground 
  import py4godot.classes.RemoteTransform3D as py4godot_remotetransform3d 
  import py4godot.classes.EditorFileSystem as py4godot_editorfilesystem 
  import py4godot.classes.GPUParticles2D as py4godot_gpuparticles2d 
  import py4godot.classes.MultiplayerSynchronizer as py4godot_multiplayersynchronizer 
  import py4godot.classes.MeshInstance3D as py4godot_meshinstance3d 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.Window as py4godot_window 
  import py4godot.classes.NavigationLink2D as py4godot_navigationlink2d 
  import py4godot.classes.LightOccluder2D as py4godot_lightoccluder2d 
  import py4godot.classes.GLTFSkinTypedArray as py4godot_gltfskintypedarray 
  import py4godot.classes.CSGPolygon3D as py4godot_csgpolygon3d 
  import py4godot.classes.GLTFSkeletonTypedArray as py4godot_gltfskeletontypedarray 
  import py4godot.classes.StaticBody2D as py4godot_staticbody2d 
  import py4godot.classes.FileDialog as py4godot_filedialog 
  import py4godot.classes.RayCast3D as py4godot_raycast3d 
  import py4godot.classes.AudioListener2D as py4godot_audiolistener2d 
  import py4godot.classes.GLTFTextureSamplerTypedArray as py4godot_gltftexturesamplertypedarray 
  import py4godot.classes.AnimationPlayer as py4godot_animationplayer 
  import py4godot.classes.Container as py4godot_container 
  import py4godot.classes.PinJoint3D as py4godot_pinjoint3d 
  import py4godot.classes.ConfirmationDialog as py4godot_confirmationdialog 
  import py4godot.classes.CollisionPolygon2D as py4godot_collisionpolygon2d 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.GLTFAnimationTypedArray as py4godot_gltfanimationtypedarray 
  import py4godot.classes.CSGCylinder3D as py4godot_csgcylinder3d 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.AudioStreamPlayer2D as py4godot_audiostreamplayer2d 
  import py4godot.classes.MeshInstance2D as py4godot_meshinstance2d 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.OpenXRCompositionLayerEquirect as py4godot_openxrcompositionlayerequirect 
  import py4godot.classes.CSGMesh3D as py4godot_csgmesh3d 
  import py4godot.classes.Light2D as py4godot_light2d 
  import py4godot.classes.OpenXRCompositionLayerCylinder as py4godot_openxrcompositionlayercylinder 
  import py4godot.classes.GLTFNode as py4godot_gltfnode 
  import py4godot.classes.RetargetModifier3D as py4godot_retargetmodifier3d 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.GPUParticlesAttractorSphere3D as py4godot_gpuparticlesattractorsphere3d 
  import py4godot.classes.CanvasModulate as py4godot_canvasmodulate 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.AimModifier3D as py4godot_aimmodifier3d 
  import py4godot.classes.ResourcePreloader as py4godot_resourcepreloader 
  import py4godot.classes.XRController3D as py4godot_xrcontroller3d 
  import py4godot.classes.CSGCombiner3D as py4godot_csgcombiner3d 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.PinJoint2D as py4godot_pinjoint2d 
  import py4godot.classes.ReflectionProbe as py4godot_reflectionprobe 
  import py4godot.classes.PointLight2D as py4godot_pointlight2d 
  import py4godot.classes.XRAnchor3D as py4godot_xranchor3d 
  import py4godot.classes.HingeJoint3D as py4godot_hingejoint3d 
  import py4godot.classes.SpringBoneCollisionPlane3D as py4godot_springbonecollisionplane3d 
  import py4godot.classes.AnimatableBody2D as py4godot_animatablebody2d 
  import py4godot.classes.CharacterBody2D as py4godot_characterbody2d 
  import py4godot.classes.Generic6DOFJoint3D as py4godot_generic6dofjoint3d 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.XROrigin3D as py4godot_xrorigin3d 
  import py4godot.classes.ImporterMeshInstance3D as py4godot_importermeshinstance3d 
  import py4godot.classes.AudioListener3D as py4godot_audiolistener3d 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.GPUParticlesAttractorBox3D as py4godot_gpuparticlesattractorbox3d 
  import py4godot.classes.Bone2D as py4godot_bone2d 
  import py4godot.classes.AnimatableBody3D as py4godot_animatablebody3d 
  import py4godot.classes.SkeletonIK3D as py4godot_skeletonik3d 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.Camera3D as py4godot_camera3d 
  import py4godot.classes.BoneConstraint3D as py4godot_boneconstraint3d 
  import py4godot.classes.VisibleOnScreenNotifier2D as py4godot_visibleonscreennotifier2d 
  import py4godot.classes.VoxelGI as py4godot_voxelgi 
  import py4godot.classes.GLTFMeshTypedArray as py4godot_gltfmeshtypedarray 
  import py4godot.classes.EditorResourcePreview as py4godot_editorresourcepreview 
  import py4godot.classes.Decal as py4godot_decal 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.GridMap as py4godot_gridmap 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.RayCast2D as py4godot_raycast2d 
  import py4godot.classes.OpenXRVisibilityMask as py4godot_openxrvisibilitymask 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.VisualInstance3D as py4godot_visualinstance3d 
  import py4godot.classes.ScriptCreateDialog as py4godot_scriptcreatedialog 
  import py4godot.classes.SpringBoneCollisionSphere3D as py4godot_springbonecollisionsphere3d 
  import py4godot.classes.HTTPRequest as py4godot_httprequest 
  import py4godot.classes.Area2D as py4godot_area2d 
  import py4godot.classes.InstancePlaceholder as py4godot_instanceplaceholder 
  import py4godot.classes.FogVolume as py4godot_fogvolume 
  import py4godot.classes.PathFollow3D as py4godot_pathfollow3d 
  import py4godot.classes.Timer as py4godot_timer 
  import py4godot.classes.ShaderGlobalsOverride as py4godot_shaderglobalsoverride 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.PhysicsBody3D as py4godot_physicsbody3d 
  import py4godot.classes.Control as py4godot_control 
  import py4godot.classes.StaticBody3D as py4godot_staticbody3d 
  import py4godot.classes.PathFollow2D as py4godot_pathfollow2d 
  import py4godot.classes.BackBufferCopy as py4godot_backbuffercopy 
  import py4godot.classes.AnimationTree as py4godot_animationtree 
  import py4godot.classes.PhysicsBody2D as py4godot_physicsbody2d 
  import py4godot.classes.NavigationObstacle3D as py4godot_navigationobstacle3d 
  import py4godot.classes.RigidBody2D as py4godot_rigidbody2d 
  import py4godot.classes.GPUParticlesCollisionSDF3D as py4godot_gpuparticlescollisionsdf3d 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.GLTFTextureTypedArray as py4godot_gltftexturetypedarray 
  import py4godot.classes.XRFaceModifier3D as py4godot_xrfacemodifier3d 
  import py4godot.classes.CanvasLayer as py4godot_canvaslayer 
  import py4godot.classes.Polygon2D as py4godot_polygon2d 
  import py4godot.classes.OccluderInstance3D as py4godot_occluderinstance3d 
  import py4godot.classes.CSGTorus3D as py4godot_csgtorus3d 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.EditorFileDialog as py4godot_editorfiledialog 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.GLTFBufferViewTypedArray as py4godot_gltfbufferviewtypedarray 
  import py4godot.classes.PackedByteArrayTypedArray as py4godot_packedbytearraytypedarray 
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.CharacterBody3D as py4godot_characterbody3d 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.StatusIndicator as py4godot_statusindicator 
  import py4godot.classes.CanvasGroup as py4godot_canvasgroup 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.MissingNode as py4godot_missingnode 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.BoneAttachment3D as py4godot_boneattachment3d 
  import py4godot.classes.GLTFNodeTypedArray as py4godot_gltfnodetypedarray 
  import py4godot.classes.LookAtModifier3D as py4godot_lookatmodifier3d 
  import py4godot.classes.TouchScreenButton as py4godot_touchscreenbutton 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.NavigationLink3D as py4godot_navigationlink3d 
  import py4godot.classes.GPUParticlesCollisionSphere3D as py4godot_gpuparticlescollisionsphere3d 
  import py4godot.classes.VisibleOnScreenNotifier3D as py4godot_visibleonscreennotifier3d 
  import py4godot.classes.Skeleton2D as py4godot_skeleton2d 
  import py4godot.classes.Joint3D as py4godot_joint3d 
  import py4godot.classes.Viewport as py4godot_viewport 
  import py4godot.classes.SpotLight3D as py4godot_spotlight3d 
  import py4godot.classes.SubViewport as py4godot_subviewport 
  import py4godot.classes.PopupPanel as py4godot_popuppanel 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.ModifierBoneTarget3D as py4godot_modifierbonetarget3d 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.SpringBoneCollisionCapsule3D as py4godot_springbonecollisioncapsule3d 
  import py4godot.classes.GridMapEditorPlugin as py4godot_gridmapeditorplugin 
  import py4godot.classes.ConeTwistJoint3D as py4godot_conetwistjoint3d 
  import py4godot.classes.PhysicalBoneSimulator3D as py4godot_physicalbonesimulator3d 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.NavigationRegion2D as py4godot_navigationregion2d 
  import py4godot.classes.OpenXRRenderModel as py4godot_openxrrendermodel 
  import py4godot.classes.TabBar as py4godot_tabbar 
  import py4godot.classes.CPUParticles3D as py4godot_cpuparticles3d 
  import py4godot.classes.Popup as py4godot_popup 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.VisibleOnScreenEnabler2D as py4godot_visibleonscreenenabler2d 
  import py4godot.classes.XRCamera3D as py4godot_xrcamera3d 
  import py4godot.classes.NavigationRegion3D as py4godot_navigationregion3d 
  import py4godot.classes.AcceptDialog as py4godot_acceptdialog 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.AudioStreamPlayer3D as py4godot_audiostreamplayer3d 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.Node2D as py4godot_node2d 
  import py4godot.classes.AnimatedSprite2D as py4godot_animatedsprite2d 
  import py4godot.classes.Path2D as py4godot_path2d 
  import py4godot.classes.Parallax2D as py4godot_parallax2d 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.MultiMeshInstance3D as py4godot_multimeshinstance3d 
  import py4godot.classes.ConvertTransformModifier3D as py4godot_converttransformmodifier3d 
  import py4godot.classes.GeometryInstance3D as py4godot_geometryinstance3d 
  import py4godot.classes.SpringArm3D as py4godot_springarm3d 
  import py4godot.classes.LightmapGI as py4godot_lightmapgi 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.CSGBox3D as py4godot_csgbox3d 
  import py4godot.classes.RigidBody3D as py4godot_rigidbody3d 
  import py4godot.classes.ShapeCast3D as py4godot_shapecast3d 
  import py4godot.classes.TileMapLayer as py4godot_tilemaplayer 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.CollisionObject2D as py4godot_collisionobject2d 
  import py4godot.classes.Sprite3D as py4godot_sprite3d 
  import py4godot.classes.SoftBody3D as py4godot_softbody3d 
  import py4godot.classes.PopupMenu as py4godot_popupmenu 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.NavigationAgent3D as py4godot_navigationagent3d 
  import py4godot.classes.NavigationObstacle2D as py4godot_navigationobstacle2d 
  import py4godot.classes.OpenXRCompositionLayerQuad as py4godot_openxrcompositionlayerquad 
  import py4godot.classes.GPUParticlesAttractor3D as py4godot_gpuparticlesattractor3d 
  import py4godot.classes.CopyTransformModifier3D as py4godot_copytransformmodifier3d 
  import py4godot.classes.Path3D as py4godot_path3d 
  import py4godot.classes.GLTFAccessorTypedArray as py4godot_gltfaccessortypedarray 
  import py4godot.classes.Marker3D as py4godot_marker3d 
  import py4godot.classes.TabContainer as py4godot_tabcontainer 
  import py4godot.classes.DirectionalLight2D as py4godot_directionallight2d 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.VehicleBody3D as py4godot_vehiclebody3d 
  import py4godot.classes.SliderJoint3D as py4godot_sliderjoint3d 
  import py4godot.classes.CSGShape3D as py4godot_csgshape3d 
  import py4godot.classes.CPUParticles2D as py4godot_cpuparticles2d 
  import py4godot.classes.StringTypedArray as py4godot_stringtypedarray 
  import py4godot.classes.XRBodyModifier3D as py4godot_xrbodymodifier3d 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.OmniLight3D as py4godot_omnilight3d 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.GLTFCameraTypedArray as py4godot_gltfcameratypedarray 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.RemoteTransform2D as py4godot_remotetransform2d 
  import py4godot.classes.Node as py4godot_node 
  import py4godot.classes.TileMap as py4godot_tilemap 
  import py4godot.classes.Sprite2D as py4godot_sprite2d 
  import py4godot.classes.CSGPrimitive3D as py4godot_csgprimitive3d 
  import py4godot.classes.TextEdit as py4godot_textedit 
  import py4godot.classes.SkeletonModifier3D as py4godot_skeletonmodifier3d 
  import py4godot.classes.AnimatedSprite3D as py4godot_animatedsprite3d 
  import py4godot.classes.Line2D as py4godot_line2d 
  import py4godot.classes.Skeleton3D as py4godot_skeleton3d 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.VehicleWheel3D as py4godot_vehiclewheel3d 
  import py4godot.classes.PhysicalBone3D as py4godot_physicalbone3d 
  import py4godot.classes.Node3D as py4godot_node3d 
  import py4godot.classes.GraphElement as py4godot_graphelement 
  import py4godot.classes.VisibleOnScreenEnabler3D as py4godot_visibleonscreenenabler3d 
  import py4godot.classes.CollisionShape2D as py4godot_collisionshape2d 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.SpringBoneSimulator3D as py4godot_springbonesimulator3d 
  import py4godot.classes.CanvasItem as py4godot_canvasitem 
  import py4godot.classes.CSGSphere3D as py4godot_csgsphere3d 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.CollisionShape3D as py4godot_collisionshape3d 
  import py4godot.classes.SpringBoneCollision3D as py4godot_springbonecollision3d 
  import py4godot.classes.GraphNode as py4godot_graphnode 
  import py4godot.classes.EditorCommandPalette as py4godot_editorcommandpalette 
  import py4godot.classes.OpenXRHand as py4godot_openxrhand 
  import py4godot.classes.GPUParticlesCollisionBox3D as py4godot_gpuparticlescollisionbox3d 
  import py4godot.classes.OpenXRRenderModelManager as py4godot_openxrrendermodelmanager 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.GPUParticlesAttractorVectorField3D as py4godot_gpuparticlesattractorvectorfield3d 
  import py4godot.classes.XRHandModifier3D as py4godot_xrhandmodifier3d 
  import py4godot.classes.Label3D as py4godot_label3d 
  import py4godot.classes.GPUParticlesCollision3D as py4godot_gpuparticlescollision3d 
  import py4godot.classes.DampedSpringJoint2D as py4godot_dampedspringjoint2d 
  import py4godot.classes.Light3D as py4godot_light3d 
  import py4godot.classes.CollisionPolygon3D as py4godot_collisionpolygon3d 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.PhysicalBone2D as py4godot_physicalbone2d 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.MultiplayerSpawner as py4godot_multiplayerspawner 
  import py4godot.classes.Joint2D as py4godot_joint2d 
  import py4godot.classes.NavigationAgent2D as py4godot_navigationagent2d 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.FoldableContainer as py4godot_foldablecontainer 
  import py4godot.classes.MultiMeshInstance2D as py4godot_multimeshinstance2d 
  import py4godot.classes.GPUParticlesCollisionHeightField3D as py4godot_gpuparticlescollisionheightfield3d 
  import py4godot.classes.XRNode3D as py4godot_xrnode3d 
  import py4godot.classes.ParallaxLayer as py4godot_parallaxlayer 
  import py4godot.classes.DirectionalLight3D as py4godot_directionallight3d 
  import py4godot.classes.Area3D as py4godot_area3d 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.RootMotionView as py4godot_rootmotionview 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.Camera2D as py4godot_camera2d 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.AudioStreamPlayer as py4godot_audiostreamplayer 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
import py4godot.classes.MaterialTypedArray as py4godot_materialtypedarray 
import py4godot.classes.GLTFLightTypedArray as py4godot_gltflighttypedarray 
import py4godot.classes.Texture2DTypedArray as py4godot_texture2dtypedarray 
import py4godot.classes.GLTFSkinTypedArray as py4godot_gltfskintypedarray 
import py4godot.classes.GLTFSkeletonTypedArray as py4godot_gltfskeletontypedarray 
import py4godot.classes.GLTFTextureSamplerTypedArray as py4godot_gltftexturesamplertypedarray 
import py4godot.classes.GLTFAnimationTypedArray as py4godot_gltfanimationtypedarray 
import py4godot.classes.GLTFMeshTypedArray as py4godot_gltfmeshtypedarray 
import py4godot.classes.GLTFTextureTypedArray as py4godot_gltftexturetypedarray 
import py4godot.classes.GLTFBufferViewTypedArray as py4godot_gltfbufferviewtypedarray 
import py4godot.classes.PackedByteArrayTypedArray as py4godot_packedbytearraytypedarray 
import py4godot.classes.GLTFNodeTypedArray as py4godot_gltfnodetypedarray 
import py4godot.classes.Resource as py4godot_resource 
import py4godot.classes.GLTFAccessorTypedArray as py4godot_gltfaccessortypedarray 
import py4godot.classes.StringTypedArray as py4godot_stringtypedarray 
import py4godot.classes.GLTFCameraTypedArray as py4godot_gltfcameratypedarray 
from py4godot.wrappers.wrappers import CPPGLTFStateWrapper


class GLTFState(py4godot_resource.Resource):
  r''''''
  HANDLE_BINARY_DISCARD_TEXTURES:typing.ClassVar[int]

  HANDLE_BINARY_EXTRACT_TEXTURES:typing.ClassVar[int]

  HANDLE_BINARY_EMBED_AS_BASISU:typing.ClassVar[int]

  HANDLE_BINARY_EMBED_AS_UNCOMPRESSED:typing.ClassVar[int]

  @staticmethod
  def constructor():
    class_ = GLTFState.construct_without_init()
    class_._ptr = constructor(361,0, ())
    return class_
  @staticmethod
  def new():
    class_ = GLTFState.construct_without_init()
    class_._ptr = constructor(361,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPGLTFStateWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(361,0, ())


  def generate_wrapper(self):
    return CPPGLTFStateWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = GLTFState.__new__(GLTFState)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'GLTFState'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(146, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = GLTFState.construct_without_init()
    cls._ptr = CPPGLTFStateWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = GLTFState.construct_without_init()
    cls._ptr = CPPGLTFStateWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def json(self) -> typing.Union['Dictionary']:
    r''''''
    _ret = self. get_json()
    return _ret
  @json.setter
  def json(self,  value:'Dictionary'):
    self.set_json(value)
  @property
  def major_version(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_major_version()
    return _ret
  @major_version.setter
  def major_version(self,  value:'int'):
    self.set_major_version(value)
  @property
  def minor_version(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_minor_version()
    return _ret
  @minor_version.setter
  def minor_version(self,  value:'int'):
    self.set_minor_version(value)
  @property
  def copyright(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_copyright()
    return _ret
  @copyright.setter
  def copyright(self,  value:'str'):
    self.set_copyright(value)
  @property
  def glb_data(self) -> typing.Union['PackedByteArray']:
    r''''''
    _ret = self. get_glb_data()
    return _ret
  @glb_data.setter
  def glb_data(self,  value:'PackedByteArray'):
    self.set_glb_data(value)
  @property
  def use_named_skin_binds(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_use_named_skin_binds()
    return _ret
  @use_named_skin_binds.setter
  def use_named_skin_binds(self,  value:'bool'):
    self.set_use_named_skin_binds(value)
  @property
  def nodes(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_nodes()
    return _ret
  @nodes.setter
  def nodes(self,  value:'Array'):
    self.set_nodes(value)
  @property
  def buffers(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_buffers()
    return _ret
  @buffers.setter
  def buffers(self,  value:'Array'):
    self.set_buffers(value)
  @property
  def buffer_views(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_buffer_views()
    return _ret
  @buffer_views.setter
  def buffer_views(self,  value:'Array'):
    self.set_buffer_views(value)
  @property
  def accessors(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_accessors()
    return _ret
  @accessors.setter
  def accessors(self,  value:'Array'):
    self.set_accessors(value)
  @property
  def meshes(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_meshes()
    return _ret
  @meshes.setter
  def meshes(self,  value:'Array'):
    self.set_meshes(value)
  @property
  def materials(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_materials()
    return _ret
  @materials.setter
  def materials(self,  value:'Array'):
    self.set_materials(value)
  @property
  def scene_name(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_scene_name()
    return _ret
  @scene_name.setter
  def scene_name(self,  value:'str'):
    self.set_scene_name(value)
  @property
  def base_path(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_base_path()
    return _ret
  @base_path.setter
  def base_path(self,  value:'str'):
    self.set_base_path(value)
  @property
  def filename(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_filename()
    return _ret
  @filename.setter
  def filename(self,  value:'str'):
    self.set_filename(value)
  @property
  def root_nodes(self) -> typing.Union['PackedInt32Array']:
    r''''''
    _ret = self. get_root_nodes()
    return _ret
  @root_nodes.setter
  def root_nodes(self,  value:'PackedInt32Array'):
    self.set_root_nodes(value)
  @property
  def textures(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_textures()
    return _ret
  @textures.setter
  def textures(self,  value:'Array'):
    self.set_textures(value)
  @property
  def texture_samplers(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_texture_samplers()
    return _ret
  @texture_samplers.setter
  def texture_samplers(self,  value:'Array'):
    self.set_texture_samplers(value)
  @property
  def images(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_images()
    return _ret
  @images.setter
  def images(self,  value:'Array'):
    self.set_images(value)
  @property
  def skins(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_skins()
    return _ret
  @skins.setter
  def skins(self,  value:'Array'):
    self.set_skins(value)
  @property
  def cameras(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_cameras()
    return _ret
  @cameras.setter
  def cameras(self,  value:'Array'):
    self.set_cameras(value)
  @property
  def lights(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_lights()
    return _ret
  @lights.setter
  def lights(self,  value:'Array'):
    self.set_lights(value)
  @property
  def unique_names(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_unique_names()
    return _ret
  @unique_names.setter
  def unique_names(self,  value:'Array'):
    self.set_unique_names(value)
  @property
  def unique_animation_names(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_unique_animation_names()
    return _ret
  @unique_animation_names.setter
  def unique_animation_names(self,  value:'Array'):
    self.set_unique_animation_names(value)
  @property
  def skeletons(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_skeletons()
    return _ret
  @skeletons.setter
  def skeletons(self,  value:'Array'):
    self.set_skeletons(value)
  @property
  def create_animations(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_create_animations()
    return _ret
  @create_animations.setter
  def create_animations(self,  value:'bool'):
    self.set_create_animations(value)
  @property
  def import_as_skeleton_bones(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_import_as_skeleton_bones()
    return _ret
  @import_as_skeleton_bones.setter
  def import_as_skeleton_bones(self,  value:'bool'):
    self.set_import_as_skeleton_bones(value)
  @property
  def animations(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_animations()
    return _ret
  @animations.setter
  def animations(self,  value:'Array'):
    self.set_animations(value)
  @property
  def handle_binary_image(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_handle_binary_image()
    return _ret
  @handle_binary_image.setter
  def handle_binary_image(self,  value:'int'):
    self.set_handle_binary_image(value)
  @property
  def bake_fps(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_bake_fps()
    return _ret
  @bake_fps.setter
  def bake_fps(self,  value:'float'):
    self.set_bake_fps(value)
  @functools.native_method
  def add_used_extension(self, extension_name:'str'   , required:'bool'   ) -> None:
    r''''''

    assert(not extension_name is None)
    assert isinstance(extension_name, (str, String)), 'extension_name must be str or String'
    assert isinstance(required, bool), 'required must be bool'





    assert(isinstance(extension_name, (str, String)))
    py_string_extension_name = extension_name if isinstance(extension_name, StringName) else c_utils.py_string_to_string(extension_name)


    self._ptr.call_with_return(77,tuple([py_string_extension_name._ptr, required]))

  @functools.native_method
  def append_data_to_buffers(self, data:'PackedByteArray'   , deduplication:'bool'   ) -> typing.Union[int]:
    r''''''

    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'
    assert isinstance(deduplication, bool), 'deduplication must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([data._ptr, deduplication]))
    return _ret


  @functools.native_method
  def append_gltf_node(self, gltf_node:'py4godot_gltfnode.GLTFNode'   , godot_scene_node:'py4godot_node.Node'   , parent_node_index:'int'   ) -> typing.Union[int]:
    r''''''

    assert(not gltf_node is None)
    assert isinstance(gltf_node, get_class('GLTFNode')), 'gltf_node must be GLTFNode'
    assert(not godot_scene_node is None)
    assert isinstance(godot_scene_node, get_class('Node')), 'godot_scene_node must be Node'
    assert isinstance(parent_node_index, (int, float)), 'parent_node_index must be int or float'









    _ret = 0
    _ret = self._ptr.call_with_return(79,tuple([gltf_node._ptr, godot_scene_node._ptr, parent_node_index]))
    return _ret


  @functools.native_method
  def get_json(self) -> typing.Union['Dictionary']:
    r''''''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))

    return _ret


  @functools.native_method
  def set_json(self, json:'Dictionary'   ) -> None:
    r''''''

    assert(not json is None)
    assert isinstance(json, Dictionary), 'json must be Dictionary'


    self.py__json = json






    self._ptr.call_with_return(81,tuple([json._ptr]))

  @functools.native_method
  def get_major_version(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([]))

    return _ret


  @functools.native_method
  def set_major_version(self, major_version:'int'   ) -> None:
    r''''''

    assert isinstance(major_version, (int, float)), 'major_version must be int or float'


    self.py__major_version = major_version






    self._ptr.call_with_return(83,tuple([major_version]))

  @functools.native_method
  def get_minor_version(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([]))

    return _ret


  @functools.native_method
  def set_minor_version(self, minor_version:'int'   ) -> None:
    r''''''

    assert isinstance(minor_version, (int, float)), 'minor_version must be int or float'


    self.py__minor_version = minor_version






    self._ptr.call_with_return(85,tuple([minor_version]))

  @functools.native_method
  def get_copyright(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_copyright(self, copyright:'str'   ) -> None:
    r''''''

    assert(not copyright is None)
    assert isinstance(copyright, (str, String)), 'copyright must be str or String'


    self.py__copyright = copyright



    assert(isinstance(copyright, (str, String)))
    py_string_copyright = copyright if isinstance(copyright, StringName) else c_utils.py_string_to_string(copyright)

    py__string_copyright = utils.py_string_to_string(copyright)
    py__string_copyright.shouldBeDeleted = False


    self._ptr.call_with_return(87,tuple([py__string_copyright._ptr]))

  @functools.native_method
  def get_glb_data(self) -> typing.Union['PackedByteArray']:
    r''''''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([]))

    return _ret


  @functools.native_method
  def set_glb_data(self, glb_data:'PackedByteArray'   ) -> None:
    r''''''

    assert(not glb_data is None)
    assert isinstance(glb_data, PackedByteArray), 'glb_data must be PackedByteArray'


    self.py__glb_data = glb_data






    self._ptr.call_with_return(89,tuple([glb_data._ptr]))

  @functools.native_method
  def get_use_named_skin_binds(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([]))

    return _ret


  @functools.native_method
  def set_use_named_skin_binds(self, use_named_skin_binds:'bool'   ) -> None:
    r''''''

    assert isinstance(use_named_skin_binds, bool), 'use_named_skin_binds must be bool'


    self.py__use_named_skin_binds = use_named_skin_binds






    self._ptr.call_with_return(91,tuple([use_named_skin_binds]))

  @functools.native_method
  def get_nodes(self) -> typing.Union['py4godot_gltfnodetypedarray.GLTFNodeTypedArray']:
    r''''''




    _ret = py4godot_gltfnodetypedarray.GLTFNodeTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(92,tuple([]))

    return _ret


  @functools.native_method
  def set_nodes(self, nodes:'py4godot_gltfnodetypedarray.GLTFNodeTypedArray'   ) -> None:
    r''''''

    assert isinstance(nodes, Array), 'nodes must be Array'


    self.py__nodes = nodes






    self._ptr.call_with_return(93,tuple([nodes._ptr]))

  @functools.native_method
  def get_buffers(self) -> typing.Union['py4godot_packedbytearraytypedarray.PackedByteArrayTypedArray']:
    r''''''




    _ret = py4godot_packedbytearraytypedarray.PackedByteArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(94,tuple([]))

    return _ret


  @functools.native_method
  def set_buffers(self, buffers:'py4godot_packedbytearraytypedarray.PackedByteArrayTypedArray'   ) -> None:
    r''''''

    assert isinstance(buffers, Array), 'buffers must be Array'


    self.py__buffers = buffers






    self._ptr.call_with_return(95,tuple([buffers._ptr]))

  @functools.native_method
  def get_buffer_views(self) -> typing.Union['py4godot_gltfbufferviewtypedarray.GLTFBufferViewTypedArray']:
    r''''''




    _ret = py4godot_gltfbufferviewtypedarray.GLTFBufferViewTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([]))

    return _ret


  @functools.native_method
  def set_buffer_views(self, buffer_views:'py4godot_gltfbufferviewtypedarray.GLTFBufferViewTypedArray'   ) -> None:
    r''''''

    assert isinstance(buffer_views, Array), 'buffer_views must be Array'


    self.py__buffer_views = buffer_views






    self._ptr.call_with_return(97,tuple([buffer_views._ptr]))

  @functools.native_method
  def get_accessors(self) -> typing.Union['py4godot_gltfaccessortypedarray.GLTFAccessorTypedArray']:
    r''''''




    _ret = py4godot_gltfaccessortypedarray.GLTFAccessorTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(98,tuple([]))

    return _ret


  @functools.native_method
  def set_accessors(self, accessors:'py4godot_gltfaccessortypedarray.GLTFAccessorTypedArray'   ) -> None:
    r''''''

    assert isinstance(accessors, Array), 'accessors must be Array'


    self.py__accessors = accessors






    self._ptr.call_with_return(99,tuple([accessors._ptr]))

  @functools.native_method
  def get_meshes(self) -> typing.Union['py4godot_gltfmeshtypedarray.GLTFMeshTypedArray']:
    r''''''




    _ret = py4godot_gltfmeshtypedarray.GLTFMeshTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(100,tuple([]))

    return _ret


  @functools.native_method
  def set_meshes(self, meshes:'py4godot_gltfmeshtypedarray.GLTFMeshTypedArray'   ) -> None:
    r''''''

    assert isinstance(meshes, Array), 'meshes must be Array'


    self.py__meshes = meshes






    self._ptr.call_with_return(101,tuple([meshes._ptr]))

  @functools.native_method
  def get_animation_players_count(self, idx:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([idx]))
    return _ret


  @functools.native_method
  def get_animation_player(self, idx:'int'   ) -> typing.Union['py4godot_animationplayer.AnimationPlayer']:
    r''''''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AnimationPlayer
    _ret._ptr = self._ptr.call_with_return(103,tuple([idx]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_materials(self) -> typing.Union['py4godot_materialtypedarray.MaterialTypedArray']:
    r''''''




    _ret = py4godot_materialtypedarray.MaterialTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(104,tuple([]))

    return _ret


  @functools.native_method
  def set_materials(self, materials:'py4godot_materialtypedarray.MaterialTypedArray'   ) -> None:
    r''''''

    assert isinstance(materials, Array), 'materials must be Array'


    self.py__materials = materials






    self._ptr.call_with_return(105,tuple([materials._ptr]))

  @functools.native_method
  def get_scene_name(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(106,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_scene_name(self, scene_name:'str'   ) -> None:
    r''''''

    assert(not scene_name is None)
    assert isinstance(scene_name, (str, String)), 'scene_name must be str or String'


    self.py__scene_name = scene_name



    assert(isinstance(scene_name, (str, String)))
    py_string_scene_name = scene_name if isinstance(scene_name, StringName) else c_utils.py_string_to_string(scene_name)

    py__string_scene_name = utils.py_string_to_string(scene_name)
    py__string_scene_name.shouldBeDeleted = False


    self._ptr.call_with_return(107,tuple([py__string_scene_name._ptr]))

  @functools.native_method
  def get_base_path(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(108,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_base_path(self, base_path:'str'   ) -> None:
    r''''''

    assert(not base_path is None)
    assert isinstance(base_path, (str, String)), 'base_path must be str or String'


    self.py__base_path = base_path



    assert(isinstance(base_path, (str, String)))
    py_string_base_path = base_path if isinstance(base_path, StringName) else c_utils.py_string_to_string(base_path)

    py__string_base_path = utils.py_string_to_string(base_path)
    py__string_base_path.shouldBeDeleted = False


    self._ptr.call_with_return(109,tuple([py__string_base_path._ptr]))

  @functools.native_method
  def get_filename(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(110,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_filename(self, filename:'str'   ) -> None:
    r''''''

    assert(not filename is None)
    assert isinstance(filename, (str, String)), 'filename must be str or String'


    self.py__filename = filename



    assert(isinstance(filename, (str, String)))
    py_string_filename = filename if isinstance(filename, StringName) else c_utils.py_string_to_string(filename)

    py__string_filename = utils.py_string_to_string(filename)
    py__string_filename.shouldBeDeleted = False


    self._ptr.call_with_return(111,tuple([py__string_filename._ptr]))

  @functools.native_method
  def get_root_nodes(self) -> typing.Union['PackedInt32Array']:
    r''''''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(112,tuple([]))

    return _ret


  @functools.native_method
  def set_root_nodes(self, root_nodes:'PackedInt32Array'   ) -> None:
    r''''''

    assert(not root_nodes is None)
    assert isinstance(root_nodes, PackedInt32Array), 'root_nodes must be PackedInt32Array'


    self.py__root_nodes = root_nodes






    self._ptr.call_with_return(113,tuple([root_nodes._ptr]))

  @functools.native_method
  def get_textures(self) -> typing.Union['py4godot_gltftexturetypedarray.GLTFTextureTypedArray']:
    r''''''




    _ret = py4godot_gltftexturetypedarray.GLTFTextureTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(114,tuple([]))

    return _ret


  @functools.native_method
  def set_textures(self, textures:'py4godot_gltftexturetypedarray.GLTFTextureTypedArray'   ) -> None:
    r''''''

    assert isinstance(textures, Array), 'textures must be Array'


    self.py__textures = textures






    self._ptr.call_with_return(115,tuple([textures._ptr]))

  @functools.native_method
  def get_texture_samplers(self) -> typing.Union['py4godot_gltftexturesamplertypedarray.GLTFTextureSamplerTypedArray']:
    r''''''




    _ret = py4godot_gltftexturesamplertypedarray.GLTFTextureSamplerTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(116,tuple([]))

    return _ret


  @functools.native_method
  def set_texture_samplers(self, texture_samplers:'py4godot_gltftexturesamplertypedarray.GLTFTextureSamplerTypedArray'   ) -> None:
    r''''''

    assert isinstance(texture_samplers, Array), 'texture_samplers must be Array'


    self.py__texture_samplers = texture_samplers






    self._ptr.call_with_return(117,tuple([texture_samplers._ptr]))

  @functools.native_method
  def get_images(self) -> typing.Union['py4godot_texture2dtypedarray.Texture2DTypedArray']:
    r''''''




    _ret = py4godot_texture2dtypedarray.Texture2DTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(118,tuple([]))

    return _ret


  @functools.native_method
  def set_images(self, images:'py4godot_texture2dtypedarray.Texture2DTypedArray'   ) -> None:
    r''''''

    assert isinstance(images, Array), 'images must be Array'


    self.py__images = images






    self._ptr.call_with_return(119,tuple([images._ptr]))

  @functools.native_method
  def get_skins(self) -> typing.Union['py4godot_gltfskintypedarray.GLTFSkinTypedArray']:
    r''''''




    _ret = py4godot_gltfskintypedarray.GLTFSkinTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(120,tuple([]))

    return _ret


  @functools.native_method
  def set_skins(self, skins:'py4godot_gltfskintypedarray.GLTFSkinTypedArray'   ) -> None:
    r''''''

    assert isinstance(skins, Array), 'skins must be Array'


    self.py__skins = skins






    self._ptr.call_with_return(121,tuple([skins._ptr]))

  @functools.native_method
  def get_cameras(self) -> typing.Union['py4godot_gltfcameratypedarray.GLTFCameraTypedArray']:
    r''''''




    _ret = py4godot_gltfcameratypedarray.GLTFCameraTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(122,tuple([]))

    return _ret


  @functools.native_method
  def set_cameras(self, cameras:'py4godot_gltfcameratypedarray.GLTFCameraTypedArray'   ) -> None:
    r''''''

    assert isinstance(cameras, Array), 'cameras must be Array'


    self.py__cameras = cameras






    self._ptr.call_with_return(123,tuple([cameras._ptr]))

  @functools.native_method
  def get_lights(self) -> typing.Union['py4godot_gltflighttypedarray.GLTFLightTypedArray']:
    r''''''




    _ret = py4godot_gltflighttypedarray.GLTFLightTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(124,tuple([]))

    return _ret


  @functools.native_method
  def set_lights(self, lights:'py4godot_gltflighttypedarray.GLTFLightTypedArray'   ) -> None:
    r''''''

    assert isinstance(lights, Array), 'lights must be Array'


    self.py__lights = lights






    self._ptr.call_with_return(125,tuple([lights._ptr]))

  @functools.native_method
  def get_unique_names(self) -> typing.Union['py4godot_stringtypedarray.StringTypedArray']:
    r''''''




    _ret = py4godot_stringtypedarray.StringTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(126,tuple([]))

    return _ret


  @functools.native_method
  def set_unique_names(self, unique_names:'py4godot_stringtypedarray.StringTypedArray'   ) -> None:
    r''''''

    assert isinstance(unique_names, Array), 'unique_names must be Array'


    self.py__unique_names = unique_names






    self._ptr.call_with_return(127,tuple([unique_names._ptr]))

  @functools.native_method
  def get_unique_animation_names(self) -> typing.Union['py4godot_stringtypedarray.StringTypedArray']:
    r''''''




    _ret = py4godot_stringtypedarray.StringTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(128,tuple([]))

    return _ret


  @functools.native_method
  def set_unique_animation_names(self, unique_animation_names:'py4godot_stringtypedarray.StringTypedArray'   ) -> None:
    r''''''

    assert isinstance(unique_animation_names, Array), 'unique_animation_names must be Array'


    self.py__unique_animation_names = unique_animation_names






    self._ptr.call_with_return(129,tuple([unique_animation_names._ptr]))

  @functools.native_method
  def get_skeletons(self) -> typing.Union['py4godot_gltfskeletontypedarray.GLTFSkeletonTypedArray']:
    r''''''




    _ret = py4godot_gltfskeletontypedarray.GLTFSkeletonTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(130,tuple([]))

    return _ret


  @functools.native_method
  def set_skeletons(self, skeletons:'py4godot_gltfskeletontypedarray.GLTFSkeletonTypedArray'   ) -> None:
    r''''''

    assert isinstance(skeletons, Array), 'skeletons must be Array'


    self.py__skeletons = skeletons






    self._ptr.call_with_return(131,tuple([skeletons._ptr]))

  @functools.native_method
  def get_create_animations(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(132,tuple([]))

    return _ret


  @functools.native_method
  def set_create_animations(self, create_animations:'bool'   ) -> None:
    r''''''

    assert isinstance(create_animations, bool), 'create_animations must be bool'


    self.py__create_animations = create_animations






    self._ptr.call_with_return(133,tuple([create_animations]))

  @functools.native_method
  def get_import_as_skeleton_bones(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(134,tuple([]))

    return _ret


  @functools.native_method
  def set_import_as_skeleton_bones(self, import_as_skeleton_bones:'bool'   ) -> None:
    r''''''

    assert isinstance(import_as_skeleton_bones, bool), 'import_as_skeleton_bones must be bool'


    self.py__import_as_skeleton_bones = import_as_skeleton_bones






    self._ptr.call_with_return(135,tuple([import_as_skeleton_bones]))

  @functools.native_method
  def get_animations(self) -> typing.Union['py4godot_gltfanimationtypedarray.GLTFAnimationTypedArray']:
    r''''''




    _ret = py4godot_gltfanimationtypedarray.GLTFAnimationTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(136,tuple([]))

    return _ret


  @functools.native_method
  def set_animations(self, animations:'py4godot_gltfanimationtypedarray.GLTFAnimationTypedArray'   ) -> None:
    r''''''

    assert isinstance(animations, Array), 'animations must be Array'


    self.py__animations = animations






    self._ptr.call_with_return(137,tuple([animations._ptr]))

  @functools.native_method
  def get_scene_node(self, idx:'int'   ) -> typing.Any:
    r''''''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Node
    _ret._ptr = self._ptr.call_with_return(138,tuple([idx]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_node_index(self, scene_node:'py4godot_node.Node'   ) -> typing.Union[int]:
    r''''''

    assert(not scene_node is None)
    assert isinstance(scene_node, get_class('Node')), 'scene_node must be Node'







    _ret = 0
    _ret = self._ptr.call_with_return(139,tuple([scene_node._ptr]))
    return _ret


  @functools.native_method
  def get_additional_data(self, extension_name:'object'   ) -> typing.Union[typing.Any]:
    r''''''

    assert(not extension_name is None)
    assert isinstance(extension_name, (str, StringName)), 'extension_name must be str or StringName'





    assert(isinstance(extension_name, (str, StringName)))
    py_stringname_extension_name = extension_name if isinstance(extension_name, StringName) else c_utils.py_string_to_string_name(extension_name)

    _ret = None
    _ret = self._ptr.call_with_return(140,tuple([py_stringname_extension_name._ptr]))
    return _ret


  @functools.native_method
  def set_additional_data(self, extension_name:'object'   , additional_data:'object'   ) -> None:
    r''''''

    assert(not extension_name is None)
    assert isinstance(extension_name, (str, StringName)), 'extension_name must be str or StringName'
    

    if not (type(additional_data).__name__ in py4godot.variant_types.core_types or isinstance(additional_data, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'additional_data': "
                f"{type(additional_data).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(extension_name, (str, StringName)))
    py_stringname_extension_name = extension_name if isinstance(extension_name, StringName) else c_utils.py_string_to_string_name(extension_name)


    self._ptr.call_with_return(141,tuple([py_stringname_extension_name._ptr, additional_data]))

  @functools.native_method
  def get_handle_binary_image(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(142,tuple([]))

    return _ret


  @functools.native_method
  def set_handle_binary_image(self, method:'int'   ) -> None:
    r''''''

    assert isinstance(method, (int, float)), 'method must be int or float'


    self.py__handle_binary_image = method






    self._ptr.call_with_return(143,tuple([method]))

  @functools.native_method
  def set_bake_fps(self, value:'float'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'


    self.py__bake_fps = value






    self._ptr.call_with_return(144,tuple([value]))

  @functools.native_method
  def get_bake_fps(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(145,tuple([]))

    return _ret



register_cast_function('GLTFState', GLTFState.cast)
register_class('GLTFState', GLTFState)
