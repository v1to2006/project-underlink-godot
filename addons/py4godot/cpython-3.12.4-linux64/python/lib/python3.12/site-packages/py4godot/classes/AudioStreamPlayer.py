# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.AudioStreamPolyphonic as py4godot_audiostreampolyphonic 
  import py4godot.classes.AudioServer as py4godot_audioserver 
  import py4godot.classes.AudioStreamPlaybackPolyphonic as py4godot_audiostreamplaybackpolyphonic 
  import py4godot.classes.AudioStreamPlaybackPlaylist as py4godot_audiostreamplaybackplaylist 
  import py4godot.classes.AudioStreamPlaylist as py4godot_audiostreamplaylist 
  import py4godot.classes.AudioStreamPlaybackInteractive as py4godot_audiostreamplaybackinteractive 
  import py4godot.classes.AudioStreamPlaybackResampled as py4godot_audiostreamplaybackresampled 
  import py4godot.classes.AudioStreamPlayback as py4godot_audiostreamplayback 
  import py4godot.classes.AudioStreamInteractive as py4godot_audiostreaminteractive 
  import py4godot.classes.AudioStream as py4godot_audiostream 
  import py4godot.classes.AudioStreamMicrophone as py4godot_audiostreammicrophone 
  import py4godot.classes.AudioStreamOggVorbis as py4godot_audiostreamoggvorbis 
  import py4godot.classes.AudioStreamSynchronized as py4godot_audiostreamsynchronized 
  import py4godot.classes.AudioStreamGeneratorPlayback as py4godot_audiostreamgeneratorplayback 
  import py4godot.classes.AudioStreamMP3 as py4godot_audiostreammp3 
  import py4godot.classes.AudioStreamPlaybackOggVorbis as py4godot_audiostreamplaybackoggvorbis 
  import py4godot.classes.AudioStreamWAV as py4godot_audiostreamwav 
  import py4godot.classes.AudioStreamGenerator as py4godot_audiostreamgenerator 
  import py4godot.classes.AudioStreamRandomizer as py4godot_audiostreamrandomizer 
  import py4godot.classes.AudioStreamPlaybackSynchronized as py4godot_audiostreamplaybacksynchronized 
import py4godot.classes.Node as py4godot_node 
from py4godot.wrappers.wrappers import CPPAudioStreamPlayerWrapper

class MixTarget:
  MIX_TARGET_STEREO = 0
  MIX_TARGET_SURROUND = 1
  MIX_TARGET_CENTER = 2


class AudioStreamPlayer(py4godot_node.Node):
  r'''
		The `AudioStreamPlayer` node plays an audio stream non-positionally. It is ideal for user interfaces, menus, or background music.
		To use this node, `stream` needs to be set to a valid `AudioStream` resource. Playing more than one sound at the same time is also supported, see `max_polyphony`.
		If you need to play audio at a specific position, use `AudioStreamPlayer2D` or `AudioStreamPlayer3D` instead.
	'''

  @staticmethod
  def constructor():
    class_ = AudioStreamPlayer.construct_without_init()
    class_._ptr = constructor(154,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AudioStreamPlayer.construct_without_init()
    class_._ptr = constructor(154,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAudioStreamPlayerWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(154,0, ())


  def generate_wrapper(self):
    return CPPAudioStreamPlayerWrapper()
  def init_signals(self):
    super().init_signals()
    finished_name = utils.py_string_to_string_name("finished")
    self.finished = signals.BuiltinSignal(self, finished_name)

  @staticmethod
  def construct_without_init():
    cls = AudioStreamPlayer.__new__(AudioStreamPlayer)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AudioStreamPlayer'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AudioStreamPlayer.construct_without_init()
    cls._ptr = CPPAudioStreamPlayerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AudioStreamPlayer.construct_without_init()
    cls._ptr = CPPAudioStreamPlayerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def stream(self) -> typing.Any:
    r''''''
    _ret = self. get_stream()
    return _ret
  @stream.setter
  def stream(self,  value:'py4godot_object.Object'):
    self.set_stream(value)
  @property
  def volume_db(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volume_db()
    return _ret
  @volume_db.setter
  def volume_db(self,  value:'float'):
    self.set_volume_db(value)
  @property
  def volume_linear(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volume_linear()
    return _ret
  @volume_linear.setter
  def volume_linear(self,  value:'float'):
    self.set_volume_linear(value)
  @property
  def pitch_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_pitch_scale()
    return _ret
  @pitch_scale.setter
  def pitch_scale(self,  value:'float'):
    self.set_pitch_scale(value)
  @property
  def playing(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_playing()
    return _ret
  @playing.setter
  def playing(self,  value:'bool'):
    self.set_playing(value)
  @property
  def autoplay(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_autoplay_enabled()
    return _ret
  @autoplay.setter
  def autoplay(self,  value:'bool'):
    self.set_autoplay(value)
  @property
  def stream_paused(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_stream_paused()
    return _ret
  @stream_paused.setter
  def stream_paused(self,  value:'bool'):
    self.set_stream_paused(value)
  @property
  def mix_target(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_mix_target()
    return _ret
  @mix_target.setter
  def mix_target(self,  value:'int'):
    self.set_mix_target(value)
  @property
  def max_polyphony(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_polyphony()
    return _ret
  @max_polyphony.setter
  def max_polyphony(self,  value:'int'):
    self.set_max_polyphony(value)
  @property
  def bus(self) -> typing.Union['StringName']:
    r''''''
    _ret = self. get_bus()
    return _ret
  @bus.setter
  def bus(self,  value:'object'):
    self.set_bus(value)
  @property
  def playback_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_playback_type()
    return _ret
  @playback_type.setter
  def playback_type(self,  value:'int'):
    self.set_playback_type(value)
  @functools.native_method
  def set_stream(self, stream:'py4godot_audiostream.AudioStream'   ) -> None:
    r''''''

    assert(not stream is None)
    assert isinstance(stream, get_class('AudioStream')), 'stream must be AudioStream'


    self.py__stream = stream






    self._ptr.call_with_return(180,tuple([stream._ptr]))

  @functools.native_method
  def get_stream(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioStream
    _ret._ptr = self._ptr.call_with_return(181,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_volume_db(self, volume_db:'float'   ) -> None:
    r''''''

    assert isinstance(volume_db, (int, float)), 'volume_db must be int or float'


    self.py__volume_db = volume_db






    self._ptr.call_with_return(182,tuple([volume_db]))

  @functools.native_method
  def get_volume_db(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(183,tuple([]))

    return _ret


  @functools.native_method
  def set_volume_linear(self, volume_linear:'float'   ) -> None:
    r''''''

    assert isinstance(volume_linear, (int, float)), 'volume_linear must be int or float'


    self.py__volume_linear = volume_linear






    self._ptr.call_with_return(184,tuple([volume_linear]))

  @functools.native_method
  def get_volume_linear(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(185,tuple([]))

    return _ret


  @functools.native_method
  def set_pitch_scale(self, pitch_scale:'float'   ) -> None:
    r''''''

    assert isinstance(pitch_scale, (int, float)), 'pitch_scale must be int or float'


    self.py__pitch_scale = pitch_scale






    self._ptr.call_with_return(186,tuple([pitch_scale]))

  @functools.native_method
  def get_pitch_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(187,tuple([]))

    return _ret


  @functools.native_method
  def play(self, from_position:'float' =0.0  ) -> None:
    r'''
				Plays a sound from the beginning, or the given `from_position` in seconds.
			'''

    assert isinstance(from_position, (int, float)), 'from_position must be int or float'







    self._ptr.call_with_return(188,tuple([from_position]))

  @functools.native_method
  def seek(self, to_position:'float'   ) -> None:
    r'''
				Restarts all sounds to be played from the given `to_position`, in seconds. Does nothing if no sounds are playing.
			'''

    assert isinstance(to_position, (int, float)), 'to_position must be int or float'







    self._ptr.call_with_return(189,tuple([to_position]))

  @functools.native_method
  def stop(self) -> None:
    r'''
				Stops all sounds from this node.
			'''




    self._ptr.call_with_return(190,tuple([]))

  @functools.native_method
  def is_playing(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(191,tuple([]))

    return _ret


  @functools.native_method
  def get_playback_position(self) -> typing.Union[float]:
    r'''
				Returns the position in the `AudioStream` of the latest sound, in seconds. Returns `0.0` if no sounds are playing.
				**Note:** The position is not always accurate, as the `AudioServer` does not mix audio every processed frame. To get more accurate results, add `AudioServer.get_time_since_last_mix` to the returned position.
				**Note:** This method always returns `0.0` if the `stream` is an `AudioStreamInteractive`, since it can have multiple clips playing at once.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(192,tuple([]))
    return _ret


  @functools.native_method
  def set_bus(self, bus:'object'   ) -> None:
    r''''''

    assert(not bus is None)
    assert isinstance(bus, (str, StringName)), 'bus must be str or StringName'


    self.py__bus = bus



    assert(isinstance(bus, (str, StringName)))
    py_stringname_bus = bus if isinstance(bus, StringName) else c_utils.py_string_to_string_name(bus)


    self._ptr.call_with_return(193,tuple([py_stringname_bus._ptr]))

  @functools.native_method
  def get_bus(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(194,tuple([]))

    return str(_ret)


  @functools.native_method
  def set_autoplay(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__autoplay = enable






    self._ptr.call_with_return(195,tuple([enable]))

  @functools.native_method
  def is_autoplay_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(196,tuple([]))

    return _ret


  @functools.native_method
  def set_mix_target(self, mix_target:'int'  ) -> None:
    r''''''

    assert isinstance(mix_target, (int, float)), 'mix_target must be int or float'


    self.py__mix_target = mix_target






    self._ptr.call_with_return(197,tuple([mix_target]))

  @functools.native_method
  def get_mix_target(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(198,tuple([]))

    return _ret


  @functools.native_method
  def set_playing(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__playing = enable






    self._ptr.call_with_return(199,tuple([enable]))

  @functools.native_method
  def set_stream_paused(self, pause:'bool'   ) -> None:
    r''''''

    assert isinstance(pause, bool), 'pause must be bool'


    self.py__stream_paused = pause






    self._ptr.call_with_return(200,tuple([pause]))

  @functools.native_method
  def get_stream_paused(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(201,tuple([]))

    return _ret


  @functools.native_method
  def set_max_polyphony(self, max_polyphony:'int'   ) -> None:
    r''''''

    assert isinstance(max_polyphony, (int, float)), 'max_polyphony must be int or float'


    self.py__max_polyphony = max_polyphony






    self._ptr.call_with_return(202,tuple([max_polyphony]))

  @functools.native_method
  def get_max_polyphony(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(203,tuple([]))

    return _ret


  @functools.native_method
  def has_stream_playback(self) -> typing.Union[bool]:
    r'''
				Returns `true` if any sound is active, even if `stream_paused` is set to `true`. See also `playing` and `get_stream_playback`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(204,tuple([]))
    return _ret


  @functools.native_method
  def get_stream_playback(self) -> typing.Any:
    r'''
				Returns the latest `AudioStreamPlayback` of this node, usually the most recently created by `play`. If no sounds are playing, this method fails and returns an empty playback.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioStreamPlayback
    _ret._ptr = self._ptr.call_with_return(205,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_playback_type(self, playback_type:'int'  ) -> None:
    r''''''

    assert isinstance(playback_type, (int, float)), 'playback_type must be int or float'


    self.py__playback_type = playback_type






    self._ptr.call_with_return(206,tuple([playback_type]))

  @functools.native_method
  def get_playback_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(207,tuple([]))

    return _ret



register_cast_function('AudioStreamPlayer', AudioStreamPlayer.cast)
register_class('AudioStreamPlayer', AudioStreamPlayer)
