# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPEditorExportPresetWrapper

class ExportFilter:
  EXPORT_ALL_RESOURCES = 0
  EXPORT_SELECTED_SCENES = 1
  EXPORT_SELECTED_RESOURCES = 2
  EXCLUDE_SELECTED_RESOURCES = 3
  EXPORT_CUSTOMIZED = 4
class FileExportMode:
  MODE_FILE_NOT_CUSTOMIZED = 0
  MODE_FILE_STRIP = 1
  MODE_FILE_KEEP = 2
  MODE_FILE_REMOVE = 3
class ScriptExportMode:
  MODE_SCRIPT_TEXT = 0
  MODE_SCRIPT_BINARY_TOKENS = 1
  MODE_SCRIPT_BINARY_TOKENS_COMPRESSED = 2


class EditorExportPreset(py4godot_refcounted.RefCounted):
  r'''
		Represents the configuration of an export preset, as created by the editor's export dialog. An `EditorExportPreset` instance is intended to be used a read-only configuration passed to the `EditorExportPlatform` methods when exporting the project.
	'''

  @staticmethod
  def constructor():
    class_ = EditorExportPreset.construct_without_init()
    class_._ptr = constructor(282,0, ())
    return class_
  @staticmethod
  def new():
    class_ = EditorExportPreset.construct_without_init()
    class_._ptr = constructor(282,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEditorExportPresetWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(282,0, ())


  def generate_wrapper(self):
    return CPPEditorExportPresetWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = EditorExportPreset.__new__(EditorExportPreset)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorExportPreset'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(78, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorExportPreset.construct_without_init()
    cls._ptr = CPPEditorExportPresetWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorExportPreset.construct_without_init()
    cls._ptr = CPPEditorExportPresetWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def has(self, property:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the preset has the property named `property`.
			'''

    assert(not property is None)
    assert isinstance(property, (str, StringName)), 'property must be str or StringName'





    assert(isinstance(property, (str, StringName)))
    py_stringname_property = property if isinstance(property, StringName) else c_utils.py_string_to_string_name(property)

    _ret = 0
    _ret = self._ptr.call_with_return(53,tuple([py_stringname_property._ptr]))
    return _ret


  @functools.native_method
  def get_files_to_export(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns array of files to export.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([]))
    return _ret


  @functools.native_method
  def get_customized_files(self) -> typing.Union['Dictionary']:
    r'''
				Returns a dictionary of files selected in the "Resources" tab of the export dialog. The dictionary's keys are file paths, and its values are the corresponding export modes: `"strip"`, `"keep"`, or `"remove"`. See also `get_file_export_mode`.
			'''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(55,tuple([]))
    return _ret


  @functools.native_method
  def get_customized_files_count(self) -> typing.Union[int]:
    r'''
				Returns the number of files selected in the "Resources" tab of the export dialog.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([]))
    return _ret


  @functools.native_method
  def has_export_file(self, path:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the file at the specified `path` will be exported.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def get_file_export_mode(self, path:'str'   , default:'int'  =0) -> typing.Union[int]:
    r'''
				Returns file export mode for the specified file.
			'''


    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(default, (int, float)), 'default must be int or float'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)


    _ret:int
    _ret = self._ptr.call_with_return(58,tuple([py_string_path._ptr, default]))
    return _ret


  @functools.native_method
  def get_project_setting(self, name:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the value of the setting identified by `name` using export preset feature tag overrides instead of current OS features.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = None
    _ret = self._ptr.call_with_return(59,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def get_preset_name(self) -> typing.Union[str]:
    r'''
				Returns this export preset's name.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def is_runnable(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the "Runnable" toggle is enabled in the export dialog.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(61,tuple([]))
    return _ret


  @functools.native_method
  def are_advanced_options_enabled(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the "Advanced" toggle is enabled in the export dialog.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(62,tuple([]))
    return _ret


  @functools.native_method
  def is_dedicated_server(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the dedicated server export mode is selected in the export dialog.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(63,tuple([]))
    return _ret


  @functools.native_method
  def get_export_filter(self) -> typing.Union[int]:
    r'''
				Returns export file filter mode selected in the "Resources" tab of the export dialog.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(64,tuple([]))
    return _ret


  @functools.native_method
  def get_include_filter(self) -> typing.Union[str]:
    r'''
				Returns file filters to include during export.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(65,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_exclude_filter(self) -> typing.Union[str]:
    r'''
				Returns file filters to exclude during export.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(66,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_custom_features(self) -> typing.Union[str]:
    r'''
				Returns a comma-separated list of custom features added to this preset, as a string. See `url=$DOCS_URL/tutorials/export/feature_tags.html`Feature tags`/url` in the documentation for more information.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(67,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_patches(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns the list of packs on which to base a patch export on.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(68,tuple([]))
    return _ret


  @functools.native_method
  def get_export_path(self) -> typing.Union[str]:
    r'''
				Returns export target path.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(69,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_encryption_in_filter(self) -> typing.Union[str]:
    r'''
				Returns file filters to include during PCK encryption.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(70,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_encryption_ex_filter(self) -> typing.Union[str]:
    r'''
				Returns file filters to exclude during PCK encryption.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(71,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_encrypt_pck(self) -> typing.Union[bool]:
    r'''
				Returns `true` if PCK encryption is enabled in the export dialog.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(72,tuple([]))
    return _ret


  @functools.native_method
  def get_encrypt_directory(self) -> typing.Union[bool]:
    r'''
				Returns `true` if PCK directory encryption is enabled in the export dialog.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(73,tuple([]))
    return _ret


  @functools.native_method
  def get_encryption_key(self) -> typing.Union[str]:
    r'''
				Returns PCK encryption key.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(74,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_script_export_mode(self) -> typing.Union[int]:
    r'''
				Returns the export mode used by GDScript files. `0` for "Text", `1` for "Binary tokens", and `2` for "Compressed binary tokens (smaller files)".
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(75,tuple([]))
    return _ret


  @functools.native_method
  def get_or_env(self, name:'object'   , env_var:'str'   ) -> typing.Union[typing.Any]:
    r'''
				Returns export option value or value of environment variable if it is set.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not env_var is None)
    assert isinstance(env_var, (str, String)), 'env_var must be str or String'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(env_var, (str, String)))
    py_string_env_var = env_var if isinstance(env_var, StringName) else c_utils.py_string_to_string(env_var)

    _ret = None
    _ret = self._ptr.call_with_return(76,tuple([py_stringname_name._ptr, py_string_env_var._ptr]))
    return _ret


  @functools.native_method
  def get_version(self, name:'object'   , windows_version:'bool'   ) -> typing.Union[str]:
    r'''
				Returns the preset's version number, or fall back to the `ProjectSettings.application/config/version` project setting if set to an empty string.
				If `windows_version` is `true`, formats the returned version number to be compatible with Windows executable metadata.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(windows_version, bool), 'windows_version must be bool'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(77,tuple([py_stringname_name._ptr, windows_version]))
    return utils.gd_string_to_py_string(_ret)



register_cast_function('EditorExportPreset', EditorExportPreset.cast)
register_class('EditorExportPreset', EditorExportPreset)
