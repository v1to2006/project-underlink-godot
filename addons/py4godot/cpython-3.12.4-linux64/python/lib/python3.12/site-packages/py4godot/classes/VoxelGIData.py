# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPVoxelGIDataWrapper


class VoxelGIData(py4godot_resource.Resource):
  r'''
		`VoxelGIData` contains baked voxel global illumination for use in a `VoxelGI` node. `VoxelGIData` also offers several properties to adjust the final appearance of the global illumination. These properties can be adjusted at run-time without having to bake the `VoxelGI` node again.
		**Note:** To prevent text-based scene files (`.tscn`) from growing too much and becoming slow to load and save, always save `VoxelGIData` to an external binary resource file (`.res`) instead of embedding it within the scene. This can be done by clicking the dropdown arrow next to the `VoxelGIData` resource, choosing **Edit**, clicking the floppy disk icon at the top of the Inspector then choosing **Save As...**.
	'''

  @staticmethod
  def constructor():
    class_ = VoxelGIData.construct_without_init()
    class_._ptr = constructor(992,0, ())
    return class_
  @staticmethod
  def new():
    class_ = VoxelGIData.construct_without_init()
    class_._ptr = constructor(992,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPVoxelGIDataWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(992,0, ())


  def generate_wrapper(self):
    return CPPVoxelGIDataWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = VoxelGIData.__new__(VoxelGIData)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'VoxelGIData'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(98, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = VoxelGIData.construct_without_init()
    cls._ptr = CPPVoxelGIDataWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = VoxelGIData.construct_without_init()
    cls._ptr = CPPVoxelGIDataWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def dynamic_range(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_dynamic_range()
    return _ret
  @dynamic_range.setter
  def dynamic_range(self,  value:'float'):
    self.set_dynamic_range(value)
  @property
  def energy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_energy()
    return _ret
  @energy.setter
  def energy(self,  value:'float'):
    self.set_energy(value)
  @property
  def bias(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_bias()
    return _ret
  @bias.setter
  def bias(self,  value:'float'):
    self.set_bias(value)
  @property
  def normal_bias(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_normal_bias()
    return _ret
  @normal_bias.setter
  def normal_bias(self,  value:'float'):
    self.set_normal_bias(value)
  @property
  def propagation(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_propagation()
    return _ret
  @propagation.setter
  def propagation(self,  value:'float'):
    self.set_propagation(value)
  @property
  def use_two_bounces(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_two_bounces()
    return _ret
  @use_two_bounces.setter
  def use_two_bounces(self,  value:'bool'):
    self.set_use_two_bounces(value)
  @property
  def interior(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_interior()
    return _ret
  @interior.setter
  def interior(self,  value:'bool'):
    self.set_interior(value)
  @functools.native_method
  def allocate(self, to_cell_xform:'Transform3D'   , aabb:'AABB'   , octree_size:'Vector3'   , octree_cells:'PackedByteArray'   , data_cells:'PackedByteArray'   , distance_field:'PackedByteArray'   , level_counts:'PackedInt32Array'   ) -> None:
    r'''
'''

    assert(not to_cell_xform is None)
    assert isinstance(to_cell_xform, Transform3D), 'to_cell_xform must be Transform3D'
    assert(not aabb is None)
    assert isinstance(aabb, AABB), 'aabb must be AABB'
    assert(not octree_size is None)
    assert isinstance(octree_size, Vector3), 'octree_size must be Vector3'
    assert(not octree_cells is None)
    assert isinstance(octree_cells, PackedByteArray), 'octree_cells must be PackedByteArray'
    assert(not data_cells is None)
    assert isinstance(data_cells, PackedByteArray), 'data_cells must be PackedByteArray'
    assert(not distance_field is None)
    assert isinstance(distance_field, PackedByteArray), 'distance_field must be PackedByteArray'
    assert(not level_counts is None)
    assert isinstance(level_counts, PackedInt32Array), 'level_counts must be PackedInt32Array'













    self._ptr.call_with_return(77,tuple([to_cell_xform._ptr, aabb._ptr, octree_size._ptr, octree_cells._ptr, data_cells._ptr, distance_field._ptr, level_counts._ptr]))

  @functools.native_method
  def get_bounds(self) -> typing.Union['AABB']:
    r'''
				Returns the bounds of the baked voxel data as an `AABB`, which should match `VoxelGI.size` after being baked (which only contains the size as a `Vector3`).
				**Note:** If the size was modified without baking the VoxelGI data, then the value of `get_bounds` and `VoxelGI.size` will not match.
			'''




    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([]))
    return _ret


  @functools.native_method
  def get_octree_size(self) -> typing.Union['Vector3']:
    r'''
'''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([]))
    return _ret


  @functools.native_method
  def get_to_cell_xform(self) -> typing.Union['Transform3D']:
    r'''
'''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))
    return _ret


  @functools.native_method
  def get_octree_cells(self) -> typing.Union['PackedByteArray']:
    r'''
'''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([]))
    return _ret


  @functools.native_method
  def get_data_cells(self) -> typing.Union['PackedByteArray']:
    r'''
'''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(82,tuple([]))
    return _ret


  @functools.native_method
  def get_level_counts(self) -> typing.Union['PackedInt32Array']:
    r'''
'''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(83,tuple([]))
    return _ret


  @functools.native_method
  def set_dynamic_range(self, dynamic_range:'float'   ) -> None:
    r''''''

    assert isinstance(dynamic_range, (int, float)), 'dynamic_range must be int or float'


    self.py__dynamic_range = dynamic_range






    self._ptr.call_with_return(84,tuple([dynamic_range]))

  @functools.native_method
  def get_dynamic_range(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([]))

    return _ret


  @functools.native_method
  def set_energy(self, energy:'float'   ) -> None:
    r''''''

    assert isinstance(energy, (int, float)), 'energy must be int or float'


    self.py__energy = energy






    self._ptr.call_with_return(86,tuple([energy]))

  @functools.native_method
  def get_energy(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(87,tuple([]))

    return _ret


  @functools.native_method
  def set_bias(self, bias:'float'   ) -> None:
    r''''''

    assert isinstance(bias, (int, float)), 'bias must be int or float'


    self.py__bias = bias






    self._ptr.call_with_return(88,tuple([bias]))

  @functools.native_method
  def get_bias(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([]))

    return _ret


  @functools.native_method
  def set_normal_bias(self, bias:'float'   ) -> None:
    r''''''

    assert isinstance(bias, (int, float)), 'bias must be int or float'


    self.py__normal_bias = bias






    self._ptr.call_with_return(90,tuple([bias]))

  @functools.native_method
  def get_normal_bias(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(91,tuple([]))

    return _ret


  @functools.native_method
  def set_propagation(self, propagation:'float'   ) -> None:
    r''''''

    assert isinstance(propagation, (int, float)), 'propagation must be int or float'


    self.py__propagation = propagation






    self._ptr.call_with_return(92,tuple([propagation]))

  @functools.native_method
  def get_propagation(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([]))

    return _ret


  @functools.native_method
  def set_interior(self, interior:'bool'   ) -> None:
    r''''''

    assert isinstance(interior, bool), 'interior must be bool'


    self.py__interior = interior






    self._ptr.call_with_return(94,tuple([interior]))

  @functools.native_method
  def is_interior(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(95,tuple([]))

    return _ret


  @functools.native_method
  def set_use_two_bounces(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__use_two_bounces = enable






    self._ptr.call_with_return(96,tuple([enable]))

  @functools.native_method
  def is_using_two_bounces(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([]))

    return _ret



register_cast_function('VoxelGIData', VoxelGIData.cast)
register_class('VoxelGIData', VoxelGIData)
