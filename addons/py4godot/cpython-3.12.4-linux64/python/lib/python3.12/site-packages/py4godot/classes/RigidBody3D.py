# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PhysicsDirectBodyState3D as py4godot_physicsdirectbodystate3d 
  import py4godot.classes.PhysicsMaterial as py4godot_physicsmaterial 
  import py4godot.classes.VehicleBody3D as py4godot_vehiclebody3d 
  import py4godot.classes.Node3DTypedArray as py4godot_node3dtypedarray 
import py4godot.classes.PhysicsBody3D as py4godot_physicsbody3d 
import py4godot.classes.Node3DTypedArray as py4godot_node3dtypedarray 
from py4godot.wrappers.wrappers import CPPRigidBody3DWrapper

class FreezeMode:
  FREEZE_MODE_STATIC = 0
  FREEZE_MODE_KINEMATIC = 1
class CenterOfMassMode:
  CENTER_OF_MASS_MODE_AUTO = 0
  CENTER_OF_MASS_MODE_CUSTOM = 1
class DampMode:
  DAMP_MODE_COMBINE = 0
  DAMP_MODE_REPLACE = 1


class RigidBody3D(py4godot_physicsbody3d.PhysicsBody3D):
  r'''
		`RigidBody3D` implements full 3D physics. It cannot be controlled directly, instead, you must apply forces to it (gravity, impulses, etc.), and the physics simulation will calculate the resulting movement, rotation, react to collisions, and affect other physics bodies in its path.
		The body's behavior can be adjusted via `lock_rotation`, `freeze`, and `freeze_mode`. By changing various properties of the object, such as `mass`, you can control how the physics simulation acts on it.
		A rigid body will always maintain its shape and size, even when forces are applied to it. It is useful for objects that can be interacted with in an environment, such as a tree that can be knocked over or a stack of crates that can be pushed around.
		If you need to directly affect the body, prefer `_integrate_forces` as it allows you to directly access the physics state.
		If you need to override the default physics behavior, you can write a custom force integration function. See `custom_integrator`.
		**Note:** Changing the 3D transform or `linear_velocity` of a `RigidBody3D` very often may lead to some unpredictable behaviors. This also happens when a `RigidBody3D` is the descendant of a constantly moving node, like another `RigidBody3D`, as that will cause its global transform to be set whenever its ancestor moves.
	'''

  @staticmethod
  def constructor():
    class_ = RigidBody3D.construct_without_init()
    class_._ptr = constructor(714,0, ())
    return class_
  @staticmethod
  def new():
    class_ = RigidBody3D.construct_without_init()
    class_._ptr = constructor(714,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPRigidBody3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(714,0, ())


  def generate_wrapper(self):
    return CPPRigidBody3DWrapper()
  def init_signals(self):
    super().init_signals()
    body_shape_entered_name = utils.py_string_to_string_name("body_shape_entered")
    self.body_shape_entered = signals.BuiltinSignal(self, body_shape_entered_name)
    body_shape_exited_name = utils.py_string_to_string_name("body_shape_exited")
    self.body_shape_exited = signals.BuiltinSignal(self, body_shape_exited_name)
    body_entered_name = utils.py_string_to_string_name("body_entered")
    self.body_entered = signals.BuiltinSignal(self, body_entered_name)
    body_exited_name = utils.py_string_to_string_name("body_exited")
    self.body_exited = signals.BuiltinSignal(self, body_exited_name)
    sleeping_state_changed_name = utils.py_string_to_string_name("sleeping_state_changed")
    self.sleeping_state_changed = signals.BuiltinSignal(self, sleeping_state_changed_name)

  @staticmethod
  def construct_without_init():
    cls = RigidBody3D.__new__(RigidBody3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'RigidBody3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = RigidBody3D.construct_without_init()
    cls._ptr = CPPRigidBody3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = RigidBody3D.construct_without_init()
    cls._ptr = CPPRigidBody3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def mass(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_mass()
    return _ret
  @mass.setter
  def mass(self,  value:'float'):
    self.set_mass(value)
  @property
  def physics_material_override(self) -> typing.Union['py4godot_physicsmaterial.PhysicsMaterial']:
    r''''''
    _ret = self. get_physics_material_override()
    return _ret
  @physics_material_override.setter
  def physics_material_override(self,  value:'py4godot_object.Object'):
    self.set_physics_material_override(value)
  @property
  def gravity_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_gravity_scale()
    return _ret
  @gravity_scale.setter
  def gravity_scale(self,  value:'float'):
    self.set_gravity_scale(value)
  @property
  def center_of_mass_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_center_of_mass_mode()
    return _ret
  @center_of_mass_mode.setter
  def center_of_mass_mode(self,  value:'int'):
    self.set_center_of_mass_mode(value)
  @property
  def center_of_mass(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_center_of_mass()
    return _ret
  @center_of_mass.setter
  def center_of_mass(self,  value:'Vector3'):
    self.set_center_of_mass(value)
  @property
  def inertia(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_inertia()
    return _ret
  @inertia.setter
  def inertia(self,  value:'Vector3'):
    self.set_inertia(value)
  @property
  def sleeping(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_sleeping()
    return _ret
  @sleeping.setter
  def sleeping(self,  value:'bool'):
    self.set_sleeping(value)
  @property
  def can_sleep(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_able_to_sleep()
    return _ret
  @can_sleep.setter
  def can_sleep(self,  value:'bool'):
    self.set_can_sleep(value)
  @property
  def lock_rotation(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_lock_rotation_enabled()
    return _ret
  @lock_rotation.setter
  def lock_rotation(self,  value:'bool'):
    self.set_lock_rotation_enabled(value)
  @property
  def freeze(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_freeze_enabled()
    return _ret
  @freeze.setter
  def freeze(self,  value:'bool'):
    self.set_freeze_enabled(value)
  @property
  def freeze_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_freeze_mode()
    return _ret
  @freeze_mode.setter
  def freeze_mode(self,  value:'int'):
    self.set_freeze_mode(value)
  @property
  def custom_integrator(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_custom_integrator()
    return _ret
  @custom_integrator.setter
  def custom_integrator(self,  value:'bool'):
    self.set_use_custom_integrator(value)
  @property
  def continuous_cd(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_continuous_collision_detection()
    return _ret
  @continuous_cd.setter
  def continuous_cd(self,  value:'bool'):
    self.set_use_continuous_collision_detection(value)
  @property
  def contact_monitor(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_contact_monitor_enabled()
    return _ret
  @contact_monitor.setter
  def contact_monitor(self,  value:'bool'):
    self.set_contact_monitor(value)
  @property
  def max_contacts_reported(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_contacts_reported()
    return _ret
  @max_contacts_reported.setter
  def max_contacts_reported(self,  value:'int'):
    self.set_max_contacts_reported(value)
  @property
  def linear_velocity(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_linear_velocity()
    return _ret
  @linear_velocity.setter
  def linear_velocity(self,  value:'Vector3'):
    self.set_linear_velocity(value)
  @property
  def linear_damp_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_linear_damp_mode()
    return _ret
  @linear_damp_mode.setter
  def linear_damp_mode(self,  value:'int'):
    self.set_linear_damp_mode(value)
  @property
  def linear_damp(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_linear_damp()
    return _ret
  @linear_damp.setter
  def linear_damp(self,  value:'float'):
    self.set_linear_damp(value)
  @property
  def angular_velocity(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_angular_velocity()
    return _ret
  @angular_velocity.setter
  def angular_velocity(self,  value:'Vector3'):
    self.set_angular_velocity(value)
  @property
  def angular_damp_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_angular_damp_mode()
    return _ret
  @angular_damp_mode.setter
  def angular_damp_mode(self,  value:'int'):
    self.set_angular_damp_mode(value)
  @property
  def angular_damp(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_angular_damp()
    return _ret
  @angular_damp.setter
  def angular_damp(self,  value:'float'):
    self.set_angular_damp(value)
  @property
  def constant_force(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_constant_force()
    return _ret
  @constant_force.setter
  def constant_force(self,  value:'Vector3'):
    self.set_constant_force(value)
  @property
  def constant_torque(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_constant_torque()
    return _ret
  @constant_torque.setter
  def constant_torque(self,  value:'Vector3'):
    self.set_constant_torque(value)
  @functools.native_method
  def _integrate_forces(self, state:'py4godot_physicsdirectbodystate3d.PhysicsDirectBodyState3D'   ) -> None:
    r'''
				Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default, it is called before the standard force integration, but the `custom_integrator` property allows you to disable the standard force integration and do fully custom force integration for a body.
			'''

    assert(not state is None)
    assert isinstance(state, get_class('PhysicsDirectBodyState3D')), 'state must be PhysicsDirectBodyState3D'







    self._ptr.call_with_return(294,tuple([state._ptr]))

  @functools.native_method
  def set_mass(self, mass:'float'   ) -> None:
    r''''''

    assert isinstance(mass, (int, float)), 'mass must be int or float'


    self.py__mass = mass






    self._ptr.call_with_return(295,tuple([mass]))

  @functools.native_method
  def get_mass(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(296,tuple([]))

    return _ret


  @functools.native_method
  def set_inertia(self, inertia:'Vector3'   ) -> None:
    r''''''

    assert(not inertia is None)
    assert isinstance(inertia, Vector3), 'inertia must be Vector3'


    self.py__inertia = inertia






    self._ptr.call_with_return(297,tuple([inertia._ptr]))

  @functools.native_method
  def get_inertia(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(298,tuple([]))

    return _ret


  @functools.native_method
  def set_center_of_mass_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__center_of_mass_mode = mode






    self._ptr.call_with_return(299,tuple([mode]))

  @functools.native_method
  def get_center_of_mass_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(300,tuple([]))

    return _ret


  @functools.native_method
  def set_center_of_mass(self, center_of_mass:'Vector3'   ) -> None:
    r''''''

    assert(not center_of_mass is None)
    assert isinstance(center_of_mass, Vector3), 'center_of_mass must be Vector3'


    self.py__center_of_mass = center_of_mass






    self._ptr.call_with_return(301,tuple([center_of_mass._ptr]))

  @functools.native_method
  def get_center_of_mass(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(302,tuple([]))

    return _ret


  @functools.native_method
  def set_physics_material_override(self, physics_material_override:'py4godot_physicsmaterial.PhysicsMaterial'   ) -> None:
    r''''''

    assert(not physics_material_override is None)
    assert isinstance(physics_material_override, get_class('PhysicsMaterial')), 'physics_material_override must be PhysicsMaterial'


    self.py__physics_material_override = physics_material_override






    self._ptr.call_with_return(303,tuple([physics_material_override._ptr]))

  @functools.native_method
  def get_physics_material_override(self) -> typing.Union['py4godot_physicsmaterial.PhysicsMaterial']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: PhysicsMaterial
    _ret._ptr = self._ptr.call_with_return(304,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_linear_velocity(self, linear_velocity:'Vector3'   ) -> None:
    r''''''

    assert(not linear_velocity is None)
    assert isinstance(linear_velocity, Vector3), 'linear_velocity must be Vector3'


    self.py__linear_velocity = linear_velocity






    self._ptr.call_with_return(305,tuple([linear_velocity._ptr]))

  @functools.native_method
  def get_linear_velocity(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(306,tuple([]))

    return _ret


  @functools.native_method
  def set_angular_velocity(self, angular_velocity:'Vector3'   ) -> None:
    r''''''

    assert(not angular_velocity is None)
    assert isinstance(angular_velocity, Vector3), 'angular_velocity must be Vector3'


    self.py__angular_velocity = angular_velocity






    self._ptr.call_with_return(307,tuple([angular_velocity._ptr]))

  @functools.native_method
  def get_angular_velocity(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(308,tuple([]))

    return _ret


  @functools.native_method
  def get_inverse_inertia_tensor(self) -> typing.Union['Basis']:
    r'''
				Returns the inverse inertia tensor basis. This is used to calculate the angular acceleration resulting from a torque applied to the `RigidBody3D`.
			'''




    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(309,tuple([]))
    return _ret


  @functools.native_method
  def set_gravity_scale(self, gravity_scale:'float'   ) -> None:
    r''''''

    assert isinstance(gravity_scale, (int, float)), 'gravity_scale must be int or float'


    self.py__gravity_scale = gravity_scale






    self._ptr.call_with_return(310,tuple([gravity_scale]))

  @functools.native_method
  def get_gravity_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(311,tuple([]))

    return _ret


  @functools.native_method
  def set_linear_damp_mode(self, linear_damp_mode:'int'  ) -> None:
    r''''''

    assert isinstance(linear_damp_mode, (int, float)), 'linear_damp_mode must be int or float'


    self.py__linear_damp_mode = linear_damp_mode






    self._ptr.call_with_return(312,tuple([linear_damp_mode]))

  @functools.native_method
  def get_linear_damp_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(313,tuple([]))

    return _ret


  @functools.native_method
  def set_angular_damp_mode(self, angular_damp_mode:'int'  ) -> None:
    r''''''

    assert isinstance(angular_damp_mode, (int, float)), 'angular_damp_mode must be int or float'


    self.py__angular_damp_mode = angular_damp_mode






    self._ptr.call_with_return(314,tuple([angular_damp_mode]))

  @functools.native_method
  def get_angular_damp_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(315,tuple([]))

    return _ret


  @functools.native_method
  def set_linear_damp(self, linear_damp:'float'   ) -> None:
    r''''''

    assert isinstance(linear_damp, (int, float)), 'linear_damp must be int or float'


    self.py__linear_damp = linear_damp






    self._ptr.call_with_return(316,tuple([linear_damp]))

  @functools.native_method
  def get_linear_damp(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(317,tuple([]))

    return _ret


  @functools.native_method
  def set_angular_damp(self, angular_damp:'float'   ) -> None:
    r''''''

    assert isinstance(angular_damp, (int, float)), 'angular_damp must be int or float'


    self.py__angular_damp = angular_damp






    self._ptr.call_with_return(318,tuple([angular_damp]))

  @functools.native_method
  def get_angular_damp(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(319,tuple([]))

    return _ret


  @functools.native_method
  def set_max_contacts_reported(self, amount:'int'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__max_contacts_reported = amount






    self._ptr.call_with_return(320,tuple([amount]))

  @functools.native_method
  def get_max_contacts_reported(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(321,tuple([]))

    return _ret


  @functools.native_method
  def get_contact_count(self) -> typing.Union[int]:
    r'''
				Returns the number of contacts this body has with other bodies. By default, this returns 0 unless bodies are configured to monitor contacts (see `contact_monitor`).
				**Note:** To retrieve the colliding bodies, use `get_colliding_bodies`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(322,tuple([]))
    return _ret


  @functools.native_method
  def set_use_custom_integrator(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__custom_integrator = enable






    self._ptr.call_with_return(323,tuple([enable]))

  @functools.native_method
  def is_using_custom_integrator(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(324,tuple([]))

    return _ret


  @functools.native_method
  def set_contact_monitor(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__contact_monitor = enabled






    self._ptr.call_with_return(325,tuple([enabled]))

  @functools.native_method
  def is_contact_monitor_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(326,tuple([]))

    return _ret


  @functools.native_method
  def set_use_continuous_collision_detection(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__continuous_cd = enable






    self._ptr.call_with_return(327,tuple([enable]))

  @functools.native_method
  def is_using_continuous_collision_detection(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(328,tuple([]))

    return _ret


  @functools.native_method
  def set_axis_velocity(self, axis_velocity:'Vector3'   ) -> None:
    r'''
				Sets an axis velocity. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
			'''

    assert(not axis_velocity is None)
    assert isinstance(axis_velocity, Vector3), 'axis_velocity must be Vector3'







    self._ptr.call_with_return(329,tuple([axis_velocity._ptr]))

  @functools.native_method
  def apply_central_impulse(self, impulse:'Vector3'   ) -> None:
    r'''
				Applies a directional impulse without affecting rotation.
				An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
				This is equivalent to using `apply_impulse` at the body's center of mass.
			'''

    assert(not impulse is None)
    assert isinstance(impulse, Vector3), 'impulse must be Vector3'







    self._ptr.call_with_return(330,tuple([impulse._ptr]))

  @functools.native_method
  def apply_impulse(self, impulse:'Vector3'   , position:'Vector3' = None  ) -> None:
    r'''
				Applies a positioned impulse to the body.
				An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
				`position` is the offset from the body origin in global coordinates.
			'''
    if position is None:
      position = Vector3.new0()

    assert(not impulse is None)
    assert isinstance(impulse, Vector3), 'impulse must be Vector3'








    self._ptr.call_with_return(331,tuple([impulse._ptr, position._ptr]))

  @functools.native_method
  def apply_torque_impulse(self, impulse:'Vector3'   ) -> None:
    r'''
				Applies a rotational impulse to the body without affecting the position.
				An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
				**Note:** `inertia` is required for this to work. To have `inertia`, an active `CollisionShape3D` must be a child of the node, or you can manually set `inertia`.
			'''

    assert(not impulse is None)
    assert isinstance(impulse, Vector3), 'impulse must be Vector3'







    self._ptr.call_with_return(332,tuple([impulse._ptr]))

  @functools.native_method
  def apply_central_force(self, force:'Vector3'   ) -> None:
    r'''
				Applies a directional force without affecting rotation. A force is time dependent and meant to be applied every physics update.
				This is equivalent to using `apply_force` at the body's center of mass.
			'''

    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'







    self._ptr.call_with_return(333,tuple([force._ptr]))

  @functools.native_method
  def apply_force(self, force:'Vector3'   , position:'Vector3' = None  ) -> None:
    r'''
				Applies a positioned force to the body. A force is time dependent and meant to be applied every physics update.
				`position` is the offset from the body origin in global coordinates.
			'''
    if position is None:
      position = Vector3.new0()

    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'








    self._ptr.call_with_return(334,tuple([force._ptr, position._ptr]))

  @functools.native_method
  def apply_torque(self, torque:'Vector3'   ) -> None:
    r'''
				Applies a rotational force without affecting position. A force is time dependent and meant to be applied every physics update.
				**Note:** `inertia` is required for this to work. To have `inertia`, an active `CollisionShape3D` must be a child of the node, or you can manually set `inertia`.
			'''

    assert(not torque is None)
    assert isinstance(torque, Vector3), 'torque must be Vector3'







    self._ptr.call_with_return(335,tuple([torque._ptr]))

  @functools.native_method
  def add_constant_central_force(self, force:'Vector3'   ) -> None:
    r'''
				Adds a constant directional force without affecting rotation that keeps being applied over time until cleared with `constant_force = Vector3(0, 0, 0)`.
				This is equivalent to using `add_constant_force` at the body's center of mass.
			'''

    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'







    self._ptr.call_with_return(336,tuple([force._ptr]))

  @functools.native_method
  def add_constant_force(self, force:'Vector3'   , position:'Vector3' = None  ) -> None:
    r'''
				Adds a constant positioned force to the body that keeps being applied over time until cleared with `constant_force = Vector3(0, 0, 0)`.
				`position` is the offset from the body origin in global coordinates.
			'''
    if position is None:
      position = Vector3.new0()

    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'








    self._ptr.call_with_return(337,tuple([force._ptr, position._ptr]))

  @functools.native_method
  def add_constant_torque(self, torque:'Vector3'   ) -> None:
    r'''
				Adds a constant rotational force without affecting position that keeps being applied over time until cleared with `constant_torque = Vector3(0, 0, 0)`.
			'''

    assert(not torque is None)
    assert isinstance(torque, Vector3), 'torque must be Vector3'







    self._ptr.call_with_return(338,tuple([torque._ptr]))

  @functools.native_method
  def set_constant_force(self, force:'Vector3'   ) -> None:
    r''''''

    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'


    self.py__constant_force = force






    self._ptr.call_with_return(339,tuple([force._ptr]))

  @functools.native_method
  def get_constant_force(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(340,tuple([]))

    return _ret


  @functools.native_method
  def set_constant_torque(self, torque:'Vector3'   ) -> None:
    r''''''

    assert(not torque is None)
    assert isinstance(torque, Vector3), 'torque must be Vector3'


    self.py__constant_torque = torque






    self._ptr.call_with_return(341,tuple([torque._ptr]))

  @functools.native_method
  def get_constant_torque(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(342,tuple([]))

    return _ret


  @functools.native_method
  def set_sleeping(self, sleeping:'bool'   ) -> None:
    r''''''

    assert isinstance(sleeping, bool), 'sleeping must be bool'


    self.py__sleeping = sleeping






    self._ptr.call_with_return(343,tuple([sleeping]))

  @functools.native_method
  def is_sleeping(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(344,tuple([]))

    return _ret


  @functools.native_method
  def set_can_sleep(self, able_to_sleep:'bool'   ) -> None:
    r''''''

    assert isinstance(able_to_sleep, bool), 'able_to_sleep must be bool'


    self.py__can_sleep = able_to_sleep






    self._ptr.call_with_return(345,tuple([able_to_sleep]))

  @functools.native_method
  def is_able_to_sleep(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(346,tuple([]))

    return _ret


  @functools.native_method
  def set_lock_rotation_enabled(self, lock_rotation:'bool'   ) -> None:
    r''''''

    assert isinstance(lock_rotation, bool), 'lock_rotation must be bool'


    self.py__lock_rotation = lock_rotation






    self._ptr.call_with_return(347,tuple([lock_rotation]))

  @functools.native_method
  def is_lock_rotation_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(348,tuple([]))

    return _ret


  @functools.native_method
  def set_freeze_enabled(self, freeze_mode:'bool'   ) -> None:
    r''''''

    assert isinstance(freeze_mode, bool), 'freeze_mode must be bool'


    self.py__freeze = freeze_mode






    self._ptr.call_with_return(349,tuple([freeze_mode]))

  @functools.native_method
  def is_freeze_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(350,tuple([]))

    return _ret


  @functools.native_method
  def set_freeze_mode(self, freeze_mode:'int'  ) -> None:
    r''''''

    assert isinstance(freeze_mode, (int, float)), 'freeze_mode must be int or float'


    self.py__freeze_mode = freeze_mode






    self._ptr.call_with_return(351,tuple([freeze_mode]))

  @functools.native_method
  def get_freeze_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(352,tuple([]))

    return _ret


  @functools.native_method
  def get_colliding_bodies(self) -> typing.Union['py4godot_node3dtypedarray.Node3DTypedArray']:
    r'''
				Returns a list of the bodies colliding with this one. Requires `contact_monitor` to be set to `true` and `max_contacts_reported` to be set high enough to detect all the collisions.
				**Note:** The result of this test is not immediate after moving objects. For performance, list of collisions is updated once per frame and before the physics step. Consider using signals instead.
			'''




    _ret = py4godot_node3dtypedarray.Node3DTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(353,tuple([]))
    return _ret



register_cast_function('RigidBody3D', RigidBody3D.cast)
register_class('RigidBody3D', RigidBody3D)
