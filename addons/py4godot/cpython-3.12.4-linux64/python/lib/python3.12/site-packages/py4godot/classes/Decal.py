# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
import py4godot.classes.VisualInstance3D as py4godot_visualinstance3d 
from py4godot.wrappers.wrappers import CPPDecalWrapper

class DecalTexture:
  TEXTURE_ALBEDO = 0
  TEXTURE_NORMAL = 1
  TEXTURE_ORM = 2
  TEXTURE_EMISSION = 3
  TEXTURE_MAX = 4


class Decal(py4godot_visualinstance3d.VisualInstance3D):
  r'''
		`Decal`s are used to project a texture onto a `Mesh` in the scene. Use Decals to add detail to a scene without affecting the underlying `Mesh`. They are often used to add weathering to building, add dirt or mud to the ground, or add variety to props. Decals can be moved at any time, making them suitable for things like blob shadows or laser sight dots.
		They are made of an `AABB` and a group of `Texture2D`s specifying `Color`, normal, ORM (ambient occlusion, roughness, metallic), and emission. Decals are projected within their `AABB` so altering the orientation of the Decal affects the direction in which they are projected. By default, Decals are projected down (i.e. from positive Y to negative Y).
		The `Texture2D`s associated with the Decal are automatically stored in a texture atlas which is used for drawing the decals so all decals can be drawn at once. Godot uses clustered decals, meaning they are stored in cluster data and drawn when the mesh is drawn, they are not drawn as a post-processing effect after.
		**Note:** Decals cannot affect an underlying material's transparency, regardless of its transparency mode (alpha blend, alpha scissor, alpha hash, opaque pre-pass). This means translucent or transparent areas of a material will remain translucent or transparent even if an opaque decal is applied on them.
		**Note:** Decals are only supported in the Forward+ and Mobile rendering methods, not Compatibility. When using the Mobile rendering method, only 8 decals can be displayed on each mesh resource. Attempting to display more than 8 decals on a single mesh resource will result in decals flickering in and out as the camera moves.
		**Note:** When using the Mobile rendering method, decals will only correctly affect meshes whose visibility AABB intersects with the decal's AABB. If using a shader to deform the mesh in a way that makes it go outside its AABB, `GeometryInstance3D.extra_cull_margin` must be increased on the mesh. Otherwise, the decal may not be visible on the mesh.
	'''

  @staticmethod
  def constructor():
    class_ = Decal.construct_without_init()
    class_._ptr = constructor(258,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Decal.construct_without_init()
    class_._ptr = constructor(258,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPDecalWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(258,0, ())


  def generate_wrapper(self):
    return CPPDecalWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Decal.__new__(Decal)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Decal'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Decal.construct_without_init()
    cls._ptr = CPPDecalWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Decal.construct_without_init()
    cls._ptr = CPPDecalWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def size(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_size()
    return _ret
  @size.setter
  def size(self,  value:'Vector3'):
    self.set_size(value)
  @property
  def texture_albedo(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(0)
    return _ret
  @texture_albedo.setter
  def texture_albedo(self,  value:'py4godot_object.Object'):
    self.set_texture(0, value)
  @property
  def texture_normal(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(1)
    return _ret
  @texture_normal.setter
  def texture_normal(self,  value:'py4godot_object.Object'):
    self.set_texture(1, value)
  @property
  def texture_orm(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(2)
    return _ret
  @texture_orm.setter
  def texture_orm(self,  value:'py4godot_object.Object'):
    self.set_texture(2, value)
  @property
  def texture_emission(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(3)
    return _ret
  @texture_emission.setter
  def texture_emission(self,  value:'py4godot_object.Object'):
    self.set_texture(3, value)
  @property
  def emission_energy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_emission_energy()
    return _ret
  @emission_energy.setter
  def emission_energy(self,  value:'float'):
    self.set_emission_energy(value)
  @property
  def modulate(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_modulate()
    return _ret
  @modulate.setter
  def modulate(self,  value:'Color'):
    self.set_modulate(value)
  @property
  def albedo_mix(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_albedo_mix()
    return _ret
  @albedo_mix.setter
  def albedo_mix(self,  value:'float'):
    self.set_albedo_mix(value)
  @property
  def normal_fade(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_normal_fade()
    return _ret
  @normal_fade.setter
  def normal_fade(self,  value:'float'):
    self.set_normal_fade(value)
  @property
  def upper_fade(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_upper_fade()
    return _ret
  @upper_fade.setter
  def upper_fade(self,  value:'float'):
    self.set_upper_fade(value)
  @property
  def lower_fade(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_lower_fade()
    return _ret
  @lower_fade.setter
  def lower_fade(self,  value:'float'):
    self.set_lower_fade(value)
  @property
  def distance_fade_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_distance_fade_enabled()
    return _ret
  @distance_fade_enabled.setter
  def distance_fade_enabled(self,  value:'bool'):
    self.set_enable_distance_fade(value)
  @property
  def distance_fade_begin(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_distance_fade_begin()
    return _ret
  @distance_fade_begin.setter
  def distance_fade_begin(self,  value:'float'):
    self.set_distance_fade_begin(value)
  @property
  def distance_fade_length(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_distance_fade_length()
    return _ret
  @distance_fade_length.setter
  def distance_fade_length(self,  value:'float'):
    self.set_distance_fade_length(value)
  @property
  def cull_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_cull_mask()
    return _ret
  @cull_mask.setter
  def cull_mask(self,  value:'int'):
    self.set_cull_mask(value)
  @functools.native_method
  def set_size(self, size:'Vector3'   ) -> None:
    r''''''

    assert(not size is None)
    assert isinstance(size, Vector3), 'size must be Vector3'


    self.py__size = size






    self._ptr.call_with_return(264,tuple([size._ptr]))

  @functools.native_method
  def get_size(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(265,tuple([]))

    return _ret


  @functools.native_method
  def set_texture(self, type:'int'  , texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets the `Texture2D` associated with the specified `enum DecalTexture`. This is a convenience method, in most cases you should access the texture directly.
				For example, instead of `$Decal.set_texture(Decal.TEXTURE_ALBEDO, albedo_tex)`, use `$Decal.texture_albedo = albedo_tex`.
				One case where this is better than accessing the texture directly is when you want to copy one Decal's textures to another. For example:
				
				```gdscript
				for i in Decal.TEXTURE_MAX:
					$NewDecal.set_texture(i, $OldDecal.get_texture(i))
				```
				
				
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'


    self.py__texture_albedo = type







    self._ptr.call_with_return(266,tuple([type, texture._ptr]))

  @functools.native_method
  def get_texture(self, type:'int'  ) -> typing.Any:
    r'''
				Returns the `Texture2D` associated with the specified `enum DecalTexture`. This is a convenience method, in most cases you should access the texture directly.
				For example, instead of `albedo_tex = $Decal.get_texture(Decal.TEXTURE_ALBEDO)`, use `albedo_tex = $Decal.texture_albedo`.
				One case where this is better than accessing the texture directly is when you want to copy one Decal's textures to another. For example:
				
				```gdscript
				for i in Decal.TEXTURE_MAX:
					$NewDecal.set_texture(i, $OldDecal.get_texture(i))
				```
				
				
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(267,tuple([type]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_emission_energy(self, energy:'float'   ) -> None:
    r''''''

    assert isinstance(energy, (int, float)), 'energy must be int or float'


    self.py__emission_energy = energy






    self._ptr.call_with_return(268,tuple([energy]))

  @functools.native_method
  def get_emission_energy(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(269,tuple([]))

    return _ret


  @functools.native_method
  def set_albedo_mix(self, energy:'float'   ) -> None:
    r''''''

    assert isinstance(energy, (int, float)), 'energy must be int or float'


    self.py__albedo_mix = energy






    self._ptr.call_with_return(270,tuple([energy]))

  @functools.native_method
  def get_albedo_mix(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(271,tuple([]))

    return _ret


  @functools.native_method
  def set_modulate(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__modulate = color






    self._ptr.call_with_return(272,tuple([color._ptr]))

  @functools.native_method
  def get_modulate(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(273,tuple([]))

    return _ret


  @functools.native_method
  def set_upper_fade(self, fade:'float'   ) -> None:
    r''''''

    assert isinstance(fade, (int, float)), 'fade must be int or float'


    self.py__upper_fade = fade






    self._ptr.call_with_return(274,tuple([fade]))

  @functools.native_method
  def get_upper_fade(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(275,tuple([]))

    return _ret


  @functools.native_method
  def set_lower_fade(self, fade:'float'   ) -> None:
    r''''''

    assert isinstance(fade, (int, float)), 'fade must be int or float'


    self.py__lower_fade = fade






    self._ptr.call_with_return(276,tuple([fade]))

  @functools.native_method
  def get_lower_fade(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(277,tuple([]))

    return _ret


  @functools.native_method
  def set_normal_fade(self, fade:'float'   ) -> None:
    r''''''

    assert isinstance(fade, (int, float)), 'fade must be int or float'


    self.py__normal_fade = fade






    self._ptr.call_with_return(278,tuple([fade]))

  @functools.native_method
  def get_normal_fade(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(279,tuple([]))

    return _ret


  @functools.native_method
  def set_enable_distance_fade(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__distance_fade_enabled = enable






    self._ptr.call_with_return(280,tuple([enable]))

  @functools.native_method
  def is_distance_fade_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(281,tuple([]))

    return _ret


  @functools.native_method
  def set_distance_fade_begin(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__distance_fade_begin = distance






    self._ptr.call_with_return(282,tuple([distance]))

  @functools.native_method
  def get_distance_fade_begin(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(283,tuple([]))

    return _ret


  @functools.native_method
  def set_distance_fade_length(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__distance_fade_length = distance






    self._ptr.call_with_return(284,tuple([distance]))

  @functools.native_method
  def get_distance_fade_length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(285,tuple([]))

    return _ret


  @functools.native_method
  def set_cull_mask(self, mask:'int'   ) -> None:
    r''''''

    assert isinstance(mask, (int, float)), 'mask must be int or float'


    self.py__cull_mask = mask






    self._ptr.call_with_return(286,tuple([mask]))

  @functools.native_method
  def get_cull_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(287,tuple([]))

    return _ret



register_cast_function('Decal', Decal.cast)
register_class('Decal', Decal)
