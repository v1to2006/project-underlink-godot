# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Skin as py4godot_skin 
  import py4godot.classes.Transform3DTypedArray as py4godot_transform3dtypedarray 
import py4godot.classes.Resource as py4godot_resource 
import py4godot.classes.Transform3DTypedArray as py4godot_transform3dtypedarray 
from py4godot.wrappers.wrappers import CPPGLTFSkinWrapper


class GLTFSkin(py4godot_resource.Resource):
  r''''''

  @staticmethod
  def constructor():
    class_ = GLTFSkin.construct_without_init()
    class_._ptr = constructor(359,0, ())
    return class_
  @staticmethod
  def new():
    class_ = GLTFSkin.construct_without_init()
    class_._ptr = constructor(359,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPGLTFSkinWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(359,0, ())


  def generate_wrapper(self):
    return CPPGLTFSkinWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = GLTFSkin.__new__(GLTFSkin)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'GLTFSkin'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(97, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = GLTFSkin.construct_without_init()
    cls._ptr = CPPGLTFSkinWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = GLTFSkin.construct_without_init()
    cls._ptr = CPPGLTFSkinWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def skin_root(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_skin_root()
    return _ret
  @skin_root.setter
  def skin_root(self,  value:'int'):
    self.set_skin_root(value)
  @property
  def joints_original(self) -> typing.Union['PackedInt32Array']:
    r''''''
    _ret = self. get_joints_original()
    return _ret
  @joints_original.setter
  def joints_original(self,  value:'PackedInt32Array'):
    self.set_joints_original(value)
  @property
  def inverse_binds(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_inverse_binds()
    return _ret
  @inverse_binds.setter
  def inverse_binds(self,  value:'Array'):
    self.set_inverse_binds(value)
  @property
  def joints(self) -> typing.Union['PackedInt32Array']:
    r''''''
    _ret = self. get_joints()
    return _ret
  @joints.setter
  def joints(self,  value:'PackedInt32Array'):
    self.set_joints(value)
  @property
  def non_joints(self) -> typing.Union['PackedInt32Array']:
    r''''''
    _ret = self. get_non_joints()
    return _ret
  @non_joints.setter
  def non_joints(self,  value:'PackedInt32Array'):
    self.set_non_joints(value)
  @property
  def roots(self) -> typing.Union['PackedInt32Array']:
    r''''''
    _ret = self. get_roots()
    return _ret
  @roots.setter
  def roots(self,  value:'PackedInt32Array'):
    self.set_roots(value)
  @property
  def skeleton(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_skeleton()
    return _ret
  @skeleton.setter
  def skeleton(self,  value:'int'):
    self.set_skeleton(value)
  @property
  def joint_i_to_bone_i(self) -> typing.Union['Dictionary']:
    r''''''
    _ret = self. get_joint_i_to_bone_i()
    return _ret
  @joint_i_to_bone_i.setter
  def joint_i_to_bone_i(self,  value:'Dictionary'):
    self.set_joint_i_to_bone_i(value)
  @property
  def joint_i_to_name(self) -> typing.Union['Dictionary']:
    r''''''
    _ret = self. get_joint_i_to_name()
    return _ret
  @joint_i_to_name.setter
  def joint_i_to_name(self,  value:'Dictionary'):
    self.set_joint_i_to_name(value)
  @property
  def godot_skin(self) -> typing.Union['py4godot_skin.Skin']:
    r''''''
    _ret = self. get_godot_skin()
    return _ret
  @godot_skin.setter
  def godot_skin(self,  value:'py4godot_object.Object'):
    self.set_godot_skin(value)
  @functools.native_method
  def get_skin_root(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(77,tuple([]))

    return _ret


  @functools.native_method
  def set_skin_root(self, skin_root:'int'   ) -> None:
    r''''''

    assert isinstance(skin_root, (int, float)), 'skin_root must be int or float'


    self.py__skin_root = skin_root






    self._ptr.call_with_return(78,tuple([skin_root]))

  @functools.native_method
  def get_joints_original(self) -> typing.Union['PackedInt32Array']:
    r''''''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([]))

    return _ret


  @functools.native_method
  def set_joints_original(self, joints_original:'PackedInt32Array'   ) -> None:
    r''''''

    assert(not joints_original is None)
    assert isinstance(joints_original, PackedInt32Array), 'joints_original must be PackedInt32Array'


    self.py__joints_original = joints_original






    self._ptr.call_with_return(80,tuple([joints_original._ptr]))

  @functools.native_method
  def get_inverse_binds(self) -> typing.Union['py4godot_transform3dtypedarray.Transform3DTypedArray']:
    r''''''




    _ret = py4godot_transform3dtypedarray.Transform3DTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([]))

    return _ret


  @functools.native_method
  def set_inverse_binds(self, inverse_binds:'py4godot_transform3dtypedarray.Transform3DTypedArray'   ) -> None:
    r''''''

    assert isinstance(inverse_binds, Array), 'inverse_binds must be Array'


    self.py__inverse_binds = inverse_binds






    self._ptr.call_with_return(82,tuple([inverse_binds._ptr]))

  @functools.native_method
  def get_joints(self) -> typing.Union['PackedInt32Array']:
    r''''''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(83,tuple([]))

    return _ret


  @functools.native_method
  def set_joints(self, joints:'PackedInt32Array'   ) -> None:
    r''''''

    assert(not joints is None)
    assert isinstance(joints, PackedInt32Array), 'joints must be PackedInt32Array'


    self.py__joints = joints






    self._ptr.call_with_return(84,tuple([joints._ptr]))

  @functools.native_method
  def get_non_joints(self) -> typing.Union['PackedInt32Array']:
    r''''''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(85,tuple([]))

    return _ret


  @functools.native_method
  def set_non_joints(self, non_joints:'PackedInt32Array'   ) -> None:
    r''''''

    assert(not non_joints is None)
    assert isinstance(non_joints, PackedInt32Array), 'non_joints must be PackedInt32Array'


    self.py__non_joints = non_joints






    self._ptr.call_with_return(86,tuple([non_joints._ptr]))

  @functools.native_method
  def get_roots(self) -> typing.Union['PackedInt32Array']:
    r''''''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([]))

    return _ret


  @functools.native_method
  def set_roots(self, roots:'PackedInt32Array'   ) -> None:
    r''''''

    assert(not roots is None)
    assert isinstance(roots, PackedInt32Array), 'roots must be PackedInt32Array'


    self.py__roots = roots






    self._ptr.call_with_return(88,tuple([roots._ptr]))

  @functools.native_method
  def get_skeleton(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([]))

    return _ret


  @functools.native_method
  def set_skeleton(self, skeleton:'int'   ) -> None:
    r''''''

    assert isinstance(skeleton, (int, float)), 'skeleton must be int or float'


    self.py__skeleton = skeleton






    self._ptr.call_with_return(90,tuple([skeleton]))

  @functools.native_method
  def get_joint_i_to_bone_i(self) -> typing.Union['Dictionary']:
    r''''''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([]))

    return _ret


  @functools.native_method
  def set_joint_i_to_bone_i(self, joint_i_to_bone_i:'Dictionary'   ) -> None:
    r''''''

    assert(not joint_i_to_bone_i is None)
    assert isinstance(joint_i_to_bone_i, Dictionary), 'joint_i_to_bone_i must be Dictionary'


    self.py__joint_i_to_bone_i = joint_i_to_bone_i






    self._ptr.call_with_return(92,tuple([joint_i_to_bone_i._ptr]))

  @functools.native_method
  def get_joint_i_to_name(self) -> typing.Union['Dictionary']:
    r''''''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(93,tuple([]))

    return _ret


  @functools.native_method
  def set_joint_i_to_name(self, joint_i_to_name:'Dictionary'   ) -> None:
    r''''''

    assert(not joint_i_to_name is None)
    assert isinstance(joint_i_to_name, Dictionary), 'joint_i_to_name must be Dictionary'


    self.py__joint_i_to_name = joint_i_to_name






    self._ptr.call_with_return(94,tuple([joint_i_to_name._ptr]))

  @functools.native_method
  def get_godot_skin(self) -> typing.Union['py4godot_skin.Skin']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Skin
    _ret._ptr = self._ptr.call_with_return(95,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_godot_skin(self, godot_skin:'py4godot_skin.Skin'   ) -> None:
    r''''''

    assert(not godot_skin is None)
    assert isinstance(godot_skin, get_class('Skin')), 'godot_skin must be Skin'


    self.py__godot_skin = godot_skin






    self._ptr.call_with_return(96,tuple([godot_skin._ptr]))


register_cast_function('GLTFSkin', GLTFSkin.cast)
register_class('GLTFSkin', GLTFSkin)
