# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Image as py4godot_image 
  import py4godot.classes.PackedVector2ArrayTypedArray as py4godot_packedvector2arraytypedarray 
import py4godot.classes.Resource as py4godot_resource 
import py4godot.classes.PackedVector2ArrayTypedArray as py4godot_packedvector2arraytypedarray 
from py4godot.wrappers.wrappers import CPPBitMapWrapper


class BitMap(py4godot_resource.Resource):
  r'''
		A two-dimensional array of boolean values, can be used to efficiently store a binary matrix (every matrix element takes only one bit) and query the values using natural cartesian coordinates.
	'''

  @staticmethod
  def constructor():
    class_ = BitMap.construct_without_init()
    class_._ptr = constructor(165,0, ())
    return class_
  @staticmethod
  def new():
    class_ = BitMap.construct_without_init()
    class_._ptr = constructor(165,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPBitMapWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(165,0, ())


  def generate_wrapper(self):
    return CPPBitMapWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = BitMap.__new__(BitMap)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'BitMap'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(90, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = BitMap.construct_without_init()
    cls._ptr = CPPBitMapWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = BitMap.construct_without_init()
    cls._ptr = CPPBitMapWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def data(self) -> typing.Union['Dictionary']:
    r''''''
    _ret = self. _get_data()
    return _ret
  @data.setter
  def data(self,  value:'Dictionary'):
    self._set_data(value)
  @functools.native_method
  def create(self, size:'Vector2i'   ) -> None:
    r'''
				Creates a bitmap with the specified size, filled with `false`.
			'''

    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'







    self._ptr.call_with_return(77,tuple([size._ptr]))

  @functools.native_method
  def create_from_image_alpha(self, image:'py4godot_image.Image'   , threshold:'float' =0.1  ) -> None:
    r'''
				Creates a bitmap that matches the given image dimensions, every element of the bitmap is set to `false` if the alpha value of the image at that position is equal to `threshold` or less, and `true` in other case.
			'''

    assert(not image is None)
    assert isinstance(image, get_class('Image')), 'image must be Image'
    assert isinstance(threshold, (int, float)), 'threshold must be int or float'








    self._ptr.call_with_return(78,tuple([image._ptr, threshold]))

  @functools.native_method
  def set_bitv(self, position:'Vector2i'   , bit:'bool'   ) -> None:
    r'''
				Sets the bitmap's element at the specified position, to the specified value.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'
    assert isinstance(bit, bool), 'bit must be bool'








    self._ptr.call_with_return(79,tuple([position._ptr, bit]))

  @functools.native_method
  def set_bit(self, x:'int'   , y:'int'   , bit:'bool'   ) -> None:
    r'''
				Sets the bitmap's element at the specified position, to the specified value.
			'''

    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(bit, bool), 'bit must be bool'









    self._ptr.call_with_return(80,tuple([x, y, bit]))

  @functools.native_method
  def get_bitv(self, position:'Vector2i'   ) -> typing.Union[bool]:
    r'''
				Returns bitmap's value at the specified position.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(81,tuple([position._ptr]))
    return _ret


  @functools.native_method
  def get_bit(self, x:'int'   , y:'int'   ) -> typing.Union[bool]:
    r'''
				Returns bitmap's value at the specified position.
			'''

    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([x, y]))
    return _ret


  @functools.native_method
  def set_bit_rect(self, rect:'Rect2i'   , bit:'bool'   ) -> None:
    r'''
				Sets a rectangular portion of the bitmap to the specified value.
			'''

    assert(not rect is None)
    assert isinstance(rect, Rect2i), 'rect must be Rect2i'
    assert isinstance(bit, bool), 'bit must be bool'








    self._ptr.call_with_return(83,tuple([rect._ptr, bit]))

  @functools.native_method
  def get_true_bit_count(self) -> typing.Union[int]:
    r'''
				Returns the number of bitmap elements that are set to `true`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([]))
    return _ret


  @functools.native_method
  def get_size(self) -> typing.Union['Vector2i']:
    r'''
				Returns bitmap's dimensions.
			'''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(85,tuple([]))
    return _ret


  @functools.native_method
  def resize(self, new_size:'Vector2i'   ) -> None:
    r'''
				Resizes the image to `new_size`.
			'''

    assert(not new_size is None)
    assert isinstance(new_size, Vector2i), 'new_size must be Vector2i'







    self._ptr.call_with_return(86,tuple([new_size._ptr]))

  @functools.native_method
  def grow_mask(self, pixels:'int'   , rect:'Rect2i'   ) -> None:
    r'''
				Applies morphological dilation or erosion to the bitmap. If `pixels` is positive, dilation is applied to the bitmap. If `pixels` is negative, erosion is applied to the bitmap. `rect` defines the area where the morphological operation is applied. Pixels located outside the `rect` are unaffected by `grow_mask`.
			'''

    assert isinstance(pixels, (int, float)), 'pixels must be int or float'
    assert(not rect is None)
    assert isinstance(rect, Rect2i), 'rect must be Rect2i'








    self._ptr.call_with_return(87,tuple([pixels, rect._ptr]))

  @functools.native_method
  def convert_to_image(self) -> typing.Union['py4godot_image.Image']:
    r'''
				Returns an image of the same size as the bitmap and with an `enum Image.Format` of type `constant Image.FORMAT_L8`. `true` bits of the bitmap are being converted into white pixels, and `false` bits into black.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Image
    _ret._ptr = self._ptr.call_with_return(88,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def opaque_to_polygons(self, rect:'Rect2i'   , epsilon:'float' =2.0  ) -> typing.Union['py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray']:
    r'''
				Creates an `Array` of polygons covering a rectangular portion of the bitmap. It uses a marching squares algorithm, followed by Ramer-Douglas-Peucker (RDP) reduction of the number of vertices. Each polygon is described as a `PackedVector2Array` of its vertices.
				To get polygons covering the whole bitmap, pass:
				```gdscript
				Rect2(Vector2(), get_size())
				```
				`epsilon` is passed to RDP to control how accurately the polygons cover the bitmap: a lower `epsilon` corresponds to more points in the polygons.
			'''

    assert(not rect is None)
    assert isinstance(rect, Rect2i), 'rect must be Rect2i'
    assert isinstance(epsilon, (int, float)), 'epsilon must be int or float'








    _ret = py4godot_packedvector2arraytypedarray.PackedVector2ArrayTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(89,tuple([rect._ptr, epsilon]))
    return _ret



register_cast_function('BitMap', BitMap.cast)
register_class('BitMap', BitMap)
