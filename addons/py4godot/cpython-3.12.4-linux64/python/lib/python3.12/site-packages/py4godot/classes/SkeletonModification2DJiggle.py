# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.SkeletonModification2D as py4godot_skeletonmodification2d 
from py4godot.wrappers.wrappers import CPPSkeletonModification2DJiggleWrapper


class SkeletonModification2DJiggle(py4godot_skeletonmodification2d.SkeletonModification2D):
  r'''
		This modification moves a series of bones, typically called a bone chain, towards a target. What makes this modification special is that it calculates the velocity and acceleration for each bone in the bone chain, and runs a very light physics-like calculation using the inputted values. This allows the bones to overshoot the target and "jiggle" around. It can be configured to act more like a spring, or sway around like cloth might.
		This modification is useful for adding additional motion to things like hair, the edges of clothing, and more. It has several settings to that allow control over how the joint moves when the target moves.
		**Note:** The Jiggle modifier has `jiggle_joints`, which are the data objects that hold the data for each joint in the Jiggle chain. This is different from than `Bone2D` nodes! Jiggle joints hold the data needed for each `Bone2D` in the bone chain used by the Jiggle modification.
	'''

  @staticmethod
  def constructor():
    class_ = SkeletonModification2DJiggle.construct_without_init()
    class_._ptr = constructor(752,0, ())
    return class_
  @staticmethod
  def new():
    class_ = SkeletonModification2DJiggle.construct_without_init()
    class_._ptr = constructor(752,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPSkeletonModification2DJiggleWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(752,0, ())


  def generate_wrapper(self):
    return CPPSkeletonModification2DJiggleWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = SkeletonModification2DJiggle.__new__(SkeletonModification2DJiggle)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'SkeletonModification2DJiggle'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(124, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = SkeletonModification2DJiggle.construct_without_init()
    cls._ptr = CPPSkeletonModification2DJiggleWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = SkeletonModification2DJiggle.construct_without_init()
    cls._ptr = CPPSkeletonModification2DJiggleWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def target_nodepath(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_target_node()
    return _ret
  @target_nodepath.setter
  def target_nodepath(self,  value:'object'):
    self.set_target_node(value)
  @property
  def jiggle_data_chain_length(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_jiggle_data_chain_length()
    return _ret
  @jiggle_data_chain_length.setter
  def jiggle_data_chain_length(self,  value:'int'):
    self.set_jiggle_data_chain_length(value)
  @property
  def stiffness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_stiffness()
    return _ret
  @stiffness.setter
  def stiffness(self,  value:'float'):
    self.set_stiffness(value)
  @property
  def mass(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_mass()
    return _ret
  @mass.setter
  def mass(self,  value:'float'):
    self.set_mass(value)
  @property
  def damping(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_damping()
    return _ret
  @damping.setter
  def damping(self,  value:'float'):
    self.set_damping(value)
  @property
  def use_gravity(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_use_gravity()
    return _ret
  @use_gravity.setter
  def use_gravity(self,  value:'bool'):
    self.set_use_gravity(value)
  @property
  def gravity(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_gravity()
    return _ret
  @gravity.setter
  def gravity(self,  value:'Vector2'):
    self.set_gravity(value)
  @functools.native_method
  def set_target_node(self, target_nodepath:'object'   ) -> None:
    r''''''

    assert(not target_nodepath is None)
    assert isinstance(target_nodepath, (str, NodePath)), 'target_nodepath must be str or NodePath'


    self.py__target_nodepath = target_nodepath



    assert(isinstance(target_nodepath, (str, NodePath)))
    py_nodepath_target_nodepath = target_nodepath if isinstance(target_nodepath,NodePath) else NodePath.new2(target_nodepath)


    self._ptr.call_with_return(90,tuple([py_nodepath_target_nodepath._ptr]))

  @functools.native_method
  def get_target_node(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([]))

    return _ret


  @functools.native_method
  def set_jiggle_data_chain_length(self, length:'int'   ) -> None:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'


    self.py__jiggle_data_chain_length = length






    self._ptr.call_with_return(92,tuple([length]))

  @functools.native_method
  def get_jiggle_data_chain_length(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([]))

    return _ret


  @functools.native_method
  def set_stiffness(self, stiffness:'float'   ) -> None:
    r''''''

    assert isinstance(stiffness, (int, float)), 'stiffness must be int or float'


    self.py__stiffness = stiffness






    self._ptr.call_with_return(94,tuple([stiffness]))

  @functools.native_method
  def get_stiffness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(95,tuple([]))

    return _ret


  @functools.native_method
  def set_mass(self, mass:'float'   ) -> None:
    r''''''

    assert isinstance(mass, (int, float)), 'mass must be int or float'


    self.py__mass = mass






    self._ptr.call_with_return(96,tuple([mass]))

  @functools.native_method
  def get_mass(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([]))

    return _ret


  @functools.native_method
  def set_damping(self, damping:'float'   ) -> None:
    r''''''

    assert isinstance(damping, (int, float)), 'damping must be int or float'


    self.py__damping = damping






    self._ptr.call_with_return(98,tuple([damping]))

  @functools.native_method
  def get_damping(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([]))

    return _ret


  @functools.native_method
  def set_use_gravity(self, use_gravity:'bool'   ) -> None:
    r''''''

    assert isinstance(use_gravity, bool), 'use_gravity must be bool'


    self.py__use_gravity = use_gravity






    self._ptr.call_with_return(100,tuple([use_gravity]))

  @functools.native_method
  def get_use_gravity(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(101,tuple([]))

    return _ret


  @functools.native_method
  def set_gravity(self, gravity:'Vector2'   ) -> None:
    r''''''

    assert(not gravity is None)
    assert isinstance(gravity, Vector2), 'gravity must be Vector2'


    self.py__gravity = gravity






    self._ptr.call_with_return(102,tuple([gravity._ptr]))

  @functools.native_method
  def get_gravity(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(103,tuple([]))

    return _ret


  @functools.native_method
  def set_use_colliders(self, use_colliders:'bool'   ) -> None:
    r'''
				If `true`, the Jiggle modifier will take colliders into account, keeping them from entering into these collision objects.
			'''

    assert isinstance(use_colliders, bool), 'use_colliders must be bool'







    self._ptr.call_with_return(104,tuple([use_colliders]))

  @functools.native_method
  def get_use_colliders(self) -> typing.Union[bool]:
    r'''
				Returns whether the jiggle modifier is taking physics colliders into account when solving.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(105,tuple([]))
    return _ret


  @functools.native_method
  def set_collision_mask(self, collision_mask:'int'   ) -> None:
    r'''
				Sets the collision mask that the Jiggle modifier will use when reacting to colliders, if the Jiggle modifier is set to take colliders into account.
			'''

    assert isinstance(collision_mask, (int, float)), 'collision_mask must be int or float'







    self._ptr.call_with_return(106,tuple([collision_mask]))

  @functools.native_method
  def get_collision_mask(self) -> typing.Union[int]:
    r'''
				Returns the collision mask used by the Jiggle modifier when collisions are enabled.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(107,tuple([]))
    return _ret


  @functools.native_method
  def set_jiggle_joint_bone2d_node(self, joint_idx:'int'   , bone2d_node:'object'   ) -> None:
    r'''
				Sets the `Bone2D` node assigned to the Jiggle joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert(not bone2d_node is None)
    assert isinstance(bone2d_node, (str, NodePath)), 'bone2d_node must be str or NodePath'






    assert(isinstance(bone2d_node, (str, NodePath)))
    py_nodepath_bone2d_node = bone2d_node if isinstance(bone2d_node,NodePath) else NodePath.new2(bone2d_node)

    self._ptr.call_with_return(108,tuple([joint_idx, py_nodepath_bone2d_node._ptr]))

  @functools.native_method
  def get_jiggle_joint_bone2d_node(self, joint_idx:'int'   ) -> typing.Union['NodePath']:
    r'''
				Returns the `Bone2D` node assigned to the Jiggle joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(109,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_jiggle_joint_bone_index(self, joint_idx:'int'   , bone_idx:'int'   ) -> None:
    r'''
				Sets the bone index, `bone_idx`, of the Jiggle joint at `joint_idx`. When possible, this will also update the `bone2d_node` of the Jiggle joint based on data provided by the linked skeleton.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'








    self._ptr.call_with_return(110,tuple([joint_idx, bone_idx]))

  @functools.native_method
  def get_jiggle_joint_bone_index(self, joint_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the index of the `Bone2D` node assigned to the Jiggle joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(111,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_jiggle_joint_override(self, joint_idx:'int'   , override:'bool'   ) -> None:
    r'''
				Sets whether the Jiggle joint at `joint_idx` should override the default Jiggle joint settings. Setting this to `true` will make the joint use its own settings rather than the default ones attached to the modification.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert isinstance(override, bool), 'override must be bool'








    self._ptr.call_with_return(112,tuple([joint_idx, override]))

  @functools.native_method
  def get_jiggle_joint_override(self, joint_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns a boolean that indicates whether the joint at `joint_idx` is overriding the default Jiggle joint data defined in the modification.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(113,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_jiggle_joint_stiffness(self, joint_idx:'int'   , stiffness:'float'   ) -> None:
    r'''
				Sets the of stiffness of the Jiggle joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert isinstance(stiffness, (int, float)), 'stiffness must be int or float'








    self._ptr.call_with_return(114,tuple([joint_idx, stiffness]))

  @functools.native_method
  def get_jiggle_joint_stiffness(self, joint_idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the stiffness of the Jiggle joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(115,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_jiggle_joint_mass(self, joint_idx:'int'   , mass:'float'   ) -> None:
    r'''
				Sets the of mass of the Jiggle joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert isinstance(mass, (int, float)), 'mass must be int or float'








    self._ptr.call_with_return(116,tuple([joint_idx, mass]))

  @functools.native_method
  def get_jiggle_joint_mass(self, joint_idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the amount of mass of the jiggle joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(117,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_jiggle_joint_damping(self, joint_idx:'int'   , damping:'float'   ) -> None:
    r'''
				Sets the amount of damping of the Jiggle joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert isinstance(damping, (int, float)), 'damping must be int or float'








    self._ptr.call_with_return(118,tuple([joint_idx, damping]))

  @functools.native_method
  def get_jiggle_joint_damping(self, joint_idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the amount of damping of the Jiggle joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(119,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_jiggle_joint_use_gravity(self, joint_idx:'int'   , use_gravity:'bool'   ) -> None:
    r'''
				Sets whether the Jiggle joint at `joint_idx` should use gravity.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert isinstance(use_gravity, bool), 'use_gravity must be bool'








    self._ptr.call_with_return(120,tuple([joint_idx, use_gravity]))

  @functools.native_method
  def get_jiggle_joint_use_gravity(self, joint_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns a boolean that indicates whether the joint at `joint_idx` is using gravity or not.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(121,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_jiggle_joint_gravity(self, joint_idx:'int'   , gravity:'Vector2'   ) -> None:
    r'''
				Sets the gravity vector of the Jiggle joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert(not gravity is None)
    assert isinstance(gravity, Vector2), 'gravity must be Vector2'








    self._ptr.call_with_return(122,tuple([joint_idx, gravity._ptr]))

  @functools.native_method
  def get_jiggle_joint_gravity(self, joint_idx:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns a `Vector2` representing the amount of gravity the Jiggle joint at `joint_idx` is influenced by.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(123,tuple([joint_idx]))
    return _ret



register_cast_function('SkeletonModification2DJiggle', SkeletonModification2DJiggle.cast)
register_class('SkeletonModification2DJiggle', SkeletonModification2DJiggle)
