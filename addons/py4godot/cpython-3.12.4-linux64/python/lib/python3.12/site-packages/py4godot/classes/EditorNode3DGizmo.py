# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.SliderJoint3D as py4godot_sliderjoint3d 
  import py4godot.classes.CharacterBody3D as py4godot_characterbody3d 
  import py4godot.classes.AimModifier3D as py4godot_aimmodifier3d 
  import py4godot.classes.CSGShape3D as py4godot_csgshape3d 
  import py4godot.classes.XRController3D as py4godot_xrcontroller3d 
  import py4godot.classes.CSGCombiner3D as py4godot_csgcombiner3d 
  import py4godot.classes.XRBodyModifier3D as py4godot_xrbodymodifier3d 
  import py4godot.classes.OmniLight3D as py4godot_omnilight3d 
  import py4godot.classes.BoneAttachment3D as py4godot_boneattachment3d 
  import py4godot.classes.ReflectionProbe as py4godot_reflectionprobe 
  import py4godot.classes.LookAtModifier3D as py4godot_lookatmodifier3d 
  import py4godot.classes.XRAnchor3D as py4godot_xranchor3d 
  import py4godot.classes.Node as py4godot_node 
  import py4godot.classes.HingeJoint3D as py4godot_hingejoint3d 
  import py4godot.classes.NavigationLink3D as py4godot_navigationlink3d 
  import py4godot.classes.GPUParticlesCollisionSphere3D as py4godot_gpuparticlescollisionsphere3d 
  import py4godot.classes.CSGPrimitive3D as py4godot_csgprimitive3d 
  import py4godot.classes.VisibleOnScreenNotifier3D as py4godot_visibleonscreennotifier3d 
  import py4godot.classes.SkeletonModifier3D as py4godot_skeletonmodifier3d 
  import py4godot.classes.Joint3D as py4godot_joint3d 
  import py4godot.classes.AnimatedSprite3D as py4godot_animatedsprite3d 
  import py4godot.classes.SpotLight3D as py4godot_spotlight3d 
  import py4godot.classes.SpriteBase3D as py4godot_spritebase3d 
  import py4godot.classes.Skeleton3D as py4godot_skeleton3d 
  import py4godot.classes.VehicleWheel3D as py4godot_vehiclewheel3d 
  import py4godot.classes.ModifierBoneTarget3D as py4godot_modifierbonetarget3d 
  import py4godot.classes.SpringBoneCollisionPlane3D as py4godot_springbonecollisionplane3d 
  import py4godot.classes.PhysicalBone3D as py4godot_physicalbone3d 
  import py4godot.classes.Generic6DOFJoint3D as py4godot_generic6dofjoint3d 
  import py4godot.classes.Node3D as py4godot_node3d 
  import py4godot.classes.SpringBoneCollisionCapsule3D as py4godot_springbonecollisioncapsule3d 
  import py4godot.classes.OpenXRCompositionLayer as py4godot_openxrcompositionlayer 
  import py4godot.classes.GPUParticles3D as py4godot_gpuparticles3d 
  import py4godot.classes.ConeTwistJoint3D as py4godot_conetwistjoint3d 
  import py4godot.classes.VisibleOnScreenEnabler3D as py4godot_visibleonscreenenabler3d 
  import py4godot.classes.PhysicalBoneSimulator3D as py4godot_physicalbonesimulator3d 
  import py4godot.classes.OpenXRRenderModel as py4godot_openxrrendermodel 
  import py4godot.classes.XROrigin3D as py4godot_xrorigin3d 
  import py4godot.classes.CPUParticles3D as py4godot_cpuparticles3d 
  import py4godot.classes.ImporterMeshInstance3D as py4godot_importermeshinstance3d 
  import py4godot.classes.AudioListener3D as py4godot_audiolistener3d 
  import py4godot.classes.CollisionObject3D as py4godot_collisionobject3d 
  import py4godot.classes.LightmapProbe as py4godot_lightmapprobe 
  import py4godot.classes.XRCamera3D as py4godot_xrcamera3d 
  import py4godot.classes.RemoteTransform3D as py4godot_remotetransform3d 
  import py4godot.classes.Mesh as py4godot_mesh 
  import py4godot.classes.NavigationRegion3D as py4godot_navigationregion3d 
  import py4godot.classes.AudioStreamPlayer3D as py4godot_audiostreamplayer3d 
  import py4godot.classes.GPUParticlesAttractorBox3D as py4godot_gpuparticlesattractorbox3d 
  import py4godot.classes.SpringBoneSimulator3D as py4godot_springbonesimulator3d 
  import py4godot.classes.MeshInstance3D as py4godot_meshinstance3d 
  import py4godot.classes.AnimatableBody3D as py4godot_animatablebody3d 
  import py4godot.classes.SkeletonIK3D as py4godot_skeletonik3d 
  import py4godot.classes.CSGSphere3D as py4godot_csgsphere3d 
  import py4godot.classes.Camera3D as py4godot_camera3d 
  import py4godot.classes.EditorNode3DGizmoPlugin as py4godot_editornode3dgizmoplugin 
  import py4godot.classes.BoneConstraint3D as py4godot_boneconstraint3d 
  import py4godot.classes.CollisionShape3D as py4godot_collisionshape3d 
  import py4godot.classes.SpringBoneCollision3D as py4godot_springbonecollision3d 
  import py4godot.classes.CSGPolygon3D as py4godot_csgpolygon3d 
  import py4godot.classes.VoxelGI as py4godot_voxelgi 
  import py4godot.classes.MultiMeshInstance3D as py4godot_multimeshinstance3d 
  import py4godot.classes.Decal as py4godot_decal 
  import py4godot.classes.GridMap as py4godot_gridmap 
  import py4godot.classes.ConvertTransformModifier3D as py4godot_converttransformmodifier3d 
  import py4godot.classes.OpenXRHand as py4godot_openxrhand 
  import py4godot.classes.RayCast3D as py4godot_raycast3d 
  import py4godot.classes.GeometryInstance3D as py4godot_geometryinstance3d 
  import py4godot.classes.GPUParticlesCollisionBox3D as py4godot_gpuparticlescollisionbox3d 
  import py4godot.classes.OpenXRRenderModelManager as py4godot_openxrrendermodelmanager 
  import py4godot.classes.SpringArm3D as py4godot_springarm3d 
  import py4godot.classes.LightmapGI as py4godot_lightmapgi 
  import py4godot.classes.TriangleMesh as py4godot_trianglemesh 
  import py4godot.classes.OpenXRVisibilityMask as py4godot_openxrvisibilitymask 
  import py4godot.classes.GPUParticlesAttractorVectorField3D as py4godot_gpuparticlesattractorvectorfield3d 
  import py4godot.classes.CSGBox3D as py4godot_csgbox3d 
  import py4godot.classes.XRHandModifier3D as py4godot_xrhandmodifier3d 
  import py4godot.classes.Label3D as py4godot_label3d 
  import py4godot.classes.VisualInstance3D as py4godot_visualinstance3d 
  import py4godot.classes.GPUParticlesCollision3D as py4godot_gpuparticlescollision3d 
  import py4godot.classes.RigidBody3D as py4godot_rigidbody3d 
  import py4godot.classes.SpringBoneCollisionSphere3D as py4godot_springbonecollisionsphere3d 
  import py4godot.classes.Material as py4godot_material 
  import py4godot.classes.Light3D as py4godot_light3d 
  import py4godot.classes.ShapeCast3D as py4godot_shapecast3d 
  import py4godot.classes.FogVolume as py4godot_fogvolume 
  import py4godot.classes.CollisionPolygon3D as py4godot_collisionpolygon3d 
  import py4godot.classes.PathFollow3D as py4godot_pathfollow3d 
  import py4godot.classes.PinJoint3D as py4godot_pinjoint3d 
  import py4godot.classes.Sprite3D as py4godot_sprite3d 
  import py4godot.classes.SoftBody3D as py4godot_softbody3d 
  import py4godot.classes.PhysicsBody3D as py4godot_physicsbody3d 
  import py4godot.classes.CSGCylinder3D as py4godot_csgcylinder3d 
  import py4godot.classes.StaticBody3D as py4godot_staticbody3d 
  import py4godot.classes.NavigationObstacle3D as py4godot_navigationobstacle3d 
  import py4godot.classes.GPUParticlesCollisionSDF3D as py4godot_gpuparticlescollisionsdf3d 
  import py4godot.classes.OpenXRCompositionLayerEquirect as py4godot_openxrcompositionlayerequirect 
  import py4godot.classes.CSGMesh3D as py4godot_csgmesh3d 
  import py4godot.classes.GPUParticlesCollisionHeightField3D as py4godot_gpuparticlescollisionheightfield3d 
  import py4godot.classes.XRNode3D as py4godot_xrnode3d 
  import py4godot.classes.DirectionalLight3D as py4godot_directionallight3d 
  import py4godot.classes.Area3D as py4godot_area3d 
  import py4godot.classes.OpenXRCompositionLayerQuad as py4godot_openxrcompositionlayerquad 
  import py4godot.classes.OpenXRCompositionLayerCylinder as py4godot_openxrcompositionlayercylinder 
  import py4godot.classes.GPUParticlesAttractor3D as py4godot_gpuparticlesattractor3d 
  import py4godot.classes.PlaneTypedArray as py4godot_planetypedarray 
  import py4godot.classes.RootMotionView as py4godot_rootmotionview 
  import py4godot.classes.CopyTransformModifier3D as py4godot_copytransformmodifier3d 
  import py4godot.classes.Path3D as py4godot_path3d 
  import py4godot.classes.XRFaceModifier3D as py4godot_xrfacemodifier3d 
  import py4godot.classes.Transform3DTypedArray as py4godot_transform3dtypedarray 
  import py4godot.classes.OccluderInstance3D as py4godot_occluderinstance3d 
  import py4godot.classes.CSGTorus3D as py4godot_csgtorus3d 
  import py4godot.classes.RetargetModifier3D as py4godot_retargetmodifier3d 
  import py4godot.classes.GPUParticlesAttractorSphere3D as py4godot_gpuparticlesattractorsphere3d 
  import py4godot.classes.SkinReference as py4godot_skinreference 
  import py4godot.classes.Marker3D as py4godot_marker3d 
  import py4godot.classes.VehicleBody3D as py4godot_vehiclebody3d 
import py4godot.classes.Node3DGizmo as py4godot_node3dgizmo 
import py4godot.classes.PlaneTypedArray as py4godot_planetypedarray 
import py4godot.classes.Transform3DTypedArray as py4godot_transform3dtypedarray 
from py4godot.wrappers.wrappers import CPPEditorNode3DGizmoWrapper


class EditorNode3DGizmo(py4godot_node3dgizmo.Node3DGizmo):
  r'''
		Gizmo that is used for providing custom visualization and editing (handles and subgizmos) for `Node3D` objects. Can be overridden to create custom gizmos, but for simple gizmos creating an `EditorNode3DGizmoPlugin` is usually recommended.
	'''

  @staticmethod
  def constructor():
    class_ = EditorNode3DGizmo.construct_without_init()
    class_._ptr = constructor(292,0, ())
    return class_
  @staticmethod
  def new():
    class_ = EditorNode3DGizmo.construct_without_init()
    class_._ptr = constructor(292,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEditorNode3DGizmoWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(292,0, ())


  def generate_wrapper(self):
    return CPPEditorNode3DGizmoWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = EditorNode3DGizmo.__new__(EditorNode3DGizmo)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorNode3DGizmo'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(78, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorNode3DGizmo.construct_without_init()
    cls._ptr = CPPEditorNode3DGizmoWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorNode3DGizmo.construct_without_init()
    cls._ptr = CPPEditorNode3DGizmoWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _redraw(self) -> None:
    r'''
				Override this method to add all the gizmo elements whenever a gizmo update is requested. It's common to call `clear` at the beginning of this method and then add visual elements depending on the node's properties.
			'''




    self._ptr.call_with_return(53,tuple([]))

  @functools.native_method
  def _get_handle_name(self, id:'int'   , secondary:'bool'   ) -> typing.Union[str]:
    r'''
				Override this method to return the name of an edited handle (handles must have been previously added by `add_handles`). Handles can be named for reference to the user when editing.
				The `secondary` argument is `true` when the requested handle is secondary (see `add_handles` for more information).
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(secondary, bool), 'secondary must be bool'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([id, secondary]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _is_handle_highlighted(self, id:'int'   , secondary:'bool'   ) -> typing.Union[bool]:
    r'''
				Override this method to return `true` whenever the given handle should be highlighted in the editor.
				The `secondary` argument is `true` when the requested handle is secondary (see `add_handles` for more information).
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(secondary, bool), 'secondary must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(55,tuple([id, secondary]))
    return _ret


  @functools.native_method
  def _get_handle_value(self, id:'int'   , secondary:'bool'   ) -> typing.Union[typing.Any]:
    r'''
				Override this method to return the current value of a handle. This value will be requested at the start of an edit and used as the `restore` argument in `_commit_handle`.
				The `secondary` argument is `true` when the requested handle is secondary (see `add_handles` for more information).
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(secondary, bool), 'secondary must be bool'








    _ret = None
    _ret = self._ptr.call_with_return(56,tuple([id, secondary]))
    return _ret


  @functools.native_method
  def _begin_handle_action(self, id:'int'   , secondary:'bool'   ) -> None:
    r'''
'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(secondary, bool), 'secondary must be bool'








    self._ptr.call_with_return(57,tuple([id, secondary]))

  @functools.native_method
  def _set_handle(self, id:'int'   , secondary:'bool'   , camera:'py4godot_camera3d.Camera3D'   , point:'Vector2'   ) -> None:
    r'''
				Override this method to update the node properties when the user drags a gizmo handle (previously added with `add_handles`). The provided `point` is the mouse position in screen coordinates and the `camera` can be used to convert it to raycasts.
				The `secondary` argument is `true` when the edited handle is secondary (see `add_handles` for more information).
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(secondary, bool), 'secondary must be bool'
    assert(not camera is None)
    assert isinstance(camera, get_class('Camera3D')), 'camera must be Camera3D'
    assert(not point is None)
    assert isinstance(point, Vector2), 'point must be Vector2'










    self._ptr.call_with_return(58,tuple([id, secondary, camera._ptr, point._ptr]))

  @functools.native_method
  def _commit_handle(self, id:'int'   , secondary:'bool'   , restore:'object'   , cancel:'bool'   ) -> None:
    r'''
				Override this method to commit a handle being edited (handles must have been previously added by `add_handles`). This usually means creating an `UndoRedo` action for the change, using the current handle value as "do" and the `restore` argument as "undo".
				If the `cancel` argument is `true`, the `restore` value should be directly set, without any `UndoRedo` action.
				The `secondary` argument is `true` when the committed handle is secondary (see `add_handles` for more information).
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(secondary, bool), 'secondary must be bool'
    
    assert isinstance(cancel, bool), 'cancel must be bool'

    if not (type(restore).__name__ in py4godot.variant_types.core_types or isinstance(restore, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'restore': "
                f"{type(restore).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )









    self._ptr.call_with_return(59,tuple([id, secondary, restore, cancel]))

  @functools.native_method
  def _subgizmos_intersect_ray(self, camera:'py4godot_camera3d.Camera3D'   , point:'Vector2'   ) -> typing.Union[int]:
    r'''
				Override this method to allow selecting subgizmos using mouse clicks. Given a `camera` and a `point` in screen coordinates, this method should return which subgizmo should be selected. The returned value should be a unique subgizmo identifier, which can have any non-negative value and will be used in other virtual methods like `_get_subgizmo_transform` or `_commit_subgizmos`.
			'''

    assert(not camera is None)
    assert isinstance(camera, get_class('Camera3D')), 'camera must be Camera3D'
    assert(not point is None)
    assert isinstance(point, Vector2), 'point must be Vector2'








    _ret = 0
    _ret = self._ptr.call_with_return(60,tuple([camera._ptr, point._ptr]))
    return _ret


  @functools.native_method
  def _subgizmos_intersect_frustum(self, camera:'py4godot_camera3d.Camera3D'   , frustum:'py4godot_planetypedarray.PlaneTypedArray'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Override this method to allow selecting subgizmos using mouse drag box selection. Given a `camera` and a `frustum`, this method should return which subgizmos are contained within the frustum. The `frustum` argument consists of an array with all the `Plane`s that make up the selection frustum. The returned value should contain a list of unique subgizmo identifiers, which can have any non-negative value and will be used in other virtual methods like `_get_subgizmo_transform` or `_commit_subgizmos`.
			'''

    assert(not camera is None)
    assert isinstance(camera, get_class('Camera3D')), 'camera must be Camera3D'
    assert isinstance(frustum, Array), 'frustum must be Array'








    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([camera._ptr, frustum._ptr]))
    return _ret


  @functools.native_method
  def _set_subgizmo_transform(self, id:'int'   , transform:'Transform3D'   ) -> None:
    r'''
				Override this method to update the node properties during subgizmo editing (see `_subgizmos_intersect_ray` and `_subgizmos_intersect_frustum`). The `transform` is given in the `Node3D`'s local coordinate system.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'








    self._ptr.call_with_return(62,tuple([id, transform._ptr]))

  @functools.native_method
  def _get_subgizmo_transform(self, id:'int'   ) -> typing.Union['Transform3D']:
    r'''
				Override this method to return the current transform of a subgizmo. This transform will be requested at the start of an edit and used as the `restore` argument in `_commit_subgizmos`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(63,tuple([id]))
    return _ret


  @functools.native_method
  def _commit_subgizmos(self, ids:'PackedInt32Array'   , restores:'py4godot_transform3dtypedarray.Transform3DTypedArray'   , cancel:'bool'   ) -> None:
    r'''
				Override this method to commit a group of subgizmos being edited (see `_subgizmos_intersect_ray` and `_subgizmos_intersect_frustum`). This usually means creating an `UndoRedo` action for the change, using the current transforms as "do" and the `restores` transforms as "undo".
				If the `cancel` argument is `true`, the `restores` transforms should be directly set, without any `UndoRedo` action.
			'''

    assert(not ids is None)
    assert isinstance(ids, PackedInt32Array), 'ids must be PackedInt32Array'
    assert isinstance(restores, Array), 'restores must be Array'
    assert isinstance(cancel, bool), 'cancel must be bool'









    self._ptr.call_with_return(64,tuple([ids._ptr, restores._ptr, cancel]))

  @functools.native_method
  def add_lines(self, lines:'PackedVector3Array'   , material:'py4godot_material.Material'   , billboard:'bool' =False  , modulate:'Color' = None  ) -> None:
    r'''
				Adds lines to the gizmo (as sets of 2 points), with a given material. The lines are used for visualizing the gizmo. Call this method during `_redraw`.
			'''
    if modulate is None:
      modulate = Color.new0()

    assert(not lines is None)
    assert isinstance(lines, PackedVector3Array), 'lines must be PackedVector3Array'
    assert(not material is None)
    assert isinstance(material, get_class('Material')), 'material must be Material'
    assert isinstance(billboard, bool), 'billboard must be bool'










    self._ptr.call_with_return(65,tuple([lines._ptr, material._ptr, billboard, modulate._ptr]))

  @functools.native_method
  def add_mesh(self, mesh:'py4godot_mesh.Mesh'   , material:'py4godot_material.Material' = None  , transform:'Transform3D' = None  , skeleton:'py4godot_skinreference.SkinReference' = None  ) -> None:
    r'''
				Adds a mesh to the gizmo with the specified `material`, local `transform` and `skeleton`. Call this method during `_redraw`.
			'''
    if material is None:
      material = c_utils.empty_object
    if transform is None:
      transform = Transform3D.new0()
    if skeleton is None:
      skeleton = c_utils.empty_object

    assert(not mesh is None)
    assert isinstance(mesh, get_class('Mesh')), 'mesh must be Mesh'










    self._ptr.call_with_return(66,tuple([mesh._ptr, material._ptr, transform._ptr, skeleton._ptr]))

  @functools.native_method
  def add_collision_segments(self, segments:'PackedVector3Array'   ) -> None:
    r'''
				Adds the specified `segments` to the gizmo's collision shape for picking. Call this method during `_redraw`.
			'''

    assert(not segments is None)
    assert isinstance(segments, PackedVector3Array), 'segments must be PackedVector3Array'







    self._ptr.call_with_return(67,tuple([segments._ptr]))

  @functools.native_method
  def add_collision_triangles(self, triangles:'py4godot_trianglemesh.TriangleMesh'   ) -> None:
    r'''
				Adds collision triangles to the gizmo for picking. A `TriangleMesh` can be generated from a regular `Mesh` too. Call this method during `_redraw`.
			'''

    assert(not triangles is None)
    assert isinstance(triangles, get_class('TriangleMesh')), 'triangles must be TriangleMesh'







    self._ptr.call_with_return(68,tuple([triangles._ptr]))

  @functools.native_method
  def add_unscaled_billboard(self, material:'py4godot_material.Material'   , default_scale:'float' =1  , modulate:'Color' = None  ) -> None:
    r'''
				Adds an unscaled billboard for visualization and selection. Call this method during `_redraw`.
			'''
    if modulate is None:
      modulate = Color.new0()

    assert(not material is None)
    assert isinstance(material, get_class('Material')), 'material must be Material'
    assert isinstance(default_scale, (int, float)), 'default_scale must be int or float'









    self._ptr.call_with_return(69,tuple([material._ptr, default_scale, modulate._ptr]))

  @functools.native_method
  def add_handles(self, handles:'PackedVector3Array'   , material:'py4godot_material.Material'   , ids:'PackedInt32Array'   , billboard:'bool' =False  , secondary:'bool' =False  ) -> None:
    r'''
				Adds a list of handles (points) which can be used to edit the properties of the gizmo's `Node3D`. The `ids` argument can be used to specify a custom identifier for each handle, if an empty array is passed, the ids will be assigned automatically from the `handles` argument order.
				The `secondary` argument marks the added handles as secondary, meaning they will normally have lower selection priority than regular handles. When the user is holding the shift key secondary handles will switch to have higher priority than regular handles. This change in priority can be used to place multiple handles at the same point while still giving the user control on their selection.
				There are virtual methods which will be called upon editing of these handles. Call this method during `_redraw`.
			'''

    assert(not handles is None)
    assert isinstance(handles, PackedVector3Array), 'handles must be PackedVector3Array'
    assert(not material is None)
    assert isinstance(material, get_class('Material')), 'material must be Material'
    assert(not ids is None)
    assert isinstance(ids, PackedInt32Array), 'ids must be PackedInt32Array'
    assert isinstance(billboard, bool), 'billboard must be bool'
    assert isinstance(secondary, bool), 'secondary must be bool'











    self._ptr.call_with_return(70,tuple([handles._ptr, material._ptr, ids._ptr, billboard, secondary]))

  @functools.native_method
  def set_node_3d(self, node:'py4godot_node.Node'   ) -> None:
    r'''
				Sets the reference `Node3D` node for the gizmo. `node` must inherit from `Node3D`.
			'''

    assert(not node is None)
    assert isinstance(node, get_class('Node')), 'node must be Node'







    self._ptr.call_with_return(71,tuple([node._ptr]))

  @functools.native_method
  def get_node_3d(self) -> typing.Any:
    r'''
				Returns the `Node3D` node associated with this gizmo.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Node3D
    _ret._ptr = self._ptr.call_with_return(72,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_plugin(self) -> typing.Union['py4godot_editornode3dgizmoplugin.EditorNode3DGizmoPlugin']:
    r'''
				Returns the `EditorNode3DGizmoPlugin` that owns this gizmo. It's useful to retrieve materials using `EditorNode3DGizmoPlugin.get_material`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: EditorNode3DGizmoPlugin
    _ret._ptr = self._ptr.call_with_return(73,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def clear(self) -> None:
    r'''
				Removes everything in the gizmo including meshes, collisions and handles.
			'''




    self._ptr.call_with_return(74,tuple([]))

  @functools.native_method
  def set_hidden(self, hidden:'bool'   ) -> None:
    r'''
				Sets the gizmo's hidden state. If `true`, the gizmo will be hidden. If `false`, it will be shown.
			'''

    assert isinstance(hidden, bool), 'hidden must be bool'







    self._ptr.call_with_return(75,tuple([hidden]))

  @functools.native_method
  def is_subgizmo_selected(self, id:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given subgizmo is currently selected. Can be used to highlight selected elements during `_redraw`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(76,tuple([id]))
    return _ret


  @functools.native_method
  def get_subgizmo_selection(self) -> typing.Union['PackedInt32Array']:
    r'''
				Returns a list of the currently selected subgizmos. Can be used to highlight selected elements during `_redraw`.
			'''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(77,tuple([]))
    return _ret



register_cast_function('EditorNode3DGizmo', EditorNode3DGizmo.cast)
register_class('EditorNode3DGizmo', EditorNode3DGizmo)
