# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PackedScene as py4godot_packedscene 
import py4godot.classes.TileSetSource as py4godot_tilesetsource 
from py4godot.wrappers.wrappers import CPPTileSetScenesCollectionSourceWrapper


class TileSetScenesCollectionSource(py4godot_tilesetsource.TileSetSource):
  r'''
		When placed on a `TileMapLayer`, tiles from `TileSetScenesCollectionSource` will automatically instantiate an associated scene at the cell's position in the TileMapLayer.
		Scenes are instantiated as children of the `TileMapLayer` after it enters the tree, at the end of the frame (their creation is deferred). If you add/remove a scene tile in the `TileMapLayer` that is already inside the tree, the `TileMapLayer` will automatically instantiate/free the scene accordingly.
		**Note:** Scene tiles all occupy one tile slot and instead use alternate tile ID to identify scene index. `TileSetSource.get_tiles_count` will always return `1`. Use `get_scene_tiles_count` to get a number of scenes in a `TileSetScenesCollectionSource`.
		Use this code if you want to find the scene path at a given tile in `TileMapLayer`:
		
		```gdscript
		var source_id = tile_map_layer.get_cell_source_id(Vector2i(x, y))
		if source_id > -1:
			var scene_source = tile_map_layer.tile_set.get_source(source_id)
			if scene_source is TileSetScenesCollectionSource:
				var alt_id = tile_map_layer.get_cell_alternative_tile(Vector2i(x, y))
				# The assigned PackedScene.
				var scene = scene_source.get_scene_tile_scene(alt_id)
		```
		
		
	'''

  @staticmethod
  def constructor():
    class_ = TileSetScenesCollectionSource.construct_without_init()
    class_._ptr = constructor(840,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TileSetScenesCollectionSource.construct_without_init()
    class_._ptr = constructor(840,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTileSetScenesCollectionSourceWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(840,0, ())


  def generate_wrapper(self):
    return CPPTileSetScenesCollectionSourceWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = TileSetScenesCollectionSource.__new__(TileSetScenesCollectionSource)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TileSetScenesCollectionSource'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(94, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TileSetScenesCollectionSource.construct_without_init()
    cls._ptr = CPPTileSetScenesCollectionSourceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TileSetScenesCollectionSource.construct_without_init()
    cls._ptr = CPPTileSetScenesCollectionSourceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def get_scene_tiles_count(self) -> typing.Union[int]:
    r'''
				Returns the number or scene tiles this TileSet source has.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(83,tuple([]))
    return _ret


  @functools.native_method
  def get_scene_tile_id(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the scene tile ID of the scene tile at `index`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([index]))
    return _ret


  @functools.native_method
  def has_scene_tile_id(self, id:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether this TileSet source has a scene tile with `id`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([id]))
    return _ret


  @functools.native_method
  def create_scene_tile(self, packed_scene:'py4godot_packedscene.PackedScene'   , id_override:'int' =-1  ) -> typing.Union[int]:
    r'''
				Creates a scene-based tile out of the given scene.
				Returns a newly generated unique ID.
			'''

    assert(not packed_scene is None)
    assert isinstance(packed_scene, get_class('PackedScene')), 'packed_scene must be PackedScene'
    assert isinstance(id_override, (int, float)), 'id_override must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([packed_scene._ptr, id_override]))
    return _ret


  @functools.native_method
  def set_scene_tile_id(self, id:'int'   , new_id:'int'   ) -> None:
    r'''
				Changes a scene tile's ID from `id` to `new_id`. This will fail if there is already a tile with an ID equal to `new_id`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(new_id, (int, float)), 'new_id must be int or float'








    self._ptr.call_with_return(87,tuple([id, new_id]))

  @functools.native_method
  def set_scene_tile_scene(self, id:'int'   , packed_scene:'py4godot_packedscene.PackedScene'   ) -> None:
    r'''
				Assigns a `PackedScene` resource to the scene tile with `id`. This will fail if the scene does not extend `CanvasItem`, as positioning properties are needed to place the scene on the `TileMapLayer`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not packed_scene is None)
    assert isinstance(packed_scene, get_class('PackedScene')), 'packed_scene must be PackedScene'








    self._ptr.call_with_return(88,tuple([id, packed_scene._ptr]))

  @functools.native_method
  def get_scene_tile_scene(self, id:'int'   ) -> typing.Union['py4godot_packedscene.PackedScene']:
    r'''
				Returns the `PackedScene` resource of scene tile with `id`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: PackedScene
    _ret._ptr = self._ptr.call_with_return(89,tuple([id]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_scene_tile_display_placeholder(self, id:'int'   , display_placeholder:'bool'   ) -> None:
    r'''
				Sets whether or not the scene tile with `id` should display a placeholder in the editor. This might be useful for scenes that are not visible.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(display_placeholder, bool), 'display_placeholder must be bool'








    self._ptr.call_with_return(90,tuple([id, display_placeholder]))

  @functools.native_method
  def get_scene_tile_display_placeholder(self, id:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether the scene tile with `id` displays a placeholder in the editor.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(91,tuple([id]))
    return _ret


  @functools.native_method
  def remove_scene_tile(self, id:'int'   ) -> None:
    r'''
				Remove the scene tile with `id`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    self._ptr.call_with_return(92,tuple([id]))

  @functools.native_method
  def get_next_scene_tile_id(self) -> typing.Union[int]:
    r'''
				Returns the scene ID a following call to `create_scene_tile` would return.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([]))
    return _ret



register_cast_function('TileSetScenesCollectionSource', TileSetScenesCollectionSource.cast)
register_class('TileSetScenesCollectionSource', TileSetScenesCollectionSource)
