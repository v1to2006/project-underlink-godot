# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.Tree as py4godot_tree 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.TextEdit as py4godot_textedit 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.GraphElement as py4godot_graphelement 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.RichTextLabel as py4godot_richtextlabel 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.TabBar as py4godot_tabbar 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.GraphNode as py4godot_graphnode 
  import py4godot.classes.TextServerExtension as py4godot_textserverextension 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.TextServer as py4godot_textserver 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.Container as py4godot_container 
  import py4godot.classes.TextServerAdvanced as py4godot_textserveradvanced 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.TextServerDummy as py4godot_textserverdummy 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.PopupMenu as py4godot_popupmenu 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.FoldableContainer as py4godot_foldablecontainer 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.TabContainer as py4godot_tabcontainer 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
import py4godot.classes.Control as py4godot_control 
from py4godot.wrappers.wrappers import CPPLineEditWrapper

class MenuItems:
  MENU_CUT = 0
  MENU_COPY = 1
  MENU_PASTE = 2
  MENU_CLEAR = 3
  MENU_SELECT_ALL = 4
  MENU_UNDO = 5
  MENU_REDO = 6
  MENU_SUBMENU_TEXT_DIR = 7
  MENU_DIR_INHERITED = 8
  MENU_DIR_AUTO = 9
  MENU_DIR_LTR = 10
  MENU_DIR_RTL = 11
  MENU_DISPLAY_UCC = 12
  MENU_SUBMENU_INSERT_UCC = 13
  MENU_INSERT_LRM = 14
  MENU_INSERT_RLM = 15
  MENU_INSERT_LRE = 16
  MENU_INSERT_RLE = 17
  MENU_INSERT_LRO = 18
  MENU_INSERT_RLO = 19
  MENU_INSERT_PDF = 20
  MENU_INSERT_ALM = 21
  MENU_INSERT_LRI = 22
  MENU_INSERT_RLI = 23
  MENU_INSERT_FSI = 24
  MENU_INSERT_PDI = 25
  MENU_INSERT_ZWJ = 26
  MENU_INSERT_ZWNJ = 27
  MENU_INSERT_WJ = 28
  MENU_INSERT_SHY = 29
  MENU_EMOJI_AND_SYMBOL = 30
  MENU_MAX = 31
class VirtualKeyboardType:
  KEYBOARD_TYPE_DEFAULT = 0
  KEYBOARD_TYPE_MULTILINE = 1
  KEYBOARD_TYPE_NUMBER = 2
  KEYBOARD_TYPE_NUMBER_DECIMAL = 3
  KEYBOARD_TYPE_PHONE = 4
  KEYBOARD_TYPE_EMAIL_ADDRESS = 5
  KEYBOARD_TYPE_PASSWORD = 6
  KEYBOARD_TYPE_URL = 7


class LineEdit(py4godot_control.Control):
  r'''
		`LineEdit` provides an input field for editing a single line of text.
		- When the `LineEdit` control is focused using the keyboard arrow keys, it will only gain focus and not enter edit mode.
		- To enter edit mode, click on the control with the mouse, see also `keep_editing_on_text_submit`.
		- To exit edit mode, press `ui_text_submit` or `ui_cancel` (by default `kbd`Escape`/kbd`) actions.
		- Check `edit`, `unedit`, `is_editing`, and `signal editing_toggled` for more information.
		While entering text, it is possible to insert special characters using Unicode, OEM or Windows alt codes:
		- To enter Unicode codepoints, hold `kbd`Alt`/kbd` and type the codepoint on the numpad. For example, to enter the character `Ã¡` (U+00E1), hold `kbd`Alt`/kbd` and type `kbd`+E1`/kbd` on the numpad (the leading zeroes can be omitted).
		- To enter OEM codepoints, hold `kbd`Alt`/kbd` and type the code on the numpad. For example, to enter the character `Ã¡` (OEM 160), hold `kbd`Alt`/kbd` and type `160` on the numpad.
		- To enter Windows codepoints, hold `kbd`Alt`/kbd` and type the code on the numpad. For example, to enter the character `Ã¡` (Windows 0225), hold `kbd`Alt`/kbd` and type `kbd`0`/kbd`, `kbd`2`/kbd`, `kbd`2`/kbd`, `kbd`5`/kbd` on the numpad. The leading zero here must **not** be omitted, as this is how Windows codepoints are distinguished from OEM codepoints.
		**Important:**
		- Focusing the `LineEdit` with `ui_focus_next` (by default `kbd`Tab`/kbd`) or `ui_focus_prev` (by default `kbd`Shift + Tab`/kbd`) or `Control.grab_focus` still enters edit mode (for compatibility).
		`LineEdit` features many built-in shortcuts that are always available (`kbd`Ctrl`/kbd` here maps to `kbd`Cmd`/kbd` on macOS):
		- `kbd`Ctrl + C`/kbd`: Copy
		- `kbd`Ctrl + X`/kbd`: Cut
		- `kbd`Ctrl + V`/kbd` or `kbd`Ctrl + Y`/kbd`: Paste/"yank"
		- `kbd`Ctrl + Z`/kbd`: Undo
		- `kbd`Ctrl + ~`/kbd`: Swap input direction.
		- `kbd`Ctrl + Shift + Z`/kbd`: Redo
		- `kbd`Ctrl + U`/kbd`: Delete text from the caret position to the beginning of the line
		- `kbd`Ctrl + K`/kbd`: Delete text from the caret position to the end of the line
		- `kbd`Ctrl + A`/kbd`: Select all text
		- `kbd`Up Arrow`/kbd`/`kbd`Down Arrow`/kbd`: Move the caret to the beginning/end of the line
		On macOS, some extra keyboard shortcuts are available:
		- `kbd`Cmd + F`/kbd`: Same as `kbd`Right Arrow`/kbd`, move the caret one character right
		- `kbd`Cmd + B`/kbd`: Same as `kbd`Left Arrow`/kbd`, move the caret one character left
		- `kbd`Cmd + P`/kbd`: Same as `kbd`Up Arrow`/kbd`, move the caret to the previous line
		- `kbd`Cmd + N`/kbd`: Same as `kbd`Down Arrow`/kbd`, move the caret to the next line
		- `kbd`Cmd + D`/kbd`: Same as `kbd`Delete`/kbd`, delete the character on the right side of caret
		- `kbd`Cmd + H`/kbd`: Same as `kbd`Backspace`/kbd`, delete the character on the left side of the caret
		- `kbd`Cmd + A`/kbd`: Same as `kbd`Home`/kbd`, move the caret to the beginning of the line
		- `kbd`Cmd + E`/kbd`: Same as `kbd`End`/kbd`, move the caret to the end of the line
		- `kbd`Cmd + Left Arrow`/kbd`: Same as `kbd`Home`/kbd`, move the caret to the beginning of the line
		- `kbd`Cmd + Right Arrow`/kbd`: Same as `kbd`End`/kbd`, move the caret to the end of the line
		**Note:** Caret movement shortcuts listed above are not affected by `shortcut_keys_enabled`.
	'''

  @staticmethod
  def constructor():
    class_ = LineEdit.construct_without_init()
    class_._ptr = constructor(458,0, ())
    return class_
  @staticmethod
  def new():
    class_ = LineEdit.construct_without_init()
    class_._ptr = constructor(458,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPLineEditWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(458,0, ())


  def generate_wrapper(self):
    return CPPLineEditWrapper()
  def init_signals(self):
    super().init_signals()
    text_changed_name = utils.py_string_to_string_name("text_changed")
    self.text_changed = signals.BuiltinSignal(self, text_changed_name)
    text_change_rejected_name = utils.py_string_to_string_name("text_change_rejected")
    self.text_change_rejected = signals.BuiltinSignal(self, text_change_rejected_name)
    text_submitted_name = utils.py_string_to_string_name("text_submitted")
    self.text_submitted = signals.BuiltinSignal(self, text_submitted_name)
    editing_toggled_name = utils.py_string_to_string_name("editing_toggled")
    self.editing_toggled = signals.BuiltinSignal(self, editing_toggled_name)

  @staticmethod
  def construct_without_init():
    cls = LineEdit.__new__(LineEdit)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'LineEdit'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = LineEdit.construct_without_init()
    cls._ptr = CPPLineEditWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = LineEdit.construct_without_init()
    cls._ptr = CPPLineEditWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def text(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_text()
    return _ret
  @text.setter
  def text(self,  value:'str'):
    self.set_text(value)
  @property
  def placeholder_text(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_placeholder()
    return _ret
  @placeholder_text.setter
  def placeholder_text(self,  value:'str'):
    self.set_placeholder(value)
  @property
  def alignment(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_horizontal_alignment()
    return _ret
  @alignment.setter
  def alignment(self,  value:'int'):
    self.set_horizontal_alignment(value)
  @property
  def max_length(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_length()
    return _ret
  @max_length.setter
  def max_length(self,  value:'int'):
    self.set_max_length(value)
  @property
  def editable(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_editable()
    return _ret
  @editable.setter
  def editable(self,  value:'bool'):
    self.set_editable(value)
  @property
  def keep_editing_on_text_submit(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_editing_kept_on_text_submit()
    return _ret
  @keep_editing_on_text_submit.setter
  def keep_editing_on_text_submit(self,  value:'bool'):
    self.set_keep_editing_on_text_submit(value)
  @property
  def expand_to_text_length(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_expand_to_text_length_enabled()
    return _ret
  @expand_to_text_length.setter
  def expand_to_text_length(self,  value:'bool'):
    self.set_expand_to_text_length_enabled(value)
  @property
  def context_menu_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_context_menu_enabled()
    return _ret
  @context_menu_enabled.setter
  def context_menu_enabled(self,  value:'bool'):
    self.set_context_menu_enabled(value)
  @property
  def emoji_menu_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_emoji_menu_enabled()
    return _ret
  @emoji_menu_enabled.setter
  def emoji_menu_enabled(self,  value:'bool'):
    self.set_emoji_menu_enabled(value)
  @property
  def backspace_deletes_composite_character_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_backspace_deletes_composite_character_enabled()
    return _ret
  @backspace_deletes_composite_character_enabled.setter
  def backspace_deletes_composite_character_enabled(self,  value:'bool'):
    self.set_backspace_deletes_composite_character_enabled(value)
  @property
  def virtual_keyboard_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_virtual_keyboard_enabled()
    return _ret
  @virtual_keyboard_enabled.setter
  def virtual_keyboard_enabled(self,  value:'bool'):
    self.set_virtual_keyboard_enabled(value)
  @property
  def virtual_keyboard_show_on_focus(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_virtual_keyboard_show_on_focus()
    return _ret
  @virtual_keyboard_show_on_focus.setter
  def virtual_keyboard_show_on_focus(self,  value:'bool'):
    self.set_virtual_keyboard_show_on_focus(value)
  @property
  def virtual_keyboard_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_virtual_keyboard_type()
    return _ret
  @virtual_keyboard_type.setter
  def virtual_keyboard_type(self,  value:'int'):
    self.set_virtual_keyboard_type(value)
  @property
  def clear_button_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_clear_button_enabled()
    return _ret
  @clear_button_enabled.setter
  def clear_button_enabled(self,  value:'bool'):
    self.set_clear_button_enabled(value)
  @property
  def shortcut_keys_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_shortcut_keys_enabled()
    return _ret
  @shortcut_keys_enabled.setter
  def shortcut_keys_enabled(self,  value:'bool'):
    self.set_shortcut_keys_enabled(value)
  @property
  def middle_mouse_paste_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_middle_mouse_paste_enabled()
    return _ret
  @middle_mouse_paste_enabled.setter
  def middle_mouse_paste_enabled(self,  value:'bool'):
    self.set_middle_mouse_paste_enabled(value)
  @property
  def selecting_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_selecting_enabled()
    return _ret
  @selecting_enabled.setter
  def selecting_enabled(self,  value:'bool'):
    self.set_selecting_enabled(value)
  @property
  def deselect_on_focus_loss_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_deselect_on_focus_loss_enabled()
    return _ret
  @deselect_on_focus_loss_enabled.setter
  def deselect_on_focus_loss_enabled(self,  value:'bool'):
    self.set_deselect_on_focus_loss_enabled(value)
  @property
  def drag_and_drop_selection_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_drag_and_drop_selection_enabled()
    return _ret
  @drag_and_drop_selection_enabled.setter
  def drag_and_drop_selection_enabled(self,  value:'bool'):
    self.set_drag_and_drop_selection_enabled(value)
  @property
  def right_icon(self) -> typing.Any:
    r''''''
    _ret = self. get_right_icon()
    return _ret
  @right_icon.setter
  def right_icon(self,  value:'py4godot_object.Object'):
    self.set_right_icon(value)
  @property
  def flat(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_flat()
    return _ret
  @flat.setter
  def flat(self,  value:'bool'):
    self.set_flat(value)
  @property
  def draw_control_chars(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_draw_control_chars()
    return _ret
  @draw_control_chars.setter
  def draw_control_chars(self,  value:'bool'):
    self.set_draw_control_chars(value)
  @property
  def select_all_on_focus(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_select_all_on_focus()
    return _ret
  @select_all_on_focus.setter
  def select_all_on_focus(self,  value:'bool'):
    self.set_select_all_on_focus(value)
  @property
  def caret_blink(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_caret_blink_enabled()
    return _ret
  @caret_blink.setter
  def caret_blink(self,  value:'bool'):
    self.set_caret_blink_enabled(value)
  @property
  def caret_blink_interval(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_caret_blink_interval()
    return _ret
  @caret_blink_interval.setter
  def caret_blink_interval(self,  value:'float'):
    self.set_caret_blink_interval(value)
  @property
  def caret_column(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_caret_column()
    return _ret
  @caret_column.setter
  def caret_column(self,  value:'int'):
    self.set_caret_column(value)
  @property
  def caret_force_displayed(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_caret_force_displayed()
    return _ret
  @caret_force_displayed.setter
  def caret_force_displayed(self,  value:'bool'):
    self.set_caret_force_displayed(value)
  @property
  def caret_mid_grapheme(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_caret_mid_grapheme_enabled()
    return _ret
  @caret_mid_grapheme.setter
  def caret_mid_grapheme(self,  value:'bool'):
    self.set_caret_mid_grapheme_enabled(value)
  @property
  def secret(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_secret()
    return _ret
  @secret.setter
  def secret(self,  value:'bool'):
    self.set_secret(value)
  @property
  def secret_character(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_secret_character()
    return _ret
  @secret_character.setter
  def secret_character(self,  value:'str'):
    self.set_secret_character(value)
  @property
  def text_direction(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_text_direction()
    return _ret
  @text_direction.setter
  def text_direction(self,  value:'int'):
    self.set_text_direction(value)
  @property
  def language(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_language()
    return _ret
  @language.setter
  def language(self,  value:'str'):
    self.set_language(value)
  @property
  def structured_text_bidi_override(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_structured_text_bidi_override()
    return _ret
  @structured_text_bidi_override.setter
  def structured_text_bidi_override(self,  value:'int'):
    self.set_structured_text_bidi_override(value)
  @property
  def structured_text_bidi_override_options(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_structured_text_bidi_override_options()
    return _ret
  @structured_text_bidi_override_options.setter
  def structured_text_bidi_override_options(self,  value:'Array'):
    self.set_structured_text_bidi_override_options(value)
  @functools.native_method
  def has_ime_text(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the user has text in the `url=https://en.wikipedia.org/wiki/Input_method`Input Method Editor`/url` (IME).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(433,tuple([]))
    return _ret


  @functools.native_method
  def cancel_ime(self) -> None:
    r'''
				Closes the `url=https://en.wikipedia.org/wiki/Input_method`Input Method Editor`/url` (IME) if it is open. Any text in the IME will be lost.
			'''




    self._ptr.call_with_return(434,tuple([]))

  @functools.native_method
  def apply_ime(self) -> None:
    r'''
				Applies text from the `url=https://en.wikipedia.org/wiki/Input_method`Input Method Editor`/url` (IME) and closes the IME if it is open.
			'''




    self._ptr.call_with_return(435,tuple([]))

  @functools.native_method
  def set_horizontal_alignment(self, alignment:'int'  ) -> None:
    r''''''

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'


    self.py__alignment = alignment






    self._ptr.call_with_return(436,tuple([alignment]))

  @functools.native_method
  def get_horizontal_alignment(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(437,tuple([]))

    return _ret


  @functools.native_method
  def edit(self) -> None:
    r'''
				Allows entering edit mode whether the `LineEdit` is focused or not. If `hide_focus` is `true`, the focused state will not be shown (see `Control.grab_focus`).
				See also `keep_editing_on_text_submit`.
			'''




    self._ptr.call_with_return(438,tuple([]))

  @functools.native_method
  def unedit(self) -> None:
    r'''
				Allows exiting edit mode while preserving focus.
			'''




    self._ptr.call_with_return(439,tuple([]))

  @functools.native_method
  def is_editing(self) -> typing.Union[bool]:
    r'''
				Returns whether the `LineEdit` is being edited.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(440,tuple([]))
    return _ret


  @functools.native_method
  def set_keep_editing_on_text_submit(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__keep_editing_on_text_submit = enable






    self._ptr.call_with_return(441,tuple([enable]))

  @functools.native_method
  def is_editing_kept_on_text_submit(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(442,tuple([]))

    return _ret


  @functools.native_method
  def clear(self) -> None:
    r'''
				Erases the `LineEdit`'s `text`.
			'''




    self._ptr.call_with_return(443,tuple([]))

  @functools.native_method
  def select(self, from_:'int' =0  , to:'int' =-1  ) -> None:
    r'''
				Selects characters inside `LineEdit` between `from` and `to`. By default, `from` is at the beginning and `to` at the end.
				
				```gdscript
				text = "Welcome"
				select() # Will select "Welcome".
				select(4) # Will select "ome".
				select(2, 5) # Will select "lco".
				```
				
				
			'''

    assert isinstance(from_, (int, float)), 'from_ must be int or float'
    assert isinstance(to, (int, float)), 'to must be int or float'








    self._ptr.call_with_return(444,tuple([from_, to]))

  @functools.native_method
  def select_all(self) -> None:
    r'''
				Selects the whole `String`.
			'''




    self._ptr.call_with_return(445,tuple([]))

  @functools.native_method
  def deselect(self) -> None:
    r'''
				Clears the current selection.
			'''




    self._ptr.call_with_return(446,tuple([]))

  @functools.native_method
  def has_undo(self) -> typing.Union[bool]:
    r'''
				Returns `true` if an "undo" action is available.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(447,tuple([]))
    return _ret


  @functools.native_method
  def has_redo(self) -> typing.Union[bool]:
    r'''
				Returns `true` if a "redo" action is available.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(448,tuple([]))
    return _ret


  @functools.native_method
  def has_selection(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the user has selected text.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(449,tuple([]))
    return _ret


  @functools.native_method
  def get_selected_text(self) -> typing.Union[str]:
    r'''
				Returns the text inside the selection.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(450,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_selection_from_column(self) -> typing.Union[int]:
    r'''
				Returns the selection begin column.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(451,tuple([]))
    return _ret


  @functools.native_method
  def get_selection_to_column(self) -> typing.Union[int]:
    r'''
				Returns the selection end column.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(452,tuple([]))
    return _ret


  @functools.native_method
  def set_text(self, text:'str'   ) -> None:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'


    self.py__text = text



    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    py__string_text = utils.py_string_to_string(text)
    py__string_text.shouldBeDeleted = False


    self._ptr.call_with_return(453,tuple([py__string_text._ptr]))

  @functools.native_method
  def get_text(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(454,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_draw_control_chars(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(455,tuple([]))

    return _ret


  @functools.native_method
  def set_draw_control_chars(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__draw_control_chars = enable






    self._ptr.call_with_return(456,tuple([enable]))

  @functools.native_method
  def set_text_direction(self, direction:'int'  ) -> None:
    r''''''

    assert isinstance(direction, (int, float)), 'direction must be int or float'


    self.py__text_direction = direction






    self._ptr.call_with_return(457,tuple([direction]))

  @functools.native_method
  def get_text_direction(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(458,tuple([]))

    return _ret


  @functools.native_method
  def set_language(self, language:'str'   ) -> None:
    r''''''

    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'


    self.py__language = language



    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    py__string_language = utils.py_string_to_string(language)
    py__string_language.shouldBeDeleted = False


    self._ptr.call_with_return(459,tuple([py__string_language._ptr]))

  @functools.native_method
  def get_language(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(460,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_structured_text_bidi_override(self, parser:'int'  ) -> None:
    r''''''

    assert isinstance(parser, (int, float)), 'parser must be int or float'


    self.py__structured_text_bidi_override = parser






    self._ptr.call_with_return(461,tuple([parser]))

  @functools.native_method
  def get_structured_text_bidi_override(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(462,tuple([]))

    return _ret


  @functools.native_method
  def set_structured_text_bidi_override_options(self, args:'Array'   ) -> None:
    r''''''

    assert(not args is None)
    assert isinstance(args, Array), 'args must be Array'


    self.py__structured_text_bidi_override_options = args






    self._ptr.call_with_return(463,tuple([args._ptr]))

  @functools.native_method
  def get_structured_text_bidi_override_options(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(464,tuple([]))

    return _ret


  @functools.native_method
  def set_placeholder(self, text:'str'   ) -> None:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'


    self.py__placeholder_text = text



    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    py__string_text = utils.py_string_to_string(text)
    py__string_text.shouldBeDeleted = False


    self._ptr.call_with_return(465,tuple([py__string_text._ptr]))

  @functools.native_method
  def get_placeholder(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(466,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_caret_column(self, position:'int'   ) -> None:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'


    self.py__caret_column = position






    self._ptr.call_with_return(467,tuple([position]))

  @functools.native_method
  def get_caret_column(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(468,tuple([]))

    return _ret


  @functools.native_method
  def get_next_composite_character_column(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the correct column at the end of a composite character like â¤ï¸â€ðŸ©¹ (mending heart; Unicode: `U+2764 U+FE0F U+200D U+1FA79`) which is comprised of more than one Unicode code point, if the caret is at the start of the composite character. Also returns the correct column with the caret at mid grapheme and for non-composite characters.
				**Note:** To check at caret location use `get_next_composite_character_column(get_caret_column())`
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(469,tuple([column]))
    return _ret


  @functools.native_method
  def get_previous_composite_character_column(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the correct column at the start of a composite character like â¤ï¸â€ðŸ©¹ (mending heart; Unicode: `U+2764 U+FE0F U+200D U+1FA79`) which is comprised of more than one Unicode code point, if the caret is at the end of the composite character. Also returns the correct column with the caret at mid grapheme and for non-composite characters.
				**Note:** To check at caret location use `get_previous_composite_character_column(get_caret_column())`
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(470,tuple([column]))
    return _ret


  @functools.native_method
  def get_scroll_offset(self) -> typing.Union[float]:
    r'''
				Returns the scroll offset due to `caret_column`, as a number of characters.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(471,tuple([]))
    return _ret


  @functools.native_method
  def set_expand_to_text_length_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__expand_to_text_length = enabled






    self._ptr.call_with_return(472,tuple([enabled]))

  @functools.native_method
  def is_expand_to_text_length_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(473,tuple([]))

    return _ret


  @functools.native_method
  def set_caret_blink_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__caret_blink = enabled






    self._ptr.call_with_return(474,tuple([enabled]))

  @functools.native_method
  def is_caret_blink_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(475,tuple([]))

    return _ret


  @functools.native_method
  def set_caret_mid_grapheme_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__caret_mid_grapheme = enabled






    self._ptr.call_with_return(476,tuple([enabled]))

  @functools.native_method
  def is_caret_mid_grapheme_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(477,tuple([]))

    return _ret


  @functools.native_method
  def set_caret_force_displayed(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__caret_force_displayed = enabled






    self._ptr.call_with_return(478,tuple([enabled]))

  @functools.native_method
  def is_caret_force_displayed(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(479,tuple([]))

    return _ret


  @functools.native_method
  def set_caret_blink_interval(self, interval:'float'   ) -> None:
    r''''''

    assert isinstance(interval, (int, float)), 'interval must be int or float'


    self.py__caret_blink_interval = interval






    self._ptr.call_with_return(480,tuple([interval]))

  @functools.native_method
  def get_caret_blink_interval(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(481,tuple([]))

    return _ret


  @functools.native_method
  def set_max_length(self, chars:'int'   ) -> None:
    r''''''

    assert isinstance(chars, (int, float)), 'chars must be int or float'


    self.py__max_length = chars






    self._ptr.call_with_return(482,tuple([chars]))

  @functools.native_method
  def get_max_length(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(483,tuple([]))

    return _ret


  @functools.native_method
  def insert_text_at_caret(self, text:'str'   ) -> None:
    r'''
				Inserts `text` at the caret. If the resulting value is longer than `max_length`, nothing happens.
			'''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    self._ptr.call_with_return(484,tuple([py_string_text._ptr]))

  @functools.native_method
  def delete_char_at_caret(self) -> None:
    r'''
				Deletes one character at the caret's current position (equivalent to pressing `kbd`Delete`/kbd`).
			'''




    self._ptr.call_with_return(485,tuple([]))

  @functools.native_method
  def delete_text(self, from_column:'int'   , to_column:'int'   ) -> None:
    r'''
				Deletes a section of the `text` going from position `from_column` to `to_column`. Both parameters should be within the text's length.
			'''

    assert isinstance(from_column, (int, float)), 'from_column must be int or float'
    assert isinstance(to_column, (int, float)), 'to_column must be int or float'








    self._ptr.call_with_return(486,tuple([from_column, to_column]))

  @functools.native_method
  def set_editable(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__editable = enabled






    self._ptr.call_with_return(487,tuple([enabled]))

  @functools.native_method
  def is_editable(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(488,tuple([]))

    return _ret


  @functools.native_method
  def set_secret(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__secret = enabled






    self._ptr.call_with_return(489,tuple([enabled]))

  @functools.native_method
  def is_secret(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(490,tuple([]))

    return _ret


  @functools.native_method
  def set_secret_character(self, character:'str'   ) -> None:
    r''''''

    assert(not character is None)
    assert isinstance(character, (str, String)), 'character must be str or String'


    self.py__secret_character = character



    assert(isinstance(character, (str, String)))
    py_string_character = character if isinstance(character, StringName) else c_utils.py_string_to_string(character)

    py__string_character = utils.py_string_to_string(character)
    py__string_character.shouldBeDeleted = False


    self._ptr.call_with_return(491,tuple([py__string_character._ptr]))

  @functools.native_method
  def get_secret_character(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(492,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def menu_option(self, option:'int'   ) -> None:
    r'''
				Executes a given action as defined in the `enum MenuItems` enum.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'







    self._ptr.call_with_return(493,tuple([option]))

  @functools.native_method
  def get_menu(self) -> typing.Union['py4godot_popupmenu.PopupMenu']:
    r'''
				Returns the `PopupMenu` of this `LineEdit`. By default, this menu is displayed when right-clicking on the `LineEdit`.
				You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see `enum MenuItems`). For example:
				
				```gdscript
				func _ready():
					var menu = get_menu()
					# Remove all items after "Redo".
					menu.item_count = menu.get_item_index(MENU_REDO) + 1
					# Add custom items.
					menu.add_separator()
					menu.add_item("Insert Date", MENU_MAX + 1)
					# Connect callback.
					menu.id_pressed.connect(_on_item_pressed)

				func _on_item_pressed(id):
					if id == MENU_MAX + 1:
						insert_text_at_caret(Time.get_date_string_from_system())
				```
				
				
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their `Window.visible` property.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: PopupMenu
    _ret._ptr = self._ptr.call_with_return(494,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def is_menu_visible(self) -> typing.Union[bool]:
    r'''
				Returns whether the menu is visible. Use this instead of `get_menu().visible` to improve performance (so the creation of the menu is avoided).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(495,tuple([]))
    return _ret


  @functools.native_method
  def set_context_menu_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__context_menu_enabled = enable






    self._ptr.call_with_return(496,tuple([enable]))

  @functools.native_method
  def is_context_menu_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(497,tuple([]))

    return _ret


  @functools.native_method
  def set_emoji_menu_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__emoji_menu_enabled = enable






    self._ptr.call_with_return(498,tuple([enable]))

  @functools.native_method
  def is_emoji_menu_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(499,tuple([]))

    return _ret


  @functools.native_method
  def set_backspace_deletes_composite_character_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__backspace_deletes_composite_character_enabled = enable






    self._ptr.call_with_return(500,tuple([enable]))

  @functools.native_method
  def is_backspace_deletes_composite_character_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(501,tuple([]))

    return _ret


  @functools.native_method
  def set_virtual_keyboard_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__virtual_keyboard_enabled = enable






    self._ptr.call_with_return(502,tuple([enable]))

  @functools.native_method
  def is_virtual_keyboard_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(503,tuple([]))

    return _ret


  @functools.native_method
  def set_virtual_keyboard_show_on_focus(self, show_on_focus:'bool'   ) -> None:
    r''''''

    assert isinstance(show_on_focus, bool), 'show_on_focus must be bool'


    self.py__virtual_keyboard_show_on_focus = show_on_focus






    self._ptr.call_with_return(504,tuple([show_on_focus]))

  @functools.native_method
  def get_virtual_keyboard_show_on_focus(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(505,tuple([]))

    return _ret


  @functools.native_method
  def set_virtual_keyboard_type(self, type:'int'  ) -> None:
    r''''''

    assert isinstance(type, (int, float)), 'type must be int or float'


    self.py__virtual_keyboard_type = type






    self._ptr.call_with_return(506,tuple([type]))

  @functools.native_method
  def get_virtual_keyboard_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(507,tuple([]))

    return _ret


  @functools.native_method
  def set_clear_button_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__clear_button_enabled = enable






    self._ptr.call_with_return(508,tuple([enable]))

  @functools.native_method
  def is_clear_button_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(509,tuple([]))

    return _ret


  @functools.native_method
  def set_shortcut_keys_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__shortcut_keys_enabled = enable






    self._ptr.call_with_return(510,tuple([enable]))

  @functools.native_method
  def is_shortcut_keys_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(511,tuple([]))

    return _ret


  @functools.native_method
  def set_middle_mouse_paste_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__middle_mouse_paste_enabled = enable






    self._ptr.call_with_return(512,tuple([enable]))

  @functools.native_method
  def is_middle_mouse_paste_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(513,tuple([]))

    return _ret


  @functools.native_method
  def set_selecting_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__selecting_enabled = enable






    self._ptr.call_with_return(514,tuple([enable]))

  @functools.native_method
  def is_selecting_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(515,tuple([]))

    return _ret


  @functools.native_method
  def set_deselect_on_focus_loss_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__deselect_on_focus_loss_enabled = enable






    self._ptr.call_with_return(516,tuple([enable]))

  @functools.native_method
  def is_deselect_on_focus_loss_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(517,tuple([]))

    return _ret


  @functools.native_method
  def set_drag_and_drop_selection_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__drag_and_drop_selection_enabled = enable






    self._ptr.call_with_return(518,tuple([enable]))

  @functools.native_method
  def is_drag_and_drop_selection_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(519,tuple([]))

    return _ret


  @functools.native_method
  def set_right_icon(self, icon:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'


    self.py__right_icon = icon






    self._ptr.call_with_return(520,tuple([icon._ptr]))

  @functools.native_method
  def get_right_icon(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(521,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_flat(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__flat = enabled






    self._ptr.call_with_return(522,tuple([enabled]))

  @functools.native_method
  def is_flat(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(523,tuple([]))

    return _ret


  @functools.native_method
  def set_select_all_on_focus(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__select_all_on_focus = enabled






    self._ptr.call_with_return(524,tuple([enabled]))

  @functools.native_method
  def is_select_all_on_focus(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(525,tuple([]))

    return _ret



register_cast_function('LineEdit', LineEdit.cast)
register_class('LineEdit', LineEdit)
