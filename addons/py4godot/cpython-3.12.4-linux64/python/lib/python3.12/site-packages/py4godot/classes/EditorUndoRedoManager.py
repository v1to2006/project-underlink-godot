# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.UndoRedo as py4godot_undoredo 
import py4godot.classes.Object as py4godot_object 
from py4godot.wrappers.wrappers import CPPEditorUndoRedoManagerWrapper

class SpecialHistory:
  GLOBAL_HISTORY = 0
  REMOTE_HISTORY = -9
  INVALID_HISTORY = -99


class EditorUndoRedoManager(py4godot_object.Object):
  r'''
		`EditorUndoRedoManager` is a manager for `UndoRedo` objects associated with edited scenes. Each scene has its own undo history and `EditorUndoRedoManager` ensures that each action performed in the editor gets associated with a proper scene. For actions not related to scenes (`ProjectSettings` edits, external resources, etc.), a separate global history is used.
		The usage is mostly the same as `UndoRedo`. You create and commit actions and the manager automatically decides under-the-hood what scenes it belongs to. The scene is deduced based on the first operation in an action, using the object from the operation. The rules are as follows:
		- If the object is a `Node`, use the currently edited scene;
		- If the object is a built-in resource, use the scene from its path;
		- If the object is external resource or anything else, use global history.
		This guessing can sometimes yield false results, so you can provide a custom context object when creating an action.
		`EditorUndoRedoManager` is intended to be used by Godot editor plugins. You can obtain it using `EditorPlugin.get_undo_redo`. For non-editor uses or plugins that don't need to integrate with the editor's undo history, use `UndoRedo` instead.
		The manager's API is mostly the same as in `UndoRedo`, so you can refer to its documentation for more examples. The main difference is that `EditorUndoRedoManager` uses object + method name for actions, instead of `Callable`.
	'''

  @staticmethod
  def constructor():
    class_ = EditorUndoRedoManager.construct_without_init()
    class_._ptr = constructor(317,0, ())
    return class_
  @staticmethod
  def new():
    class_ = EditorUndoRedoManager.construct_without_init()
    class_._ptr = constructor(317,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEditorUndoRedoManagerWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(317,0, ())


  def generate_wrapper(self):
    return CPPEditorUndoRedoManagerWrapper()
  def init_signals(self):
    super().init_signals()
    history_changed_name = utils.py_string_to_string_name("history_changed")
    self.history_changed = signals.BuiltinSignal(self, history_changed_name)
    version_changed_name = utils.py_string_to_string_name("version_changed")
    self.version_changed = signals.BuiltinSignal(self, version_changed_name)

  @staticmethod
  def construct_without_init():
    cls = EditorUndoRedoManager.__new__(EditorUndoRedoManager)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorUndoRedoManager'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorUndoRedoManager.construct_without_init()
    cls._ptr = CPPEditorUndoRedoManagerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorUndoRedoManager.construct_without_init()
    cls._ptr = CPPEditorUndoRedoManagerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def create_action(self, name:'str'   , merge_mode:'int'  =0, custom_context:'py4godot_object.Object' = None  , backward_undo_ops:'bool' =False  , mark_unsaved:'bool' =True  ) -> None:
    r'''
				Create a new action. After this is called, do all your calls to `add_do_method`, `add_undo_method`, `add_do_property`, and `add_undo_property`, then commit the action with `commit_action`.
				The way actions are merged is dictated by the `merge_mode` argument.
				If `custom_context` object is provided, it will be used for deducing target history (instead of using the first operation).
				The way undo operation are ordered in actions is dictated by `backward_undo_ops`. When `backward_undo_ops` is `false` undo option are ordered in the same order they were added. Which means the first operation to be added will be the first to be undone.
				If `mark_unsaved` is `false`, the action will not mark the history as unsaved. This is useful for example for actions that change a selection, or a setting that will be saved automatically. Otherwise, this should be left to `true` if the action requires saving by the user or if it can cause data loss when left unsaved.
			'''

    if custom_context is None:
      custom_context = c_utils.empty_object

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert isinstance(merge_mode, (int, float)), 'merge_mode must be int or float'
    assert isinstance(backward_undo_ops, bool), 'backward_undo_ops must be bool'
    assert isinstance(mark_unsaved, bool), 'mark_unsaved must be bool'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)





    self._ptr.call_with_return(49,tuple([py_string_name._ptr, merge_mode, custom_context._ptr, backward_undo_ops, mark_unsaved]))

  @functools.native_method
  def commit_action(self, execute:'bool' =True  ) -> None:
    r'''
				Commits the action. If `execute` is `true` (default), all "do" methods/properties are called/set when this function is called.
			'''

    assert isinstance(execute, bool), 'execute must be bool'







    self._ptr.call_with_return(50,tuple([execute]))

  @functools.native_method
  def is_committing_action(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the `EditorUndoRedoManager` is currently committing the action, i.e. running its "do" method or property change (see `commit_action`).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(51,tuple([]))
    return _ret


  @functools.native_method
  def force_fixed_history(self) -> None:
    r'''
				Forces the next operation (e.g. `add_do_method`) to use the action's history rather than guessing it from the object. This is sometimes needed when a history can't be correctly determined, like for a nested resource that doesn't have a path yet.
				This method should only be used when absolutely necessary, otherwise it might cause invalid history state. For most of complex cases, the `custom_context` parameter of `create_action` is sufficient.
			'''




    self._ptr.call_with_return(52,tuple([]))

  @functools.native_method
  def add_do_method(self, object_:'py4godot_object.Object'   , method:'object'   , *varargs) -> None:
    r'''
				Register a method that will be called when the action is committed (i.e. the "do" action).
				If this is the first operation, the `object` will be used to deduce target undo history.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not method is None)
    assert isinstance(method, (str, StringName)), 'method must be str or StringName'

    for arg in varargs:
      if not (type(arg).__name__ in py4godot.variant_types.core_types or isinstance(arg, classes.Object.Object)):
        raise ValueError(
            f"Unsupported type in varargs: {type(arg).__name__}. "
            "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
            "and built-in types int, float, and bool."
        )




    assert(isinstance(method, (str, StringName)))
    py_stringname_method = method if isinstance(method, StringName) else c_utils.py_string_to_string_name(method)

    self._ptr.call_with_return(53,tuple([object_._ptr, py_stringname_method._ptr, *varargs]))

  @functools.native_method
  def add_undo_method(self, object_:'py4godot_object.Object'   , method:'object'   , *varargs) -> None:
    r'''
				Register a method that will be called when the action is undone (i.e. the "undo" action).
				If this is the first operation, the `object` will be used to deduce target undo history.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not method is None)
    assert isinstance(method, (str, StringName)), 'method must be str or StringName'

    for arg in varargs:
      if not (type(arg).__name__ in py4godot.variant_types.core_types or isinstance(arg, classes.Object.Object)):
        raise ValueError(
            f"Unsupported type in varargs: {type(arg).__name__}. "
            "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
            "and built-in types int, float, and bool."
        )




    assert(isinstance(method, (str, StringName)))
    py_stringname_method = method if isinstance(method, StringName) else c_utils.py_string_to_string_name(method)

    self._ptr.call_with_return(54,tuple([object_._ptr, py_stringname_method._ptr, *varargs]))

  @functools.native_method
  def add_do_property(self, object_:'py4godot_object.Object'   , property:'object'   , value:'object'   ) -> None:
    r'''
				Register a property value change for "do".
				If this is the first operation, the `object` will be used to deduce target undo history.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not property is None)
    assert isinstance(property, (str, StringName)), 'property must be str or StringName'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(property, (str, StringName)))
    py_stringname_property = property if isinstance(property, StringName) else c_utils.py_string_to_string_name(property)


    self._ptr.call_with_return(55,tuple([object_._ptr, py_stringname_property._ptr, value]))

  @functools.native_method
  def add_undo_property(self, object_:'py4godot_object.Object'   , property:'object'   , value:'object'   ) -> None:
    r'''
				Register a property value change for "undo".
				If this is the first operation, the `object` will be used to deduce target undo history.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not property is None)
    assert isinstance(property, (str, StringName)), 'property must be str or StringName'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(property, (str, StringName)))
    py_stringname_property = property if isinstance(property, StringName) else c_utils.py_string_to_string_name(property)


    self._ptr.call_with_return(56,tuple([object_._ptr, py_stringname_property._ptr, value]))

  @functools.native_method
  def add_do_reference(self, object_:'py4godot_object.Object'   ) -> None:
    r'''
				Register a reference for "do" that will be erased if the "do" history is lost. This is useful mostly for new nodes created for the "do" call. Do not use for resources.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'







    self._ptr.call_with_return(57,tuple([object_._ptr]))

  @functools.native_method
  def add_undo_reference(self, object_:'py4godot_object.Object'   ) -> None:
    r'''
				Register a reference for "undo" that will be erased if the "undo" history is lost. This is useful mostly for nodes removed with the "do" call (not the "undo" call!).
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'







    self._ptr.call_with_return(58,tuple([object_._ptr]))

  @functools.native_method
  def get_object_history_id(self, object_:'py4godot_object.Object'   ) -> typing.Union[int]:
    r'''
				Returns the history ID deduced from the given `object`. It can be used with `get_history_undo_redo`.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'







    _ret = 0
    _ret = self._ptr.call_with_return(59,tuple([object_._ptr]))
    return _ret


  @functools.native_method
  def get_history_undo_redo(self, id:'int'   ) -> typing.Union['py4godot_undoredo.UndoRedo']:
    r'''
				Returns the `UndoRedo` object associated with the given history `id`.
				`id` above `0` are mapped to the opened scene tabs (but it doesn't match their order). `id` of `0` or lower have special meaning (see `enum SpecialHistory`).
				Best used with `get_object_history_id`. This method is only provided in case you need some more advanced methods of `UndoRedo` (but keep in mind that directly operating on the `UndoRedo` object might affect editor's stability).
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: UndoRedo
    _ret._ptr = self._ptr.call_with_return(60,tuple([id]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def clear_history(self, id:'int' =-99  , increase_version:'bool' =True  ) -> None:
    r'''
				Clears the given undo history. You can clear history for a specific scene, global history, or for all histories at once (except `constant REMOTE_HISTORY`) if `id` is `constant INVALID_HISTORY`.
				If `increase_version` is `true`, the undo history version will be increased, marking it as unsaved. Useful for operations that modify the scene, but don't support undo.
				```gdscript
				var scene_root = EditorInterface.get_edited_scene_root()
				var undo_redo = EditorInterface.get_editor_undo_redo()
				undo_redo.clear_history(undo_redo.get_object_history_id(scene_root))
				```
				**Note:** If you want to mark an edited scene as unsaved without clearing its history, use `EditorInterface.mark_scene_as_unsaved` instead.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(increase_version, bool), 'increase_version must be bool'








    self._ptr.call_with_return(61,tuple([id, increase_version]))


register_cast_function('EditorUndoRedoManager', EditorUndoRedoManager.cast)
register_class('EditorUndoRedoManager', EditorUndoRedoManager)
