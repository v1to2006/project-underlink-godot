# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.AimModifier3D as py4godot_aimmodifier3d 
  import py4godot.classes.ConvertTransformModifier3D as py4godot_converttransformmodifier3d 
  import py4godot.classes.SkeletonIK3D as py4godot_skeletonik3d 
  import py4godot.classes.PhysicalBoneSimulator3D as py4godot_physicalbonesimulator3d 
  import py4godot.classes.XRBodyModifier3D as py4godot_xrbodymodifier3d 
  import py4godot.classes.Tween as py4godot_tween 
  import py4godot.classes.RetargetModifier3D as py4godot_retargetmodifier3d 
  import py4godot.classes.BoneConstraint3D as py4godot_boneconstraint3d 
  import py4godot.classes.XRHandModifier3D as py4godot_xrhandmodifier3d 
  import py4godot.classes.ModifierBoneTarget3D as py4godot_modifierbonetarget3d 
  import py4godot.classes.SpringBoneSimulator3D as py4godot_springbonesimulator3d 
  import py4godot.classes.CopyTransformModifier3D as py4godot_copytransformmodifier3d 
import py4godot.classes.SkeletonModifier3D as py4godot_skeletonmodifier3d 
from py4godot.wrappers.wrappers import CPPLookAtModifier3DWrapper

class OriginFrom:
  ORIGIN_FROM_SELF = 0
  ORIGIN_FROM_SPECIFIC_BONE = 1
  ORIGIN_FROM_EXTERNAL_NODE = 2


class LookAtModifier3D(py4godot_skeletonmodifier3d.SkeletonModifier3D):
  r'''
		This `SkeletonModifier3D` rotates a bone to look at a target. This is helpful for moving a character's head to look at the player, rotating a turret to look at a target, or any other case where you want to make a bone rotate towards something quickly and easily.
		When applying multiple `LookAtModifier3D`s, the `LookAtModifier3D` assigned to the parent bone must be put above the `LookAtModifier3D` assigned to the child bone in the list in order for the child bone results to be correct.
	'''

  @staticmethod
  def constructor():
    class_ = LookAtModifier3D.construct_without_init()
    class_._ptr = constructor(461,0, ())
    return class_
  @staticmethod
  def new():
    class_ = LookAtModifier3D.construct_without_init()
    class_._ptr = constructor(461,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPLookAtModifier3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(461,0, ())


  def generate_wrapper(self):
    return CPPLookAtModifier3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = LookAtModifier3D.__new__(LookAtModifier3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'LookAtModifier3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = LookAtModifier3D.construct_without_init()
    cls._ptr = CPPLookAtModifier3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = LookAtModifier3D.construct_without_init()
    cls._ptr = CPPLookAtModifier3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def target_node(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_target_node()
    return _ret
  @target_node.setter
  def target_node(self,  value:'object'):
    self.set_target_node(value)
  @property
  def bone_name(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_bone_name()
    return _ret
  @bone_name.setter
  def bone_name(self,  value:'str'):
    self.set_bone_name(value)
  @property
  def bone(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_bone()
    return _ret
  @bone.setter
  def bone(self,  value:'int'):
    self.set_bone(value)
  @property
  def forward_axis(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_forward_axis()
    return _ret
  @forward_axis.setter
  def forward_axis(self,  value:'int'):
    self.set_forward_axis(value)
  @property
  def primary_rotation_axis(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_primary_rotation_axis()
    return _ret
  @primary_rotation_axis.setter
  def primary_rotation_axis(self,  value:'int'):
    self.set_primary_rotation_axis(value)
  @property
  def use_secondary_rotation(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_secondary_rotation()
    return _ret
  @use_secondary_rotation.setter
  def use_secondary_rotation(self,  value:'bool'):
    self.set_use_secondary_rotation(value)
  @property
  def origin_from(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_origin_from()
    return _ret
  @origin_from.setter
  def origin_from(self,  value:'int'):
    self.set_origin_from(value)
  @property
  def origin_bone_name(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_origin_bone_name()
    return _ret
  @origin_bone_name.setter
  def origin_bone_name(self,  value:'str'):
    self.set_origin_bone_name(value)
  @property
  def origin_bone(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_origin_bone()
    return _ret
  @origin_bone.setter
  def origin_bone(self,  value:'int'):
    self.set_origin_bone(value)
  @property
  def origin_external_node(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_origin_external_node()
    return _ret
  @origin_external_node.setter
  def origin_external_node(self,  value:'object'):
    self.set_origin_external_node(value)
  @property
  def origin_offset(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_origin_offset()
    return _ret
  @origin_offset.setter
  def origin_offset(self,  value:'Vector3'):
    self.set_origin_offset(value)
  @property
  def origin_safe_margin(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_origin_safe_margin()
    return _ret
  @origin_safe_margin.setter
  def origin_safe_margin(self,  value:'float'):
    self.set_origin_safe_margin(value)
  @property
  def duration(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_duration()
    return _ret
  @duration.setter
  def duration(self,  value:'float'):
    self.set_duration(value)
  @property
  def transition_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_transition_type()
    return _ret
  @transition_type.setter
  def transition_type(self,  value:'int'):
    self.set_transition_type(value)
  @property
  def ease_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_ease_type()
    return _ret
  @ease_type.setter
  def ease_type(self,  value:'int'):
    self.set_ease_type(value)
  @property
  def use_angle_limitation(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_angle_limitation()
    return _ret
  @use_angle_limitation.setter
  def use_angle_limitation(self,  value:'bool'):
    self.set_use_angle_limitation(value)
  @property
  def symmetry_limitation(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_limitation_symmetry()
    return _ret
  @symmetry_limitation.setter
  def symmetry_limitation(self,  value:'bool'):
    self.set_symmetry_limitation(value)
  @property
  def primary_limit_angle(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_primary_limit_angle()
    return _ret
  @primary_limit_angle.setter
  def primary_limit_angle(self,  value:'float'):
    self.set_primary_limit_angle(value)
  @property
  def primary_damp_threshold(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_primary_damp_threshold()
    return _ret
  @primary_damp_threshold.setter
  def primary_damp_threshold(self,  value:'float'):
    self.set_primary_damp_threshold(value)
  @property
  def primary_positive_limit_angle(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_primary_positive_limit_angle()
    return _ret
  @primary_positive_limit_angle.setter
  def primary_positive_limit_angle(self,  value:'float'):
    self.set_primary_positive_limit_angle(value)
  @property
  def primary_positive_damp_threshold(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_primary_positive_damp_threshold()
    return _ret
  @primary_positive_damp_threshold.setter
  def primary_positive_damp_threshold(self,  value:'float'):
    self.set_primary_positive_damp_threshold(value)
  @property
  def primary_negative_limit_angle(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_primary_negative_limit_angle()
    return _ret
  @primary_negative_limit_angle.setter
  def primary_negative_limit_angle(self,  value:'float'):
    self.set_primary_negative_limit_angle(value)
  @property
  def primary_negative_damp_threshold(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_primary_negative_damp_threshold()
    return _ret
  @primary_negative_damp_threshold.setter
  def primary_negative_damp_threshold(self,  value:'float'):
    self.set_primary_negative_damp_threshold(value)
  @property
  def secondary_limit_angle(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_secondary_limit_angle()
    return _ret
  @secondary_limit_angle.setter
  def secondary_limit_angle(self,  value:'float'):
    self.set_secondary_limit_angle(value)
  @property
  def secondary_damp_threshold(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_secondary_damp_threshold()
    return _ret
  @secondary_damp_threshold.setter
  def secondary_damp_threshold(self,  value:'float'):
    self.set_secondary_damp_threshold(value)
  @property
  def secondary_positive_limit_angle(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_secondary_positive_limit_angle()
    return _ret
  @secondary_positive_limit_angle.setter
  def secondary_positive_limit_angle(self,  value:'float'):
    self.set_secondary_positive_limit_angle(value)
  @property
  def secondary_positive_damp_threshold(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_secondary_positive_damp_threshold()
    return _ret
  @secondary_positive_damp_threshold.setter
  def secondary_positive_damp_threshold(self,  value:'float'):
    self.set_secondary_positive_damp_threshold(value)
  @property
  def secondary_negative_limit_angle(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_secondary_negative_limit_angle()
    return _ret
  @secondary_negative_limit_angle.setter
  def secondary_negative_limit_angle(self,  value:'float'):
    self.set_secondary_negative_limit_angle(value)
  @property
  def secondary_negative_damp_threshold(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_secondary_negative_damp_threshold()
    return _ret
  @secondary_negative_damp_threshold.setter
  def secondary_negative_damp_threshold(self,  value:'float'):
    self.set_secondary_negative_damp_threshold(value)
  @functools.native_method
  def set_target_node(self, target_node:'object'   ) -> None:
    r''''''

    assert(not target_node is None)
    assert isinstance(target_node, (str, NodePath)), 'target_node must be str or NodePath'


    self.py__target_node = target_node



    assert(isinstance(target_node, (str, NodePath)))
    py_nodepath_target_node = target_node if isinstance(target_node,NodePath) else NodePath.new2(target_node)


    self._ptr.call_with_return(260,tuple([py_nodepath_target_node._ptr]))

  @functools.native_method
  def get_target_node(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(261,tuple([]))

    return _ret


  @functools.native_method
  def set_bone_name(self, bone_name:'str'   ) -> None:
    r''''''

    assert(not bone_name is None)
    assert isinstance(bone_name, (str, String)), 'bone_name must be str or String'


    self.py__bone_name = bone_name



    assert(isinstance(bone_name, (str, String)))
    py_string_bone_name = bone_name if isinstance(bone_name, StringName) else c_utils.py_string_to_string(bone_name)

    py__string_bone_name = utils.py_string_to_string(bone_name)
    py__string_bone_name.shouldBeDeleted = False


    self._ptr.call_with_return(262,tuple([py__string_bone_name._ptr]))

  @functools.native_method
  def get_bone_name(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(263,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_bone(self, bone:'int'   ) -> None:
    r''''''

    assert isinstance(bone, (int, float)), 'bone must be int or float'


    self.py__bone = bone






    self._ptr.call_with_return(264,tuple([bone]))

  @functools.native_method
  def get_bone(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(265,tuple([]))

    return _ret


  @functools.native_method
  def set_forward_axis(self, forward_axis:'int'  ) -> None:
    r''''''

    assert isinstance(forward_axis, (int, float)), 'forward_axis must be int or float'


    self.py__forward_axis = forward_axis






    self._ptr.call_with_return(266,tuple([forward_axis]))

  @functools.native_method
  def get_forward_axis(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(267,tuple([]))

    return _ret


  @functools.native_method
  def set_primary_rotation_axis(self, axis:'int'  ) -> None:
    r''''''

    assert isinstance(axis, (int, float)), 'axis must be int or float'


    self.py__primary_rotation_axis = axis






    self._ptr.call_with_return(268,tuple([axis]))

  @functools.native_method
  def get_primary_rotation_axis(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(269,tuple([]))

    return _ret


  @functools.native_method
  def set_use_secondary_rotation(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__use_secondary_rotation = enabled






    self._ptr.call_with_return(270,tuple([enabled]))

  @functools.native_method
  def is_using_secondary_rotation(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(271,tuple([]))

    return _ret


  @functools.native_method
  def set_origin_safe_margin(self, margin:'float'   ) -> None:
    r''''''

    assert isinstance(margin, (int, float)), 'margin must be int or float'


    self.py__origin_safe_margin = margin






    self._ptr.call_with_return(272,tuple([margin]))

  @functools.native_method
  def get_origin_safe_margin(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(273,tuple([]))

    return _ret


  @functools.native_method
  def set_origin_from(self, origin_from:'int'  ) -> None:
    r''''''

    assert isinstance(origin_from, (int, float)), 'origin_from must be int or float'


    self.py__origin_from = origin_from






    self._ptr.call_with_return(274,tuple([origin_from]))

  @functools.native_method
  def get_origin_from(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(275,tuple([]))

    return _ret


  @functools.native_method
  def set_origin_bone_name(self, bone_name:'str'   ) -> None:
    r''''''

    assert(not bone_name is None)
    assert isinstance(bone_name, (str, String)), 'bone_name must be str or String'


    self.py__origin_bone_name = bone_name



    assert(isinstance(bone_name, (str, String)))
    py_string_bone_name = bone_name if isinstance(bone_name, StringName) else c_utils.py_string_to_string(bone_name)

    py__string_bone_name = utils.py_string_to_string(bone_name)
    py__string_bone_name.shouldBeDeleted = False


    self._ptr.call_with_return(276,tuple([py__string_bone_name._ptr]))

  @functools.native_method
  def get_origin_bone_name(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(277,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_origin_bone(self, bone:'int'   ) -> None:
    r''''''

    assert isinstance(bone, (int, float)), 'bone must be int or float'


    self.py__origin_bone = bone






    self._ptr.call_with_return(278,tuple([bone]))

  @functools.native_method
  def get_origin_bone(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(279,tuple([]))

    return _ret


  @functools.native_method
  def set_origin_external_node(self, external_node:'object'   ) -> None:
    r''''''

    assert(not external_node is None)
    assert isinstance(external_node, (str, NodePath)), 'external_node must be str or NodePath'


    self.py__origin_external_node = external_node



    assert(isinstance(external_node, (str, NodePath)))
    py_nodepath_external_node = external_node if isinstance(external_node,NodePath) else NodePath.new2(external_node)


    self._ptr.call_with_return(280,tuple([py_nodepath_external_node._ptr]))

  @functools.native_method
  def get_origin_external_node(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(281,tuple([]))

    return _ret


  @functools.native_method
  def set_origin_offset(self, offset:'Vector3'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector3), 'offset must be Vector3'


    self.py__origin_offset = offset






    self._ptr.call_with_return(282,tuple([offset._ptr]))

  @functools.native_method
  def get_origin_offset(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(283,tuple([]))

    return _ret


  @functools.native_method
  def set_duration(self, duration:'float'   ) -> None:
    r''''''

    assert isinstance(duration, (int, float)), 'duration must be int or float'


    self.py__duration = duration






    self._ptr.call_with_return(284,tuple([duration]))

  @functools.native_method
  def get_duration(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(285,tuple([]))

    return _ret


  @functools.native_method
  def set_transition_type(self, transition_type:'int'  ) -> None:
    r''''''

    assert isinstance(transition_type, (int, float)), 'transition_type must be int or float'


    self.py__transition_type = transition_type






    self._ptr.call_with_return(286,tuple([transition_type]))

  @functools.native_method
  def get_transition_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(287,tuple([]))

    return _ret


  @functools.native_method
  def set_ease_type(self, ease_type:'int'  ) -> None:
    r''''''

    assert isinstance(ease_type, (int, float)), 'ease_type must be int or float'


    self.py__ease_type = ease_type






    self._ptr.call_with_return(288,tuple([ease_type]))

  @functools.native_method
  def get_ease_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(289,tuple([]))

    return _ret


  @functools.native_method
  def set_use_angle_limitation(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__use_angle_limitation = enabled






    self._ptr.call_with_return(290,tuple([enabled]))

  @functools.native_method
  def is_using_angle_limitation(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(291,tuple([]))

    return _ret


  @functools.native_method
  def set_symmetry_limitation(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__symmetry_limitation = enabled






    self._ptr.call_with_return(292,tuple([enabled]))

  @functools.native_method
  def is_limitation_symmetry(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(293,tuple([]))

    return _ret


  @functools.native_method
  def set_primary_limit_angle(self, angle:'float'   ) -> None:
    r''''''

    assert isinstance(angle, (int, float)), 'angle must be int or float'


    self.py__primary_limit_angle = angle






    self._ptr.call_with_return(294,tuple([angle]))

  @functools.native_method
  def get_primary_limit_angle(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(295,tuple([]))

    return _ret


  @functools.native_method
  def set_primary_damp_threshold(self, power:'float'   ) -> None:
    r''''''

    assert isinstance(power, (int, float)), 'power must be int or float'


    self.py__primary_damp_threshold = power






    self._ptr.call_with_return(296,tuple([power]))

  @functools.native_method
  def get_primary_damp_threshold(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(297,tuple([]))

    return _ret


  @functools.native_method
  def set_primary_positive_limit_angle(self, angle:'float'   ) -> None:
    r''''''

    assert isinstance(angle, (int, float)), 'angle must be int or float'


    self.py__primary_positive_limit_angle = angle






    self._ptr.call_with_return(298,tuple([angle]))

  @functools.native_method
  def get_primary_positive_limit_angle(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(299,tuple([]))

    return _ret


  @functools.native_method
  def set_primary_positive_damp_threshold(self, power:'float'   ) -> None:
    r''''''

    assert isinstance(power, (int, float)), 'power must be int or float'


    self.py__primary_positive_damp_threshold = power






    self._ptr.call_with_return(300,tuple([power]))

  @functools.native_method
  def get_primary_positive_damp_threshold(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(301,tuple([]))

    return _ret


  @functools.native_method
  def set_primary_negative_limit_angle(self, angle:'float'   ) -> None:
    r''''''

    assert isinstance(angle, (int, float)), 'angle must be int or float'


    self.py__primary_negative_limit_angle = angle






    self._ptr.call_with_return(302,tuple([angle]))

  @functools.native_method
  def get_primary_negative_limit_angle(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(303,tuple([]))

    return _ret


  @functools.native_method
  def set_primary_negative_damp_threshold(self, power:'float'   ) -> None:
    r''''''

    assert isinstance(power, (int, float)), 'power must be int or float'


    self.py__primary_negative_damp_threshold = power






    self._ptr.call_with_return(304,tuple([power]))

  @functools.native_method
  def get_primary_negative_damp_threshold(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(305,tuple([]))

    return _ret


  @functools.native_method
  def set_secondary_limit_angle(self, angle:'float'   ) -> None:
    r''''''

    assert isinstance(angle, (int, float)), 'angle must be int or float'


    self.py__secondary_limit_angle = angle






    self._ptr.call_with_return(306,tuple([angle]))

  @functools.native_method
  def get_secondary_limit_angle(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(307,tuple([]))

    return _ret


  @functools.native_method
  def set_secondary_damp_threshold(self, power:'float'   ) -> None:
    r''''''

    assert isinstance(power, (int, float)), 'power must be int or float'


    self.py__secondary_damp_threshold = power






    self._ptr.call_with_return(308,tuple([power]))

  @functools.native_method
  def get_secondary_damp_threshold(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(309,tuple([]))

    return _ret


  @functools.native_method
  def set_secondary_positive_limit_angle(self, angle:'float'   ) -> None:
    r''''''

    assert isinstance(angle, (int, float)), 'angle must be int or float'


    self.py__secondary_positive_limit_angle = angle






    self._ptr.call_with_return(310,tuple([angle]))

  @functools.native_method
  def get_secondary_positive_limit_angle(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(311,tuple([]))

    return _ret


  @functools.native_method
  def set_secondary_positive_damp_threshold(self, power:'float'   ) -> None:
    r''''''

    assert isinstance(power, (int, float)), 'power must be int or float'


    self.py__secondary_positive_damp_threshold = power






    self._ptr.call_with_return(312,tuple([power]))

  @functools.native_method
  def get_secondary_positive_damp_threshold(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(313,tuple([]))

    return _ret


  @functools.native_method
  def set_secondary_negative_limit_angle(self, angle:'float'   ) -> None:
    r''''''

    assert isinstance(angle, (int, float)), 'angle must be int or float'


    self.py__secondary_negative_limit_angle = angle






    self._ptr.call_with_return(314,tuple([angle]))

  @functools.native_method
  def get_secondary_negative_limit_angle(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(315,tuple([]))

    return _ret


  @functools.native_method
  def set_secondary_negative_damp_threshold(self, power:'float'   ) -> None:
    r''''''

    assert isinstance(power, (int, float)), 'power must be int or float'


    self.py__secondary_negative_damp_threshold = power






    self._ptr.call_with_return(316,tuple([power]))

  @functools.native_method
  def get_secondary_negative_damp_threshold(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(317,tuple([]))

    return _ret


  @functools.native_method
  def get_interpolation_remaining(self) -> typing.Union[float]:
    r'''
				Returns the remaining seconds of the time-based interpolation.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(318,tuple([]))
    return _ret


  @functools.native_method
  def is_interpolating(self) -> typing.Union[bool]:
    r'''
				Returns `true` if time-based interpolation is running. If `true`, it is equivalent to `get_interpolation_remaining` returning `0.0`.
				This is useful to determine whether a `LookAtModifier3D` can be removed safely.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(319,tuple([]))
    return _ret


  @functools.native_method
  def is_target_within_limitation(self) -> typing.Union[bool]:
    r'''
				Returns whether the target is within the angle limitations. It is useful for unsetting the `target_node` when the target is outside of the angle limitations.
				**Note:** The value is updated after `SkeletonModifier3D._process_modification`. To retrieve this value correctly, we recommend using the signal `signal SkeletonModifier3D.modification_processed`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(320,tuple([]))
    return _ret



register_cast_function('LookAtModifier3D', LookAtModifier3D.cast)
register_class('LookAtModifier3D', LookAtModifier3D)
