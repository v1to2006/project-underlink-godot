# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.SyntaxHighlighter as py4godot_syntaxhighlighter 
from py4godot.wrappers.wrappers import CPPCodeHighlighterWrapper


class CodeHighlighter(py4godot_syntaxhighlighter.SyntaxHighlighter):
  r'''
		By adjusting various properties of this resource, you can change the colors of strings, comments, numbers, and other text patterns inside a `TextEdit` control.
	'''

  @staticmethod
  def constructor():
    class_ = CodeHighlighter.construct_without_init()
    class_._ptr = constructor(214,0, ())
    return class_
  @staticmethod
  def new():
    class_ = CodeHighlighter.construct_without_init()
    class_._ptr = constructor(214,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPCodeHighlighterWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(214,0, ())


  def generate_wrapper(self):
    return CPPCodeHighlighterWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = CodeHighlighter.__new__(CodeHighlighter)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'CodeHighlighter'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(112, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = CodeHighlighter.construct_without_init()
    cls._ptr = CPPCodeHighlighterWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = CodeHighlighter.construct_without_init()
    cls._ptr = CPPCodeHighlighterWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def number_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_number_color()
    return _ret
  @number_color.setter
  def number_color(self,  value:'Color'):
    self.set_number_color(value)
  @property
  def symbol_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_symbol_color()
    return _ret
  @symbol_color.setter
  def symbol_color(self,  value:'Color'):
    self.set_symbol_color(value)
  @property
  def function_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_function_color()
    return _ret
  @function_color.setter
  def function_color(self,  value:'Color'):
    self.set_function_color(value)
  @property
  def member_variable_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_member_variable_color()
    return _ret
  @member_variable_color.setter
  def member_variable_color(self,  value:'Color'):
    self.set_member_variable_color(value)
  @property
  def keyword_colors(self) -> typing.Union['Dictionary']:
    r''''''
    _ret = self. get_keyword_colors()
    return _ret
  @keyword_colors.setter
  def keyword_colors(self,  value:'Dictionary'):
    self.set_keyword_colors(value)
  @property
  def member_keyword_colors(self) -> typing.Union['Dictionary']:
    r''''''
    _ret = self. get_member_keyword_colors()
    return _ret
  @member_keyword_colors.setter
  def member_keyword_colors(self,  value:'Dictionary'):
    self.set_member_keyword_colors(value)
  @property
  def color_regions(self) -> typing.Union['Dictionary']:
    r''''''
    _ret = self. get_color_regions()
    return _ret
  @color_regions.setter
  def color_regions(self,  value:'Dictionary'):
    self.set_color_regions(value)
  @functools.native_method
  def add_keyword_color(self, keyword:'str'   , color:'Color'   ) -> None:
    r'''
				Sets the color for a keyword.
				The keyword cannot contain any symbols except '_'.
			'''

    assert(not keyword is None)
    assert isinstance(keyword, (str, String)), 'keyword must be str or String'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'





    assert(isinstance(keyword, (str, String)))
    py_string_keyword = keyword if isinstance(keyword, StringName) else c_utils.py_string_to_string(keyword)


    self._ptr.call_with_return(84,tuple([py_string_keyword._ptr, color._ptr]))

  @functools.native_method
  def remove_keyword_color(self, keyword:'str'   ) -> None:
    r'''
				Removes the keyword.
			'''

    assert(not keyword is None)
    assert isinstance(keyword, (str, String)), 'keyword must be str or String'





    assert(isinstance(keyword, (str, String)))
    py_string_keyword = keyword if isinstance(keyword, StringName) else c_utils.py_string_to_string(keyword)

    self._ptr.call_with_return(85,tuple([py_string_keyword._ptr]))

  @functools.native_method
  def has_keyword_color(self, keyword:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the keyword exists, else `false`.
			'''

    assert(not keyword is None)
    assert isinstance(keyword, (str, String)), 'keyword must be str or String'





    assert(isinstance(keyword, (str, String)))
    py_string_keyword = keyword if isinstance(keyword, StringName) else c_utils.py_string_to_string(keyword)

    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([py_string_keyword._ptr]))
    return _ret


  @functools.native_method
  def get_keyword_color(self, keyword:'str'   ) -> typing.Union['Color']:
    r'''
				Returns the color for a keyword.
			'''

    assert(not keyword is None)
    assert isinstance(keyword, (str, String)), 'keyword must be str or String'





    assert(isinstance(keyword, (str, String)))
    py_string_keyword = keyword if isinstance(keyword, StringName) else c_utils.py_string_to_string(keyword)

    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([py_string_keyword._ptr]))
    return _ret


  @functools.native_method
  def set_keyword_colors(self, keywords:'Dictionary'   ) -> None:
    r''''''

    assert(not keywords is None)
    assert isinstance(keywords, Dictionary), 'keywords must be Dictionary'


    self.py__keyword_colors = keywords






    self._ptr.call_with_return(88,tuple([keywords._ptr]))

  @functools.native_method
  def clear_keyword_colors(self) -> None:
    r'''
				Removes all keywords.
			'''




    self._ptr.call_with_return(89,tuple([]))

  @functools.native_method
  def get_keyword_colors(self) -> typing.Union['Dictionary']:
    r''''''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(90,tuple([]))

    return _ret


  @functools.native_method
  def add_member_keyword_color(self, member_keyword:'str'   , color:'Color'   ) -> None:
    r'''
				Sets the color for a member keyword.
				The member keyword cannot contain any symbols except '_'.
				It will not be highlighted if preceded by a '.'.
			'''

    assert(not member_keyword is None)
    assert isinstance(member_keyword, (str, String)), 'member_keyword must be str or String'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'





    assert(isinstance(member_keyword, (str, String)))
    py_string_member_keyword = member_keyword if isinstance(member_keyword, StringName) else c_utils.py_string_to_string(member_keyword)


    self._ptr.call_with_return(91,tuple([py_string_member_keyword._ptr, color._ptr]))

  @functools.native_method
  def remove_member_keyword_color(self, member_keyword:'str'   ) -> None:
    r'''
				Removes the member keyword.
			'''

    assert(not member_keyword is None)
    assert isinstance(member_keyword, (str, String)), 'member_keyword must be str or String'





    assert(isinstance(member_keyword, (str, String)))
    py_string_member_keyword = member_keyword if isinstance(member_keyword, StringName) else c_utils.py_string_to_string(member_keyword)

    self._ptr.call_with_return(92,tuple([py_string_member_keyword._ptr]))

  @functools.native_method
  def has_member_keyword_color(self, member_keyword:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the member keyword exists, else `false`.
			'''

    assert(not member_keyword is None)
    assert isinstance(member_keyword, (str, String)), 'member_keyword must be str or String'





    assert(isinstance(member_keyword, (str, String)))
    py_string_member_keyword = member_keyword if isinstance(member_keyword, StringName) else c_utils.py_string_to_string(member_keyword)

    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([py_string_member_keyword._ptr]))
    return _ret


  @functools.native_method
  def get_member_keyword_color(self, member_keyword:'str'   ) -> typing.Union['Color']:
    r'''
				Returns the color for a member keyword.
			'''

    assert(not member_keyword is None)
    assert isinstance(member_keyword, (str, String)), 'member_keyword must be str or String'





    assert(isinstance(member_keyword, (str, String)))
    py_string_member_keyword = member_keyword if isinstance(member_keyword, StringName) else c_utils.py_string_to_string(member_keyword)

    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(94,tuple([py_string_member_keyword._ptr]))
    return _ret


  @functools.native_method
  def set_member_keyword_colors(self, member_keyword:'Dictionary'   ) -> None:
    r''''''

    assert(not member_keyword is None)
    assert isinstance(member_keyword, Dictionary), 'member_keyword must be Dictionary'


    self.py__member_keyword_colors = member_keyword






    self._ptr.call_with_return(95,tuple([member_keyword._ptr]))

  @functools.native_method
  def clear_member_keyword_colors(self) -> None:
    r'''
				Removes all member keywords.
			'''




    self._ptr.call_with_return(96,tuple([]))

  @functools.native_method
  def get_member_keyword_colors(self) -> typing.Union['Dictionary']:
    r''''''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(97,tuple([]))

    return _ret


  @functools.native_method
  def add_color_region(self, start_key:'str'   , end_key:'str'   , color:'Color'   , line_only:'bool' =False  ) -> None:
    r'''
				Adds a color region (such as for comments or strings) from `start_key` to `end_key`. Both keys should be symbols, and `start_key` must not be shared with other delimiters.
				If `line_only` is `true` or `end_key` is an empty `String`, the region does not carry over to the next line.
			'''

    assert(not start_key is None)
    assert isinstance(start_key, (str, String)), 'start_key must be str or String'
    assert(not end_key is None)
    assert isinstance(end_key, (str, String)), 'end_key must be str or String'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(line_only, bool), 'line_only must be bool'





    assert(isinstance(start_key, (str, String)))
    py_string_start_key = start_key if isinstance(start_key, StringName) else c_utils.py_string_to_string(start_key)
    assert(isinstance(end_key, (str, String)))
    py_string_end_key = end_key if isinstance(end_key, StringName) else c_utils.py_string_to_string(end_key)



    self._ptr.call_with_return(98,tuple([py_string_start_key._ptr, py_string_end_key._ptr, color._ptr, line_only]))

  @functools.native_method
  def remove_color_region(self, start_key:'str'   ) -> None:
    r'''
				Removes the color region that uses that start key.
			'''

    assert(not start_key is None)
    assert isinstance(start_key, (str, String)), 'start_key must be str or String'





    assert(isinstance(start_key, (str, String)))
    py_string_start_key = start_key if isinstance(start_key, StringName) else c_utils.py_string_to_string(start_key)

    self._ptr.call_with_return(99,tuple([py_string_start_key._ptr]))

  @functools.native_method
  def has_color_region(self, start_key:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the start key exists, else `false`.
			'''

    assert(not start_key is None)
    assert isinstance(start_key, (str, String)), 'start_key must be str or String'





    assert(isinstance(start_key, (str, String)))
    py_string_start_key = start_key if isinstance(start_key, StringName) else c_utils.py_string_to_string(start_key)

    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([py_string_start_key._ptr]))
    return _ret


  @functools.native_method
  def set_color_regions(self, color_regions:'Dictionary'   ) -> None:
    r''''''

    assert(not color_regions is None)
    assert isinstance(color_regions, Dictionary), 'color_regions must be Dictionary'


    self.py__color_regions = color_regions






    self._ptr.call_with_return(101,tuple([color_regions._ptr]))

  @functools.native_method
  def clear_color_regions(self) -> None:
    r'''
				Removes all color regions.
			'''




    self._ptr.call_with_return(102,tuple([]))

  @functools.native_method
  def get_color_regions(self) -> typing.Union['Dictionary']:
    r''''''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(103,tuple([]))

    return _ret


  @functools.native_method
  def set_function_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__function_color = color






    self._ptr.call_with_return(104,tuple([color._ptr]))

  @functools.native_method
  def get_function_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(105,tuple([]))

    return _ret


  @functools.native_method
  def set_number_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__number_color = color






    self._ptr.call_with_return(106,tuple([color._ptr]))

  @functools.native_method
  def get_number_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(107,tuple([]))

    return _ret


  @functools.native_method
  def set_symbol_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__symbol_color = color






    self._ptr.call_with_return(108,tuple([color._ptr]))

  @functools.native_method
  def get_symbol_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(109,tuple([]))

    return _ret


  @functools.native_method
  def set_member_variable_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__member_variable_color = color






    self._ptr.call_with_return(110,tuple([color._ptr]))

  @functools.native_method
  def get_member_variable_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(111,tuple([]))

    return _ret



register_cast_function('CodeHighlighter', CodeHighlighter.cast)
register_class('CodeHighlighter', CodeHighlighter)
