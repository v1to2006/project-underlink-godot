# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.SkeletonModification2D as py4godot_skeletonmodification2d 
from py4godot.wrappers.wrappers import CPPSkeletonModification2DCCDIKWrapper


class SkeletonModification2DCCDIK(py4godot_skeletonmodification2d.SkeletonModification2D):
  r'''
		This `SkeletonModification2D` uses an algorithm called Cyclic Coordinate Descent Inverse Kinematics, or CCDIK, to manipulate a chain of bones in a `Skeleton2D` so it reaches a defined target.
		CCDIK works by rotating a set of bones, typically called a "bone chain", on a single axis. Each bone is rotated to face the target from the tip (by default), which over a chain of bones allow it to rotate properly to reach the target. Because the bones only rotate on a single axis, CCDIK _can_ look more robotic than other IK solvers.
		**Note:** The CCDIK modifier has `ccdik_joints`, which are the data objects that hold the data for each joint in the CCDIK chain. This is different from a bone! CCDIK joints hold the data needed for each bone in the bone chain used by CCDIK.
		CCDIK also fully supports angle constraints, allowing for more control over how a solution is met.
	'''

  @staticmethod
  def constructor():
    class_ = SkeletonModification2DCCDIK.construct_without_init()
    class_._ptr = constructor(750,0, ())
    return class_
  @staticmethod
  def new():
    class_ = SkeletonModification2DCCDIK.construct_without_init()
    class_._ptr = constructor(750,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPSkeletonModification2DCCDIKWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(750,0, ())


  def generate_wrapper(self):
    return CPPSkeletonModification2DCCDIKWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = SkeletonModification2DCCDIK.__new__(SkeletonModification2DCCDIK)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'SkeletonModification2DCCDIK'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(110, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = SkeletonModification2DCCDIK.construct_without_init()
    cls._ptr = CPPSkeletonModification2DCCDIKWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = SkeletonModification2DCCDIK.construct_without_init()
    cls._ptr = CPPSkeletonModification2DCCDIKWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def target_nodepath(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_target_node()
    return _ret
  @target_nodepath.setter
  def target_nodepath(self,  value:'object'):
    self.set_target_node(value)
  @property
  def tip_nodepath(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_tip_node()
    return _ret
  @tip_nodepath.setter
  def tip_nodepath(self,  value:'object'):
    self.set_tip_node(value)
  @property
  def ccdik_data_chain_length(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_ccdik_data_chain_length()
    return _ret
  @ccdik_data_chain_length.setter
  def ccdik_data_chain_length(self,  value:'int'):
    self.set_ccdik_data_chain_length(value)
  @functools.native_method
  def set_target_node(self, target_nodepath:'object'   ) -> None:
    r''''''

    assert(not target_nodepath is None)
    assert isinstance(target_nodepath, (str, NodePath)), 'target_nodepath must be str or NodePath'


    self.py__target_nodepath = target_nodepath



    assert(isinstance(target_nodepath, (str, NodePath)))
    py_nodepath_target_nodepath = target_nodepath if isinstance(target_nodepath,NodePath) else NodePath.new2(target_nodepath)


    self._ptr.call_with_return(90,tuple([py_nodepath_target_nodepath._ptr]))

  @functools.native_method
  def get_target_node(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([]))

    return _ret


  @functools.native_method
  def set_tip_node(self, tip_nodepath:'object'   ) -> None:
    r''''''

    assert(not tip_nodepath is None)
    assert isinstance(tip_nodepath, (str, NodePath)), 'tip_nodepath must be str or NodePath'


    self.py__tip_nodepath = tip_nodepath



    assert(isinstance(tip_nodepath, (str, NodePath)))
    py_nodepath_tip_nodepath = tip_nodepath if isinstance(tip_nodepath,NodePath) else NodePath.new2(tip_nodepath)


    self._ptr.call_with_return(92,tuple([py_nodepath_tip_nodepath._ptr]))

  @functools.native_method
  def get_tip_node(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(93,tuple([]))

    return _ret


  @functools.native_method
  def set_ccdik_data_chain_length(self, length:'int'   ) -> None:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'


    self.py__ccdik_data_chain_length = length






    self._ptr.call_with_return(94,tuple([length]))

  @functools.native_method
  def get_ccdik_data_chain_length(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(95,tuple([]))

    return _ret


  @functools.native_method
  def set_ccdik_joint_bone2d_node(self, joint_idx:'int'   , bone2d_nodepath:'object'   ) -> None:
    r'''
				Sets the `Bone2D` node assigned to the CCDIK joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert(not bone2d_nodepath is None)
    assert isinstance(bone2d_nodepath, (str, NodePath)), 'bone2d_nodepath must be str or NodePath'






    assert(isinstance(bone2d_nodepath, (str, NodePath)))
    py_nodepath_bone2d_nodepath = bone2d_nodepath if isinstance(bone2d_nodepath,NodePath) else NodePath.new2(bone2d_nodepath)

    self._ptr.call_with_return(96,tuple([joint_idx, py_nodepath_bone2d_nodepath._ptr]))

  @functools.native_method
  def get_ccdik_joint_bone2d_node(self, joint_idx:'int'   ) -> typing.Union['NodePath']:
    r'''
				Returns the `Bone2D` node assigned to the CCDIK joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(97,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_ccdik_joint_bone_index(self, joint_idx:'int'   , bone_idx:'int'   ) -> None:
    r'''
				Sets the bone index, `bone_idx`, of the CCDIK joint at `joint_idx`. When possible, this will also update the `bone2d_node` of the CCDIK joint based on data provided by the linked skeleton.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'








    self._ptr.call_with_return(98,tuple([joint_idx, bone_idx]))

  @functools.native_method
  def get_ccdik_joint_bone_index(self, joint_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the index of the `Bone2D` node assigned to the CCDIK joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_ccdik_joint_rotate_from_joint(self, joint_idx:'int'   , rotate_from_joint:'bool'   ) -> None:
    r'''
				Sets whether the joint at `joint_idx` is set to rotate from the joint, `true`, or to rotate from the tip, `false`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert isinstance(rotate_from_joint, bool), 'rotate_from_joint must be bool'








    self._ptr.call_with_return(100,tuple([joint_idx, rotate_from_joint]))

  @functools.native_method
  def get_ccdik_joint_rotate_from_joint(self, joint_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether the joint at `joint_idx` is set to rotate from the joint, `true`, or to rotate from the tip, `false`. The default is to rotate from the tip.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(101,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_ccdik_joint_enable_constraint(self, joint_idx:'int'   , enable_constraint:'bool'   ) -> None:
    r'''
				Determines whether angle constraints on the CCDIK joint at `joint_idx` are enabled. When `true`, constraints will be enabled and taken into account when solving.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert isinstance(enable_constraint, bool), 'enable_constraint must be bool'








    self._ptr.call_with_return(102,tuple([joint_idx, enable_constraint]))

  @functools.native_method
  def get_ccdik_joint_enable_constraint(self, joint_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether angle constraints on the CCDIK joint at `joint_idx` are enabled.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_ccdik_joint_constraint_angle_min(self, joint_idx:'int'   , angle_min:'float'   ) -> None:
    r'''
				Sets the minimum angle constraint for the joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert isinstance(angle_min, (int, float)), 'angle_min must be int or float'








    self._ptr.call_with_return(104,tuple([joint_idx, angle_min]))

  @functools.native_method
  def get_ccdik_joint_constraint_angle_min(self, joint_idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the minimum angle constraint for the joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(105,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_ccdik_joint_constraint_angle_max(self, joint_idx:'int'   , angle_max:'float'   ) -> None:
    r'''
				Sets the maximum angle constraint for the joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert isinstance(angle_max, (int, float)), 'angle_max must be int or float'








    self._ptr.call_with_return(106,tuple([joint_idx, angle_max]))

  @functools.native_method
  def get_ccdik_joint_constraint_angle_max(self, joint_idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the maximum angle constraint for the joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(107,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_ccdik_joint_constraint_angle_invert(self, joint_idx:'int'   , invert:'bool'   ) -> None:
    r'''
				Sets whether the CCDIK joint at `joint_idx` uses an inverted joint constraint.
				An inverted joint constraint only constraints the CCDIK joint to the angles _outside of_ the inputted minimum and maximum angles. For this reason, it is referred to as an inverted joint constraint, as it constraints the joint to the outside of the inputted values.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert isinstance(invert, bool), 'invert must be bool'








    self._ptr.call_with_return(108,tuple([joint_idx, invert]))

  @functools.native_method
  def get_ccdik_joint_constraint_angle_invert(self, joint_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether the CCDIK joint at `joint_idx` uses an inverted joint constraint. See `set_ccdik_joint_constraint_angle_invert` for details.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(109,tuple([joint_idx]))
    return _ret



register_cast_function('SkeletonModification2DCCDIK', SkeletonModification2DCCDIK.cast)
register_class('SkeletonModification2DCCDIK', SkeletonModification2DCCDIK)
