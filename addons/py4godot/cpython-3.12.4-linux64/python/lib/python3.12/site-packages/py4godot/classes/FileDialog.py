# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.LineEdit as py4godot_lineedit 
import py4godot.classes.ConfirmationDialog as py4godot_confirmationdialog 
from py4godot.wrappers.wrappers import CPPFileDialogWrapper

class FileMode:
  FILE_MODE_OPEN_FILE = 0
  FILE_MODE_OPEN_FILES = 1
  FILE_MODE_OPEN_DIR = 2
  FILE_MODE_OPEN_ANY = 3
  FILE_MODE_SAVE_FILE = 4
class Access:
  ACCESS_RESOURCES = 0
  ACCESS_USERDATA = 1
  ACCESS_FILESYSTEM = 2
class DisplayMode:
  DISPLAY_THUMBNAILS = 0
  DISPLAY_LIST = 1
class Customization:
  CUSTOMIZATION_HIDDEN_FILES = 0
  CUSTOMIZATION_CREATE_FOLDER = 1
  CUSTOMIZATION_FILE_FILTER = 2
  CUSTOMIZATION_FILE_SORT = 3
  CUSTOMIZATION_FAVORITES = 4
  CUSTOMIZATION_RECENT = 5
  CUSTOMIZATION_LAYOUT = 6


class FileDialog(py4godot_confirmationdialog.ConfirmationDialog):
  r'''
		`FileDialog` is a preset dialog used to choose files and directories in the filesystem. It supports filter masks. `FileDialog` automatically sets its window title according to the `file_mode`. If you want to use a custom title, disable this by setting `mode_overrides_title` to `false`.
		**Note:** `FileDialog` is invisible by default. To make it visible, call one of the `popup_*` methods from `Window` on the node, such as `Window.popup_centered_clamped`.
	'''

  @staticmethod
  def constructor():
    class_ = FileDialog.construct_without_init()
    class_._ptr = constructor(330,0, ())
    return class_
  @staticmethod
  def new():
    class_ = FileDialog.construct_without_init()
    class_._ptr = constructor(330,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPFileDialogWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(330,0, ())


  def generate_wrapper(self):
    return CPPFileDialogWrapper()
  def init_signals(self):
    super().init_signals()
    file_selected_name = utils.py_string_to_string_name("file_selected")
    self.file_selected = signals.BuiltinSignal(self, file_selected_name)
    files_selected_name = utils.py_string_to_string_name("files_selected")
    self.files_selected = signals.BuiltinSignal(self, files_selected_name)
    dir_selected_name = utils.py_string_to_string_name("dir_selected")
    self.dir_selected = signals.BuiltinSignal(self, dir_selected_name)
    filename_filter_changed_name = utils.py_string_to_string_name("filename_filter_changed")
    self.filename_filter_changed = signals.BuiltinSignal(self, filename_filter_changed_name)

  @staticmethod
  def construct_without_init():
    cls = FileDialog.__new__(FileDialog)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'FileDialog'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = FileDialog.construct_without_init()
    cls._ptr = CPPFileDialogWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = FileDialog.construct_without_init()
    cls._ptr = CPPFileDialogWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def mode_overrides_title(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_mode_overriding_title()
    return _ret
  @mode_overrides_title.setter
  def mode_overrides_title(self,  value:'bool'):
    self.set_mode_overrides_title(value)
  @property
  def file_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_file_mode()
    return _ret
  @file_mode.setter
  def file_mode(self,  value:'int'):
    self.set_file_mode(value)
  @property
  def display_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_display_mode()
    return _ret
  @display_mode.setter
  def display_mode(self,  value:'int'):
    self.set_display_mode(value)
  @property
  def access(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_access()
    return _ret
  @access.setter
  def access(self,  value:'int'):
    self.set_access(value)
  @property
  def root_subfolder(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_root_subfolder()
    return _ret
  @root_subfolder.setter
  def root_subfolder(self,  value:'str'):
    self.set_root_subfolder(value)
  @property
  def filters(self) -> typing.Union['PackedStringArray']:
    r''''''
    _ret = self. get_filters()
    return _ret
  @filters.setter
  def filters(self,  value:'PackedStringArray'):
    self.set_filters(value)
  @property
  def filename_filter(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_filename_filter()
    return _ret
  @filename_filter.setter
  def filename_filter(self,  value:'str'):
    self.set_filename_filter(value)
  @property
  def show_hidden_files(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_showing_hidden_files()
    return _ret
  @show_hidden_files.setter
  def show_hidden_files(self,  value:'bool'):
    self.set_show_hidden_files(value)
  @property
  def use_native_dialog(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_use_native_dialog()
    return _ret
  @use_native_dialog.setter
  def use_native_dialog(self,  value:'bool'):
    self.set_use_native_dialog(value)
  @property
  def option_count(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_option_count()
    return _ret
  @option_count.setter
  def option_count(self,  value:'int'):
    self.set_option_count(value)
  @property
  def hidden_files_toggle_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_customization_flag_enabled(0)
    return _ret
  @hidden_files_toggle_enabled.setter
  def hidden_files_toggle_enabled(self,  value:'bool'):
    self.set_customization_flag_enabled(0, value)
  @property
  def file_filter_toggle_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_customization_flag_enabled(2)
    return _ret
  @file_filter_toggle_enabled.setter
  def file_filter_toggle_enabled(self,  value:'bool'):
    self.set_customization_flag_enabled(2, value)
  @property
  def file_sort_options_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_customization_flag_enabled(3)
    return _ret
  @file_sort_options_enabled.setter
  def file_sort_options_enabled(self,  value:'bool'):
    self.set_customization_flag_enabled(3, value)
  @property
  def folder_creation_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_customization_flag_enabled(1)
    return _ret
  @folder_creation_enabled.setter
  def folder_creation_enabled(self,  value:'bool'):
    self.set_customization_flag_enabled(1, value)
  @property
  def favorites_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_customization_flag_enabled(4)
    return _ret
  @favorites_enabled.setter
  def favorites_enabled(self,  value:'bool'):
    self.set_customization_flag_enabled(4, value)
  @property
  def recent_list_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_customization_flag_enabled(5)
    return _ret
  @recent_list_enabled.setter
  def recent_list_enabled(self,  value:'bool'):
    self.set_customization_flag_enabled(5, value)
  @property
  def layout_toggle_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_customization_flag_enabled(6)
    return _ret
  @layout_toggle_enabled.setter
  def layout_toggle_enabled(self,  value:'bool'):
    self.set_customization_flag_enabled(6, value)
  @property
  def current_dir(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_current_dir()
    return _ret
  @current_dir.setter
  def current_dir(self,  value:'str'):
    self.set_current_dir(value)
  @property
  def current_file(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_current_file()
    return _ret
  @current_file.setter
  def current_file(self,  value:'str'):
    self.set_current_file(value)
  @property
  def current_path(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_current_path()
    return _ret
  @current_path.setter
  def current_path(self,  value:'str'):
    self.set_current_path(value)
  @functools.native_method
  def clear_filters(self) -> None:
    r'''
				Clear all the added filters in the dialog.
			'''




    self._ptr.call_with_return(453,tuple([]))

  @functools.native_method
  def add_filter(self, filter:'str'   , description:'str' =""  ) -> None:
    r'''
				Adds a comma-separated file extension `filter` and comma-separated MIME type `mime_type` option to the `FileDialog` with an optional `description`, which restricts what files can be picked.
				A `filter` should be of the form `"filename.extension"`, where filename and extension can be `*` to match any string. Filters starting with `.` (i.e. empty filenames) are not allowed.
				For example, a `filter` of `"*.png, *.jpg"`, a `mime_type` of `image/png, image/jpeg`, and a `description` of `"Images"` results in filter text "Images (*.png, *.jpg)".
				**Note:** Embedded file dialogs and Windows file dialogs support only file extensions, while Android, Linux, and macOS file dialogs also support MIME types.
			'''
    if description is None:
      description = String.new0()

    assert(not filter is None)
    assert isinstance(filter, (str, String)), 'filter must be str or String'





    assert(isinstance(filter, (str, String)))
    py_string_filter = filter if isinstance(filter, StringName) else c_utils.py_string_to_string(filter)
    assert(isinstance(description, (str, String)))
    py_string_description = description if isinstance(description, StringName) else c_utils.py_string_to_string(description)

    self._ptr.call_with_return(454,tuple([py_string_filter._ptr, py_string_description._ptr]))

  @functools.native_method
  def set_filters(self, filters:'PackedStringArray'   ) -> None:
    r''''''

    assert(not filters is None)
    assert isinstance(filters, PackedStringArray), 'filters must be PackedStringArray'


    self.py__filters = filters






    self._ptr.call_with_return(455,tuple([filters._ptr]))

  @functools.native_method
  def get_filters(self) -> typing.Union['PackedStringArray']:
    r''''''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(456,tuple([]))

    return _ret


  @functools.native_method
  def clear_filename_filter(self) -> None:
    r'''
				Clear the filter for file names.
			'''




    self._ptr.call_with_return(457,tuple([]))

  @functools.native_method
  def set_filename_filter(self, filter:'str'   ) -> None:
    r''''''

    assert(not filter is None)
    assert isinstance(filter, (str, String)), 'filter must be str or String'


    self.py__filename_filter = filter



    assert(isinstance(filter, (str, String)))
    py_string_filter = filter if isinstance(filter, StringName) else c_utils.py_string_to_string(filter)

    py__string_filter = utils.py_string_to_string(filter)
    py__string_filter.shouldBeDeleted = False


    self._ptr.call_with_return(458,tuple([py__string_filter._ptr]))

  @functools.native_method
  def get_filename_filter(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(459,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_option_name(self, option:'int'   ) -> typing.Union[str]:
    r'''
				Returns the name of the `OptionButton` or `CheckBox` with index `option`.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(460,tuple([option]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_option_values(self, option:'int'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns an array of values of the `OptionButton` with index `option`.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'







    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(461,tuple([option]))
    return _ret


  @functools.native_method
  def get_option_default(self, option:'int'   ) -> typing.Union[int]:
    r'''
				Returns the default value index of the `OptionButton` or `CheckBox` with index `option`.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(462,tuple([option]))
    return _ret


  @functools.native_method
  def set_option_name(self, option:'int'   , name:'str'   ) -> None:
    r'''
				Sets the name of the `OptionButton` or `CheckBox` with index `option`.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(463,tuple([option, py_string_name._ptr]))

  @functools.native_method
  def set_option_values(self, option:'int'   , values:'PackedStringArray'   ) -> None:
    r'''
				Sets the option values of the `OptionButton` with index `option`.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'
    assert(not values is None)
    assert isinstance(values, PackedStringArray), 'values must be PackedStringArray'








    self._ptr.call_with_return(464,tuple([option, values._ptr]))

  @functools.native_method
  def set_option_default(self, option:'int'   , default_value_index:'int'   ) -> None:
    r'''
				Sets the default value index of the `OptionButton` or `CheckBox` with index `option`.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'
    assert isinstance(default_value_index, (int, float)), 'default_value_index must be int or float'








    self._ptr.call_with_return(465,tuple([option, default_value_index]))

  @functools.native_method
  def set_option_count(self, count:'int'   ) -> None:
    r''''''

    assert isinstance(count, (int, float)), 'count must be int or float'


    self.py__option_count = count






    self._ptr.call_with_return(466,tuple([count]))

  @functools.native_method
  def get_option_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(467,tuple([]))

    return _ret


  @functools.native_method
  def add_option(self, name:'str'   , values:'PackedStringArray'   , default_value_index:'int'   ) -> None:
    r'''
				Adds an additional `OptionButton` to the file dialog. If `values` is empty, a `CheckBox` is added instead.
				`default_value_index` should be an index of the value in the `values`. If `values` is empty it should be either `1` (checked), or `0` (unchecked).
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert(not values is None)
    assert isinstance(values, PackedStringArray), 'values must be PackedStringArray'
    assert isinstance(default_value_index, (int, float)), 'default_value_index must be int or float'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)



    self._ptr.call_with_return(468,tuple([py_string_name._ptr, values._ptr, default_value_index]))

  @functools.native_method
  def get_selected_options(self) -> typing.Union['Dictionary']:
    r'''
				Returns a `Dictionary` with the selected values of the additional `OptionButton`s and/or `CheckBox`es. `Dictionary` keys are names and values are selected value indices.
			'''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(469,tuple([]))
    return _ret


  @functools.native_method
  def get_current_dir(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(470,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_current_file(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(471,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_current_path(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(472,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_current_dir(self, dir:'str'   ) -> None:
    r''''''

    assert(not dir is None)
    assert isinstance(dir, (str, String)), 'dir must be str or String'


    self.py__current_dir = dir



    assert(isinstance(dir, (str, String)))
    py_string_dir = dir if isinstance(dir, StringName) else c_utils.py_string_to_string(dir)

    py__string_dir = utils.py_string_to_string(dir)
    py__string_dir.shouldBeDeleted = False


    self._ptr.call_with_return(473,tuple([py__string_dir._ptr]))

  @functools.native_method
  def set_current_file(self, file:'str'   ) -> None:
    r''''''

    assert(not file is None)
    assert isinstance(file, (str, String)), 'file must be str or String'


    self.py__current_file = file



    assert(isinstance(file, (str, String)))
    py_string_file = file if isinstance(file, StringName) else c_utils.py_string_to_string(file)

    py__string_file = utils.py_string_to_string(file)
    py__string_file.shouldBeDeleted = False


    self._ptr.call_with_return(474,tuple([py__string_file._ptr]))

  @functools.native_method
  def set_current_path(self, path:'str'   ) -> None:
    r''''''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'


    self.py__current_path = path



    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    py__string_path = utils.py_string_to_string(path)
    py__string_path.shouldBeDeleted = False


    self._ptr.call_with_return(475,tuple([py__string_path._ptr]))

  @functools.native_method
  def set_mode_overrides_title(self, override:'bool'   ) -> None:
    r''''''

    assert isinstance(override, bool), 'override must be bool'


    self.py__mode_overrides_title = override






    self._ptr.call_with_return(476,tuple([override]))

  @functools.native_method
  def is_mode_overriding_title(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(477,tuple([]))

    return _ret


  @functools.native_method
  def set_file_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__file_mode = mode






    self._ptr.call_with_return(478,tuple([mode]))

  @functools.native_method
  def get_file_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(479,tuple([]))

    return _ret


  @functools.native_method
  def set_display_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__display_mode = mode






    self._ptr.call_with_return(480,tuple([mode]))

  @functools.native_method
  def get_display_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(481,tuple([]))

    return _ret


  @functools.native_method
  def get_vbox(self) -> typing.Union['py4godot_vboxcontainer.VBoxContainer','py4godot_colorpicker.ColorPicker','py4godot_filesystemdock.FileSystemDock','py4godot_scripteditorbase.ScriptEditorBase']:
    r'''
				Returns the vertical box container of the dialog, custom controls can be added to it.
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their `CanvasItem.visible` property.
				**Note:** Changes to this node are ignored by native file dialogs, use `add_option` to add custom elements to the dialog instead.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: VBoxContainer
    _ret._ptr = self._ptr.call_with_return(482,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_line_edit(self) -> typing.Union['py4godot_lineedit.LineEdit']:
    r'''
				Returns the LineEdit for the selected file.
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their `CanvasItem.visible` property.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: LineEdit
    _ret._ptr = self._ptr.call_with_return(483,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_access(self, access:'int'  ) -> None:
    r''''''

    assert isinstance(access, (int, float)), 'access must be int or float'


    self.py__access = access






    self._ptr.call_with_return(484,tuple([access]))

  @functools.native_method
  def get_access(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(485,tuple([]))

    return _ret


  @functools.native_method
  def set_root_subfolder(self, dir:'str'   ) -> None:
    r''''''

    assert(not dir is None)
    assert isinstance(dir, (str, String)), 'dir must be str or String'


    self.py__root_subfolder = dir



    assert(isinstance(dir, (str, String)))
    py_string_dir = dir if isinstance(dir, StringName) else c_utils.py_string_to_string(dir)

    py__string_dir = utils.py_string_to_string(dir)
    py__string_dir.shouldBeDeleted = False


    self._ptr.call_with_return(486,tuple([py__string_dir._ptr]))

  @functools.native_method
  def get_root_subfolder(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(487,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_show_hidden_files(self, show:'bool'   ) -> None:
    r''''''

    assert isinstance(show, bool), 'show must be bool'


    self.py__show_hidden_files = show






    self._ptr.call_with_return(488,tuple([show]))

  @functools.native_method
  def is_showing_hidden_files(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(489,tuple([]))

    return _ret


  @functools.native_method
  def set_use_native_dialog(self, native:'bool'   ) -> None:
    r''''''

    assert isinstance(native, bool), 'native must be bool'


    self.py__use_native_dialog = native






    self._ptr.call_with_return(490,tuple([native]))

  @functools.native_method
  def get_use_native_dialog(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(491,tuple([]))

    return _ret


  @functools.native_method
  def set_customization_flag_enabled(self, flag:'int'  , enabled:'bool'   ) -> None:
    r'''
				Sets the specified customization `flag`, allowing to customize the features available in this `FileDialog`.
			'''

    assert isinstance(flag, (int, float)), 'flag must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__hidden_files_toggle_enabled = flag







    self._ptr.call_with_return(492,tuple([flag, enabled]))

  @functools.native_method
  def is_customization_flag_enabled(self, flag:'int'  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the provided `flag` is enabled.
			'''

    assert isinstance(flag, (int, float)), 'flag must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(493,tuple([flag]))

    return _ret


  @functools.native_method
  def deselect_all(self) -> None:
    r'''
				Clear all currently selected items in the dialog.
			'''




    self._ptr.call_with_return(494,tuple([]))

  @functools.native_method
  def invalidate(self) -> None:
    r'''
				Invalidates and updates this dialog's content list.
				**Note:** This method does nothing on native file dialogs.
			'''




    self._ptr.call_with_return(495,tuple([]))


register_cast_function('FileDialog', FileDialog.cast)
register_class('FileDialog', FileDialog)
