# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.CylinderMesh as py4godot_cylindermesh 
  import py4godot.classes.PlaneMesh as py4godot_planemesh 
  import py4godot.classes.TextMesh as py4godot_textmesh 
  import py4godot.classes.SphereMesh as py4godot_spheremesh 
  import py4godot.classes.RibbonTrailMesh as py4godot_ribbontrailmesh 
  import py4godot.classes.TorusMesh as py4godot_torusmesh 
  import py4godot.classes.QuadMesh as py4godot_quadmesh 
  import py4godot.classes.ArrayTypedArray as py4godot_arraytypedarray 
  import py4godot.classes.PrismMesh as py4godot_prismmesh 
  import py4godot.classes.CapsuleMesh as py4godot_capsulemesh 
  import py4godot.classes.PlaceholderMesh as py4godot_placeholdermesh 
  import py4godot.classes.TubeTrailMesh as py4godot_tubetrailmesh 
  import py4godot.classes.BoxMesh as py4godot_boxmesh 
  import py4godot.classes.PrimitiveMesh as py4godot_primitivemesh 
  import py4godot.classes.ImmediateMesh as py4godot_immediatemesh 
  import py4godot.classes.PointMesh as py4godot_pointmesh 
import py4godot.classes.Mesh as py4godot_mesh 
import py4godot.classes.ArrayTypedArray as py4godot_arraytypedarray 
from py4godot.wrappers.wrappers import CPPArrayMeshWrapper


class ArrayMesh(py4godot_mesh.Mesh):
  r'''
		The `ArrayMesh` is used to construct a `Mesh` by specifying the attributes as arrays.
		The most basic example is the creation of a single triangle:
		
		```gdscript
		var vertices = PackedVector3Array()
		vertices.push_back(Vector3(0, 1, 0))
		vertices.push_back(Vector3(1, 0, 0))
		vertices.push_back(Vector3(0, 0, 1))

		# Initialize the ArrayMesh.
		var arr_mesh = ArrayMesh.new()
		var arrays = ``
		arrays.resize(Mesh.ARRAY_MAX)
		arrays`Mesh.ARRAY_VERTEX` = vertices

		# Create the Mesh.
		arr_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, arrays)
		var m = MeshInstance3D.new()
		m.mesh = arr_mesh
		```
		
		
		The `MeshInstance3D` is ready to be added to the `SceneTree` to be shown.
		See also `ImmediateMesh`, `MeshDataTool` and `SurfaceTool` for procedural geometry generation.
		**Note:** Godot uses clockwise `url=https://learnopengl.com/Advanced-OpenGL/Face-culling`winding order`/url` for front faces of triangle primitive modes.
	'''

  @staticmethod
  def constructor():
    class_ = ArrayMesh.construct_without_init()
    class_._ptr = constructor(100,0, ())
    return class_
  @staticmethod
  def new():
    class_ = ArrayMesh.construct_without_init()
    class_._ptr = constructor(100,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPArrayMeshWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(100,0, ())


  def generate_wrapper(self):
    return CPPArrayMeshWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = ArrayMesh.__new__(ArrayMesh)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'ArrayMesh'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(131, ())
      self._ptr = None
  def __setitem__(self,  index, value):
    self._ptr.call_with_return(133, (index, value))

  def __getitem__(self,  index):

    if index < 0:
      raise KeyError(f"Index '{index}' invalid")
    pyobject = self._ptr.call_with_return(132, (index,))
    return pyobject
  def __iter__(self):
    self._index = 0
    return self
  def __next__(self):
    if self._index >= self.size():
      raise StopIteration()
    val = self[self._index]
    self._index += 1
    return val

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = ArrayMesh.construct_without_init()
    cls._ptr = CPPArrayMeshWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = ArrayMesh.construct_without_init()
    cls._ptr = CPPArrayMeshWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def from_list(values):
    result = ArrayMesh.new0()
    for value in values:
      result.push_back(value)
    return result

  def to_list(self):
    return [value for value in self]


  @property
  def blend_shape_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_blend_shape_mode()
    return _ret
  @blend_shape_mode.setter
  def blend_shape_mode(self,  value:'int'):
    self.set_blend_shape_mode(value)
  @property
  def custom_aabb(self) -> typing.Union['AABB']:
    r''''''
    _ret = self. get_custom_aabb()
    return _ret
  @custom_aabb.setter
  def custom_aabb(self,  value:'AABB'):
    self.set_custom_aabb(value)
  @property
  def shadow_mesh(self) -> typing.Union['typing.Self']:
    r''''''
    _ret = self. get_shadow_mesh()
    return _ret
  @shadow_mesh.setter
  def shadow_mesh(self,  value:'py4godot_object.Object'):
    self.set_shadow_mesh(value)
  @functools.native_method
  def add_blend_shape(self, name:'object'   ) -> None:
    r'''
				Adds name for a blend shape that will be added with `add_surface_from_arrays`. Must be called before surface is added.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(105,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def get_blend_shape_count(self) -> typing.Union[int]:
    r'''
				Returns the number of blend shapes that the `ArrayMesh` holds.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(106,tuple([]))
    return _ret


  @functools.native_method
  def get_blend_shape_name(self, index:'int'   ) -> typing.Union['StringName']:
    r'''
				Returns the name of the blend shape at this index.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(107,tuple([index]))
    return str(_ret)


  @functools.native_method
  def set_blend_shape_name(self, index:'int'   , name:'object'   ) -> None:
    r'''
				Sets the name of the blend shape at this index.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'






    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(108,tuple([index, py_stringname_name._ptr]))

  @functools.native_method
  def clear_blend_shapes(self) -> None:
    r'''
				Removes all blend shapes from this `ArrayMesh`.
			'''




    self._ptr.call_with_return(109,tuple([]))

  @functools.native_method
  def set_blend_shape_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__blend_shape_mode = mode






    self._ptr.call_with_return(110,tuple([mode]))

  @functools.native_method
  def get_blend_shape_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(111,tuple([]))

    return _ret


  @functools.native_method
  def add_surface_from_arrays(self, primitive:'int'  , arrays:'Array'   , blend_shapes:'py4godot_arraytypedarray.ArrayTypedArray' = None  , lods:'Dictionary' = None  , flags:'int' =0  ) -> None:
    r'''
				Creates a new surface. `Mesh.get_surface_count` will become the `surf_idx` for this new surface.
				Surfaces are created to be rendered using a `primitive`, which may be any of the values defined in `enum Mesh.PrimitiveType`.
				The `arrays` argument is an array of arrays. Each of the `constant Mesh.ARRAY_MAX` elements contains an array with some of the mesh data for this surface as described by the corresponding member of `enum Mesh.ArrayType` or `null` if it is not used by the surface. For example, `arrays`0`` is the array of vertices. That first vertex sub-array is always required; the others are optional. Adding an index array puts this surface into "index mode" where the vertex and other arrays become the sources of data and the index array defines the vertex order. All sub-arrays must have the same length as the vertex array (or be an exact multiple of the vertex array's length, when multiple elements of a sub-array correspond to a single vertex) or be empty, except for `constant Mesh.ARRAY_INDEX` if it is used.
				The `blend_shapes` argument is an array of vertex data for each blend shape. Each element is an array of the same structure as `arrays`, but `constant Mesh.ARRAY_VERTEX`, `constant Mesh.ARRAY_NORMAL`, and `constant Mesh.ARRAY_TANGENT` are set if and only if they are set in `arrays` and all other entries are `null`.
				The `lods` argument is a dictionary with `float` keys and `PackedInt32Array` values. Each entry in the dictionary represents an LOD level of the surface, where the value is the `constant Mesh.ARRAY_INDEX` array to use for the LOD level and the key is roughly proportional to the distance at which the LOD stats being used. I.e., increasing the key of an LOD also increases the distance that the objects has to be from the camera before the LOD is used.
				The `flags` argument is the bitwise OR of, as required: One value of `enum Mesh.ArrayCustomFormat` left shifted by `ARRAY_FORMAT_CUSTOMn_SHIFT` for each custom channel in use, `constant Mesh.ARRAY_FLAG_USE_DYNAMIC_UPDATE`, `constant Mesh.ARRAY_FLAG_USE_8_BONE_WEIGHTS`, or `constant Mesh.ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY`.
				**Note:** When using indices, it is recommended to only use points, lines, or triangles.
			'''

    if lods is None:
      lods = Dictionary.new0()


    assert isinstance(primitive, (int, float)), 'primitive must be int or float'
    assert(not arrays is None)
    assert isinstance(arrays, Array), 'arrays must be Array'
    assert isinstance(blend_shapes, Array), 'blend_shapes must be Array'
    assert isinstance(flags, (int, float)), 'flags must be int or float'











    self._ptr.call_with_return(112,tuple([primitive, arrays._ptr, blend_shapes._ptr, lods._ptr, flags]))

  @functools.native_method
  def clear_surfaces(self) -> None:
    r'''
				Removes all surfaces from this `ArrayMesh`.
			'''




    self._ptr.call_with_return(113,tuple([]))

  @functools.native_method
  def surface_remove(self, surf_idx:'int'   ) -> None:
    r'''
				Removes the surface at the given index from the Mesh, shifting surfaces with higher index down by one.
			'''

    assert isinstance(surf_idx, (int, float)), 'surf_idx must be int or float'







    self._ptr.call_with_return(114,tuple([surf_idx]))

  @functools.native_method
  def surface_update_vertex_region(self, surf_idx:'int'   , offset:'int'   , data:'PackedByteArray'   ) -> None:
    r'''
'''

    assert isinstance(surf_idx, (int, float)), 'surf_idx must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'









    self._ptr.call_with_return(115,tuple([surf_idx, offset, data._ptr]))

  @functools.native_method
  def surface_update_attribute_region(self, surf_idx:'int'   , offset:'int'   , data:'PackedByteArray'   ) -> None:
    r'''
'''

    assert isinstance(surf_idx, (int, float)), 'surf_idx must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'









    self._ptr.call_with_return(116,tuple([surf_idx, offset, data._ptr]))

  @functools.native_method
  def surface_update_skin_region(self, surf_idx:'int'   , offset:'int'   , data:'PackedByteArray'   ) -> None:
    r'''
'''

    assert isinstance(surf_idx, (int, float)), 'surf_idx must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'









    self._ptr.call_with_return(117,tuple([surf_idx, offset, data._ptr]))

  @functools.native_method
  def surface_get_array_len(self, surf_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the length in vertices of the vertex array in the requested surface (see `add_surface_from_arrays`).
			'''

    assert isinstance(surf_idx, (int, float)), 'surf_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(118,tuple([surf_idx]))
    return _ret


  @functools.native_method
  def surface_get_array_index_len(self, surf_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the length in indices of the index array in the requested surface (see `add_surface_from_arrays`).
			'''

    assert isinstance(surf_idx, (int, float)), 'surf_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(119,tuple([surf_idx]))
    return _ret


  @functools.native_method
  def surface_get_format(self, surf_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the format mask of the requested surface (see `add_surface_from_arrays`).
			'''

    assert isinstance(surf_idx, (int, float)), 'surf_idx must be int or float'







    _ret
    _ret = self._ptr.call_with_return(120,tuple([surf_idx]))
    return _ret


  @functools.native_method
  def surface_get_primitive_type(self, surf_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the primitive type of the requested surface (see `add_surface_from_arrays`).
			'''

    assert isinstance(surf_idx, (int, float)), 'surf_idx must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(121,tuple([surf_idx]))
    return _ret


  @functools.native_method
  def surface_find_by_name(self, name:'str'   ) -> typing.Union[int]:
    r'''
				Returns the index of the first surface with this name held within this `ArrayMesh`. If none are found, -1 is returned.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(122,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def surface_set_name(self, surf_idx:'int'   , name:'str'   ) -> None:
    r'''
				Sets a name for a given surface.
			'''

    assert isinstance(surf_idx, (int, float)), 'surf_idx must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(123,tuple([surf_idx, py_string_name._ptr]))

  @functools.native_method
  def surface_get_name(self, surf_idx:'int'   ) -> typing.Union[str]:
    r'''
				Gets the name assigned to this surface.
			'''

    assert isinstance(surf_idx, (int, float)), 'surf_idx must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(124,tuple([surf_idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def regen_normal_maps(self) -> None:
    r'''
				Regenerates tangents for each of the `ArrayMesh`'s surfaces.
			'''




    self._ptr.call_with_return(125,tuple([]))

  @functools.native_method
  def lightmap_unwrap(self, transform:'Transform3D'   , texel_size:'float'   ) -> typing.Union[int]:
    r'''
				Performs a UV unwrap on the `ArrayMesh` to prepare the mesh for lightmapping.
			'''

    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'
    assert isinstance(texel_size, (int, float)), 'texel_size must be int or float'








    _ret:int
    _ret = self._ptr.call_with_return(126,tuple([transform._ptr, texel_size]))
    return _ret


  @functools.native_method
  def set_custom_aabb(self, aabb:'AABB'   ) -> None:
    r''''''

    assert(not aabb is None)
    assert isinstance(aabb, AABB), 'aabb must be AABB'


    self.py__custom_aabb = aabb






    self._ptr.call_with_return(127,tuple([aabb._ptr]))

  @functools.native_method
  def get_custom_aabb(self) -> typing.Union['AABB']:
    r''''''




    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(128,tuple([]))

    return _ret


  @functools.native_method
  def set_shadow_mesh(self, mesh:'ArrayMesh'   ) -> None:
    r''''''

    assert(not mesh is None)
    assert isinstance(mesh, get_class('ArrayMesh')), 'mesh must be ArrayMesh'


    self.py__shadow_mesh = mesh






    self._ptr.call_with_return(129,tuple([mesh._ptr]))

  @functools.native_method
  def get_shadow_mesh(self) -> typing.Union['typing.Self']:
    r''''''




    _ret = ArrayMesh.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(130,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('ArrayMesh', ArrayMesh.cast)
register_class('ArrayMesh', ArrayMesh)
