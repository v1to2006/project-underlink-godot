# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.InputEvent as py4godot_inputevent 
from py4godot.wrappers.wrappers import CPPInputEventMIDIWrapper


class InputEventMIDI(py4godot_inputevent.InputEvent):
  r'''
		InputEventMIDI stores information about messages from `url=https://en.wikipedia.org/wiki/MIDI`MIDI`/url` (Musical Instrument Digital Interface) devices. These may include musical keyboards, synthesizers, and drum machines.
		MIDI messages can be received over a 5-pin MIDI connector or over USB. If your device supports both be sure to check the settings in the device to see which output it is using.
		By default, Godot does not detect MIDI devices. You need to call `OS.open_midi_inputs`, first. You can check which devices are detected with `OS.get_connected_midi_inputs`, and close the connection with `OS.close_midi_inputs`.
		
		```gdscript
		func _ready():
			OS.open_midi_inputs()
			print(OS.get_connected_midi_inputs())

		func _input(input_event):
			if input_event is InputEventMIDI:
				_print_midi_info(input_event)

		func _print_midi_info(midi_event):
			print(midi_event)
			print("Channel ", midi_event.channel)
			print("Message ", midi_event.message)
			print("Pitch ", midi_event.pitch)
			print("Velocity ", midi_event.velocity)
			print("Instrument ", midi_event.instrument)
			print("Pressure ", midi_event.pressure)
			print("Controller number: ", midi_event.controller_number)
			print("Controller value: ", midi_event.controller_value)
		```
		
		
		**Note:** Godot does not support MIDI output, so there is no way to emit MIDI messages from Godot. Only MIDI input is supported.
		**Note:** On the Web platform, using MIDI input requires a browser permission to be granted first. This permission request is performed when calling `OS.open_midi_inputs`. MIDI input will not work until the user accepts the permission request.
	'''

  @staticmethod
  def constructor():
    class_ = InputEventMIDI.construct_without_init()
    class_._ptr = constructor(420,0, ())
    return class_
  @staticmethod
  def new():
    class_ = InputEventMIDI.construct_without_init()
    class_._ptr = constructor(420,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPInputEventMIDIWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(420,0, ())


  def generate_wrapper(self):
    return CPPInputEventMIDIWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = InputEventMIDI.__new__(InputEventMIDI)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'InputEventMIDI'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(108, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = InputEventMIDI.construct_without_init()
    cls._ptr = CPPInputEventMIDIWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = InputEventMIDI.construct_without_init()
    cls._ptr = CPPInputEventMIDIWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def channel(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_channel()
    return _ret
  @channel.setter
  def channel(self,  value:'int'):
    self.set_channel(value)
  @property
  def message(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_message()
    return _ret
  @message.setter
  def message(self,  value:'int'):
    self.set_message(value)
  @property
  def pitch(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_pitch()
    return _ret
  @pitch.setter
  def pitch(self,  value:'int'):
    self.set_pitch(value)
  @property
  def velocity(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_velocity()
    return _ret
  @velocity.setter
  def velocity(self,  value:'int'):
    self.set_velocity(value)
  @property
  def instrument(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_instrument()
    return _ret
  @instrument.setter
  def instrument(self,  value:'int'):
    self.set_instrument(value)
  @property
  def pressure(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_pressure()
    return _ret
  @pressure.setter
  def pressure(self,  value:'int'):
    self.set_pressure(value)
  @property
  def controller_number(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_controller_number()
    return _ret
  @controller_number.setter
  def controller_number(self,  value:'int'):
    self.set_controller_number(value)
  @property
  def controller_value(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_controller_value()
    return _ret
  @controller_value.setter
  def controller_value(self,  value:'int'):
    self.set_controller_value(value)
  @functools.native_method
  def set_channel(self, channel:'int'   ) -> None:
    r''''''

    assert isinstance(channel, (int, float)), 'channel must be int or float'


    self.py__channel = channel






    self._ptr.call_with_return(92,tuple([channel]))

  @functools.native_method
  def get_channel(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([]))

    return _ret


  @functools.native_method
  def set_message(self, message:'int'  ) -> None:
    r''''''

    assert isinstance(message, (int, float)), 'message must be int or float'


    self.py__message = message






    self._ptr.call_with_return(94,tuple([message]))

  @functools.native_method
  def get_message(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(95,tuple([]))

    return _ret


  @functools.native_method
  def set_pitch(self, pitch:'int'   ) -> None:
    r''''''

    assert isinstance(pitch, (int, float)), 'pitch must be int or float'


    self.py__pitch = pitch






    self._ptr.call_with_return(96,tuple([pitch]))

  @functools.native_method
  def get_pitch(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([]))

    return _ret


  @functools.native_method
  def set_velocity(self, velocity:'int'   ) -> None:
    r''''''

    assert isinstance(velocity, (int, float)), 'velocity must be int or float'


    self.py__velocity = velocity






    self._ptr.call_with_return(98,tuple([velocity]))

  @functools.native_method
  def get_velocity(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([]))

    return _ret


  @functools.native_method
  def set_instrument(self, instrument:'int'   ) -> None:
    r''''''

    assert isinstance(instrument, (int, float)), 'instrument must be int or float'


    self.py__instrument = instrument






    self._ptr.call_with_return(100,tuple([instrument]))

  @functools.native_method
  def get_instrument(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(101,tuple([]))

    return _ret


  @functools.native_method
  def set_pressure(self, pressure:'int'   ) -> None:
    r''''''

    assert isinstance(pressure, (int, float)), 'pressure must be int or float'


    self.py__pressure = pressure






    self._ptr.call_with_return(102,tuple([pressure]))

  @functools.native_method
  def get_pressure(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([]))

    return _ret


  @functools.native_method
  def set_controller_number(self, controller_number:'int'   ) -> None:
    r''''''

    assert isinstance(controller_number, (int, float)), 'controller_number must be int or float'


    self.py__controller_number = controller_number






    self._ptr.call_with_return(104,tuple([controller_number]))

  @functools.native_method
  def get_controller_number(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(105,tuple([]))

    return _ret


  @functools.native_method
  def set_controller_value(self, controller_value:'int'   ) -> None:
    r''''''

    assert isinstance(controller_value, (int, float)), 'controller_value must be int or float'


    self.py__controller_value = controller_value






    self._ptr.call_with_return(106,tuple([controller_value]))

  @functools.native_method
  def get_controller_value(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(107,tuple([]))

    return _ret



register_cast_function('InputEventMIDI', InputEventMIDI.cast)
register_class('InputEventMIDI', InputEventMIDI)
