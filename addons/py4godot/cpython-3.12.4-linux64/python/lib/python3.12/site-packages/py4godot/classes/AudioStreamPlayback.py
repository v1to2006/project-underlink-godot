# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.AudioSamplePlayback as py4godot_audiosampleplayback 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPAudioStreamPlaybackWrapper


class AudioStreamPlayback(py4godot_refcounted.RefCounted):
  r'''
		Can play, loop, pause a scroll through audio. See `AudioStream` and `AudioStreamOggVorbis` for usage.
	'''

  @staticmethod
  def constructor():
    class_ = AudioStreamPlayback.construct_without_init()
    class_._ptr = constructor(147,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AudioStreamPlayback.construct_without_init()
    class_._ptr = constructor(147,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAudioStreamPlaybackWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(147,0, ())


  def generate_wrapper(self):
    return CPPAudioStreamPlaybackWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = AudioStreamPlayback.__new__(AudioStreamPlayback)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AudioStreamPlayback'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(71, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AudioStreamPlayback.construct_without_init()
    cls._ptr = CPPAudioStreamPlaybackWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AudioStreamPlayback.construct_without_init()
    cls._ptr = CPPAudioStreamPlaybackWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _start(self, from_pos:'float'   ) -> None:
    r'''
				Override this method to customize what happens when the playback starts at the given position, such as by calling `AudioStreamPlayer.play`.
			'''

    assert isinstance(from_pos, (int, float)), 'from_pos must be int or float'







    self._ptr.call_with_return(53,tuple([from_pos]))

  @functools.native_method
  def _stop(self) -> None:
    r'''
				Override this method to customize what happens when the playback is stopped, such as by calling `AudioStreamPlayer.stop`.
			'''




    self._ptr.call_with_return(54,tuple([]))

  @functools.native_method
  def _is_playing(self) -> typing.Union[bool]:
    r'''
				Overridable method. Should return `true` if this playback is active and playing its audio stream.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(55,tuple([]))
    return _ret


  @functools.native_method
  def _get_loop_count(self) -> typing.Union[int]:
    r'''
				Overridable method. Should return how many times this audio stream has looped. Most built-in playbacks always return `0`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([]))
    return _ret


  @functools.native_method
  def _get_playback_position(self) -> typing.Union[float]:
    r'''
				Overridable method. Should return the current progress along the audio stream, in seconds.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([]))
    return _ret


  @functools.native_method
  def _seek(self, position:'float'   ) -> None:
    r'''
				Override this method to customize what happens when seeking this audio stream at the given `position`, such as by calling `AudioStreamPlayer.seek`.
			'''

    assert isinstance(position, (int, float)), 'position must be int or float'







    self._ptr.call_with_return(58,tuple([position]))

  @functools.native_method
  def _tag_used_streams(self) -> None:
    r'''
				Overridable method. Called whenever the audio stream is mixed if the playback is active and `AudioServer.set_enable_tagging_used_audio_streams` has been set to `true`. Editor plugins may use this method to "tag" the current position along the audio stream and display it in a preview.
			'''




    self._ptr.call_with_return(59,tuple([]))

  @functools.native_method
  def _set_parameter(self, name:'object'   , value:'object'   ) -> None:
    r'''
				Set the current value of a playback parameter by name (see `AudioStream._get_parameter_list`).
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(60,tuple([py_stringname_name._ptr, value]))

  @functools.native_method
  def _get_parameter(self, name:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Return the current value of a playback parameter by name (see `AudioStream._get_parameter_list`).
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = None
    _ret = self._ptr.call_with_return(61,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def set_sample_playback(self, playback_sample:'py4godot_audiosampleplayback.AudioSamplePlayback'   ) -> None:
    r'''
				Associates `AudioSamplePlayback` to this `AudioStreamPlayback` for playing back the audio sample of this stream.
			'''

    assert(not playback_sample is None)
    assert isinstance(playback_sample, get_class('AudioSamplePlayback')), 'playback_sample must be AudioSamplePlayback'







    self._ptr.call_with_return(62,tuple([playback_sample._ptr]))

  @functools.native_method
  def get_sample_playback(self) -> typing.Union['py4godot_audiosampleplayback.AudioSamplePlayback']:
    r'''
				Returns the `AudioSamplePlayback` associated with this `AudioStreamPlayback` for playing back the audio sample of this stream.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioSamplePlayback
    _ret._ptr = self._ptr.call_with_return(63,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def mix_audio(self, rate_scale:'float'   , frames:'int'   ) -> typing.Union['PackedVector2Array']:
    r'''
				Mixes up to `frames` of audio from the stream from the current position, at a rate of `rate_scale`, advancing the stream.
				Returns a `PackedVector2Array` where each element holds the left and right channel volume levels of each frame.
				**Note:** Can return fewer frames than requested, make sure to use the size of the return value.
			'''

    assert isinstance(rate_scale, (int, float)), 'rate_scale must be int or float'
    assert isinstance(frames, (int, float)), 'frames must be int or float'








    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(64,tuple([rate_scale, frames]))
    return _ret


  @functools.native_method
  def start(self, from_pos:'float' =0.0  ) -> None:
    r'''
				Starts the stream from the given `from_pos`, in seconds.
			'''

    assert isinstance(from_pos, (int, float)), 'from_pos must be int or float'







    self._ptr.call_with_return(65,tuple([from_pos]))

  @functools.native_method
  def seek(self, time:'float' =0.0  ) -> None:
    r'''
				Seeks the stream at the given `time`, in seconds.
			'''

    assert isinstance(time, (int, float)), 'time must be int or float'







    self._ptr.call_with_return(66,tuple([time]))

  @functools.native_method
  def stop(self) -> None:
    r'''
				Stops the stream.
			'''




    self._ptr.call_with_return(67,tuple([]))

  @functools.native_method
  def get_loop_count(self) -> typing.Union[int]:
    r'''
				Returns the number of times the stream has looped.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(68,tuple([]))
    return _ret


  @functools.native_method
  def get_playback_position(self) -> typing.Union[float]:
    r'''
				Returns the current position in the stream, in seconds.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(69,tuple([]))
    return _ret


  @functools.native_method
  def is_playing(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the stream is playing.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(70,tuple([]))
    return _ret



register_cast_function('AudioStreamPlayback', AudioStreamPlayback.cast)
register_class('AudioStreamPlayback', AudioStreamPlayback)
