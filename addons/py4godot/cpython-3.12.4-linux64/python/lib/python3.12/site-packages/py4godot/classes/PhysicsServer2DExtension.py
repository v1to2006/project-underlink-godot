# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PhysicsDirectSpaceState2D as py4godot_physicsdirectspacestate2d 
  import py4godot.classes.RIDTypedArray as py4godot_ridtypedarray 
  import py4godot.classes.PhysicsDirectBodyState2DExtension as py4godot_physicsdirectbodystate2dextension 
  import py4godot.classes.PhysicsDirectSpaceState2DExtension as py4godot_physicsdirectspacestate2dextension 
  import py4godot.classes.PhysicsDirectBodyState2D as py4godot_physicsdirectbodystate2d 
import py4godot.classes.RIDTypedArray as py4godot_ridtypedarray 
import py4godot.classes.PhysicsServer2D as py4godot_physicsserver2d 
from py4godot.wrappers.wrappers import CPPPhysicsServer2DExtensionWrapper


class PhysicsServer2DExtension(py4godot_physicsserver2d.PhysicsServer2D):
  r'''
		This class extends `PhysicsServer2D` by providing additional virtual methods that can be overridden. When these methods are overridden, they will be called instead of the internal methods of the physics server.
		Intended for use with GDExtension to create custom implementations of `PhysicsServer2D`.
	'''

  @staticmethod
  def constructor():
    class_ = PhysicsServer2DExtension.construct_without_init()
    class_._ptr = constructor(605,0, ())
    return class_
  @staticmethod
  def new():
    class_ = PhysicsServer2DExtension.construct_without_init()
    class_._ptr = constructor(605,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPPhysicsServer2DExtensionWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(605,0, ())


  def generate_wrapper(self):
    return CPPPhysicsServer2DExtensionWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = PhysicsServer2DExtension.__new__(PhysicsServer2DExtension)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PhysicsServer2DExtension'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = PhysicsServer2DExtension.construct_without_init()
    cls._ptr = CPPPhysicsServer2DExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = PhysicsServer2DExtension.construct_without_init()
    cls._ptr = CPPPhysicsServer2DExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _world_boundary_shape_create(self) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.world_boundary_shape_create`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(168,tuple([]))
    return _ret


  @functools.native_method
  def _separation_ray_shape_create(self) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.separation_ray_shape_create`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(169,tuple([]))
    return _ret


  @functools.native_method
  def _segment_shape_create(self) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.segment_shape_create`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(170,tuple([]))
    return _ret


  @functools.native_method
  def _circle_shape_create(self) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.circle_shape_create`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(171,tuple([]))
    return _ret


  @functools.native_method
  def _rectangle_shape_create(self) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.rectangle_shape_create`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(172,tuple([]))
    return _ret


  @functools.native_method
  def _capsule_shape_create(self) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.capsule_shape_create`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(173,tuple([]))
    return _ret


  @functools.native_method
  def _convex_polygon_shape_create(self) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.convex_polygon_shape_create`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(174,tuple([]))
    return _ret


  @functools.native_method
  def _concave_polygon_shape_create(self) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.concave_polygon_shape_create`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(175,tuple([]))
    return _ret


  @functools.native_method
  def _shape_set_data(self, shape:'RID'   , data:'object'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.shape_set_data`.
			'''

    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'
    

    if not (type(data).__name__ in py4godot.variant_types.core_types or isinstance(data, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'data': "
                f"{type(data).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    self._ptr.call_with_return(176,tuple([shape._ptr, data]))

  @functools.native_method
  def _shape_set_custom_solver_bias(self, shape:'RID'   , bias:'float'   ) -> None:
    r'''
				Should set the custom solver bias for the given `shape`. It defines how much bodies are forced to separate on contact.
				Overridable version of `PhysicsServer2D`'s internal `shape_get_custom_solver_bias` method. Corresponds to `Shape2D.custom_solver_bias`.
			'''

    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'
    assert isinstance(bias, (int, float)), 'bias must be int or float'








    self._ptr.call_with_return(177,tuple([shape._ptr, bias]))

  @functools.native_method
  def _shape_get_type(self, shape:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.shape_get_type`.
			'''

    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(178,tuple([shape._ptr]))
    return _ret


  @functools.native_method
  def _shape_get_data(self, shape:'RID'   ) -> typing.Union[typing.Any]:
    r'''
				Overridable version of `PhysicsServer2D.shape_get_data`.
			'''

    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'







    _ret = None
    _ret = self._ptr.call_with_return(179,tuple([shape._ptr]))
    return _ret


  @functools.native_method
  def _shape_get_custom_solver_bias(self, shape:'RID'   ) -> typing.Union[float]:
    r'''
				Should return the custom solver bias of the given `shape`, which defines how much bodies are forced to separate on contact when this shape is involved.
				Overridable version of `PhysicsServer2D`'s internal `shape_get_custom_solver_bias` method. Corresponds to `Shape2D.custom_solver_bias`.
			'''

    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(180,tuple([shape._ptr]))
    return _ret


  @functools.native_method
  def _space_create(self) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.space_create`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(181,tuple([]))
    return _ret


  @functools.native_method
  def _space_set_active(self, space:'RID'   , active:'bool'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.space_set_active`.
			'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'
    assert isinstance(active, bool), 'active must be bool'








    self._ptr.call_with_return(182,tuple([space._ptr, active]))

  @functools.native_method
  def _space_is_active(self, space:'RID'   ) -> typing.Union[bool]:
    r'''
				Overridable version of `PhysicsServer2D.space_is_active`.
			'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(183,tuple([space._ptr]))
    return _ret


  @functools.native_method
  def _space_set_param(self, space:'RID'   , param:'int'  , value:'float'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.space_set_param`.
			'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'









    self._ptr.call_with_return(184,tuple([space._ptr, param, value]))

  @functools.native_method
  def _space_get_param(self, space:'RID'   , param:'int'  ) -> typing.Union[float]:
    r'''
				Overridable version of `PhysicsServer2D.space_get_param`.
			'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(185,tuple([space._ptr, param]))
    return _ret


  @functools.native_method
  def _space_get_direct_state(self, space:'RID'   ) -> typing.Union['py4godot_physicsdirectspacestate2d.PhysicsDirectSpaceState2D','py4godot_physicsdirectspacestate2dextension.PhysicsDirectSpaceState2DExtension']:
    r'''
				Overridable version of `PhysicsServer2D.space_get_direct_state`.
			'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: PhysicsDirectSpaceState2D
    _ret._ptr = self._ptr.call_with_return(186,tuple([space._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def _space_set_debug_contacts(self, space:'RID'   , max_contacts:'int'   ) -> None:
    r'''
				Used internally to allow the given `space` to store contact points, up to `max_contacts`. This is automatically set for the main `World2D`'s space when `SceneTree.debug_collisions_hint` is `true`, or by checking "Visible Collision Shapes" in the editor. Only works in debug builds.
				Overridable version of `PhysicsServer2D`'s internal `space_set_debug_contacts` method.
			'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'
    assert isinstance(max_contacts, (int, float)), 'max_contacts must be int or float'








    self._ptr.call_with_return(187,tuple([space._ptr, max_contacts]))

  @functools.native_method
  def _space_get_contacts(self, space:'RID'   ) -> typing.Union['PackedVector2Array']:
    r'''
				Should return the positions of all contacts that have occurred during the last physics step in the given `space`. See also `_space_get_contact_count` and `_space_set_debug_contacts`.
				Overridable version of `PhysicsServer2D`'s internal `space_get_contacts` method.
			'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'







    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(188,tuple([space._ptr]))
    return _ret


  @functools.native_method
  def _space_get_contact_count(self, space:'RID'   ) -> typing.Union[int]:
    r'''
				Should return how many contacts have occurred during the last physics step in the given `space`. See also `_space_get_contacts` and `_space_set_debug_contacts`.
				Overridable version of `PhysicsServer2D`'s internal `space_get_contact_count` method.
			'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(189,tuple([space._ptr]))
    return _ret


  @functools.native_method
  def _area_create(self) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.area_create`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(190,tuple([]))
    return _ret


  @functools.native_method
  def _area_set_space(self, area:'RID'   , space:'RID'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_set_space`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'








    self._ptr.call_with_return(191,tuple([area._ptr, space._ptr]))

  @functools.native_method
  def _area_get_space(self, area:'RID'   ) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.area_get_space`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(192,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def _area_add_shape(self, area:'RID'   , shape:'RID'   , transform:'Transform2D'   , disabled:'bool'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_add_shape`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'
    assert isinstance(disabled, bool), 'disabled must be bool'










    self._ptr.call_with_return(193,tuple([area._ptr, shape._ptr, transform._ptr, disabled]))

  @functools.native_method
  def _area_set_shape(self, area:'RID'   , shape_idx:'int'   , shape:'RID'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_set_shape`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'
    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'









    self._ptr.call_with_return(194,tuple([area._ptr, shape_idx, shape._ptr]))

  @functools.native_method
  def _area_set_shape_transform(self, area:'RID'   , shape_idx:'int'   , transform:'Transform2D'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_set_shape_transform`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'









    self._ptr.call_with_return(195,tuple([area._ptr, shape_idx, transform._ptr]))

  @functools.native_method
  def _area_set_shape_disabled(self, area:'RID'   , shape_idx:'int'   , disabled:'bool'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_set_shape_disabled`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'
    assert isinstance(disabled, bool), 'disabled must be bool'









    self._ptr.call_with_return(196,tuple([area._ptr, shape_idx, disabled]))

  @functools.native_method
  def _area_get_shape_count(self, area:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.area_get_shape_count`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(197,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def _area_get_shape(self, area:'RID'   , shape_idx:'int'   ) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.area_get_shape`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(198,tuple([area._ptr, shape_idx]))
    return _ret


  @functools.native_method
  def _area_get_shape_transform(self, area:'RID'   , shape_idx:'int'   ) -> typing.Union['Transform2D']:
    r'''
				Overridable version of `PhysicsServer2D.area_get_shape_transform`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'








    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(199,tuple([area._ptr, shape_idx]))
    return _ret


  @functools.native_method
  def _area_remove_shape(self, area:'RID'   , shape_idx:'int'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_remove_shape`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'








    self._ptr.call_with_return(200,tuple([area._ptr, shape_idx]))

  @functools.native_method
  def _area_clear_shapes(self, area:'RID'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_clear_shapes`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    self._ptr.call_with_return(201,tuple([area._ptr]))

  @functools.native_method
  def _area_attach_object_instance_id(self, area:'RID'   , id:'int'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_attach_object_instance_id`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(id, (int, float)), 'id must be int or float'








    self._ptr.call_with_return(202,tuple([area._ptr, id]))

  @functools.native_method
  def _area_get_object_instance_id(self, area:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.area_get_object_instance_id`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(203,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def _area_attach_canvas_instance_id(self, area:'RID'   , id:'int'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_attach_canvas_instance_id`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(id, (int, float)), 'id must be int or float'








    self._ptr.call_with_return(204,tuple([area._ptr, id]))

  @functools.native_method
  def _area_get_canvas_instance_id(self, area:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.area_get_canvas_instance_id`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(205,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def _area_set_param(self, area:'RID'   , param:'int'  , value:'object'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_set_param`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    self._ptr.call_with_return(206,tuple([area._ptr, param, value]))

  @functools.native_method
  def _area_set_transform(self, area:'RID'   , transform:'Transform2D'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_set_transform`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'








    self._ptr.call_with_return(207,tuple([area._ptr, transform._ptr]))

  @functools.native_method
  def _area_get_param(self, area:'RID'   , param:'int'  ) -> typing.Union[typing.Any]:
    r'''
				Overridable version of `PhysicsServer2D.area_get_param`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(208,tuple([area._ptr, param]))
    return _ret


  @functools.native_method
  def _area_get_transform(self, area:'RID'   ) -> typing.Union['Transform2D']:
    r'''
				Overridable version of `PhysicsServer2D.area_get_transform`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(209,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def _area_set_collision_layer(self, area:'RID'   , layer:'int'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_set_collision_layer`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(layer, (int, float)), 'layer must be int or float'








    self._ptr.call_with_return(210,tuple([area._ptr, layer]))

  @functools.native_method
  def _area_get_collision_layer(self, area:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.area_get_collision_layer`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(211,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def _area_set_collision_mask(self, area:'RID'   , mask:'int'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_set_collision_mask`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'








    self._ptr.call_with_return(212,tuple([area._ptr, mask]))

  @functools.native_method
  def _area_get_collision_mask(self, area:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.area_get_collision_mask`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(213,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def _area_set_monitorable(self, area:'RID'   , monitorable:'bool'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_set_monitorable`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(monitorable, bool), 'monitorable must be bool'








    self._ptr.call_with_return(214,tuple([area._ptr, monitorable]))

  @functools.native_method
  def _area_set_pickable(self, area:'RID'   , pickable:'bool'   ) -> None:
    r'''
				If set to `true`, allows the area with the given `RID` to detect mouse inputs when the mouse cursor is hovering on it.
				Overridable version of `PhysicsServer2D`'s internal `area_set_pickable` method. Corresponds to `CollisionObject2D.input_pickable`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(pickable, bool), 'pickable must be bool'








    self._ptr.call_with_return(215,tuple([area._ptr, pickable]))

  @functools.native_method
  def _area_set_monitor_callback(self, area:'RID'   , callback:'Callable'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_set_monitor_callback`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'








    self._ptr.call_with_return(216,tuple([area._ptr, callback._ptr]))

  @functools.native_method
  def _area_set_area_monitor_callback(self, area:'RID'   , callback:'Callable'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.area_set_area_monitor_callback`.
			'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'








    self._ptr.call_with_return(217,tuple([area._ptr, callback._ptr]))

  @functools.native_method
  def _body_create(self) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.body_create`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(218,tuple([]))
    return _ret


  @functools.native_method
  def _body_set_space(self, body:'RID'   , space:'RID'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_space`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'








    self._ptr.call_with_return(219,tuple([body._ptr, space._ptr]))

  @functools.native_method
  def _body_get_space(self, body:'RID'   ) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.body_get_space`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(220,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_mode(self, body:'RID'   , mode:'int'  ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_mode`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'








    self._ptr.call_with_return(221,tuple([body._ptr, mode]))

  @functools.native_method
  def _body_get_mode(self, body:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.body_get_mode`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(222,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_add_shape(self, body:'RID'   , shape:'RID'   , transform:'Transform2D'   , disabled:'bool'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_add_shape`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'
    assert isinstance(disabled, bool), 'disabled must be bool'










    self._ptr.call_with_return(223,tuple([body._ptr, shape._ptr, transform._ptr, disabled]))

  @functools.native_method
  def _body_set_shape(self, body:'RID'   , shape_idx:'int'   , shape:'RID'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_shape`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'
    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'









    self._ptr.call_with_return(224,tuple([body._ptr, shape_idx, shape._ptr]))

  @functools.native_method
  def _body_set_shape_transform(self, body:'RID'   , shape_idx:'int'   , transform:'Transform2D'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_shape_transform`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'









    self._ptr.call_with_return(225,tuple([body._ptr, shape_idx, transform._ptr]))

  @functools.native_method
  def _body_get_shape_count(self, body:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.body_get_shape_count`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(226,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_get_shape(self, body:'RID'   , shape_idx:'int'   ) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.body_get_shape`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(227,tuple([body._ptr, shape_idx]))
    return _ret


  @functools.native_method
  def _body_get_shape_transform(self, body:'RID'   , shape_idx:'int'   ) -> typing.Union['Transform2D']:
    r'''
				Overridable version of `PhysicsServer2D.body_get_shape_transform`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'








    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(228,tuple([body._ptr, shape_idx]))
    return _ret


  @functools.native_method
  def _body_set_shape_disabled(self, body:'RID'   , shape_idx:'int'   , disabled:'bool'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_shape_disabled`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'
    assert isinstance(disabled, bool), 'disabled must be bool'









    self._ptr.call_with_return(229,tuple([body._ptr, shape_idx, disabled]))

  @functools.native_method
  def _body_set_shape_as_one_way_collision(self, body:'RID'   , shape_idx:'int'   , enable:'bool'   , margin:'float'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_shape_as_one_way_collision`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'
    assert isinstance(margin, (int, float)), 'margin must be int or float'










    self._ptr.call_with_return(230,tuple([body._ptr, shape_idx, enable, margin]))

  @functools.native_method
  def _body_remove_shape(self, body:'RID'   , shape_idx:'int'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_remove_shape`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'








    self._ptr.call_with_return(231,tuple([body._ptr, shape_idx]))

  @functools.native_method
  def _body_clear_shapes(self, body:'RID'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_clear_shapes`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    self._ptr.call_with_return(232,tuple([body._ptr]))

  @functools.native_method
  def _body_attach_object_instance_id(self, body:'RID'   , id:'int'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_attach_object_instance_id`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(id, (int, float)), 'id must be int or float'








    self._ptr.call_with_return(233,tuple([body._ptr, id]))

  @functools.native_method
  def _body_get_object_instance_id(self, body:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.body_get_object_instance_id`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(234,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_attach_canvas_instance_id(self, body:'RID'   , id:'int'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_attach_canvas_instance_id`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(id, (int, float)), 'id must be int or float'








    self._ptr.call_with_return(235,tuple([body._ptr, id]))

  @functools.native_method
  def _body_get_canvas_instance_id(self, body:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.body_get_canvas_instance_id`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(236,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_continuous_collision_detection_mode(self, body:'RID'   , mode:'int'  ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_continuous_collision_detection_mode`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'








    self._ptr.call_with_return(237,tuple([body._ptr, mode]))

  @functools.native_method
  def _body_get_continuous_collision_detection_mode(self, body:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.body_get_continuous_collision_detection_mode`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(238,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_collision_layer(self, body:'RID'   , layer:'int'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_collision_layer`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(layer, (int, float)), 'layer must be int or float'








    self._ptr.call_with_return(239,tuple([body._ptr, layer]))

  @functools.native_method
  def _body_get_collision_layer(self, body:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.body_get_collision_layer`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(240,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_collision_mask(self, body:'RID'   , mask:'int'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_collision_mask`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'








    self._ptr.call_with_return(241,tuple([body._ptr, mask]))

  @functools.native_method
  def _body_get_collision_mask(self, body:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.body_get_collision_mask`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(242,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_collision_priority(self, body:'RID'   , priority:'float'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_collision_priority`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(priority, (int, float)), 'priority must be int or float'








    self._ptr.call_with_return(243,tuple([body._ptr, priority]))

  @functools.native_method
  def _body_get_collision_priority(self, body:'RID'   ) -> typing.Union[float]:
    r'''
				Overridable version of `PhysicsServer2D.body_get_collision_priority`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(244,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_param(self, body:'RID'   , param:'int'  , value:'object'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_param`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    self._ptr.call_with_return(245,tuple([body._ptr, param, value]))

  @functools.native_method
  def _body_get_param(self, body:'RID'   , param:'int'  ) -> typing.Union[typing.Any]:
    r'''
				Overridable version of `PhysicsServer2D.body_get_param`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(246,tuple([body._ptr, param]))
    return _ret


  @functools.native_method
  def _body_reset_mass_properties(self, body:'RID'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_reset_mass_properties`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    self._ptr.call_with_return(247,tuple([body._ptr]))

  @functools.native_method
  def _body_set_state(self, body:'RID'   , state:'int'  , value:'object'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_state`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(state, (int, float)), 'state must be int or float'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    self._ptr.call_with_return(248,tuple([body._ptr, state, value]))

  @functools.native_method
  def _body_get_state(self, body:'RID'   , state:'int'  ) -> typing.Union[typing.Any]:
    r'''
				Overridable version of `PhysicsServer2D.body_get_state`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(state, (int, float)), 'state must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(249,tuple([body._ptr, state]))
    return _ret


  @functools.native_method
  def _body_apply_central_impulse(self, body:'RID'   , impulse:'Vector2'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_apply_central_impulse`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not impulse is None)
    assert isinstance(impulse, Vector2), 'impulse must be Vector2'








    self._ptr.call_with_return(250,tuple([body._ptr, impulse._ptr]))

  @functools.native_method
  def _body_apply_torque_impulse(self, body:'RID'   , impulse:'float'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_apply_torque_impulse`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(impulse, (int, float)), 'impulse must be int or float'








    self._ptr.call_with_return(251,tuple([body._ptr, impulse]))

  @functools.native_method
  def _body_apply_impulse(self, body:'RID'   , impulse:'Vector2'   , position:'Vector2'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_apply_impulse`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not impulse is None)
    assert isinstance(impulse, Vector2), 'impulse must be Vector2'
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'









    self._ptr.call_with_return(252,tuple([body._ptr, impulse._ptr, position._ptr]))

  @functools.native_method
  def _body_apply_central_force(self, body:'RID'   , force:'Vector2'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_apply_central_force`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not force is None)
    assert isinstance(force, Vector2), 'force must be Vector2'








    self._ptr.call_with_return(253,tuple([body._ptr, force._ptr]))

  @functools.native_method
  def _body_apply_force(self, body:'RID'   , force:'Vector2'   , position:'Vector2'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_apply_force`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not force is None)
    assert isinstance(force, Vector2), 'force must be Vector2'
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'









    self._ptr.call_with_return(254,tuple([body._ptr, force._ptr, position._ptr]))

  @functools.native_method
  def _body_apply_torque(self, body:'RID'   , torque:'float'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_apply_torque`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(torque, (int, float)), 'torque must be int or float'








    self._ptr.call_with_return(255,tuple([body._ptr, torque]))

  @functools.native_method
  def _body_add_constant_central_force(self, body:'RID'   , force:'Vector2'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_add_constant_central_force`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not force is None)
    assert isinstance(force, Vector2), 'force must be Vector2'








    self._ptr.call_with_return(256,tuple([body._ptr, force._ptr]))

  @functools.native_method
  def _body_add_constant_force(self, body:'RID'   , force:'Vector2'   , position:'Vector2'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_add_constant_force`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not force is None)
    assert isinstance(force, Vector2), 'force must be Vector2'
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'









    self._ptr.call_with_return(257,tuple([body._ptr, force._ptr, position._ptr]))

  @functools.native_method
  def _body_add_constant_torque(self, body:'RID'   , torque:'float'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_add_constant_torque`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(torque, (int, float)), 'torque must be int or float'








    self._ptr.call_with_return(258,tuple([body._ptr, torque]))

  @functools.native_method
  def _body_set_constant_force(self, body:'RID'   , force:'Vector2'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_constant_force`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not force is None)
    assert isinstance(force, Vector2), 'force must be Vector2'








    self._ptr.call_with_return(259,tuple([body._ptr, force._ptr]))

  @functools.native_method
  def _body_get_constant_force(self, body:'RID'   ) -> typing.Union['Vector2']:
    r'''
				Overridable version of `PhysicsServer2D.body_get_constant_force`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(260,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_constant_torque(self, body:'RID'   , torque:'float'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_constant_torque`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(torque, (int, float)), 'torque must be int or float'








    self._ptr.call_with_return(261,tuple([body._ptr, torque]))

  @functools.native_method
  def _body_get_constant_torque(self, body:'RID'   ) -> typing.Union[float]:
    r'''
				Overridable version of `PhysicsServer2D.body_get_constant_torque`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(262,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_axis_velocity(self, body:'RID'   , axis_velocity:'Vector2'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_axis_velocity`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not axis_velocity is None)
    assert isinstance(axis_velocity, Vector2), 'axis_velocity must be Vector2'








    self._ptr.call_with_return(263,tuple([body._ptr, axis_velocity._ptr]))

  @functools.native_method
  def _body_add_collision_exception(self, body:'RID'   , excepted_body:'RID'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_add_collision_exception`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not excepted_body is None)
    assert isinstance(excepted_body, RID), 'excepted_body must be RID'








    self._ptr.call_with_return(264,tuple([body._ptr, excepted_body._ptr]))

  @functools.native_method
  def _body_remove_collision_exception(self, body:'RID'   , excepted_body:'RID'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_remove_collision_exception`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not excepted_body is None)
    assert isinstance(excepted_body, RID), 'excepted_body must be RID'








    self._ptr.call_with_return(265,tuple([body._ptr, excepted_body._ptr]))

  @functools.native_method
  def _body_get_collision_exceptions(self, body:'RID'   ) -> typing.Union['py4godot_ridtypedarray.RIDTypedArray']:
    r'''
				Returns the `RID`s of all bodies added as collision exceptions for the given `body`. See also `_body_add_collision_exception` and `_body_remove_collision_exception`.
				Overridable version of `PhysicsServer2D`'s internal `body_get_collision_exceptions` method. Corresponds to `PhysicsBody2D.get_collision_exceptions`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = py4godot_ridtypedarray.RIDTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(266,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_max_contacts_reported(self, body:'RID'   , amount:'int'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_max_contacts_reported`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(amount, (int, float)), 'amount must be int or float'








    self._ptr.call_with_return(267,tuple([body._ptr, amount]))

  @functools.native_method
  def _body_get_max_contacts_reported(self, body:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.body_get_max_contacts_reported`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(268,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_contacts_reported_depth_threshold(self, body:'RID'   , threshold:'float'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D`'s internal `body_set_contacts_reported_depth_threshold` method.
				**Note:** This method is currently unused by Godot's default physics implementation.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(threshold, (int, float)), 'threshold must be int or float'








    self._ptr.call_with_return(269,tuple([body._ptr, threshold]))

  @functools.native_method
  def _body_get_contacts_reported_depth_threshold(self, body:'RID'   ) -> typing.Union[float]:
    r'''
				Overridable version of `PhysicsServer2D`'s internal `body_get_contacts_reported_depth_threshold` method.
				**Note:** This method is currently unused by Godot's default physics implementation.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(270,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_omit_force_integration(self, body:'RID'   , enable:'bool'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_omit_force_integration`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(enable, bool), 'enable must be bool'








    self._ptr.call_with_return(271,tuple([body._ptr, enable]))

  @functools.native_method
  def _body_is_omitting_force_integration(self, body:'RID'   ) -> typing.Union[bool]:
    r'''
				Overridable version of `PhysicsServer2D.body_is_omitting_force_integration`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(272,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_state_sync_callback(self, body:'RID'   , callable:'Callable'   ) -> None:
    r'''
				Assigns the `body` to call the given `callable` during the synchronization phase of the loop, before `_step` is called. See also `_sync`.
				Overridable version of `PhysicsServer2D.body_set_state_sync_callback`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'








    self._ptr.call_with_return(273,tuple([body._ptr, callable._ptr]))

  @functools.native_method
  def _body_set_force_integration_callback(self, body:'RID'   , callable:'Callable'   , userdata:'object'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.body_set_force_integration_callback`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'
    

    if not (type(userdata).__name__ in py4godot.variant_types.core_types or isinstance(userdata, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'userdata': "
                f"{type(userdata).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    self._ptr.call_with_return(274,tuple([body._ptr, callable._ptr, userdata]))

  @functools.native_method
  def _body_set_pickable(self, body:'RID'   , pickable:'bool'   ) -> None:
    r'''
				If set to `true`, allows the body with the given `RID` to detect mouse inputs when the mouse cursor is hovering on it.
				Overridable version of `PhysicsServer2D`'s internal `body_set_pickable` method. Corresponds to `CollisionObject2D.input_pickable`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(pickable, bool), 'pickable must be bool'








    self._ptr.call_with_return(275,tuple([body._ptr, pickable]))

  @functools.native_method
  def _body_get_direct_state(self, body:'RID'   ) -> typing.Union['py4godot_physicsdirectbodystate2d.PhysicsDirectBodyState2D','py4godot_physicsdirectbodystate2dextension.PhysicsDirectBodyState2DExtension']:
    r'''
				Overridable version of `PhysicsServer2D.body_get_direct_state`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: PhysicsDirectBodyState2D
    _ret._ptr = self._ptr.call_with_return(276,tuple([body._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def _joint_create(self) -> typing.Union['RID']:
    r'''
				Overridable version of `PhysicsServer2D.joint_create`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(277,tuple([]))
    return _ret


  @functools.native_method
  def _joint_clear(self, joint:'RID'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.joint_clear`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'







    self._ptr.call_with_return(278,tuple([joint._ptr]))

  @functools.native_method
  def _joint_set_param(self, joint:'RID'   , param:'int'  , value:'float'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.joint_set_param`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'









    self._ptr.call_with_return(279,tuple([joint._ptr, param, value]))

  @functools.native_method
  def _joint_get_param(self, joint:'RID'   , param:'int'  ) -> typing.Union[float]:
    r'''
				Overridable version of `PhysicsServer2D.joint_get_param`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(280,tuple([joint._ptr, param]))
    return _ret


  @functools.native_method
  def _joint_disable_collisions_between_bodies(self, joint:'RID'   , disable:'bool'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.joint_disable_collisions_between_bodies`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(disable, bool), 'disable must be bool'








    self._ptr.call_with_return(281,tuple([joint._ptr, disable]))

  @functools.native_method
  def _joint_is_disabled_collisions_between_bodies(self, joint:'RID'   ) -> typing.Union[bool]:
    r'''
				Overridable version of `PhysicsServer2D.joint_is_disabled_collisions_between_bodies`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(282,tuple([joint._ptr]))
    return _ret


  @functools.native_method
  def _joint_make_pin(self, joint:'RID'   , anchor:'Vector2'   , body_a:'RID'   , body_b:'RID'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.joint_make_pin`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert(not anchor is None)
    assert isinstance(anchor, Vector2), 'anchor must be Vector2'
    assert(not body_a is None)
    assert isinstance(body_a, RID), 'body_a must be RID'
    assert(not body_b is None)
    assert isinstance(body_b, RID), 'body_b must be RID'










    self._ptr.call_with_return(283,tuple([joint._ptr, anchor._ptr, body_a._ptr, body_b._ptr]))

  @functools.native_method
  def _joint_make_groove(self, joint:'RID'   , a_groove1:'Vector2'   , a_groove2:'Vector2'   , b_anchor:'Vector2'   , body_a:'RID'   , body_b:'RID'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.joint_make_groove`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert(not a_groove1 is None)
    assert isinstance(a_groove1, Vector2), 'a_groove1 must be Vector2'
    assert(not a_groove2 is None)
    assert isinstance(a_groove2, Vector2), 'a_groove2 must be Vector2'
    assert(not b_anchor is None)
    assert isinstance(b_anchor, Vector2), 'b_anchor must be Vector2'
    assert(not body_a is None)
    assert isinstance(body_a, RID), 'body_a must be RID'
    assert(not body_b is None)
    assert isinstance(body_b, RID), 'body_b must be RID'












    self._ptr.call_with_return(284,tuple([joint._ptr, a_groove1._ptr, a_groove2._ptr, b_anchor._ptr, body_a._ptr, body_b._ptr]))

  @functools.native_method
  def _joint_make_damped_spring(self, joint:'RID'   , anchor_a:'Vector2'   , anchor_b:'Vector2'   , body_a:'RID'   , body_b:'RID'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.joint_make_damped_spring`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert(not anchor_a is None)
    assert isinstance(anchor_a, Vector2), 'anchor_a must be Vector2'
    assert(not anchor_b is None)
    assert isinstance(anchor_b, Vector2), 'anchor_b must be Vector2'
    assert(not body_a is None)
    assert isinstance(body_a, RID), 'body_a must be RID'
    assert(not body_b is None)
    assert isinstance(body_b, RID), 'body_b must be RID'











    self._ptr.call_with_return(285,tuple([joint._ptr, anchor_a._ptr, anchor_b._ptr, body_a._ptr, body_b._ptr]))

  @functools.native_method
  def _pin_joint_set_flag(self, joint:'RID'   , flag:'int'  , enabled:'bool'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.pin_joint_set_flag`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(flag, (int, float)), 'flag must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'









    self._ptr.call_with_return(286,tuple([joint._ptr, flag, enabled]))

  @functools.native_method
  def _pin_joint_get_flag(self, joint:'RID'   , flag:'int'  ) -> typing.Union[bool]:
    r'''
				Overridable version of `PhysicsServer2D.pin_joint_get_flag`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(flag, (int, float)), 'flag must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(287,tuple([joint._ptr, flag]))
    return _ret


  @functools.native_method
  def _pin_joint_set_param(self, joint:'RID'   , param:'int'  , value:'float'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.pin_joint_set_param`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'









    self._ptr.call_with_return(288,tuple([joint._ptr, param, value]))

  @functools.native_method
  def _pin_joint_get_param(self, joint:'RID'   , param:'int'  ) -> typing.Union[float]:
    r'''
				Overridable version of `PhysicsServer2D.pin_joint_get_param`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(289,tuple([joint._ptr, param]))
    return _ret


  @functools.native_method
  def _damped_spring_joint_set_param(self, joint:'RID'   , param:'int'  , value:'float'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.damped_spring_joint_set_param`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'









    self._ptr.call_with_return(290,tuple([joint._ptr, param, value]))

  @functools.native_method
  def _damped_spring_joint_get_param(self, joint:'RID'   , param:'int'  ) -> typing.Union[float]:
    r'''
				Overridable version of `PhysicsServer2D.damped_spring_joint_get_param`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(291,tuple([joint._ptr, param]))
    return _ret


  @functools.native_method
  def _joint_get_type(self, joint:'RID'   ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.joint_get_type`.
			'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(292,tuple([joint._ptr]))
    return _ret


  @functools.native_method
  def _free_rid(self, rid:'RID'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.free_rid`.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    self._ptr.call_with_return(293,tuple([rid._ptr]))

  @functools.native_method
  def _set_active(self, active:'bool'   ) -> None:
    r'''
				Overridable version of `PhysicsServer2D.set_active`.
			'''

    assert isinstance(active, bool), 'active must be bool'







    self._ptr.call_with_return(294,tuple([active]))

  @functools.native_method
  def _init(self) -> None:
    r'''
				Called when the main loop is initialized and creates a new instance of this physics server. See also `MainLoop._initialize` and `_finish`.
				Overridable version of `PhysicsServer2D`'s internal `init` method.
			'''




    self._ptr.call_with_return(295,tuple([]))

  @functools.native_method
  def _step(self, step:'float'   ) -> None:
    r'''
				Called every physics step to process the physics simulation. `step` is the time elapsed since the last physics step, in seconds. It is usually the same as the value returned by `Node.get_physics_process_delta_time`.
				Overridable version of `PhysicsServer2D`'s internal `code skip-lint`step` method.
			'''

    assert isinstance(step, (int, float)), 'step must be int or float'







    self._ptr.call_with_return(296,tuple([step]))

  @functools.native_method
  def _sync(self) -> None:
    r'''
				Called to indicate that the physics server is synchronizing and cannot access physics states if running on a separate thread. See also `_end_sync`.
				Overridable version of `PhysicsServer2D`'s internal `sync` method.
			'''




    self._ptr.call_with_return(297,tuple([]))

  @functools.native_method
  def _flush_queries(self) -> None:
    r'''
				Called every physics step before `_step` to process all remaining queries.
				Overridable version of `PhysicsServer2D`'s internal `flush_queries` method.
			'''




    self._ptr.call_with_return(298,tuple([]))

  @functools.native_method
  def _end_sync(self) -> None:
    r'''
				Called to indicate that the physics server has stopped synchronizing. It is in the loop's iteration/physics phase, and can access physics objects even if running on a separate thread. See also `_sync`.
				Overridable version of `PhysicsServer2D`'s internal `end_sync` method.
			'''




    self._ptr.call_with_return(299,tuple([]))

  @functools.native_method
  def _finish(self) -> None:
    r'''
				Called when the main loop finalizes to shut down the physics server. See also `MainLoop._finalize` and `_init`.
				Overridable version of `PhysicsServer2D`'s internal `finish` method.
			'''




    self._ptr.call_with_return(300,tuple([]))

  @functools.native_method
  def _is_flushing_queries(self) -> typing.Union[bool]:
    r'''
				Overridable method that should return `true` when the physics server is processing queries. See also `_flush_queries`.
				Overridable version of `PhysicsServer2D`'s internal `is_flushing_queries` method.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(301,tuple([]))
    return _ret


  @functools.native_method
  def _get_process_info(self, process_info:'int'  ) -> typing.Union[int]:
    r'''
				Overridable version of `PhysicsServer2D.get_process_info`.
			'''

    assert isinstance(process_info, (int, float)), 'process_info must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(302,tuple([process_info]))
    return _ret


  @functools.native_method
  def body_test_motion_is_excluding_body(self, body:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the body with the given `RID` is being excluded from `_body_test_motion`. See also `Object.get_instance_id`.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(303,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def body_test_motion_is_excluding_object(self, object_:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the object with the given instance ID is being excluded from `_body_test_motion`. See also `Object.get_instance_id`.
			'''

    assert isinstance(object_, (int, float)), 'object_ must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(304,tuple([object_]))
    return _ret



register_cast_function('PhysicsServer2DExtension', PhysicsServer2DExtension.cast)
register_class('PhysicsServer2DExtension', PhysicsServer2DExtension)
