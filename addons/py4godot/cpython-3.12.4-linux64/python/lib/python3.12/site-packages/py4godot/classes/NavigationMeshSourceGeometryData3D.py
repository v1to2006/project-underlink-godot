# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Mesh as py4godot_mesh 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPNavigationMeshSourceGeometryData3DWrapper


class NavigationMeshSourceGeometryData3D(py4godot_resource.Resource):
  r'''
		Container for parsed source geometry data used in navigation mesh baking.
	'''

  @staticmethod
  def constructor():
    class_ = NavigationMeshSourceGeometryData3D.construct_without_init()
    class_._ptr = constructor(501,0, ())
    return class_
  @staticmethod
  def new():
    class_ = NavigationMeshSourceGeometryData3D.construct_without_init()
    class_._ptr = constructor(501,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPNavigationMeshSourceGeometryData3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(501,0, ())


  def generate_wrapper(self):
    return CPPNavigationMeshSourceGeometryData3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = NavigationMeshSourceGeometryData3D.__new__(NavigationMeshSourceGeometryData3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'NavigationMeshSourceGeometryData3D'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(93, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = NavigationMeshSourceGeometryData3D.construct_without_init()
    cls._ptr = CPPNavigationMeshSourceGeometryData3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = NavigationMeshSourceGeometryData3D.construct_without_init()
    cls._ptr = CPPNavigationMeshSourceGeometryData3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def vertices(self) -> typing.Union['PackedVector3Array']:
    r''''''
    _ret = self. get_vertices()
    return _ret
  @vertices.setter
  def vertices(self,  value:'PackedVector3Array'):
    self.set_vertices(value)
  @property
  def indices(self) -> typing.Union['PackedInt32Array']:
    r''''''
    _ret = self. get_indices()
    return _ret
  @indices.setter
  def indices(self,  value:'PackedInt32Array'):
    self.set_indices(value)
  @property
  def projected_obstructions(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_projected_obstructions()
    return _ret
  @projected_obstructions.setter
  def projected_obstructions(self,  value:'Array'):
    self.set_projected_obstructions(value)
  @functools.native_method
  def set_vertices(self, vertices:'PackedFloat32Array'   ) -> None:
    r'''
				Sets the parsed source geometry data vertices. The vertices need to be matched with appropriated indices.
				**Warning:** Inappropriate data can crash the baking process of the involved third-party libraries.
			'''

    assert(not vertices is None)
    assert isinstance(vertices, PackedFloat32Array), 'vertices must be PackedFloat32Array'


    self.py__vertices = vertices






    self._ptr.call_with_return(77,tuple([vertices._ptr]))

  @functools.native_method
  def get_vertices(self) -> typing.Union['PackedFloat32Array']:
    r'''
				Returns the parsed source geometry data vertices array.
			'''




    _ret = PackedFloat32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([]))

    return _ret


  @functools.native_method
  def set_indices(self, indices:'PackedInt32Array'   ) -> None:
    r'''
				Sets the parsed source geometry data indices. The indices need to be matched with appropriated vertices.
				**Warning:** Inappropriate data can crash the baking process of the involved third-party libraries.
			'''

    assert(not indices is None)
    assert isinstance(indices, PackedInt32Array), 'indices must be PackedInt32Array'


    self.py__indices = indices






    self._ptr.call_with_return(79,tuple([indices._ptr]))

  @functools.native_method
  def get_indices(self) -> typing.Union['PackedInt32Array']:
    r'''
				Returns the parsed source geometry data indices array.
			'''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))

    return _ret


  @functools.native_method
  def append_arrays(self, vertices:'PackedFloat32Array'   , indices:'PackedInt32Array'   ) -> None:
    r'''
				Appends arrays of `vertices` and `indices` at the end of the existing arrays. Adds the existing index as an offset to the appended indices.
			'''

    assert(not vertices is None)
    assert isinstance(vertices, PackedFloat32Array), 'vertices must be PackedFloat32Array'
    assert(not indices is None)
    assert isinstance(indices, PackedInt32Array), 'indices must be PackedInt32Array'








    self._ptr.call_with_return(81,tuple([vertices._ptr, indices._ptr]))

  @functools.native_method
  def clear(self) -> None:
    r'''
				Clears the internal data.
			'''




    self._ptr.call_with_return(82,tuple([]))

  @functools.native_method
  def has_data(self) -> typing.Union[bool]:
    r'''
				Returns `true` when parsed source geometry data exists.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(83,tuple([]))
    return _ret


  @functools.native_method
  def add_mesh(self, mesh:'py4godot_mesh.Mesh'   , xform:'Transform3D'   ) -> None:
    r'''
				Adds the geometry data of a `Mesh` resource to the navigation mesh baking data. The mesh must have valid triangulated mesh data to be considered. Since `NavigationMesh` resources have no transform, all vertex positions need to be offset by the node's transform using `xform`.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, get_class('Mesh')), 'mesh must be Mesh'
    assert(not xform is None)
    assert isinstance(xform, Transform3D), 'xform must be Transform3D'








    self._ptr.call_with_return(84,tuple([mesh._ptr, xform._ptr]))

  @functools.native_method
  def add_mesh_array(self, mesh_array:'Array'   , xform:'Transform3D'   ) -> None:
    r'''
				Adds an `Array` the size of `constant Mesh.ARRAY_MAX` and with vertices at index `constant Mesh.ARRAY_VERTEX` and indices at index `constant Mesh.ARRAY_INDEX` to the navigation mesh baking data. The array must have valid triangulated mesh data to be considered. Since `NavigationMesh` resources have no transform, all vertex positions need to be offset by the node's transform using `xform`.
			'''

    assert(not mesh_array is None)
    assert isinstance(mesh_array, Array), 'mesh_array must be Array'
    assert(not xform is None)
    assert isinstance(xform, Transform3D), 'xform must be Transform3D'








    self._ptr.call_with_return(85,tuple([mesh_array._ptr, xform._ptr]))

  @functools.native_method
  def add_faces(self, faces:'PackedVector3Array'   , xform:'Transform3D'   ) -> None:
    r'''
				Adds an array of vertex positions to the geometry data for navigation mesh baking to form triangulated faces. For each face the array must have three vertex positions in clockwise winding order. Since `NavigationMesh` resources have no transform, all vertex positions need to be offset by the node's transform using `xform`.
			'''

    assert(not faces is None)
    assert isinstance(faces, PackedVector3Array), 'faces must be PackedVector3Array'
    assert(not xform is None)
    assert isinstance(xform, Transform3D), 'xform must be Transform3D'








    self._ptr.call_with_return(86,tuple([faces._ptr, xform._ptr]))

  @functools.native_method
  def merge(self, other_geometry:'NavigationMeshSourceGeometryData3D'   ) -> None:
    r'''
				Adds the geometry data of another `NavigationMeshSourceGeometryData3D` to the navigation mesh baking data.
			'''

    assert(not other_geometry is None)
    assert isinstance(other_geometry, get_class('NavigationMeshSourceGeometryData3D')), 'other_geometry must be NavigationMeshSourceGeometryData3D'







    self._ptr.call_with_return(87,tuple([other_geometry._ptr]))

  @functools.native_method
  def add_projected_obstruction(self, vertices:'PackedVector3Array'   , elevation:'float'   , height:'float'   , carve:'bool'   ) -> None:
    r'''
				Adds a projected obstruction shape to the source geometry. The `vertices` are considered projected on an xz-axes plane, placed at the global y-axis `elevation` and extruded by `height`. If `carve` is `true` the carved shape will not be affected by additional offsets (e.g. agent radius) of the navigation mesh baking process.
			'''

    assert(not vertices is None)
    assert isinstance(vertices, PackedVector3Array), 'vertices must be PackedVector3Array'
    assert isinstance(elevation, (int, float)), 'elevation must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(carve, bool), 'carve must be bool'










    self._ptr.call_with_return(88,tuple([vertices._ptr, elevation, height, carve]))

  @functools.native_method
  def clear_projected_obstructions(self) -> None:
    r'''
				Clears all projected obstructions.
			'''




    self._ptr.call_with_return(89,tuple([]))

  @functools.native_method
  def set_projected_obstructions(self, projected_obstructions:'Array'   ) -> None:
    r'''
				Sets the projected obstructions with an Array of Dictionaries with the following key value pairs:
				
				```gdscript
				"vertices" : PackedFloat32Array
				"elevation" : float
				"height" : float
				"carve" : bool
				```
				
			'''

    assert(not projected_obstructions is None)
    assert isinstance(projected_obstructions, Array), 'projected_obstructions must be Array'


    self.py__projected_obstructions = projected_obstructions






    self._ptr.call_with_return(90,tuple([projected_obstructions._ptr]))

  @functools.native_method
  def get_projected_obstructions(self) -> typing.Union['Array']:
    r'''
				Returns the projected obstructions as an `Array` of dictionaries. Each `Dictionary` contains the following entries:
				- `vertices` - A `PackedFloat32Array` that defines the outline points of the projected shape.
				- `elevation` - A `float` that defines the projected shape placement on the y-axis.
				- `height` - A `float` that defines how much the projected shape is extruded along the y-axis.
				- `carve` - A `bool` that defines how the obstacle affects the navigation mesh baking. If `true` the projected shape will not be affected by addition offsets, e.g. agent radius.
			'''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([]))

    return _ret


  @functools.native_method
  def get_bounds(self) -> typing.Union['AABB']:
    r'''
				Returns an axis-aligned bounding box that covers all the stored geometry data. The bounds are calculated when calling this function with the result cached until further geometry changes are made.
			'''




    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(92,tuple([]))
    return _ret



register_cast_function('NavigationMeshSourceGeometryData3D', NavigationMeshSourceGeometryData3D.cast)
register_class('NavigationMeshSourceGeometryData3D', NavigationMeshSourceGeometryData3D)
