# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.StandardMaterial3D as py4godot_standardmaterial3d 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.ORMMaterial3D as py4godot_ormmaterial3d 
import py4godot.classes.Material as py4godot_material 
from py4godot.wrappers.wrappers import CPPBaseMaterial3DWrapper

class TextureParam:
  TEXTURE_ALBEDO = 0
  TEXTURE_METALLIC = 1
  TEXTURE_ROUGHNESS = 2
  TEXTURE_EMISSION = 3
  TEXTURE_NORMAL = 4
  TEXTURE_BENT_NORMAL = 18
  TEXTURE_RIM = 5
  TEXTURE_CLEARCOAT = 6
  TEXTURE_FLOWMAP = 7
  TEXTURE_AMBIENT_OCCLUSION = 8
  TEXTURE_HEIGHTMAP = 9
  TEXTURE_SUBSURFACE_SCATTERING = 10
  TEXTURE_SUBSURFACE_TRANSMITTANCE = 11
  TEXTURE_BACKLIGHT = 12
  TEXTURE_REFRACTION = 13
  TEXTURE_DETAIL_MASK = 14
  TEXTURE_DETAIL_ALBEDO = 15
  TEXTURE_DETAIL_NORMAL = 16
  TEXTURE_ORM = 17
  TEXTURE_MAX = 19
class TextureFilter:
  TEXTURE_FILTER_NEAREST = 0
  TEXTURE_FILTER_LINEAR = 1
  TEXTURE_FILTER_NEAREST_WITH_MIPMAPS = 2
  TEXTURE_FILTER_LINEAR_WITH_MIPMAPS = 3
  TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC = 4
  TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC = 5
  TEXTURE_FILTER_MAX = 6
class DetailUV:
  DETAIL_UV_1 = 0
  DETAIL_UV_2 = 1
class Transparency:
  TRANSPARENCY_DISABLED = 0
  TRANSPARENCY_ALPHA = 1
  TRANSPARENCY_ALPHA_SCISSOR = 2
  TRANSPARENCY_ALPHA_HASH = 3
  TRANSPARENCY_ALPHA_DEPTH_PRE_PASS = 4
  TRANSPARENCY_MAX = 5
class ShadingMode:
  SHADING_MODE_UNSHADED = 0
  SHADING_MODE_PER_PIXEL = 1
  SHADING_MODE_PER_VERTEX = 2
  SHADING_MODE_MAX = 3
class Feature:
  FEATURE_EMISSION = 0
  FEATURE_NORMAL_MAPPING = 1
  FEATURE_RIM = 2
  FEATURE_CLEARCOAT = 3
  FEATURE_ANISOTROPY = 4
  FEATURE_AMBIENT_OCCLUSION = 5
  FEATURE_HEIGHT_MAPPING = 6
  FEATURE_SUBSURFACE_SCATTERING = 7
  FEATURE_SUBSURFACE_TRANSMITTANCE = 8
  FEATURE_BACKLIGHT = 9
  FEATURE_REFRACTION = 10
  FEATURE_DETAIL = 11
  FEATURE_BENT_NORMAL_MAPPING = 12
  FEATURE_MAX = 13
class BlendMode:
  BLEND_MODE_MIX = 0
  BLEND_MODE_ADD = 1
  BLEND_MODE_SUB = 2
  BLEND_MODE_MUL = 3
  BLEND_MODE_PREMULT_ALPHA = 4
class AlphaAntiAliasing:
  ALPHA_ANTIALIASING_OFF = 0
  ALPHA_ANTIALIASING_ALPHA_TO_COVERAGE = 1
  ALPHA_ANTIALIASING_ALPHA_TO_COVERAGE_AND_TO_ONE = 2
class DepthDrawMode:
  DEPTH_DRAW_OPAQUE_ONLY = 0
  DEPTH_DRAW_ALWAYS = 1
  DEPTH_DRAW_DISABLED = 2
class DepthTest:
  DEPTH_TEST_DEFAULT = 0
  DEPTH_TEST_INVERTED = 1
class CullMode:
  CULL_BACK = 0
  CULL_FRONT = 1
  CULL_DISABLED = 2
class Flags:
  FLAG_DISABLE_DEPTH_TEST = 0
  FLAG_ALBEDO_FROM_VERTEX_COLOR = 1
  FLAG_SRGB_VERTEX_COLOR = 2
  FLAG_USE_POINT_SIZE = 3
  FLAG_FIXED_SIZE = 4
  FLAG_BILLBOARD_KEEP_SCALE = 5
  FLAG_UV1_USE_TRIPLANAR = 6
  FLAG_UV2_USE_TRIPLANAR = 7
  FLAG_UV1_USE_WORLD_TRIPLANAR = 8
  FLAG_UV2_USE_WORLD_TRIPLANAR = 9
  FLAG_AO_ON_UV2 = 10
  FLAG_EMISSION_ON_UV2 = 11
  FLAG_ALBEDO_TEXTURE_FORCE_SRGB = 12
  FLAG_DONT_RECEIVE_SHADOWS = 13
  FLAG_DISABLE_AMBIENT_LIGHT = 14
  FLAG_USE_SHADOW_TO_OPACITY = 15
  FLAG_USE_TEXTURE_REPEAT = 16
  FLAG_INVERT_HEIGHTMAP = 17
  FLAG_SUBSURFACE_MODE_SKIN = 18
  FLAG_PARTICLE_TRAILS_MODE = 19
  FLAG_ALBEDO_TEXTURE_MSDF = 20
  FLAG_DISABLE_FOG = 21
  FLAG_DISABLE_SPECULAR_OCCLUSION = 22
  FLAG_USE_Z_CLIP_SCALE = 23
  FLAG_USE_FOV_OVERRIDE = 24
  FLAG_MAX = 25
class DiffuseMode:
  DIFFUSE_BURLEY = 0
  DIFFUSE_LAMBERT = 1
  DIFFUSE_LAMBERT_WRAP = 2
  DIFFUSE_TOON = 3
class SpecularMode:
  SPECULAR_SCHLICK_GGX = 0
  SPECULAR_TOON = 1
  SPECULAR_DISABLED = 2
class BillboardMode:
  BILLBOARD_DISABLED = 0
  BILLBOARD_ENABLED = 1
  BILLBOARD_FIXED_Y = 2
  BILLBOARD_PARTICLES = 3
class TextureChannel:
  TEXTURE_CHANNEL_RED = 0
  TEXTURE_CHANNEL_GREEN = 1
  TEXTURE_CHANNEL_BLUE = 2
  TEXTURE_CHANNEL_ALPHA = 3
  TEXTURE_CHANNEL_GRAYSCALE = 4
class EmissionOperator:
  EMISSION_OP_ADD = 0
  EMISSION_OP_MULTIPLY = 1
class DistanceFadeMode:
  DISTANCE_FADE_DISABLED = 0
  DISTANCE_FADE_PIXEL_ALPHA = 1
  DISTANCE_FADE_PIXEL_DITHER = 2
  DISTANCE_FADE_OBJECT_DITHER = 3
class StencilMode:
  STENCIL_MODE_DISABLED = 0
  STENCIL_MODE_OUTLINE = 1
  STENCIL_MODE_XRAY = 2
  STENCIL_MODE_CUSTOM = 3
class StencilFlags:
  STENCIL_FLAG_READ = 1
  STENCIL_FLAG_WRITE = 2
  STENCIL_FLAG_WRITE_DEPTH_FAIL = 4
class StencilCompare:
  STENCIL_COMPARE_ALWAYS = 0
  STENCIL_COMPARE_LESS = 1
  STENCIL_COMPARE_EQUAL = 2
  STENCIL_COMPARE_LESS_OR_EQUAL = 3
  STENCIL_COMPARE_GREATER = 4
  STENCIL_COMPARE_NOT_EQUAL = 5
  STENCIL_COMPARE_GREATER_OR_EQUAL = 6


class BaseMaterial3D(py4godot_material.Material):
  r'''
		This class serves as a default material with a wide variety of rendering features and properties without the need to write shader code. See the tutorial below for details.
	'''

  @staticmethod
  def constructor():
    class_ = BaseMaterial3D.construct_without_init()
    class_._ptr = constructor(164,0, ())
    return class_
  @staticmethod
  def new():
    class_ = BaseMaterial3D.construct_without_init()
    class_._ptr = constructor(164,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPBaseMaterial3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(164,0, ())


  def generate_wrapper(self):
    return CPPBaseMaterial3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = BaseMaterial3D.__new__(BaseMaterial3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'BaseMaterial3D'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(241, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = BaseMaterial3D.construct_without_init()
    cls._ptr = CPPBaseMaterial3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = BaseMaterial3D.construct_without_init()
    cls._ptr = CPPBaseMaterial3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def transparency(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_transparency()
    return _ret
  @transparency.setter
  def transparency(self,  value:'int'):
    self.set_transparency(value)
  @property
  def alpha_scissor_threshold(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_alpha_scissor_threshold()
    return _ret
  @alpha_scissor_threshold.setter
  def alpha_scissor_threshold(self,  value:'float'):
    self.set_alpha_scissor_threshold(value)
  @property
  def alpha_hash_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_alpha_hash_scale()
    return _ret
  @alpha_hash_scale.setter
  def alpha_hash_scale(self,  value:'float'):
    self.set_alpha_hash_scale(value)
  @property
  def alpha_antialiasing_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_alpha_antialiasing()
    return _ret
  @alpha_antialiasing_mode.setter
  def alpha_antialiasing_mode(self,  value:'int'):
    self.set_alpha_antialiasing(value)
  @property
  def alpha_antialiasing_edge(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_alpha_antialiasing_edge()
    return _ret
  @alpha_antialiasing_edge.setter
  def alpha_antialiasing_edge(self,  value:'float'):
    self.set_alpha_antialiasing_edge(value)
  @property
  def blend_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_blend_mode()
    return _ret
  @blend_mode.setter
  def blend_mode(self,  value:'int'):
    self.set_blend_mode(value)
  @property
  def cull_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_cull_mode()
    return _ret
  @cull_mode.setter
  def cull_mode(self,  value:'int'):
    self.set_cull_mode(value)
  @property
  def depth_draw_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_depth_draw_mode()
    return _ret
  @depth_draw_mode.setter
  def depth_draw_mode(self,  value:'int'):
    self.set_depth_draw_mode(value)
  @property
  def no_depth_test(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(0)
    return _ret
  @no_depth_test.setter
  def no_depth_test(self,  value:'bool'):
    self.set_flag(0, value)
  @property
  def depth_test(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_depth_test()
    return _ret
  @depth_test.setter
  def depth_test(self,  value:'int'):
    self.set_depth_test(value)
  @property
  def shading_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_shading_mode()
    return _ret
  @shading_mode.setter
  def shading_mode(self,  value:'int'):
    self.set_shading_mode(value)
  @property
  def diffuse_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_diffuse_mode()
    return _ret
  @diffuse_mode.setter
  def diffuse_mode(self,  value:'int'):
    self.set_diffuse_mode(value)
  @property
  def specular_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_specular_mode()
    return _ret
  @specular_mode.setter
  def specular_mode(self,  value:'int'):
    self.set_specular_mode(value)
  @property
  def disable_ambient_light(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(14)
    return _ret
  @disable_ambient_light.setter
  def disable_ambient_light(self,  value:'bool'):
    self.set_flag(14, value)
  @property
  def disable_fog(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(21)
    return _ret
  @disable_fog.setter
  def disable_fog(self,  value:'bool'):
    self.set_flag(21, value)
  @property
  def disable_specular_occlusion(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(22)
    return _ret
  @disable_specular_occlusion.setter
  def disable_specular_occlusion(self,  value:'bool'):
    self.set_flag(22, value)
  @property
  def vertex_color_use_as_albedo(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(1)
    return _ret
  @vertex_color_use_as_albedo.setter
  def vertex_color_use_as_albedo(self,  value:'bool'):
    self.set_flag(1, value)
  @property
  def vertex_color_is_srgb(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(2)
    return _ret
  @vertex_color_is_srgb.setter
  def vertex_color_is_srgb(self,  value:'bool'):
    self.set_flag(2, value)
  @property
  def albedo_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_albedo()
    return _ret
  @albedo_color.setter
  def albedo_color(self,  value:'Color'):
    self.set_albedo(value)
  @property
  def albedo_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(0)
    return _ret
  @albedo_texture.setter
  def albedo_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(0, value)
  @property
  def albedo_texture_force_srgb(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(12)
    return _ret
  @albedo_texture_force_srgb.setter
  def albedo_texture_force_srgb(self,  value:'bool'):
    self.set_flag(12, value)
  @property
  def albedo_texture_msdf(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(20)
    return _ret
  @albedo_texture_msdf.setter
  def albedo_texture_msdf(self,  value:'bool'):
    self.set_flag(20, value)
  @property
  def orm_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(17)
    return _ret
  @orm_texture.setter
  def orm_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(17, value)
  @property
  def metallic(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_metallic()
    return _ret
  @metallic.setter
  def metallic(self,  value:'float'):
    self.set_metallic(value)
  @property
  def metallic_specular(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_specular()
    return _ret
  @metallic_specular.setter
  def metallic_specular(self,  value:'float'):
    self.set_specular(value)
  @property
  def metallic_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(1)
    return _ret
  @metallic_texture.setter
  def metallic_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(1, value)
  @property
  def metallic_texture_channel(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_metallic_texture_channel()
    return _ret
  @metallic_texture_channel.setter
  def metallic_texture_channel(self,  value:'int'):
    self.set_metallic_texture_channel(value)
  @property
  def roughness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_roughness()
    return _ret
  @roughness.setter
  def roughness(self,  value:'float'):
    self.set_roughness(value)
  @property
  def roughness_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(2)
    return _ret
  @roughness_texture.setter
  def roughness_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(2, value)
  @property
  def roughness_texture_channel(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_roughness_texture_channel()
    return _ret
  @roughness_texture_channel.setter
  def roughness_texture_channel(self,  value:'int'):
    self.set_roughness_texture_channel(value)
  @property
  def emission_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_feature(0)
    return _ret
  @emission_enabled.setter
  def emission_enabled(self,  value:'bool'):
    self.set_feature(0, value)
  @property
  def emission(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_emission()
    return _ret
  @emission.setter
  def emission(self,  value:'Color'):
    self.set_emission(value)
  @property
  def emission_energy_multiplier(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_emission_energy_multiplier()
    return _ret
  @emission_energy_multiplier.setter
  def emission_energy_multiplier(self,  value:'float'):
    self.set_emission_energy_multiplier(value)
  @property
  def emission_intensity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_emission_intensity()
    return _ret
  @emission_intensity.setter
  def emission_intensity(self,  value:'float'):
    self.set_emission_intensity(value)
  @property
  def emission_operator(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_emission_operator()
    return _ret
  @emission_operator.setter
  def emission_operator(self,  value:'int'):
    self.set_emission_operator(value)
  @property
  def emission_on_uv2(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(11)
    return _ret
  @emission_on_uv2.setter
  def emission_on_uv2(self,  value:'bool'):
    self.set_flag(11, value)
  @property
  def emission_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(3)
    return _ret
  @emission_texture.setter
  def emission_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(3, value)
  @property
  def normal_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_feature(1)
    return _ret
  @normal_enabled.setter
  def normal_enabled(self,  value:'bool'):
    self.set_feature(1, value)
  @property
  def normal_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_normal_scale()
    return _ret
  @normal_scale.setter
  def normal_scale(self,  value:'float'):
    self.set_normal_scale(value)
  @property
  def normal_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(4)
    return _ret
  @normal_texture.setter
  def normal_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(4, value)
  @property
  def bent_normal_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_feature(12)
    return _ret
  @bent_normal_enabled.setter
  def bent_normal_enabled(self,  value:'bool'):
    self.set_feature(12, value)
  @property
  def bent_normal_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(18)
    return _ret
  @bent_normal_texture.setter
  def bent_normal_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(18, value)
  @property
  def rim_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_feature(2)
    return _ret
  @rim_enabled.setter
  def rim_enabled(self,  value:'bool'):
    self.set_feature(2, value)
  @property
  def rim(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_rim()
    return _ret
  @rim.setter
  def rim(self,  value:'float'):
    self.set_rim(value)
  @property
  def rim_tint(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_rim_tint()
    return _ret
  @rim_tint.setter
  def rim_tint(self,  value:'float'):
    self.set_rim_tint(value)
  @property
  def rim_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(5)
    return _ret
  @rim_texture.setter
  def rim_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(5, value)
  @property
  def clearcoat_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_feature(3)
    return _ret
  @clearcoat_enabled.setter
  def clearcoat_enabled(self,  value:'bool'):
    self.set_feature(3, value)
  @property
  def clearcoat(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_clearcoat()
    return _ret
  @clearcoat.setter
  def clearcoat(self,  value:'float'):
    self.set_clearcoat(value)
  @property
  def clearcoat_roughness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_clearcoat_roughness()
    return _ret
  @clearcoat_roughness.setter
  def clearcoat_roughness(self,  value:'float'):
    self.set_clearcoat_roughness(value)
  @property
  def clearcoat_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(6)
    return _ret
  @clearcoat_texture.setter
  def clearcoat_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(6, value)
  @property
  def anisotropy_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_feature(4)
    return _ret
  @anisotropy_enabled.setter
  def anisotropy_enabled(self,  value:'bool'):
    self.set_feature(4, value)
  @property
  def anisotropy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_anisotropy()
    return _ret
  @anisotropy.setter
  def anisotropy(self,  value:'float'):
    self.set_anisotropy(value)
  @property
  def anisotropy_flowmap(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(7)
    return _ret
  @anisotropy_flowmap.setter
  def anisotropy_flowmap(self,  value:'py4godot_object.Object'):
    self.set_texture(7, value)
  @property
  def ao_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_feature(5)
    return _ret
  @ao_enabled.setter
  def ao_enabled(self,  value:'bool'):
    self.set_feature(5, value)
  @property
  def ao_light_affect(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ao_light_affect()
    return _ret
  @ao_light_affect.setter
  def ao_light_affect(self,  value:'float'):
    self.set_ao_light_affect(value)
  @property
  def ao_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(8)
    return _ret
  @ao_texture.setter
  def ao_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(8, value)
  @property
  def ao_on_uv2(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(10)
    return _ret
  @ao_on_uv2.setter
  def ao_on_uv2(self,  value:'bool'):
    self.set_flag(10, value)
  @property
  def ao_texture_channel(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_ao_texture_channel()
    return _ret
  @ao_texture_channel.setter
  def ao_texture_channel(self,  value:'int'):
    self.set_ao_texture_channel(value)
  @property
  def heightmap_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_feature(6)
    return _ret
  @heightmap_enabled.setter
  def heightmap_enabled(self,  value:'bool'):
    self.set_feature(6, value)
  @property
  def heightmap_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_heightmap_scale()
    return _ret
  @heightmap_scale.setter
  def heightmap_scale(self,  value:'float'):
    self.set_heightmap_scale(value)
  @property
  def heightmap_deep_parallax(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_heightmap_deep_parallax_enabled()
    return _ret
  @heightmap_deep_parallax.setter
  def heightmap_deep_parallax(self,  value:'bool'):
    self.set_heightmap_deep_parallax(value)
  @property
  def heightmap_min_layers(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_heightmap_deep_parallax_min_layers()
    return _ret
  @heightmap_min_layers.setter
  def heightmap_min_layers(self,  value:'int'):
    self.set_heightmap_deep_parallax_min_layers(value)
  @property
  def heightmap_max_layers(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_heightmap_deep_parallax_max_layers()
    return _ret
  @heightmap_max_layers.setter
  def heightmap_max_layers(self,  value:'int'):
    self.set_heightmap_deep_parallax_max_layers(value)
  @property
  def heightmap_flip_tangent(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_heightmap_deep_parallax_flip_tangent()
    return _ret
  @heightmap_flip_tangent.setter
  def heightmap_flip_tangent(self,  value:'bool'):
    self.set_heightmap_deep_parallax_flip_tangent(value)
  @property
  def heightmap_flip_binormal(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_heightmap_deep_parallax_flip_binormal()
    return _ret
  @heightmap_flip_binormal.setter
  def heightmap_flip_binormal(self,  value:'bool'):
    self.set_heightmap_deep_parallax_flip_binormal(value)
  @property
  def heightmap_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(9)
    return _ret
  @heightmap_texture.setter
  def heightmap_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(9, value)
  @property
  def heightmap_flip_texture(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(17)
    return _ret
  @heightmap_flip_texture.setter
  def heightmap_flip_texture(self,  value:'bool'):
    self.set_flag(17, value)
  @property
  def subsurf_scatter_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_feature(7)
    return _ret
  @subsurf_scatter_enabled.setter
  def subsurf_scatter_enabled(self,  value:'bool'):
    self.set_feature(7, value)
  @property
  def subsurf_scatter_strength(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_subsurface_scattering_strength()
    return _ret
  @subsurf_scatter_strength.setter
  def subsurf_scatter_strength(self,  value:'float'):
    self.set_subsurface_scattering_strength(value)
  @property
  def subsurf_scatter_skin_mode(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(18)
    return _ret
  @subsurf_scatter_skin_mode.setter
  def subsurf_scatter_skin_mode(self,  value:'bool'):
    self.set_flag(18, value)
  @property
  def subsurf_scatter_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(10)
    return _ret
  @subsurf_scatter_texture.setter
  def subsurf_scatter_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(10, value)
  @property
  def subsurf_scatter_transmittance_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_feature(8)
    return _ret
  @subsurf_scatter_transmittance_enabled.setter
  def subsurf_scatter_transmittance_enabled(self,  value:'bool'):
    self.set_feature(8, value)
  @property
  def subsurf_scatter_transmittance_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_transmittance_color()
    return _ret
  @subsurf_scatter_transmittance_color.setter
  def subsurf_scatter_transmittance_color(self,  value:'Color'):
    self.set_transmittance_color(value)
  @property
  def subsurf_scatter_transmittance_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(11)
    return _ret
  @subsurf_scatter_transmittance_texture.setter
  def subsurf_scatter_transmittance_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(11, value)
  @property
  def subsurf_scatter_transmittance_depth(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_transmittance_depth()
    return _ret
  @subsurf_scatter_transmittance_depth.setter
  def subsurf_scatter_transmittance_depth(self,  value:'float'):
    self.set_transmittance_depth(value)
  @property
  def subsurf_scatter_transmittance_boost(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_transmittance_boost()
    return _ret
  @subsurf_scatter_transmittance_boost.setter
  def subsurf_scatter_transmittance_boost(self,  value:'float'):
    self.set_transmittance_boost(value)
  @property
  def backlight_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_feature(9)
    return _ret
  @backlight_enabled.setter
  def backlight_enabled(self,  value:'bool'):
    self.set_feature(9, value)
  @property
  def backlight(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_backlight()
    return _ret
  @backlight.setter
  def backlight(self,  value:'Color'):
    self.set_backlight(value)
  @property
  def backlight_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(12)
    return _ret
  @backlight_texture.setter
  def backlight_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(12, value)
  @property
  def refraction_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_feature(10)
    return _ret
  @refraction_enabled.setter
  def refraction_enabled(self,  value:'bool'):
    self.set_feature(10, value)
  @property
  def refraction_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_refraction()
    return _ret
  @refraction_scale.setter
  def refraction_scale(self,  value:'float'):
    self.set_refraction(value)
  @property
  def refraction_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(13)
    return _ret
  @refraction_texture.setter
  def refraction_texture(self,  value:'py4godot_object.Object'):
    self.set_texture(13, value)
  @property
  def refraction_texture_channel(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_refraction_texture_channel()
    return _ret
  @refraction_texture_channel.setter
  def refraction_texture_channel(self,  value:'int'):
    self.set_refraction_texture_channel(value)
  @property
  def detail_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_feature(11)
    return _ret
  @detail_enabled.setter
  def detail_enabled(self,  value:'bool'):
    self.set_feature(11, value)
  @property
  def detail_mask(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(14)
    return _ret
  @detail_mask.setter
  def detail_mask(self,  value:'py4godot_object.Object'):
    self.set_texture(14, value)
  @property
  def detail_blend_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_detail_blend_mode()
    return _ret
  @detail_blend_mode.setter
  def detail_blend_mode(self,  value:'int'):
    self.set_detail_blend_mode(value)
  @property
  def detail_uv_layer(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_detail_uv()
    return _ret
  @detail_uv_layer.setter
  def detail_uv_layer(self,  value:'int'):
    self.set_detail_uv(value)
  @property
  def detail_albedo(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(15)
    return _ret
  @detail_albedo.setter
  def detail_albedo(self,  value:'py4godot_object.Object'):
    self.set_texture(15, value)
  @property
  def detail_normal(self) -> typing.Any:
    r''''''
    _ret = self. get_texture(16)
    return _ret
  @detail_normal.setter
  def detail_normal(self,  value:'py4godot_object.Object'):
    self.set_texture(16, value)
  @property
  def uv1_scale(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_uv1_scale()
    return _ret
  @uv1_scale.setter
  def uv1_scale(self,  value:'Vector3'):
    self.set_uv1_scale(value)
  @property
  def uv1_offset(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_uv1_offset()
    return _ret
  @uv1_offset.setter
  def uv1_offset(self,  value:'Vector3'):
    self.set_uv1_offset(value)
  @property
  def uv1_triplanar(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(6)
    return _ret
  @uv1_triplanar.setter
  def uv1_triplanar(self,  value:'bool'):
    self.set_flag(6, value)
  @property
  def uv1_triplanar_sharpness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_uv1_triplanar_blend_sharpness()
    return _ret
  @uv1_triplanar_sharpness.setter
  def uv1_triplanar_sharpness(self,  value:'float'):
    self.set_uv1_triplanar_blend_sharpness(value)
  @property
  def uv1_world_triplanar(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(8)
    return _ret
  @uv1_world_triplanar.setter
  def uv1_world_triplanar(self,  value:'bool'):
    self.set_flag(8, value)
  @property
  def uv2_scale(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_uv2_scale()
    return _ret
  @uv2_scale.setter
  def uv2_scale(self,  value:'Vector3'):
    self.set_uv2_scale(value)
  @property
  def uv2_offset(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_uv2_offset()
    return _ret
  @uv2_offset.setter
  def uv2_offset(self,  value:'Vector3'):
    self.set_uv2_offset(value)
  @property
  def uv2_triplanar(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(7)
    return _ret
  @uv2_triplanar.setter
  def uv2_triplanar(self,  value:'bool'):
    self.set_flag(7, value)
  @property
  def uv2_triplanar_sharpness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_uv2_triplanar_blend_sharpness()
    return _ret
  @uv2_triplanar_sharpness.setter
  def uv2_triplanar_sharpness(self,  value:'float'):
    self.set_uv2_triplanar_blend_sharpness(value)
  @property
  def uv2_world_triplanar(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(9)
    return _ret
  @uv2_world_triplanar.setter
  def uv2_world_triplanar(self,  value:'bool'):
    self.set_flag(9, value)
  @property
  def texture_filter(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_texture_filter()
    return _ret
  @texture_filter.setter
  def texture_filter(self,  value:'int'):
    self.set_texture_filter(value)
  @property
  def texture_repeat(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(16)
    return _ret
  @texture_repeat.setter
  def texture_repeat(self,  value:'bool'):
    self.set_flag(16, value)
  @property
  def disable_receive_shadows(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(13)
    return _ret
  @disable_receive_shadows.setter
  def disable_receive_shadows(self,  value:'bool'):
    self.set_flag(13, value)
  @property
  def shadow_to_opacity(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(15)
    return _ret
  @shadow_to_opacity.setter
  def shadow_to_opacity(self,  value:'bool'):
    self.set_flag(15, value)
  @property
  def billboard_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_billboard_mode()
    return _ret
  @billboard_mode.setter
  def billboard_mode(self,  value:'int'):
    self.set_billboard_mode(value)
  @property
  def billboard_keep_scale(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(5)
    return _ret
  @billboard_keep_scale.setter
  def billboard_keep_scale(self,  value:'bool'):
    self.set_flag(5, value)
  @property
  def particles_anim_h_frames(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_particles_anim_h_frames()
    return _ret
  @particles_anim_h_frames.setter
  def particles_anim_h_frames(self,  value:'int'):
    self.set_particles_anim_h_frames(value)
  @property
  def particles_anim_v_frames(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_particles_anim_v_frames()
    return _ret
  @particles_anim_v_frames.setter
  def particles_anim_v_frames(self,  value:'int'):
    self.set_particles_anim_v_frames(value)
  @property
  def particles_anim_loop(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_particles_anim_loop()
    return _ret
  @particles_anim_loop.setter
  def particles_anim_loop(self,  value:'bool'):
    self.set_particles_anim_loop(value)
  @property
  def grow(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_grow_enabled()
    return _ret
  @grow.setter
  def grow(self,  value:'bool'):
    self.set_grow_enabled(value)
  @property
  def grow_amount(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_grow()
    return _ret
  @grow_amount.setter
  def grow_amount(self,  value:'float'):
    self.set_grow(value)
  @property
  def fixed_size(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(4)
    return _ret
  @fixed_size.setter
  def fixed_size(self,  value:'bool'):
    self.set_flag(4, value)
  @property
  def use_point_size(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(3)
    return _ret
  @use_point_size.setter
  def use_point_size(self,  value:'bool'):
    self.set_flag(3, value)
  @property
  def point_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_point_size()
    return _ret
  @point_size.setter
  def point_size(self,  value:'float'):
    self.set_point_size(value)
  @property
  def use_particle_trails(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(19)
    return _ret
  @use_particle_trails.setter
  def use_particle_trails(self,  value:'bool'):
    self.set_flag(19, value)
  @property
  def use_z_clip_scale(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(23)
    return _ret
  @use_z_clip_scale.setter
  def use_z_clip_scale(self,  value:'bool'):
    self.set_flag(23, value)
  @property
  def z_clip_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_z_clip_scale()
    return _ret
  @z_clip_scale.setter
  def z_clip_scale(self,  value:'float'):
    self.set_z_clip_scale(value)
  @property
  def use_fov_override(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_flag(24)
    return _ret
  @use_fov_override.setter
  def use_fov_override(self,  value:'bool'):
    self.set_flag(24, value)
  @property
  def fov_override(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_fov_override()
    return _ret
  @fov_override.setter
  def fov_override(self,  value:'float'):
    self.set_fov_override(value)
  @property
  def proximity_fade_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_proximity_fade_enabled()
    return _ret
  @proximity_fade_enabled.setter
  def proximity_fade_enabled(self,  value:'bool'):
    self.set_proximity_fade_enabled(value)
  @property
  def proximity_fade_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_proximity_fade_distance()
    return _ret
  @proximity_fade_distance.setter
  def proximity_fade_distance(self,  value:'float'):
    self.set_proximity_fade_distance(value)
  @property
  def msdf_pixel_range(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_msdf_pixel_range()
    return _ret
  @msdf_pixel_range.setter
  def msdf_pixel_range(self,  value:'float'):
    self.set_msdf_pixel_range(value)
  @property
  def msdf_outline_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_msdf_outline_size()
    return _ret
  @msdf_outline_size.setter
  def msdf_outline_size(self,  value:'float'):
    self.set_msdf_outline_size(value)
  @property
  def distance_fade_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_distance_fade()
    return _ret
  @distance_fade_mode.setter
  def distance_fade_mode(self,  value:'int'):
    self.set_distance_fade(value)
  @property
  def distance_fade_min_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_distance_fade_min_distance()
    return _ret
  @distance_fade_min_distance.setter
  def distance_fade_min_distance(self,  value:'float'):
    self.set_distance_fade_min_distance(value)
  @property
  def distance_fade_max_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_distance_fade_max_distance()
    return _ret
  @distance_fade_max_distance.setter
  def distance_fade_max_distance(self,  value:'float'):
    self.set_distance_fade_max_distance(value)
  @property
  def stencil_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_stencil_mode()
    return _ret
  @stencil_mode.setter
  def stencil_mode(self,  value:'int'):
    self.set_stencil_mode(value)
  @property
  def stencil_flags(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_stencil_flags()
    return _ret
  @stencil_flags.setter
  def stencil_flags(self,  value:'int'):
    self.set_stencil_flags(value)
  @property
  def stencil_compare(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_stencil_compare()
    return _ret
  @stencil_compare.setter
  def stencil_compare(self,  value:'int'):
    self.set_stencil_compare(value)
  @property
  def stencil_reference(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_stencil_reference()
    return _ret
  @stencil_reference.setter
  def stencil_reference(self,  value:'int'):
    self.set_stencil_reference(value)
  @property
  def stencil_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_stencil_effect_color()
    return _ret
  @stencil_color.setter
  def stencil_color(self,  value:'Color'):
    self.set_stencil_effect_color(value)
  @property
  def stencil_outline_thickness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_stencil_effect_outline_thickness()
    return _ret
  @stencil_outline_thickness.setter
  def stencil_outline_thickness(self,  value:'float'):
    self.set_stencil_effect_outline_thickness(value)
  @functools.native_method
  def set_albedo(self, albedo:'Color'   ) -> None:
    r''''''

    assert(not albedo is None)
    assert isinstance(albedo, Color), 'albedo must be Color'


    self.py__albedo_color = albedo






    self._ptr.call_with_return(87,tuple([albedo._ptr]))

  @functools.native_method
  def get_albedo(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([]))

    return _ret


  @functools.native_method
  def set_transparency(self, transparency:'int'  ) -> None:
    r''''''

    assert isinstance(transparency, (int, float)), 'transparency must be int or float'


    self.py__transparency = transparency






    self._ptr.call_with_return(89,tuple([transparency]))

  @functools.native_method
  def get_transparency(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(90,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_antialiasing(self, alpha_aa:'int'  ) -> None:
    r''''''

    assert isinstance(alpha_aa, (int, float)), 'alpha_aa must be int or float'


    self.py__alpha_antialiasing_mode = alpha_aa






    self._ptr.call_with_return(91,tuple([alpha_aa]))

  @functools.native_method
  def get_alpha_antialiasing(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(92,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_antialiasing_edge(self, edge:'float'   ) -> None:
    r''''''

    assert isinstance(edge, (int, float)), 'edge must be int or float'


    self.py__alpha_antialiasing_edge = edge






    self._ptr.call_with_return(93,tuple([edge]))

  @functools.native_method
  def get_alpha_antialiasing_edge(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([]))

    return _ret


  @functools.native_method
  def set_shading_mode(self, shading_mode:'int'  ) -> None:
    r''''''

    assert isinstance(shading_mode, (int, float)), 'shading_mode must be int or float'


    self.py__shading_mode = shading_mode






    self._ptr.call_with_return(95,tuple([shading_mode]))

  @functools.native_method
  def get_shading_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(96,tuple([]))

    return _ret


  @functools.native_method
  def set_specular(self, specular:'float'   ) -> None:
    r''''''

    assert isinstance(specular, (int, float)), 'specular must be int or float'


    self.py__metallic_specular = specular






    self._ptr.call_with_return(97,tuple([specular]))

  @functools.native_method
  def get_specular(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(98,tuple([]))

    return _ret


  @functools.native_method
  def set_metallic(self, metallic:'float'   ) -> None:
    r''''''

    assert isinstance(metallic, (int, float)), 'metallic must be int or float'


    self.py__metallic = metallic






    self._ptr.call_with_return(99,tuple([metallic]))

  @functools.native_method
  def get_metallic(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([]))

    return _ret


  @functools.native_method
  def set_roughness(self, roughness:'float'   ) -> None:
    r''''''

    assert isinstance(roughness, (int, float)), 'roughness must be int or float'


    self.py__roughness = roughness






    self._ptr.call_with_return(101,tuple([roughness]))

  @functools.native_method
  def get_roughness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([]))

    return _ret


  @functools.native_method
  def set_emission(self, emission:'Color'   ) -> None:
    r''''''

    assert(not emission is None)
    assert isinstance(emission, Color), 'emission must be Color'


    self.py__emission = emission






    self._ptr.call_with_return(103,tuple([emission._ptr]))

  @functools.native_method
  def get_emission(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(104,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_energy_multiplier(self, emission_energy_multiplier:'float'   ) -> None:
    r''''''

    assert isinstance(emission_energy_multiplier, (int, float)), 'emission_energy_multiplier must be int or float'


    self.py__emission_energy_multiplier = emission_energy_multiplier






    self._ptr.call_with_return(105,tuple([emission_energy_multiplier]))

  @functools.native_method
  def get_emission_energy_multiplier(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(106,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_intensity(self, emission_energy_multiplier:'float'   ) -> None:
    r''''''

    assert isinstance(emission_energy_multiplier, (int, float)), 'emission_energy_multiplier must be int or float'


    self.py__emission_intensity = emission_energy_multiplier






    self._ptr.call_with_return(107,tuple([emission_energy_multiplier]))

  @functools.native_method
  def get_emission_intensity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(108,tuple([]))

    return _ret


  @functools.native_method
  def set_normal_scale(self, normal_scale:'float'   ) -> None:
    r''''''

    assert isinstance(normal_scale, (int, float)), 'normal_scale must be int or float'


    self.py__normal_scale = normal_scale






    self._ptr.call_with_return(109,tuple([normal_scale]))

  @functools.native_method
  def get_normal_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(110,tuple([]))

    return _ret


  @functools.native_method
  def set_rim(self, rim:'float'   ) -> None:
    r''''''

    assert isinstance(rim, (int, float)), 'rim must be int or float'


    self.py__rim = rim






    self._ptr.call_with_return(111,tuple([rim]))

  @functools.native_method
  def get_rim(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(112,tuple([]))

    return _ret


  @functools.native_method
  def set_rim_tint(self, rim_tint:'float'   ) -> None:
    r''''''

    assert isinstance(rim_tint, (int, float)), 'rim_tint must be int or float'


    self.py__rim_tint = rim_tint






    self._ptr.call_with_return(113,tuple([rim_tint]))

  @functools.native_method
  def get_rim_tint(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(114,tuple([]))

    return _ret


  @functools.native_method
  def set_clearcoat(self, clearcoat:'float'   ) -> None:
    r''''''

    assert isinstance(clearcoat, (int, float)), 'clearcoat must be int or float'


    self.py__clearcoat = clearcoat






    self._ptr.call_with_return(115,tuple([clearcoat]))

  @functools.native_method
  def get_clearcoat(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(116,tuple([]))

    return _ret


  @functools.native_method
  def set_clearcoat_roughness(self, clearcoat_roughness:'float'   ) -> None:
    r''''''

    assert isinstance(clearcoat_roughness, (int, float)), 'clearcoat_roughness must be int or float'


    self.py__clearcoat_roughness = clearcoat_roughness






    self._ptr.call_with_return(117,tuple([clearcoat_roughness]))

  @functools.native_method
  def get_clearcoat_roughness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(118,tuple([]))

    return _ret


  @functools.native_method
  def set_anisotropy(self, anisotropy:'float'   ) -> None:
    r''''''

    assert isinstance(anisotropy, (int, float)), 'anisotropy must be int or float'


    self.py__anisotropy = anisotropy






    self._ptr.call_with_return(119,tuple([anisotropy]))

  @functools.native_method
  def get_anisotropy(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(120,tuple([]))

    return _ret


  @functools.native_method
  def set_heightmap_scale(self, heightmap_scale:'float'   ) -> None:
    r''''''

    assert isinstance(heightmap_scale, (int, float)), 'heightmap_scale must be int or float'


    self.py__heightmap_scale = heightmap_scale






    self._ptr.call_with_return(121,tuple([heightmap_scale]))

  @functools.native_method
  def get_heightmap_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(122,tuple([]))

    return _ret


  @functools.native_method
  def set_subsurface_scattering_strength(self, strength:'float'   ) -> None:
    r''''''

    assert isinstance(strength, (int, float)), 'strength must be int or float'


    self.py__subsurf_scatter_strength = strength






    self._ptr.call_with_return(123,tuple([strength]))

  @functools.native_method
  def get_subsurface_scattering_strength(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(124,tuple([]))

    return _ret


  @functools.native_method
  def set_transmittance_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__subsurf_scatter_transmittance_color = color






    self._ptr.call_with_return(125,tuple([color._ptr]))

  @functools.native_method
  def get_transmittance_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(126,tuple([]))

    return _ret


  @functools.native_method
  def set_transmittance_depth(self, depth:'float'   ) -> None:
    r''''''

    assert isinstance(depth, (int, float)), 'depth must be int or float'


    self.py__subsurf_scatter_transmittance_depth = depth






    self._ptr.call_with_return(127,tuple([depth]))

  @functools.native_method
  def get_transmittance_depth(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(128,tuple([]))

    return _ret


  @functools.native_method
  def set_transmittance_boost(self, boost:'float'   ) -> None:
    r''''''

    assert isinstance(boost, (int, float)), 'boost must be int or float'


    self.py__subsurf_scatter_transmittance_boost = boost






    self._ptr.call_with_return(129,tuple([boost]))

  @functools.native_method
  def get_transmittance_boost(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(130,tuple([]))

    return _ret


  @functools.native_method
  def set_backlight(self, backlight:'Color'   ) -> None:
    r''''''

    assert(not backlight is None)
    assert isinstance(backlight, Color), 'backlight must be Color'


    self.py__backlight = backlight






    self._ptr.call_with_return(131,tuple([backlight._ptr]))

  @functools.native_method
  def get_backlight(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(132,tuple([]))

    return _ret


  @functools.native_method
  def set_refraction(self, refraction:'float'   ) -> None:
    r''''''

    assert isinstance(refraction, (int, float)), 'refraction must be int or float'


    self.py__refraction_scale = refraction






    self._ptr.call_with_return(133,tuple([refraction]))

  @functools.native_method
  def get_refraction(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(134,tuple([]))

    return _ret


  @functools.native_method
  def set_point_size(self, point_size:'float'   ) -> None:
    r''''''

    assert isinstance(point_size, (int, float)), 'point_size must be int or float'


    self.py__point_size = point_size






    self._ptr.call_with_return(135,tuple([point_size]))

  @functools.native_method
  def get_point_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(136,tuple([]))

    return _ret


  @functools.native_method
  def set_detail_uv(self, detail_uv:'int'  ) -> None:
    r''''''

    assert isinstance(detail_uv, (int, float)), 'detail_uv must be int or float'


    self.py__detail_uv_layer = detail_uv






    self._ptr.call_with_return(137,tuple([detail_uv]))

  @functools.native_method
  def get_detail_uv(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(138,tuple([]))

    return _ret


  @functools.native_method
  def set_blend_mode(self, blend_mode:'int'  ) -> None:
    r''''''

    assert isinstance(blend_mode, (int, float)), 'blend_mode must be int or float'


    self.py__blend_mode = blend_mode






    self._ptr.call_with_return(139,tuple([blend_mode]))

  @functools.native_method
  def get_blend_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(140,tuple([]))

    return _ret


  @functools.native_method
  def set_depth_draw_mode(self, depth_draw_mode:'int'  ) -> None:
    r''''''

    assert isinstance(depth_draw_mode, (int, float)), 'depth_draw_mode must be int or float'


    self.py__depth_draw_mode = depth_draw_mode






    self._ptr.call_with_return(141,tuple([depth_draw_mode]))

  @functools.native_method
  def get_depth_draw_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(142,tuple([]))

    return _ret


  @functools.native_method
  def set_depth_test(self, depth_test:'int'  ) -> None:
    r''''''

    assert isinstance(depth_test, (int, float)), 'depth_test must be int or float'


    self.py__depth_test = depth_test






    self._ptr.call_with_return(143,tuple([depth_test]))

  @functools.native_method
  def get_depth_test(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(144,tuple([]))

    return _ret


  @functools.native_method
  def set_cull_mode(self, cull_mode:'int'  ) -> None:
    r''''''

    assert isinstance(cull_mode, (int, float)), 'cull_mode must be int or float'


    self.py__cull_mode = cull_mode






    self._ptr.call_with_return(145,tuple([cull_mode]))

  @functools.native_method
  def get_cull_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(146,tuple([]))

    return _ret


  @functools.native_method
  def set_diffuse_mode(self, diffuse_mode:'int'  ) -> None:
    r''''''

    assert isinstance(diffuse_mode, (int, float)), 'diffuse_mode must be int or float'


    self.py__diffuse_mode = diffuse_mode






    self._ptr.call_with_return(147,tuple([diffuse_mode]))

  @functools.native_method
  def get_diffuse_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(148,tuple([]))

    return _ret


  @functools.native_method
  def set_specular_mode(self, specular_mode:'int'  ) -> None:
    r''''''

    assert isinstance(specular_mode, (int, float)), 'specular_mode must be int or float'


    self.py__specular_mode = specular_mode






    self._ptr.call_with_return(149,tuple([specular_mode]))

  @functools.native_method
  def get_specular_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(150,tuple([]))

    return _ret


  @functools.native_method
  def set_flag(self, flag:'int'  , enable:'bool'   ) -> None:
    r'''
				If `enable` is `true`, enables the specified `flag`. Flags are optional behavior that can be turned on and off. Only one flag can be enabled at a time with this function, the flag enumerators cannot be bit-masked together to enable or disable multiple flags at once. Flags can also be enabled by setting their corresponding property to `true`.
			'''

    assert isinstance(flag, (int, float)), 'flag must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'


    self.py__no_depth_test = flag







    self._ptr.call_with_return(151,tuple([flag, enable]))

  @functools.native_method
  def get_flag(self, flag:'int'  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified `flag` is enabled.
			'''

    assert isinstance(flag, (int, float)), 'flag must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(152,tuple([flag]))

    return _ret


  @functools.native_method
  def set_texture_filter(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__texture_filter = mode






    self._ptr.call_with_return(153,tuple([mode]))

  @functools.native_method
  def get_texture_filter(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(154,tuple([]))

    return _ret


  @functools.native_method
  def set_feature(self, feature:'int'  , enable:'bool'   ) -> None:
    r'''
				If `enable` is `true`, enables the specified `feature`. Many features that are available in `BaseMaterial3D` need to be enabled before use. This way, the cost for using the feature is only incurred when specified. Features can also be enabled by setting their corresponding property to `true`.
			'''

    assert isinstance(feature, (int, float)), 'feature must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'


    self.py__emission_enabled = feature







    self._ptr.call_with_return(155,tuple([feature, enable]))

  @functools.native_method
  def get_feature(self, feature:'int'  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified `feature` is enabled.
			'''

    assert isinstance(feature, (int, float)), 'feature must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(156,tuple([feature]))

    return _ret


  @functools.native_method
  def set_texture(self, param:'int'  , texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets the texture for the slot specified by `param`.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'
    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'


    self.py__albedo_texture = param







    self._ptr.call_with_return(157,tuple([param, texture._ptr]))

  @functools.native_method
  def get_texture(self, param:'int'  ) -> typing.Any:
    r'''
				Returns the `Texture2D` associated with the specified texture `param`.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(158,tuple([param]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_detail_blend_mode(self, detail_blend_mode:'int'  ) -> None:
    r''''''

    assert isinstance(detail_blend_mode, (int, float)), 'detail_blend_mode must be int or float'


    self.py__detail_blend_mode = detail_blend_mode






    self._ptr.call_with_return(159,tuple([detail_blend_mode]))

  @functools.native_method
  def get_detail_blend_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(160,tuple([]))

    return _ret


  @functools.native_method
  def set_uv1_scale(self, scale:'Vector3'   ) -> None:
    r''''''

    assert(not scale is None)
    assert isinstance(scale, Vector3), 'scale must be Vector3'


    self.py__uv1_scale = scale






    self._ptr.call_with_return(161,tuple([scale._ptr]))

  @functools.native_method
  def get_uv1_scale(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(162,tuple([]))

    return _ret


  @functools.native_method
  def set_uv1_offset(self, offset:'Vector3'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector3), 'offset must be Vector3'


    self.py__uv1_offset = offset






    self._ptr.call_with_return(163,tuple([offset._ptr]))

  @functools.native_method
  def get_uv1_offset(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(164,tuple([]))

    return _ret


  @functools.native_method
  def set_uv1_triplanar_blend_sharpness(self, sharpness:'float'   ) -> None:
    r''''''

    assert isinstance(sharpness, (int, float)), 'sharpness must be int or float'


    self.py__uv1_triplanar_sharpness = sharpness






    self._ptr.call_with_return(165,tuple([sharpness]))

  @functools.native_method
  def get_uv1_triplanar_blend_sharpness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(166,tuple([]))

    return _ret


  @functools.native_method
  def set_uv2_scale(self, scale:'Vector3'   ) -> None:
    r''''''

    assert(not scale is None)
    assert isinstance(scale, Vector3), 'scale must be Vector3'


    self.py__uv2_scale = scale






    self._ptr.call_with_return(167,tuple([scale._ptr]))

  @functools.native_method
  def get_uv2_scale(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(168,tuple([]))

    return _ret


  @functools.native_method
  def set_uv2_offset(self, offset:'Vector3'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector3), 'offset must be Vector3'


    self.py__uv2_offset = offset






    self._ptr.call_with_return(169,tuple([offset._ptr]))

  @functools.native_method
  def get_uv2_offset(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(170,tuple([]))

    return _ret


  @functools.native_method
  def set_uv2_triplanar_blend_sharpness(self, sharpness:'float'   ) -> None:
    r''''''

    assert isinstance(sharpness, (int, float)), 'sharpness must be int or float'


    self.py__uv2_triplanar_sharpness = sharpness






    self._ptr.call_with_return(171,tuple([sharpness]))

  @functools.native_method
  def get_uv2_triplanar_blend_sharpness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(172,tuple([]))

    return _ret


  @functools.native_method
  def set_billboard_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__billboard_mode = mode






    self._ptr.call_with_return(173,tuple([mode]))

  @functools.native_method
  def get_billboard_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(174,tuple([]))

    return _ret


  @functools.native_method
  def set_particles_anim_h_frames(self, frames:'int'   ) -> None:
    r''''''

    assert isinstance(frames, (int, float)), 'frames must be int or float'


    self.py__particles_anim_h_frames = frames






    self._ptr.call_with_return(175,tuple([frames]))

  @functools.native_method
  def get_particles_anim_h_frames(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(176,tuple([]))

    return _ret


  @functools.native_method
  def set_particles_anim_v_frames(self, frames:'int'   ) -> None:
    r''''''

    assert isinstance(frames, (int, float)), 'frames must be int or float'


    self.py__particles_anim_v_frames = frames






    self._ptr.call_with_return(177,tuple([frames]))

  @functools.native_method
  def get_particles_anim_v_frames(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(178,tuple([]))

    return _ret


  @functools.native_method
  def set_particles_anim_loop(self, loop:'bool'   ) -> None:
    r''''''

    assert isinstance(loop, bool), 'loop must be bool'


    self.py__particles_anim_loop = loop






    self._ptr.call_with_return(179,tuple([loop]))

  @functools.native_method
  def get_particles_anim_loop(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(180,tuple([]))

    return _ret


  @functools.native_method
  def set_heightmap_deep_parallax(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__heightmap_deep_parallax = enable






    self._ptr.call_with_return(181,tuple([enable]))

  @functools.native_method
  def is_heightmap_deep_parallax_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(182,tuple([]))

    return _ret


  @functools.native_method
  def set_heightmap_deep_parallax_min_layers(self, layer:'int'   ) -> None:
    r''''''

    assert isinstance(layer, (int, float)), 'layer must be int or float'


    self.py__heightmap_min_layers = layer






    self._ptr.call_with_return(183,tuple([layer]))

  @functools.native_method
  def get_heightmap_deep_parallax_min_layers(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(184,tuple([]))

    return _ret


  @functools.native_method
  def set_heightmap_deep_parallax_max_layers(self, layer:'int'   ) -> None:
    r''''''

    assert isinstance(layer, (int, float)), 'layer must be int or float'


    self.py__heightmap_max_layers = layer






    self._ptr.call_with_return(185,tuple([layer]))

  @functools.native_method
  def get_heightmap_deep_parallax_max_layers(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(186,tuple([]))

    return _ret


  @functools.native_method
  def set_heightmap_deep_parallax_flip_tangent(self, flip:'bool'   ) -> None:
    r''''''

    assert isinstance(flip, bool), 'flip must be bool'


    self.py__heightmap_flip_tangent = flip






    self._ptr.call_with_return(187,tuple([flip]))

  @functools.native_method
  def get_heightmap_deep_parallax_flip_tangent(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(188,tuple([]))

    return _ret


  @functools.native_method
  def set_heightmap_deep_parallax_flip_binormal(self, flip:'bool'   ) -> None:
    r''''''

    assert isinstance(flip, bool), 'flip must be bool'


    self.py__heightmap_flip_binormal = flip






    self._ptr.call_with_return(189,tuple([flip]))

  @functools.native_method
  def get_heightmap_deep_parallax_flip_binormal(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(190,tuple([]))

    return _ret


  @functools.native_method
  def set_grow(self, amount:'float'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__grow_amount = amount






    self._ptr.call_with_return(191,tuple([amount]))

  @functools.native_method
  def get_grow(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(192,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_operator(self, operator:'int'  ) -> None:
    r''''''

    assert isinstance(operator, (int, float)), 'operator must be int or float'


    self.py__emission_operator = operator






    self._ptr.call_with_return(193,tuple([operator]))

  @functools.native_method
  def get_emission_operator(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(194,tuple([]))

    return _ret


  @functools.native_method
  def set_ao_light_affect(self, amount:'float'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__ao_light_affect = amount






    self._ptr.call_with_return(195,tuple([amount]))

  @functools.native_method
  def get_ao_light_affect(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(196,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_scissor_threshold(self, threshold:'float'   ) -> None:
    r''''''

    assert isinstance(threshold, (int, float)), 'threshold must be int or float'


    self.py__alpha_scissor_threshold = threshold






    self._ptr.call_with_return(197,tuple([threshold]))

  @functools.native_method
  def get_alpha_scissor_threshold(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(198,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_hash_scale(self, threshold:'float'   ) -> None:
    r''''''

    assert isinstance(threshold, (int, float)), 'threshold must be int or float'


    self.py__alpha_hash_scale = threshold






    self._ptr.call_with_return(199,tuple([threshold]))

  @functools.native_method
  def get_alpha_hash_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(200,tuple([]))

    return _ret


  @functools.native_method
  def set_grow_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__grow = enable






    self._ptr.call_with_return(201,tuple([enable]))

  @functools.native_method
  def is_grow_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(202,tuple([]))

    return _ret


  @functools.native_method
  def set_metallic_texture_channel(self, channel:'int'  ) -> None:
    r''''''

    assert isinstance(channel, (int, float)), 'channel must be int or float'


    self.py__metallic_texture_channel = channel






    self._ptr.call_with_return(203,tuple([channel]))

  @functools.native_method
  def get_metallic_texture_channel(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(204,tuple([]))

    return _ret


  @functools.native_method
  def set_roughness_texture_channel(self, channel:'int'  ) -> None:
    r''''''

    assert isinstance(channel, (int, float)), 'channel must be int or float'


    self.py__roughness_texture_channel = channel






    self._ptr.call_with_return(205,tuple([channel]))

  @functools.native_method
  def get_roughness_texture_channel(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(206,tuple([]))

    return _ret


  @functools.native_method
  def set_ao_texture_channel(self, channel:'int'  ) -> None:
    r''''''

    assert isinstance(channel, (int, float)), 'channel must be int or float'


    self.py__ao_texture_channel = channel






    self._ptr.call_with_return(207,tuple([channel]))

  @functools.native_method
  def get_ao_texture_channel(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(208,tuple([]))

    return _ret


  @functools.native_method
  def set_refraction_texture_channel(self, channel:'int'  ) -> None:
    r''''''

    assert isinstance(channel, (int, float)), 'channel must be int or float'


    self.py__refraction_texture_channel = channel






    self._ptr.call_with_return(209,tuple([channel]))

  @functools.native_method
  def get_refraction_texture_channel(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(210,tuple([]))

    return _ret


  @functools.native_method
  def set_proximity_fade_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__proximity_fade_enabled = enabled






    self._ptr.call_with_return(211,tuple([enabled]))

  @functools.native_method
  def is_proximity_fade_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(212,tuple([]))

    return _ret


  @functools.native_method
  def set_proximity_fade_distance(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__proximity_fade_distance = distance






    self._ptr.call_with_return(213,tuple([distance]))

  @functools.native_method
  def get_proximity_fade_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(214,tuple([]))

    return _ret


  @functools.native_method
  def set_msdf_pixel_range(self, range:'float'   ) -> None:
    r''''''

    assert isinstance(range, (int, float)), 'range must be int or float'


    self.py__msdf_pixel_range = range






    self._ptr.call_with_return(215,tuple([range]))

  @functools.native_method
  def get_msdf_pixel_range(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(216,tuple([]))

    return _ret


  @functools.native_method
  def set_msdf_outline_size(self, size:'float'   ) -> None:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'


    self.py__msdf_outline_size = size






    self._ptr.call_with_return(217,tuple([size]))

  @functools.native_method
  def get_msdf_outline_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(218,tuple([]))

    return _ret


  @functools.native_method
  def set_distance_fade(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__distance_fade_mode = mode






    self._ptr.call_with_return(219,tuple([mode]))

  @functools.native_method
  def get_distance_fade(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(220,tuple([]))

    return _ret


  @functools.native_method
  def set_distance_fade_max_distance(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__distance_fade_max_distance = distance






    self._ptr.call_with_return(221,tuple([distance]))

  @functools.native_method
  def get_distance_fade_max_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(222,tuple([]))

    return _ret


  @functools.native_method
  def set_distance_fade_min_distance(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__distance_fade_min_distance = distance






    self._ptr.call_with_return(223,tuple([distance]))

  @functools.native_method
  def get_distance_fade_min_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(224,tuple([]))

    return _ret


  @functools.native_method
  def set_z_clip_scale(self, scale:'float'   ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'


    self.py__z_clip_scale = scale






    self._ptr.call_with_return(225,tuple([scale]))

  @functools.native_method
  def get_z_clip_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(226,tuple([]))

    return _ret


  @functools.native_method
  def set_fov_override(self, scale:'float'   ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'


    self.py__fov_override = scale






    self._ptr.call_with_return(227,tuple([scale]))

  @functools.native_method
  def get_fov_override(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(228,tuple([]))

    return _ret


  @functools.native_method
  def set_stencil_mode(self, stencil_mode:'int'  ) -> None:
    r''''''

    assert isinstance(stencil_mode, (int, float)), 'stencil_mode must be int or float'


    self.py__stencil_mode = stencil_mode






    self._ptr.call_with_return(229,tuple([stencil_mode]))

  @functools.native_method
  def get_stencil_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(230,tuple([]))

    return _ret


  @functools.native_method
  def set_stencil_flags(self, stencil_flags:'int'   ) -> None:
    r''''''

    assert isinstance(stencil_flags, (int, float)), 'stencil_flags must be int or float'


    self.py__stencil_flags = stencil_flags






    self._ptr.call_with_return(231,tuple([stencil_flags]))

  @functools.native_method
  def get_stencil_flags(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(232,tuple([]))

    return _ret


  @functools.native_method
  def set_stencil_compare(self, stencil_compare:'int'  ) -> None:
    r''''''

    assert isinstance(stencil_compare, (int, float)), 'stencil_compare must be int or float'


    self.py__stencil_compare = stencil_compare






    self._ptr.call_with_return(233,tuple([stencil_compare]))

  @functools.native_method
  def get_stencil_compare(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(234,tuple([]))

    return _ret


  @functools.native_method
  def set_stencil_reference(self, stencil_reference:'int'   ) -> None:
    r''''''

    assert isinstance(stencil_reference, (int, float)), 'stencil_reference must be int or float'


    self.py__stencil_reference = stencil_reference






    self._ptr.call_with_return(235,tuple([stencil_reference]))

  @functools.native_method
  def get_stencil_reference(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(236,tuple([]))

    return _ret


  @functools.native_method
  def set_stencil_effect_color(self, stencil_color:'Color'   ) -> None:
    r''''''

    assert(not stencil_color is None)
    assert isinstance(stencil_color, Color), 'stencil_color must be Color'


    self.py__stencil_color = stencil_color






    self._ptr.call_with_return(237,tuple([stencil_color._ptr]))

  @functools.native_method
  def get_stencil_effect_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(238,tuple([]))

    return _ret


  @functools.native_method
  def set_stencil_effect_outline_thickness(self, stencil_outline_thickness:'float'   ) -> None:
    r''''''

    assert isinstance(stencil_outline_thickness, (int, float)), 'stencil_outline_thickness must be int or float'


    self.py__stencil_outline_thickness = stencil_outline_thickness






    self._ptr.call_with_return(239,tuple([stencil_outline_thickness]))

  @functools.native_method
  def get_stencil_effect_outline_thickness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(240,tuple([]))

    return _ret



register_cast_function('BaseMaterial3D', BaseMaterial3D.cast)
register_class('BaseMaterial3D', BaseMaterial3D)
