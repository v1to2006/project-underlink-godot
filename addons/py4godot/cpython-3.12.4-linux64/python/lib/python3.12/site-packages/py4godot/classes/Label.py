# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.LabelSettings as py4godot_labelsettings 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.Tree as py4godot_tree 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.TextEdit as py4godot_textedit 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.GraphElement as py4godot_graphelement 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.RichTextLabel as py4godot_richtextlabel 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.TabBar as py4godot_tabbar 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.GraphNode as py4godot_graphnode 
  import py4godot.classes.TextServerExtension as py4godot_textserverextension 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.TextServer as py4godot_textserver 
  import py4godot.classes.Container as py4godot_container 
  import py4godot.classes.TextServerAdvanced as py4godot_textserveradvanced 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.TextServerDummy as py4godot_textserverdummy 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.FoldableContainer as py4godot_foldablecontainer 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.TabContainer as py4godot_tabcontainer 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
import py4godot.classes.Control as py4godot_control 
from py4godot.wrappers.wrappers import CPPLabelWrapper


class Label(py4godot_control.Control):
  r'''
		A control for displaying plain text. It gives you control over the horizontal and vertical alignment and can wrap the text inside the node's bounding rectangle. It doesn't support bold, italics, or other rich text formatting. For that, use `RichTextLabel` instead.
		**Note:** A single Label node is not designed to display huge amounts of text. To display large amounts of text in a single node, consider using `RichTextLabel` instead as it supports features like an integrated scroll bar and threading. `RichTextLabel` generally performs better when displaying large amounts of text (several pages or more).
	'''

  @staticmethod
  def constructor():
    class_ = Label.construct_without_init()
    class_._ptr = constructor(446,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Label.construct_without_init()
    class_._ptr = constructor(446,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPLabelWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(446,0, ())


  def generate_wrapper(self):
    return CPPLabelWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Label.__new__(Label)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Label'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Label.construct_without_init()
    cls._ptr = CPPLabelWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Label.construct_without_init()
    cls._ptr = CPPLabelWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def text(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_text()
    return _ret
  @text.setter
  def text(self,  value:'str'):
    self.set_text(value)
  @property
  def label_settings(self) -> typing.Union['py4godot_labelsettings.LabelSettings']:
    r''''''
    _ret = self. get_label_settings()
    return _ret
  @label_settings.setter
  def label_settings(self,  value:'py4godot_object.Object'):
    self.set_label_settings(value)
  @property
  def horizontal_alignment(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_horizontal_alignment()
    return _ret
  @horizontal_alignment.setter
  def horizontal_alignment(self,  value:'int'):
    self.set_horizontal_alignment(value)
  @property
  def vertical_alignment(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_vertical_alignment()
    return _ret
  @vertical_alignment.setter
  def vertical_alignment(self,  value:'int'):
    self.set_vertical_alignment(value)
  @property
  def autowrap_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_autowrap_mode()
    return _ret
  @autowrap_mode.setter
  def autowrap_mode(self,  value:'int'):
    self.set_autowrap_mode(value)
  @property
  def autowrap_trim_flags(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_autowrap_trim_flags()
    return _ret
  @autowrap_trim_flags.setter
  def autowrap_trim_flags(self,  value:'int'):
    self.set_autowrap_trim_flags(value)
  @property
  def justification_flags(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_justification_flags()
    return _ret
  @justification_flags.setter
  def justification_flags(self,  value:'int'):
    self.set_justification_flags(value)
  @property
  def paragraph_separator(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_paragraph_separator()
    return _ret
  @paragraph_separator.setter
  def paragraph_separator(self,  value:'str'):
    self.set_paragraph_separator(value)
  @property
  def clip_text(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_clipping_text()
    return _ret
  @clip_text.setter
  def clip_text(self,  value:'bool'):
    self.set_clip_text(value)
  @property
  def text_overrun_behavior(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_text_overrun_behavior()
    return _ret
  @text_overrun_behavior.setter
  def text_overrun_behavior(self,  value:'int'):
    self.set_text_overrun_behavior(value)
  @property
  def ellipsis_char(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_ellipsis_char()
    return _ret
  @ellipsis_char.setter
  def ellipsis_char(self,  value:'str'):
    self.set_ellipsis_char(value)
  @property
  def uppercase(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_uppercase()
    return _ret
  @uppercase.setter
  def uppercase(self,  value:'bool'):
    self.set_uppercase(value)
  @property
  def tab_stops(self) -> typing.Union['PackedFloat32Array']:
    r''''''
    _ret = self. get_tab_stops()
    return _ret
  @tab_stops.setter
  def tab_stops(self,  value:'PackedFloat32Array'):
    self.set_tab_stops(value)
  @property
  def lines_skipped(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_lines_skipped()
    return _ret
  @lines_skipped.setter
  def lines_skipped(self,  value:'int'):
    self.set_lines_skipped(value)
  @property
  def max_lines_visible(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_lines_visible()
    return _ret
  @max_lines_visible.setter
  def max_lines_visible(self,  value:'int'):
    self.set_max_lines_visible(value)
  @property
  def visible_characters(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_visible_characters()
    return _ret
  @visible_characters.setter
  def visible_characters(self,  value:'int'):
    self.set_visible_characters(value)
  @property
  def visible_characters_behavior(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_visible_characters_behavior()
    return _ret
  @visible_characters_behavior.setter
  def visible_characters_behavior(self,  value:'int'):
    self.set_visible_characters_behavior(value)
  @property
  def visible_ratio(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_visible_ratio()
    return _ret
  @visible_ratio.setter
  def visible_ratio(self,  value:'float'):
    self.set_visible_ratio(value)
  @property
  def text_direction(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_text_direction()
    return _ret
  @text_direction.setter
  def text_direction(self,  value:'int'):
    self.set_text_direction(value)
  @property
  def language(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_language()
    return _ret
  @language.setter
  def language(self,  value:'str'):
    self.set_language(value)
  @property
  def structured_text_bidi_override(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_structured_text_bidi_override()
    return _ret
  @structured_text_bidi_override.setter
  def structured_text_bidi_override(self,  value:'int'):
    self.set_structured_text_bidi_override(value)
  @property
  def structured_text_bidi_override_options(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_structured_text_bidi_override_options()
    return _ret
  @structured_text_bidi_override_options.setter
  def structured_text_bidi_override_options(self,  value:'Array'):
    self.set_structured_text_bidi_override_options(value)
  @functools.native_method
  def set_horizontal_alignment(self, alignment:'int'  ) -> None:
    r''''''

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'


    self.py__horizontal_alignment = alignment






    self._ptr.call_with_return(433,tuple([alignment]))

  @functools.native_method
  def get_horizontal_alignment(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(434,tuple([]))

    return _ret


  @functools.native_method
  def set_vertical_alignment(self, alignment:'int'  ) -> None:
    r''''''

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'


    self.py__vertical_alignment = alignment






    self._ptr.call_with_return(435,tuple([alignment]))

  @functools.native_method
  def get_vertical_alignment(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(436,tuple([]))

    return _ret


  @functools.native_method
  def set_text(self, text:'str'   ) -> None:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'


    self.py__text = text



    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    py__string_text = utils.py_string_to_string(text)
    py__string_text.shouldBeDeleted = False


    self._ptr.call_with_return(437,tuple([py__string_text._ptr]))

  @functools.native_method
  def get_text(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(438,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_label_settings(self, settings:'py4godot_labelsettings.LabelSettings'   ) -> None:
    r''''''

    assert(not settings is None)
    assert isinstance(settings, get_class('LabelSettings')), 'settings must be LabelSettings'


    self.py__label_settings = settings






    self._ptr.call_with_return(439,tuple([settings._ptr]))

  @functools.native_method
  def get_label_settings(self) -> typing.Union['py4godot_labelsettings.LabelSettings']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: LabelSettings
    _ret._ptr = self._ptr.call_with_return(440,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_text_direction(self, direction:'int'  ) -> None:
    r''''''

    assert isinstance(direction, (int, float)), 'direction must be int or float'


    self.py__text_direction = direction






    self._ptr.call_with_return(441,tuple([direction]))

  @functools.native_method
  def get_text_direction(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(442,tuple([]))

    return _ret


  @functools.native_method
  def set_language(self, language:'str'   ) -> None:
    r''''''

    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'


    self.py__language = language



    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    py__string_language = utils.py_string_to_string(language)
    py__string_language.shouldBeDeleted = False


    self._ptr.call_with_return(443,tuple([py__string_language._ptr]))

  @functools.native_method
  def get_language(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(444,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_paragraph_separator(self, paragraph_separator:'str'   ) -> None:
    r''''''

    assert(not paragraph_separator is None)
    assert isinstance(paragraph_separator, (str, String)), 'paragraph_separator must be str or String'


    self.py__paragraph_separator = paragraph_separator



    assert(isinstance(paragraph_separator, (str, String)))
    py_string_paragraph_separator = paragraph_separator if isinstance(paragraph_separator, StringName) else c_utils.py_string_to_string(paragraph_separator)

    py__string_paragraph_separator = utils.py_string_to_string(paragraph_separator)
    py__string_paragraph_separator.shouldBeDeleted = False


    self._ptr.call_with_return(445,tuple([py__string_paragraph_separator._ptr]))

  @functools.native_method
  def get_paragraph_separator(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(446,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_autowrap_mode(self, autowrap_mode:'int'  ) -> None:
    r''''''

    assert isinstance(autowrap_mode, (int, float)), 'autowrap_mode must be int or float'


    self.py__autowrap_mode = autowrap_mode






    self._ptr.call_with_return(447,tuple([autowrap_mode]))

  @functools.native_method
  def get_autowrap_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(448,tuple([]))

    return _ret


  @functools.native_method
  def set_autowrap_trim_flags(self, autowrap_trim_flags:'int'   ) -> None:
    r''''''

    assert isinstance(autowrap_trim_flags, (int, float)), 'autowrap_trim_flags must be int or float'


    self.py__autowrap_trim_flags = autowrap_trim_flags






    self._ptr.call_with_return(449,tuple([autowrap_trim_flags]))

  @functools.native_method
  def get_autowrap_trim_flags(self) -> typing.Union[int]:
    r''''''




    _ret
    _ret = self._ptr.call_with_return(450,tuple([]))

    return _ret


  @functools.native_method
  def set_justification_flags(self, justification_flags:'int'   ) -> None:
    r''''''

    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'


    self.py__justification_flags = justification_flags






    self._ptr.call_with_return(451,tuple([justification_flags]))

  @functools.native_method
  def get_justification_flags(self) -> typing.Union[int]:
    r''''''




    _ret
    _ret = self._ptr.call_with_return(452,tuple([]))

    return _ret


  @functools.native_method
  def set_clip_text(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__clip_text = enable






    self._ptr.call_with_return(453,tuple([enable]))

  @functools.native_method
  def is_clipping_text(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(454,tuple([]))

    return _ret


  @functools.native_method
  def set_tab_stops(self, tab_stops:'PackedFloat32Array'   ) -> None:
    r''''''

    assert(not tab_stops is None)
    assert isinstance(tab_stops, PackedFloat32Array), 'tab_stops must be PackedFloat32Array'


    self.py__tab_stops = tab_stops






    self._ptr.call_with_return(455,tuple([tab_stops._ptr]))

  @functools.native_method
  def get_tab_stops(self) -> typing.Union['PackedFloat32Array']:
    r''''''




    _ret = PackedFloat32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(456,tuple([]))

    return _ret


  @functools.native_method
  def set_text_overrun_behavior(self, overrun_behavior:'int'  ) -> None:
    r''''''

    assert isinstance(overrun_behavior, (int, float)), 'overrun_behavior must be int or float'


    self.py__text_overrun_behavior = overrun_behavior






    self._ptr.call_with_return(457,tuple([overrun_behavior]))

  @functools.native_method
  def get_text_overrun_behavior(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(458,tuple([]))

    return _ret


  @functools.native_method
  def set_ellipsis_char(self, char:'str'   ) -> None:
    r''''''

    assert(not char is None)
    assert isinstance(char, (str, String)), 'char must be str or String'


    self.py__ellipsis_char = char



    assert(isinstance(char, (str, String)))
    py_string_char = char if isinstance(char, StringName) else c_utils.py_string_to_string(char)

    py__string_char = utils.py_string_to_string(char)
    py__string_char.shouldBeDeleted = False


    self._ptr.call_with_return(459,tuple([py__string_char._ptr]))

  @functools.native_method
  def get_ellipsis_char(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(460,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_uppercase(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__uppercase = enable






    self._ptr.call_with_return(461,tuple([enable]))

  @functools.native_method
  def is_uppercase(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(462,tuple([]))

    return _ret


  @functools.native_method
  def get_line_height(self, line:'int' =-1  ) -> typing.Union[int]:
    r'''
				Returns the height of the line `line`.
				If `line` is set to `-1`, returns the biggest line height.
				If there are no lines, returns font size in pixels.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(463,tuple([line]))
    return _ret


  @functools.native_method
  def get_line_count(self) -> typing.Union[int]:
    r'''
				Returns the number of lines of text the Label has.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(464,tuple([]))
    return _ret


  @functools.native_method
  def get_visible_line_count(self) -> typing.Union[int]:
    r'''
				Returns the number of lines shown. Useful if the `Label`'s height cannot currently display all lines.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(465,tuple([]))
    return _ret


  @functools.native_method
  def get_total_character_count(self) -> typing.Union[int]:
    r'''
				Returns the total number of printable characters in the text (excluding spaces and newlines).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(466,tuple([]))
    return _ret


  @functools.native_method
  def set_visible_characters(self, amount:'int'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__visible_characters = amount






    self._ptr.call_with_return(467,tuple([amount]))

  @functools.native_method
  def get_visible_characters(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(468,tuple([]))

    return _ret


  @functools.native_method
  def get_visible_characters_behavior(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(469,tuple([]))

    return _ret


  @functools.native_method
  def set_visible_characters_behavior(self, behavior:'int'  ) -> None:
    r''''''

    assert isinstance(behavior, (int, float)), 'behavior must be int or float'


    self.py__visible_characters_behavior = behavior






    self._ptr.call_with_return(470,tuple([behavior]))

  @functools.native_method
  def set_visible_ratio(self, ratio:'float'   ) -> None:
    r''''''

    assert isinstance(ratio, (int, float)), 'ratio must be int or float'


    self.py__visible_ratio = ratio






    self._ptr.call_with_return(471,tuple([ratio]))

  @functools.native_method
  def get_visible_ratio(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(472,tuple([]))

    return _ret


  @functools.native_method
  def set_lines_skipped(self, lines_skipped:'int'   ) -> None:
    r''''''

    assert isinstance(lines_skipped, (int, float)), 'lines_skipped must be int or float'


    self.py__lines_skipped = lines_skipped






    self._ptr.call_with_return(473,tuple([lines_skipped]))

  @functools.native_method
  def get_lines_skipped(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(474,tuple([]))

    return _ret


  @functools.native_method
  def set_max_lines_visible(self, lines_visible:'int'   ) -> None:
    r''''''

    assert isinstance(lines_visible, (int, float)), 'lines_visible must be int or float'


    self.py__max_lines_visible = lines_visible






    self._ptr.call_with_return(475,tuple([lines_visible]))

  @functools.native_method
  def get_max_lines_visible(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(476,tuple([]))

    return _ret


  @functools.native_method
  def set_structured_text_bidi_override(self, parser:'int'  ) -> None:
    r''''''

    assert isinstance(parser, (int, float)), 'parser must be int or float'


    self.py__structured_text_bidi_override = parser






    self._ptr.call_with_return(477,tuple([parser]))

  @functools.native_method
  def get_structured_text_bidi_override(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(478,tuple([]))

    return _ret


  @functools.native_method
  def set_structured_text_bidi_override_options(self, args:'Array'   ) -> None:
    r''''''

    assert(not args is None)
    assert isinstance(args, Array), 'args must be Array'


    self.py__structured_text_bidi_override_options = args






    self._ptr.call_with_return(479,tuple([args._ptr]))

  @functools.native_method
  def get_structured_text_bidi_override_options(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(480,tuple([]))

    return _ret


  @functools.native_method
  def get_character_bounds(self, pos:'int'   ) -> typing.Union['Rect2']:
    r'''
				Returns the bounding rectangle of the character at position `pos` in the label's local coordinate system. If the character is a non-visual character or `pos` is outside the valid range, an empty `Rect2` is returned. If the character is a part of a composite grapheme, the bounding rectangle of the whole grapheme is returned.
			'''

    assert isinstance(pos, (int, float)), 'pos must be int or float'







    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(481,tuple([pos]))
    return _ret



register_cast_function('Label', Label.cast)
register_class('Label', Label)
