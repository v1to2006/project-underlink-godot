# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes

if typing.TYPE_CHECKING:
  import py4godot.classes.GLTFCamera as py4godot_gltfcamera
from py4godot.classes.core import *
from py4godot.wrappers.wrappers import CPPGLTFCameraTypedArrayWrapper


class GLTFCameraTypedArray():
  r''''''


  @staticmethod
  def new0():
    _class = GLTFCameraTypedArray.construct_without_init()
    _class.constructed_from_python = True
    _class._ptr = constructor(13, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = GLTFCameraTypedArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(13, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(base:'Array' , type:'int' , class_name:'object' , script:'object' ):
    assert(not base is None)
    assert isinstance(base, Array), 'base must be Array'
    assert isinstance(type, (int, float)), 'type must be int or float'
    assert(not class_name is None)
    assert isinstance(class_name, (str, StringName)), 'class_name must be str or StringName'
    

    _class = GLTFCameraTypedArray.construct_without_init()
    _class.constructed_from_python = True


    assert(isinstance(class_name, (str, StringName)))
    py_stringname_class_name = class_name if isinstance(class_name, StringName) else c_utils.py_string_to_string_name(class_name)


    _class.__base__ = base

    _class.py_stringname_class_name =py_stringname_class_name

    _class._ptr = constructor(13, 2, tuple([base._ptr, type, py_stringname_class_name._ptr, script]))
    return _class
  @staticmethod
  def new3(from_:'PackedByteArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedByteArray), 'from_ must be PackedByteArray'

    _class = GLTFCameraTypedArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(13, 3, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new4(from_:'PackedInt32Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedInt32Array), 'from_ must be PackedInt32Array'

    _class = GLTFCameraTypedArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(13, 4, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new5(from_:'PackedInt64Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedInt64Array), 'from_ must be PackedInt64Array'

    _class = GLTFCameraTypedArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(13, 5, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new6(from_:'PackedFloat32Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedFloat32Array), 'from_ must be PackedFloat32Array'

    _class = GLTFCameraTypedArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(13, 6, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new7(from_:'PackedFloat64Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedFloat64Array), 'from_ must be PackedFloat64Array'

    _class = GLTFCameraTypedArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(13, 7, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new8(from_:'PackedStringArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedStringArray), 'from_ must be PackedStringArray'

    _class = GLTFCameraTypedArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(13, 8, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new9(from_:'PackedVector2Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector2Array), 'from_ must be PackedVector2Array'

    _class = GLTFCameraTypedArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(13, 9, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new10(from_:'PackedVector3Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector3Array), 'from_ must be PackedVector3Array'

    _class = GLTFCameraTypedArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(13, 10, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new11(from_:'PackedColorArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedColorArray), 'from_ must be PackedColorArray'

    _class = GLTFCameraTypedArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(13, 11, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new12(from_:'PackedVector4Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector4Array), 'from_ must be PackedVector4Array'

    _class = GLTFCameraTypedArray.construct_without_init()
    _class.constructed_from_python = True


    _class.__from___ = from_
    _class._ptr = constructor(13, 12, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self.casted_from = None
    self._ptr =  constructor(13,0, ())

  def generate_wrapper(self):
    return CPPGLTFCameraTypedArrayWrapper()
  def init_signals(self):
    pass

  @staticmethod
  def construct_without_init():
    cls = GLTFCameraTypedArray.__new__(GLTFCameraTypedArray)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'GLTFCameraTypedArray'

  def __setitem__(self,  index, value):
    self._ptr.call_with_return(61, (index, value))

  def __getitem__(self,  index):

    if index < 0:
      raise KeyError(f"Index '{index}' invalid")
    pyobject = self._ptr.call_with_return(60, (index,))
    return pyobject
  def __iter__(self):
    self._index = 0
    return self
  def __next__(self):
    if self._index >= self.size():
      raise StopIteration()
    val = self[self._index]
    self._index += 1
    return val


  @staticmethod
  def from_list(values):
    result = GLTFCameraTypedArray.new0()
    for value in values:
      result.push_back(value)
    return result

  def to_list(self):
    return [value for value in self]


  @functools.native_method
  def size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(0,tuple([]))
    return _ret


  @functools.native_method
  def is_empty(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(1,tuple([]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(2,tuple([]))

  @functools.native_method
  def hash(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(3,tuple([]))
    return _ret


  @functools.native_method
  def assign(self, array:'Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, Array), 'array must be Array'







    self._ptr.call_with_return(4,tuple([array._ptr]))

  @functools.native_method
  def get(self, index:'int'   ) -> typing.Union['py4godot_gltfcamera.GLTFCamera']:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = None
    _ret = self._ptr.call_with_return(5,tuple([index]))
    return _ret


  @functools.native_method
  def set(self, index:'int'   , value:'py4godot_gltfcamera.GLTFCamera'   ) -> None:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    self._ptr.call_with_return(6,tuple([index, value]))

  @functools.native_method
  def push_back(self, value:'py4godot_gltfcamera.GLTFCamera'   ) -> None:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    self._ptr.call_with_return(7,tuple([value]))

  @functools.native_method
  def push_front(self, value:'py4godot_gltfcamera.GLTFCamera'   ) -> None:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    self._ptr.call_with_return(8,tuple([value]))

  @functools.native_method
  def append(self, value:'py4godot_gltfcamera.GLTFCamera'   ) -> None:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    self._ptr.call_with_return(9,tuple([value]))

  @functools.native_method
  def append_array(self, array:'Array'   ) -> None:
    r''''''

    assert(not array is None)
    assert isinstance(array, Array), 'array must be Array'







    self._ptr.call_with_return(10,tuple([array._ptr]))

  @functools.native_method
  def resize(self, size:'int'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(11,tuple([size]))
    return _ret


  @functools.native_method
  def insert(self, position:'int'   , value:'py4godot_gltfcamera.GLTFCamera'   ) -> typing.Union[int]:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = 0
    _ret = self._ptr.call_with_return(12,tuple([position, value]))
    return _ret


  @functools.native_method
  def remove_at(self, position:'int'   ) -> None:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'







    self._ptr.call_with_return(13,tuple([position]))

  @functools.native_method
  def fill(self, value:'py4godot_gltfcamera.GLTFCamera'   ) -> None:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    self._ptr.call_with_return(14,tuple([value]))

  @functools.native_method
  def erase(self, value:'py4godot_gltfcamera.GLTFCamera'   ) -> None:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    self._ptr.call_with_return(15,tuple([value]))

  @functools.native_method
  def front(self) -> typing.Union['py4godot_gltfcamera.GLTFCamera']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(16,tuple([]))
    return _ret


  @functools.native_method
  def back(self) -> typing.Union['py4godot_gltfcamera.GLTFCamera']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(17,tuple([]))
    return _ret


  @functools.native_method
  def pick_random(self) -> typing.Union['py4godot_gltfcamera.GLTFCamera']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(18,tuple([]))
    return _ret


  @functools.native_method
  def find(self, what:'py4godot_gltfcamera.GLTFCamera'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    
    assert isinstance(from_, (int, float)), 'from_ must be int or float'

    if not (type(what).__name__ in py4godot.variant_types.core_types or isinstance(what, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'what': "
                f"{type(what).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = 0
    _ret = self._ptr.call_with_return(19,tuple([what, from_]))
    return _ret


  @functools.native_method
  def find_custom(self, method:'Callable'   , from_:'int' =0  ) -> typing.Union[int]:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(20,tuple([method._ptr, from_]))
    return _ret


  @functools.native_method
  def rfind(self, what:'py4godot_gltfcamera.GLTFCamera'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    
    assert isinstance(from_, (int, float)), 'from_ must be int or float'

    if not (type(what).__name__ in py4godot.variant_types.core_types or isinstance(what, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'what': "
                f"{type(what).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = 0
    _ret = self._ptr.call_with_return(21,tuple([what, from_]))
    return _ret


  @functools.native_method
  def rfind_custom(self, method:'Callable'   , from_:'int' =-1  ) -> typing.Union[int]:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'
    assert isinstance(from_, (int, float)), 'from_ must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(22,tuple([method._ptr, from_]))
    return _ret


  @functools.native_method
  def count(self, value:'py4godot_gltfcamera.GLTFCamera'   ) -> typing.Union[int]:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    _ret = 0
    _ret = self._ptr.call_with_return(23,tuple([value]))
    return _ret


  @functools.native_method
  def has(self, value:'py4godot_gltfcamera.GLTFCamera'   ) -> typing.Union[bool]:
    r''''''

    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    _ret = 0
    _ret = self._ptr.call_with_return(24,tuple([value]))
    return _ret


  @functools.native_method
  def pop_back(self) -> typing.Union['py4godot_gltfcamera.GLTFCamera']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(25,tuple([]))
    return _ret


  @functools.native_method
  def pop_front(self) -> typing.Union['py4godot_gltfcamera.GLTFCamera']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(26,tuple([]))
    return _ret


  @functools.native_method
  def pop_at(self, position:'int'   ) -> typing.Union['py4godot_gltfcamera.GLTFCamera']:
    r''''''

    assert isinstance(position, (int, float)), 'position must be int or float'







    _ret = None
    _ret = self._ptr.call_with_return(27,tuple([position]))
    return _ret


  @functools.native_method
  def sort(self) -> None:
    r''''''




    self._ptr.call_with_return(28,tuple([]))

  @functools.native_method
  def sort_custom(self, func:'Callable'   ) -> None:
    r''''''

    assert(not func is None)
    assert isinstance(func, Callable), 'func must be Callable'







    self._ptr.call_with_return(29,tuple([func._ptr]))

  @functools.native_method
  def shuffle(self) -> None:
    r''''''




    self._ptr.call_with_return(30,tuple([]))

  @functools.native_method
  def bsearch(self, value:'py4godot_gltfcamera.GLTFCamera'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    
    assert isinstance(before, bool), 'before must be bool'

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = 0
    _ret = self._ptr.call_with_return(31,tuple([value, before]))
    return _ret


  @functools.native_method
  def bsearch_custom(self, value:'py4godot_gltfcamera.GLTFCamera'   , func:'Callable'   , before:'bool' =True  ) -> typing.Union[int]:
    r''''''

    
    assert(not func is None)
    assert isinstance(func, Callable), 'func must be Callable'
    assert isinstance(before, bool), 'before must be bool'

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    _ret = 0
    _ret = self._ptr.call_with_return(32,tuple([value, func._ptr, before]))
    return _ret


  @functools.native_method
  def reverse(self) -> None:
    r''''''




    self._ptr.call_with_return(33,tuple([]))

  @functools.native_method
  def duplicate(self, deep:'bool' =False  ) -> typing.Union['Array']:
    r''''''

    assert isinstance(deep, bool), 'deep must be bool'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(34,tuple([deep]))
    return _ret


  @functools.native_method
  def duplicate_deep(self, deep_subresources_mode:'int' =1  ) -> typing.Union['Array']:
    r''''''

    assert isinstance(deep_subresources_mode, (int, float)), 'deep_subresources_mode must be int or float'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(35,tuple([deep_subresources_mode]))
    return _ret


  @functools.native_method
  def slice(self, begin:'int'   , end:'int' =2147483647  , step:'int' =1  , deep:'bool' =False  ) -> typing.Union['Array']:
    r''''''

    assert isinstance(begin, (int, float)), 'begin must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'
    assert isinstance(step, (int, float)), 'step must be int or float'
    assert isinstance(deep, bool), 'deep must be bool'










    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(36,tuple([begin, end, step, deep]))
    return _ret


  @functools.native_method
  def filter(self, method:'Callable'   ) -> typing.Union['Array']:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(37,tuple([method._ptr]))
    return _ret


  @functools.native_method
  def map(self, method:'Callable'   ) -> typing.Union['Array']:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(38,tuple([method._ptr]))
    return _ret


  @functools.native_method
  def reduce(self, method:'Callable'   , accum:'py4godot_gltfcamera.GLTFCamera' = None  ) -> typing.Union['py4godot_gltfcamera.GLTFCamera']:
    r''''''


    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'
    

    if not (type(accum).__name__ in py4godot.variant_types.core_types or isinstance(accum, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'accum': "
                f"{type(accum).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = None
    _ret = self._ptr.call_with_return(39,tuple([method._ptr, accum]))
    return _ret


  @functools.native_method
  def any(self, method:'Callable'   ) -> typing.Union[bool]:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'







    _ret = 0
    _ret = self._ptr.call_with_return(40,tuple([method._ptr]))
    return _ret


  @functools.native_method
  def all(self, method:'Callable'   ) -> typing.Union[bool]:
    r''''''

    assert(not method is None)
    assert isinstance(method, Callable), 'method must be Callable'







    _ret = 0
    _ret = self._ptr.call_with_return(41,tuple([method._ptr]))
    return _ret


  @functools.native_method
  def max(self) -> typing.Union['py4godot_gltfcamera.GLTFCamera']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(42,tuple([]))
    return _ret


  @functools.native_method
  def min(self) -> typing.Union['py4godot_gltfcamera.GLTFCamera']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(43,tuple([]))
    return _ret


  @functools.native_method
  def is_typed(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(44,tuple([]))
    return _ret


  @functools.native_method
  def is_same_typed(self, array:'Array'   ) -> typing.Union[bool]:
    r''''''

    assert(not array is None)
    assert isinstance(array, Array), 'array must be Array'







    _ret = 0
    _ret = self._ptr.call_with_return(45,tuple([array._ptr]))
    return _ret


  @functools.native_method
  def get_typed_builtin(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(46,tuple([]))
    return _ret


  @functools.native_method
  def get_typed_class_name(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(47,tuple([]))
    return str(_ret)


  @functools.native_method
  def get_typed_script(self) -> typing.Union['py4godot_gltfcamera.GLTFCamera']:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(48,tuple([]))
    return _ret


  @functools.native_method
  def make_read_only(self) -> None:
    r''''''




    self._ptr.call_with_return(49,tuple([]))

  @functools.native_method
  def is_read_only(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(50,tuple([]))
    return _ret



