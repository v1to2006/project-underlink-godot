# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Translation as py4godot_translation 
  import py4godot.classes.OptimizedTranslation as py4godot_optimizedtranslation 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPTranslationDomainWrapper


class TranslationDomain(py4godot_refcounted.RefCounted):
  r'''
		`TranslationDomain` is a self-contained collection of `Translation` resources. Translations can be added to or removed from it.
		If you're working with the main translation domain, it is more convenient to use the wrap methods on `TranslationServer`.
	'''

  @staticmethod
  def constructor():
    class_ = TranslationDomain.construct_without_init()
    class_._ptr = constructor(847,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TranslationDomain.construct_without_init()
    class_._ptr = constructor(847,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTranslationDomainWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(847,0, ())


  def generate_wrapper(self):
    return CPPTranslationDomainWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = TranslationDomain.__new__(TranslationDomain)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TranslationDomain'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(82, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TranslationDomain.construct_without_init()
    cls._ptr = CPPTranslationDomainWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TranslationDomain.construct_without_init()
    cls._ptr = CPPTranslationDomainWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_enabled()
    return _ret
  @enabled.setter
  def enabled(self,  value:'bool'):
    self.set_enabled(value)
  @property
  def pseudolocalization_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_pseudolocalization_enabled()
    return _ret
  @pseudolocalization_enabled.setter
  def pseudolocalization_enabled(self,  value:'bool'):
    self.set_pseudolocalization_enabled(value)
  @property
  def pseudolocalization_accents_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_pseudolocalization_accents_enabled()
    return _ret
  @pseudolocalization_accents_enabled.setter
  def pseudolocalization_accents_enabled(self,  value:'bool'):
    self.set_pseudolocalization_accents_enabled(value)
  @property
  def pseudolocalization_double_vowels_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_pseudolocalization_double_vowels_enabled()
    return _ret
  @pseudolocalization_double_vowels_enabled.setter
  def pseudolocalization_double_vowels_enabled(self,  value:'bool'):
    self.set_pseudolocalization_double_vowels_enabled(value)
  @property
  def pseudolocalization_fake_bidi_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_pseudolocalization_fake_bidi_enabled()
    return _ret
  @pseudolocalization_fake_bidi_enabled.setter
  def pseudolocalization_fake_bidi_enabled(self,  value:'bool'):
    self.set_pseudolocalization_fake_bidi_enabled(value)
  @property
  def pseudolocalization_override_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_pseudolocalization_override_enabled()
    return _ret
  @pseudolocalization_override_enabled.setter
  def pseudolocalization_override_enabled(self,  value:'bool'):
    self.set_pseudolocalization_override_enabled(value)
  @property
  def pseudolocalization_skip_placeholders_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_pseudolocalization_skip_placeholders_enabled()
    return _ret
  @pseudolocalization_skip_placeholders_enabled.setter
  def pseudolocalization_skip_placeholders_enabled(self,  value:'bool'):
    self.set_pseudolocalization_skip_placeholders_enabled(value)
  @property
  def pseudolocalization_expansion_ratio(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_pseudolocalization_expansion_ratio()
    return _ret
  @pseudolocalization_expansion_ratio.setter
  def pseudolocalization_expansion_ratio(self,  value:'float'):
    self.set_pseudolocalization_expansion_ratio(value)
  @property
  def pseudolocalization_prefix(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_pseudolocalization_prefix()
    return _ret
  @pseudolocalization_prefix.setter
  def pseudolocalization_prefix(self,  value:'str'):
    self.set_pseudolocalization_prefix(value)
  @property
  def pseudolocalization_suffix(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_pseudolocalization_suffix()
    return _ret
  @pseudolocalization_suffix.setter
  def pseudolocalization_suffix(self,  value:'str'):
    self.set_pseudolocalization_suffix(value)
  @functools.native_method
  def get_translation_object(self, locale:'str'   ) -> typing.Union['py4godot_translation.Translation','py4godot_optimizedtranslation.OptimizedTranslation']:
    r'''
				Returns the `Translation` instance that best matches `locale`. Returns `null` if there are no matches.
			'''

    assert(not locale is None)
    assert isinstance(locale, (str, String)), 'locale must be str or String'





    assert(isinstance(locale, (str, String)))
    py_string_locale = locale if isinstance(locale, StringName) else c_utils.py_string_to_string(locale)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Translation
    _ret._ptr = self._ptr.call_with_return(53,tuple([py_string_locale._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def add_translation(self, translation:'py4godot_translation.Translation'   ) -> None:
    r'''
				Adds a translation.
			'''

    assert(not translation is None)
    assert isinstance(translation, get_class('Translation')), 'translation must be Translation'







    self._ptr.call_with_return(54,tuple([translation._ptr]))

  @functools.native_method
  def remove_translation(self, translation:'py4godot_translation.Translation'   ) -> None:
    r'''
				Removes the given translation.
			'''

    assert(not translation is None)
    assert isinstance(translation, get_class('Translation')), 'translation must be Translation'







    self._ptr.call_with_return(55,tuple([translation._ptr]))

  @functools.native_method
  def clear(self) -> None:
    r'''
				Removes all translations.
			'''




    self._ptr.call_with_return(56,tuple([]))

  @functools.native_method
  def translate(self, message:'object'   , context:'object' = None  ) -> typing.Union['StringName']:
    r'''
				Returns the current locale's translation for the given message and context.
			'''
    if context is None:
      context = StringName.new0()

    assert(not message is None)
    assert isinstance(message, (str, StringName)), 'message must be str or StringName'





    assert(isinstance(message, (str, StringName)))
    py_stringname_message = message if isinstance(message, StringName) else c_utils.py_string_to_string_name(message)
    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(57,tuple([py_stringname_message._ptr, py_stringname_context._ptr]))
    return str(_ret)


  @functools.native_method
  def translate_plural(self, message:'object'   , message_plural:'object'   , n:'int'   , context:'object' = None  ) -> typing.Union['StringName']:
    r'''
				Returns the current locale's translation for the given message, plural message and context.
				The number `n` is the number or quantity of the plural object. It will be used to guide the translation system to fetch the correct plural form for the selected language.
			'''
    if context is None:
      context = StringName.new0()

    assert(not message is None)
    assert isinstance(message, (str, StringName)), 'message must be str or StringName'
    assert(not message_plural is None)
    assert isinstance(message_plural, (str, StringName)), 'message_plural must be str or StringName'
    assert isinstance(n, (int, float)), 'n must be int or float'





    assert(isinstance(message, (str, StringName)))
    py_stringname_message = message if isinstance(message, StringName) else c_utils.py_string_to_string_name(message)
    assert(isinstance(message_plural, (str, StringName)))
    py_stringname_message_plural = message_plural if isinstance(message_plural, StringName) else c_utils.py_string_to_string_name(message_plural)

    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([py_stringname_message._ptr, py_stringname_message_plural._ptr, n, py_stringname_context._ptr]))
    return str(_ret)


  @functools.native_method
  def get_locale_override(self) -> typing.Union[str]:
    r'''
				Returns the locale override of the domain. Returns an empty string if locale override is disabled.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(59,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_locale_override(self, locale:'str'   ) -> None:
    r'''
				Sets the locale override of the domain.
				If `locale` is an empty string, locale override is disabled. Otherwise, `locale` will be standardized to match known locales (e.g. `en-US` would be matched to `en_US`).
				**Note:** Calling this method does not automatically update texts in the scene tree. Please propagate the `constant MainLoop.NOTIFICATION_TRANSLATION_CHANGED` signal manually.
			'''

    assert(not locale is None)
    assert isinstance(locale, (str, String)), 'locale must be str or String'





    assert(isinstance(locale, (str, String)))
    py_string_locale = locale if isinstance(locale, StringName) else c_utils.py_string_to_string(locale)

    self._ptr.call_with_return(60,tuple([py_string_locale._ptr]))

  @functools.native_method
  def is_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(61,tuple([]))

    return _ret


  @functools.native_method
  def set_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__enabled = enabled






    self._ptr.call_with_return(62,tuple([enabled]))

  @functools.native_method
  def is_pseudolocalization_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(63,tuple([]))

    return _ret


  @functools.native_method
  def set_pseudolocalization_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__pseudolocalization_enabled = enabled






    self._ptr.call_with_return(64,tuple([enabled]))

  @functools.native_method
  def is_pseudolocalization_accents_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(65,tuple([]))

    return _ret


  @functools.native_method
  def set_pseudolocalization_accents_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__pseudolocalization_accents_enabled = enabled






    self._ptr.call_with_return(66,tuple([enabled]))

  @functools.native_method
  def is_pseudolocalization_double_vowels_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([]))

    return _ret


  @functools.native_method
  def set_pseudolocalization_double_vowels_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__pseudolocalization_double_vowels_enabled = enabled






    self._ptr.call_with_return(68,tuple([enabled]))

  @functools.native_method
  def is_pseudolocalization_fake_bidi_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(69,tuple([]))

    return _ret


  @functools.native_method
  def set_pseudolocalization_fake_bidi_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__pseudolocalization_fake_bidi_enabled = enabled






    self._ptr.call_with_return(70,tuple([enabled]))

  @functools.native_method
  def is_pseudolocalization_override_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(71,tuple([]))

    return _ret


  @functools.native_method
  def set_pseudolocalization_override_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__pseudolocalization_override_enabled = enabled






    self._ptr.call_with_return(72,tuple([enabled]))

  @functools.native_method
  def is_pseudolocalization_skip_placeholders_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(73,tuple([]))

    return _ret


  @functools.native_method
  def set_pseudolocalization_skip_placeholders_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__pseudolocalization_skip_placeholders_enabled = enabled






    self._ptr.call_with_return(74,tuple([enabled]))

  @functools.native_method
  def get_pseudolocalization_expansion_ratio(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(75,tuple([]))

    return _ret


  @functools.native_method
  def set_pseudolocalization_expansion_ratio(self, ratio:'float'   ) -> None:
    r''''''

    assert isinstance(ratio, (int, float)), 'ratio must be int or float'


    self.py__pseudolocalization_expansion_ratio = ratio






    self._ptr.call_with_return(76,tuple([ratio]))

  @functools.native_method
  def get_pseudolocalization_prefix(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(77,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_pseudolocalization_prefix(self, prefix:'str'   ) -> None:
    r''''''

    assert(not prefix is None)
    assert isinstance(prefix, (str, String)), 'prefix must be str or String'


    self.py__pseudolocalization_prefix = prefix



    assert(isinstance(prefix, (str, String)))
    py_string_prefix = prefix if isinstance(prefix, StringName) else c_utils.py_string_to_string(prefix)

    py__string_prefix = utils.py_string_to_string(prefix)
    py__string_prefix.shouldBeDeleted = False


    self._ptr.call_with_return(78,tuple([py__string_prefix._ptr]))

  @functools.native_method
  def get_pseudolocalization_suffix(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_pseudolocalization_suffix(self, suffix:'str'   ) -> None:
    r''''''

    assert(not suffix is None)
    assert isinstance(suffix, (str, String)), 'suffix must be str or String'


    self.py__pseudolocalization_suffix = suffix



    assert(isinstance(suffix, (str, String)))
    py_string_suffix = suffix if isinstance(suffix, StringName) else c_utils.py_string_to_string(suffix)

    py__string_suffix = utils.py_string_to_string(suffix)
    py__string_suffix.shouldBeDeleted = False


    self._ptr.call_with_return(80,tuple([py__string_suffix._ptr]))

  @functools.native_method
  def pseudolocalize(self, message:'object'   ) -> typing.Union['StringName']:
    r'''
				Returns the pseudolocalized string based on the `message` passed in.
			'''

    assert(not message is None)
    assert isinstance(message, (str, StringName)), 'message must be str or StringName'





    assert(isinstance(message, (str, StringName)))
    py_stringname_message = message if isinstance(message, StringName) else c_utils.py_string_to_string_name(message)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([py_stringname_message._ptr]))
    return str(_ret)



register_cast_function('TranslationDomain', TranslationDomain.cast)
register_class('TranslationDomain', TranslationDomain)
