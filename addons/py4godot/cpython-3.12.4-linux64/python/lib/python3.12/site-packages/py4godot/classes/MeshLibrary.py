# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.PlaneMesh as py4godot_planemesh 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.TextMesh as py4godot_textmesh 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.RibbonTrailMesh as py4godot_ribbontrailmesh 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.TorusMesh as py4godot_torusmesh 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.TubeTrailMesh as py4godot_tubetrailmesh 
  import py4godot.classes.PlaceholderMesh as py4godot_placeholdermesh 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.PrimitiveMesh as py4godot_primitivemesh 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.CylinderMesh as py4godot_cylindermesh 
  import py4godot.classes.Mesh as py4godot_mesh 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.NavigationMesh as py4godot_navigationmesh 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.SphereMesh as py4godot_spheremesh 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.QuadMesh as py4godot_quadmesh 
  import py4godot.classes.PrismMesh as py4godot_prismmesh 
  import py4godot.classes.ArrayMesh as py4godot_arraymesh 
  import py4godot.classes.CapsuleMesh as py4godot_capsulemesh 
  import py4godot.classes.BoxMesh as py4godot_boxmesh 
  import py4godot.classes.RenderingServer as py4godot_renderingserver 
  import py4godot.classes.ImmediateMesh as py4godot_immediatemesh 
  import py4godot.classes.PointMesh as py4godot_pointmesh 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPMeshLibraryWrapper


class MeshLibrary(py4godot_resource.Resource):
  r'''
		A library of meshes. Contains a list of `Mesh` resources, each with a name and ID. Each item can also include collision and navigation shapes. This resource is used in `GridMap`.
	'''

  @staticmethod
  def constructor():
    class_ = MeshLibrary.construct_without_init()
    class_._ptr = constructor(475,0, ())
    return class_
  @staticmethod
  def new():
    class_ = MeshLibrary.construct_without_init()
    class_._ptr = constructor(475,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPMeshLibraryWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(475,0, ())


  def generate_wrapper(self):
    return CPPMeshLibraryWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = MeshLibrary.__new__(MeshLibrary)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'MeshLibrary'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(101, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = MeshLibrary.construct_without_init()
    cls._ptr = CPPMeshLibraryWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = MeshLibrary.construct_without_init()
    cls._ptr = CPPMeshLibraryWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def create_item(self, id:'int'   ) -> None:
    r'''
				Creates a new item in the library with the given ID.
				You can get an unused ID from `get_last_unused_item_id`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    self._ptr.call_with_return(77,tuple([id]))

  @functools.native_method
  def set_item_name(self, id:'int'   , name:'str'   ) -> None:
    r'''
				Sets the item's name.
				This name is shown in the editor. It can also be used to look up the item later using `find_item_by_name`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(78,tuple([id, py_string_name._ptr]))

  @functools.native_method
  def set_item_mesh(self, id:'int'   , mesh:'py4godot_mesh.Mesh'   ) -> None:
    r'''
				Sets the item's mesh.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not mesh is None)
    assert isinstance(mesh, get_class('Mesh')), 'mesh must be Mesh'








    self._ptr.call_with_return(79,tuple([id, mesh._ptr]))

  @functools.native_method
  def set_item_mesh_transform(self, id:'int'   , mesh_transform:'Transform3D'   ) -> None:
    r'''
				Sets the transform to apply to the item's mesh.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not mesh_transform is None)
    assert isinstance(mesh_transform, Transform3D), 'mesh_transform must be Transform3D'








    self._ptr.call_with_return(80,tuple([id, mesh_transform._ptr]))

  @functools.native_method
  def set_item_mesh_cast_shadow(self, id:'int'   , shadow_casting_setting:'int'  ) -> None:
    r'''
				Sets the item's shadow casting mode to `shadow_casting_setting`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(shadow_casting_setting, (int, float)), 'shadow_casting_setting must be int or float'








    self._ptr.call_with_return(81,tuple([id, shadow_casting_setting]))

  @functools.native_method
  def set_item_navigation_mesh(self, id:'int'   , navigation_mesh:'py4godot_navigationmesh.NavigationMesh'   ) -> None:
    r'''
				Sets the item's navigation mesh.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not navigation_mesh is None)
    assert isinstance(navigation_mesh, get_class('NavigationMesh')), 'navigation_mesh must be NavigationMesh'








    self._ptr.call_with_return(82,tuple([id, navigation_mesh._ptr]))

  @functools.native_method
  def set_item_navigation_mesh_transform(self, id:'int'   , navigation_mesh:'Transform3D'   ) -> None:
    r'''
				Sets the transform to apply to the item's navigation mesh.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not navigation_mesh is None)
    assert isinstance(navigation_mesh, Transform3D), 'navigation_mesh must be Transform3D'








    self._ptr.call_with_return(83,tuple([id, navigation_mesh._ptr]))

  @functools.native_method
  def set_item_navigation_layers(self, id:'int'   , navigation_layers:'int'   ) -> None:
    r'''
				Sets the item's navigation layers bitmask.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(navigation_layers, (int, float)), 'navigation_layers must be int or float'








    self._ptr.call_with_return(84,tuple([id, navigation_layers]))

  @functools.native_method
  def set_item_shapes(self, id:'int'   , shapes:'Array'   ) -> None:
    r'''
				Sets an item's collision shapes.
				The array should consist of `Shape3D` objects, each followed by a `Transform3D` that will be applied to it. For shapes that should not have a transform, use `constant Transform3D.IDENTITY`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not shapes is None)
    assert isinstance(shapes, Array), 'shapes must be Array'








    self._ptr.call_with_return(85,tuple([id, shapes._ptr]))

  @functools.native_method
  def set_item_preview(self, id:'int'   , texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets a texture to use as the item's preview icon in the editor.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'








    self._ptr.call_with_return(86,tuple([id, texture._ptr]))

  @functools.native_method
  def get_item_name(self, id:'int'   ) -> typing.Union[str]:
    r'''
				Returns the item's name.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([id]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_item_mesh(self, id:'int'   ) -> typing.Any:
    r'''
				Returns the item's mesh.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Mesh
    _ret._ptr = self._ptr.call_with_return(88,tuple([id]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_item_mesh_transform(self, id:'int'   ) -> typing.Union['Transform3D']:
    r'''
				Returns the transform applied to the item's mesh.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(89,tuple([id]))
    return _ret


  @functools.native_method
  def get_item_mesh_cast_shadow(self, id:'int'   ) -> typing.Union[int]:
    r'''
				Returns the item's shadow casting mode.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(90,tuple([id]))
    return _ret


  @functools.native_method
  def get_item_navigation_mesh(self, id:'int'   ) -> typing.Union['py4godot_navigationmesh.NavigationMesh']:
    r'''
				Returns the item's navigation mesh.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: NavigationMesh
    _ret._ptr = self._ptr.call_with_return(91,tuple([id]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_item_navigation_mesh_transform(self, id:'int'   ) -> typing.Union['Transform3D']:
    r'''
				Returns the transform applied to the item's navigation mesh.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(92,tuple([id]))
    return _ret


  @functools.native_method
  def get_item_navigation_layers(self, id:'int'   ) -> typing.Union[int]:
    r'''
				Returns the item's navigation layers bitmask.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([id]))
    return _ret


  @functools.native_method
  def get_item_shapes(self, id:'int'   ) -> typing.Union['Array']:
    r'''
				Returns an item's collision shapes.
				The array consists of each `Shape3D` followed by its `Transform3D`.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(94,tuple([id]))
    return _ret


  @functools.native_method
  def get_item_preview(self, id:'int'   ) -> typing.Any:
    r'''
				When running in the editor, returns a generated item preview (a 3D rendering in isometric perspective). When used in a running project, returns the manually-defined item preview which can be set using `set_item_preview`. Returns an empty `Texture2D` if no preview was manually set in a running project.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(95,tuple([id]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def remove_item(self, id:'int'   ) -> None:
    r'''
				Removes the item.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    self._ptr.call_with_return(96,tuple([id]))

  @functools.native_method
  def find_item_by_name(self, name:'str'   ) -> typing.Union[int]:
    r'''
				Returns the first item with the given name, or `-1` if no item is found.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def clear(self) -> None:
    r'''
				Clears the library.
			'''




    self._ptr.call_with_return(98,tuple([]))

  @functools.native_method
  def get_item_list(self) -> typing.Union['PackedInt32Array']:
    r'''
				Returns the list of item IDs in use.
			'''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(99,tuple([]))
    return _ret


  @functools.native_method
  def get_last_unused_item_id(self) -> typing.Union[int]:
    r'''
				Gets an unused ID for a new item.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([]))
    return _ret



register_cast_function('MeshLibrary', MeshLibrary.cast)
register_class('MeshLibrary', MeshLibrary)
