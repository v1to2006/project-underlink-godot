# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.InputEventScreenTouch as py4godot_inputeventscreentouch 
  import py4godot.classes.InputEventFromWindow as py4godot_inputeventfromwindow 
  import py4godot.classes.InputEventShortcut as py4godot_inputeventshortcut 
  import py4godot.classes.InputEventScreenDrag as py4godot_inputeventscreendrag 
  import py4godot.classes.InputEventMouseButton as py4godot_inputeventmousebutton 
  import py4godot.classes.InputEventPanGesture as py4godot_inputeventpangesture 
  import py4godot.classes.InputEventMouse as py4godot_inputeventmouse 
  import py4godot.classes.InputEventMagnifyGesture as py4godot_inputeventmagnifygesture 
  import py4godot.classes.InputEventAction as py4godot_inputeventaction 
  import py4godot.classes.InputEventJoypadButton as py4godot_inputeventjoypadbutton 
  import py4godot.classes.InputEventKey as py4godot_inputeventkey 
  import py4godot.classes.InputEventWithModifiers as py4godot_inputeventwithmodifiers 
  import py4godot.classes.InputEventMIDI as py4godot_inputeventmidi 
  import py4godot.classes.InputEventMouseMotion as py4godot_inputeventmousemotion 
  import py4godot.classes.InputEventJoypadMotion as py4godot_inputeventjoypadmotion 
  import py4godot.classes.InputEventGesture as py4godot_inputeventgesture 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPInputEventWrapper


class InputEvent(py4godot_resource.Resource):
  r'''
		Abstract base class of all types of input events. See `Node._input`.
	'''
  DEVICE_ID_EMULATION:typing.ClassVar[int]

  @staticmethod
  def constructor():
    class_ = InputEvent.construct_without_init()
    class_._ptr = constructor(413,0, ())
    return class_
  @staticmethod
  def new():
    class_ = InputEvent.construct_without_init()
    class_._ptr = constructor(413,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPInputEventWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(413,0, ())


  def generate_wrapper(self):
    return CPPInputEventWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = InputEvent.__new__(InputEvent)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'InputEvent'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(92, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = InputEvent.construct_without_init()
    cls._ptr = CPPInputEventWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = InputEvent.construct_without_init()
    cls._ptr = CPPInputEventWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def device(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_device()
    return _ret
  @device.setter
  def device(self,  value:'int'):
    self.set_device(value)
  @functools.native_method
  def set_device(self, device:'int'   ) -> None:
    r''''''

    assert isinstance(device, (int, float)), 'device must be int or float'


    self.py__device = device






    self._ptr.call_with_return(77,tuple([device]))

  @functools.native_method
  def get_device(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([]))

    return _ret


  @functools.native_method
  def is_action(self, action:'object'   , exact_match:'bool' =False  ) -> typing.Union[bool]:
    r'''
				Returns `true` if this input event matches a pre-defined action of any type.
				If `exact_match` is `false`, it ignores additional input modifiers for `InputEventKey` and `InputEventMouseButton` events, and the direction for `InputEventJoypadMotion` events.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'
    assert isinstance(exact_match, bool), 'exact_match must be bool'





    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)


    _ret = 0
    _ret = self._ptr.call_with_return(79,tuple([py_stringname_action._ptr, exact_match]))
    return _ret


  @functools.native_method
  def is_action_pressed(self, action:'object'   , allow_echo:'bool' =False  , exact_match:'bool' =False  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given action matches this event and is being pressed (and is not an echo event for `InputEventKey` events, unless `allow_echo` is `true`). Not relevant for events of type `InputEventMouseMotion` or `InputEventScreenDrag`.
				If `exact_match` is `false`, it ignores additional input modifiers for `InputEventKey` and `InputEventMouseButton` events, and the direction for `InputEventJoypadMotion` events.
				**Note:** Due to keyboard ghosting, `is_action_pressed` may return `false` even if one of the action's keys is pressed. See `url=$DOCS_URL/tutorials/inputs/input_examples.html#keyboard-events`Input examples`/url` in the documentation for more information.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'
    assert isinstance(allow_echo, bool), 'allow_echo must be bool'
    assert isinstance(exact_match, bool), 'exact_match must be bool'





    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)



    _ret = 0
    _ret = self._ptr.call_with_return(80,tuple([py_stringname_action._ptr, allow_echo, exact_match]))
    return _ret


  @functools.native_method
  def is_action_released(self, action:'object'   , exact_match:'bool' =False  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given action matches this event and is released (i.e. not pressed). Not relevant for events of type `InputEventMouseMotion` or `InputEventScreenDrag`.
				If `exact_match` is `false`, it ignores additional input modifiers for `InputEventKey` and `InputEventMouseButton` events, and the direction for `InputEventJoypadMotion` events.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'
    assert isinstance(exact_match, bool), 'exact_match must be bool'





    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)


    _ret = 0
    _ret = self._ptr.call_with_return(81,tuple([py_stringname_action._ptr, exact_match]))
    return _ret


  @functools.native_method
  def get_action_strength(self, action:'object'   , exact_match:'bool' =False  ) -> typing.Union[float]:
    r'''
				Returns a value between 0.0 and 1.0 depending on the given actions' state. Useful for getting the value of events of type `InputEventJoypadMotion`.
				If `exact_match` is `false`, it ignores additional input modifiers for `InputEventKey` and `InputEventMouseButton` events, and the direction for `InputEventJoypadMotion` events.
			'''

    assert(not action is None)
    assert isinstance(action, (str, StringName)), 'action must be str or StringName'
    assert isinstance(exact_match, bool), 'exact_match must be bool'





    assert(isinstance(action, (str, StringName)))
    py_stringname_action = action if isinstance(action, StringName) else c_utils.py_string_to_string_name(action)


    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([py_stringname_action._ptr, exact_match]))
    return _ret


  @functools.native_method
  def is_canceled(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this input event has been canceled.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(83,tuple([]))
    return _ret


  @functools.native_method
  def is_pressed(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this input event is pressed. Not relevant for events of type `InputEventMouseMotion` or `InputEventScreenDrag`.
				**Note:** Due to keyboard ghosting, `is_pressed` may return `false` even if one of the action's keys is pressed. See `url=$DOCS_URL/tutorials/inputs/input_examples.html#keyboard-events`Input examples`/url` in the documentation for more information.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([]))
    return _ret


  @functools.native_method
  def is_released(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this input event is released. Not relevant for events of type `InputEventMouseMotion` or `InputEventScreenDrag`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([]))
    return _ret


  @functools.native_method
  def is_echo(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this input event is an echo event (only for events of type `InputEventKey`). An echo event is a repeated key event sent when the user is holding down the key. Any other event type returns `false`.
				**Note:** The rate at which echo events are sent is typically around 20 events per second (after holding down the key for roughly half a second). However, the key repeat delay/speed can be changed by the user or disabled entirely in the operating system settings. To ensure your project works correctly on all configurations, do not assume the user has a specific key repeat configuration in your project's behavior.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def as_text(self) -> typing.Union[str]:
    r'''
				Returns a `String` representation of the event.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def is_match(self, event:'InputEvent'   , exact_match:'bool' =True  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified `event` matches this event. Only valid for action events, which include key (`InputEventKey`), button (`InputEventMouseButton` or `InputEventJoypadButton`), axis `InputEventJoypadMotion`, and action (`InputEventAction`) events.
				If `exact_match` is `false`, the check ignores additional input modifiers for `InputEventKey` and `InputEventMouseButton` events, and the direction for `InputEventJoypadMotion` events.
				**Note:** This method only considers the event configuration (such as the keyboard key or the joypad axis), not state information like `is_pressed`, `is_released`, `is_echo`, or `is_canceled`.
			'''

    assert(not event is None)
    assert isinstance(event, get_class('InputEvent')), 'event must be InputEvent'
    assert isinstance(exact_match, bool), 'exact_match must be bool'








    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([event._ptr, exact_match]))
    return _ret


  @functools.native_method
  def is_action_type(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this input event's type is one that can be assigned to an input action: `InputEventKey`, `InputEventMouseButton`, `InputEventJoypadButton`, `InputEventJoypadMotion`, `InputEventAction`. Returns `false` for all other input event types.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([]))
    return _ret


  @functools.native_method
  def accumulate(self, with_event:'InputEvent'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given input event and this input event can be added together (only for events of type `InputEventMouseMotion`).
				The given input event's position, global position and speed will be copied. The resulting `relative` is a sum of both events. Both events' modifiers have to be identical.
			'''

    assert(not with_event is None)
    assert isinstance(with_event, get_class('InputEvent')), 'with_event must be InputEvent'







    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([with_event._ptr]))
    return _ret


  @functools.native_method
  def xformed_by(self, xform:'Transform2D'   , local_ofs:'Vector2' = None  ) -> typing.Any:
    r'''
				Returns a copy of the given input event which has been offset by `local_ofs` and transformed by `xform`. Relevant for events of type `InputEventMouseButton`, `InputEventMouseMotion`, `InputEventScreenTouch`, `InputEventScreenDrag`, `InputEventMagnifyGesture` and `InputEventPanGesture`.
			'''
    if local_ofs is None:
      local_ofs = Vector2.new0()

    assert(not xform is None)
    assert isinstance(xform, Transform2D), 'xform must be Transform2D'








    _ret = InputEvent.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([xform._ptr, local_ofs._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('InputEvent', InputEvent.cast)
register_class('InputEvent', InputEvent)
