# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.Object as py4godot_object 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
from py4godot.wrappers.wrappers import CPPClassDBWrapper

_ClassDB_singleton_instance = None
class APIType:
  API_CORE = 0
  API_EDITOR = 1
  API_EXTENSION = 2
  API_EDITOR_EXTENSION = 3
  API_NONE = 4


class ClassDB(py4godot_object.Object):
  r'''
		Provides access to metadata stored for every available engine class.
		**Note:** Script-defined classes with `class_name` are not part of `ClassDB`, so they will not return reflection data such as a method or property list. However, `GDExtension`-defined classes _are_ part of `ClassDB`, so they will return reflection data.
	'''


  def generate_wrapper(self):
    return CPPClassDBWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = ClassDB.__new__(ClassDB)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'ClassDB'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = ClassDB.construct_without_init()
    cls._ptr = CPPClassDBWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = ClassDB.construct_without_init()
    cls._ptr = CPPClassDBWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _ClassDB_singleton_instance
    if _ClassDB_singleton_instance is None:
      singleton = ClassDB()
      singleton._ptr = constructor(212,0, ())
      _ClassDB_singleton_instance = singleton
    return _ClassDB_singleton_instance

  @functools.native_method
  def get_class_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns the names of all engine classes available.
				**Note:** Script-defined classes with `class_name` are not included in this list. Use `ProjectSettings.get_global_class_list` to get a list of script-defined classes instead.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(49,tuple([]))
    return _ret


  @functools.native_method
  def get_inheriters_from_class(self, class_:'object'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns the names of all engine classes that directly or indirectly inherit from `class`.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)

    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(50,tuple([py_stringname_class_._ptr]))
    return _ret


  @functools.native_method
  def get_parent_class(self, class_:'object'   ) -> typing.Union['StringName']:
    r'''
				Returns the parent class of `class`.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(51,tuple([py_stringname_class_._ptr]))
    return str(_ret)


  @functools.native_method
  def class_exists(self, class_:'object'   ) -> typing.Union[bool]:
    r'''
				Returns whether the specified `class` is available or not.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)

    _ret = 0
    _ret = self._ptr.call_with_return(52,tuple([py_stringname_class_._ptr]))
    return _ret


  @functools.native_method
  def is_parent_class(self, class_:'object'   , inherits:'object'   ) -> typing.Union[bool]:
    r'''
				Returns whether `inherits` is an ancestor of `class` or not.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not inherits is None)
    assert isinstance(inherits, (str, StringName)), 'inherits must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(inherits, (str, StringName)))
    py_stringname_inherits = inherits if isinstance(inherits, StringName) else c_utils.py_string_to_string_name(inherits)

    _ret = 0
    _ret = self._ptr.call_with_return(53,tuple([py_stringname_class_._ptr, py_stringname_inherits._ptr]))
    return _ret


  @functools.native_method
  def can_instantiate(self, class_:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if objects can be instantiated from the specified `class`, otherwise returns `false`.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)

    _ret = 0
    _ret = self._ptr.call_with_return(54,tuple([py_stringname_class_._ptr]))
    return _ret


  @functools.native_method
  def instantiate(self, class_:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Creates an instance of `class`.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)

    _ret = None
    _ret = self._ptr.call_with_return(55,tuple([py_stringname_class_._ptr]))
    return _ret


  @functools.native_method
  def class_get_api_type(self, class_:'object'   ) -> typing.Union[int]:
    r'''
				Returns the API type of the specified `class`.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)

    _ret:int
    _ret = self._ptr.call_with_return(56,tuple([py_stringname_class_._ptr]))
    return _ret


  @functools.native_method
  def class_has_signal(self, class_:'object'   , signal:'object'   ) -> typing.Union[bool]:
    r'''
				Returns whether `class` or its ancestry has a signal called `signal` or not.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not signal is None)
    assert isinstance(signal, (str, StringName)), 'signal must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(signal, (str, StringName)))
    py_stringname_signal = signal if isinstance(signal, StringName) else c_utils.py_string_to_string_name(signal)

    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([py_stringname_class_._ptr, py_stringname_signal._ptr]))
    return _ret


  @functools.native_method
  def class_get_signal(self, class_:'object'   , signal:'object'   ) -> typing.Union['Dictionary']:
    r'''
				Returns the `signal` data of `class` or its ancestry. The returned value is a `Dictionary` with the following keys: `args`, `default_args`, `flags`, `id`, `name`, `return: (class_name, hint, hint_string, name, type, usage)`.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not signal is None)
    assert isinstance(signal, (str, StringName)), 'signal must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(signal, (str, StringName)))
    py_stringname_signal = signal if isinstance(signal, StringName) else c_utils.py_string_to_string_name(signal)

    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([py_stringname_class_._ptr, py_stringname_signal._ptr]))
    return _ret


  @functools.native_method
  def class_get_signal_list(self, class_:'object'   , no_inheritance:'bool' =False  ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns an array with all the signals of `class` or its ancestry if `no_inheritance` is `false`. Every element of the array is a `Dictionary` as described in `class_get_signal`.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert isinstance(no_inheritance, bool), 'no_inheritance must be bool'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)


    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(59,tuple([py_stringname_class_._ptr, no_inheritance]))
    return _ret


  @functools.native_method
  def class_get_property_list(self, class_:'object'   , no_inheritance:'bool' =False  ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns an array with all the properties of `class` or its ancestry if `no_inheritance` is `false`.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert isinstance(no_inheritance, bool), 'no_inheritance must be bool'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)


    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([py_stringname_class_._ptr, no_inheritance]))
    return _ret


  @functools.native_method
  def class_get_property_getter(self, class_:'object'   , property:'object'   ) -> typing.Union['StringName']:
    r'''
				Returns the getter method name of `property` of `class`.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not property is None)
    assert isinstance(property, (str, StringName)), 'property must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(property, (str, StringName)))
    py_stringname_property = property if isinstance(property, StringName) else c_utils.py_string_to_string_name(property)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([py_stringname_class_._ptr, py_stringname_property._ptr]))
    return str(_ret)


  @functools.native_method
  def class_get_property_setter(self, class_:'object'   , property:'object'   ) -> typing.Union['StringName']:
    r'''
				Returns the setter method name of `property` of `class`.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not property is None)
    assert isinstance(property, (str, StringName)), 'property must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(property, (str, StringName)))
    py_stringname_property = property if isinstance(property, StringName) else c_utils.py_string_to_string_name(property)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([py_stringname_class_._ptr, py_stringname_property._ptr]))
    return str(_ret)


  @functools.native_method
  def class_get_property(self, object_:'py4godot_object.Object'   , property:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the value of `property` of `object` or its ancestry.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not property is None)
    assert isinstance(property, (str, StringName)), 'property must be str or StringName'






    assert(isinstance(property, (str, StringName)))
    py_stringname_property = property if isinstance(property, StringName) else c_utils.py_string_to_string_name(property)

    _ret = None
    _ret = self._ptr.call_with_return(63,tuple([object_._ptr, py_stringname_property._ptr]))
    return _ret


  @functools.native_method
  def class_set_property(self, object_:'py4godot_object.Object'   , property:'object'   , value:'object'   ) -> typing.Union[int]:
    r'''
				Sets `property` value of `object` to `value`.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not property is None)
    assert isinstance(property, (str, StringName)), 'property must be str or StringName'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(property, (str, StringName)))
    py_stringname_property = property if isinstance(property, StringName) else c_utils.py_string_to_string_name(property)


    _ret:int
    _ret = self._ptr.call_with_return(64,tuple([object_._ptr, py_stringname_property._ptr, value]))
    return _ret


  @functools.native_method
  def class_get_property_default_value(self, class_:'object'   , property:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the default value of `property` of `class` or its ancestor classes.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not property is None)
    assert isinstance(property, (str, StringName)), 'property must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(property, (str, StringName)))
    py_stringname_property = property if isinstance(property, StringName) else c_utils.py_string_to_string_name(property)

    _ret = None
    _ret = self._ptr.call_with_return(65,tuple([py_stringname_class_._ptr, py_stringname_property._ptr]))
    return _ret


  @functools.native_method
  def class_has_method(self, class_:'object'   , method:'object'   , no_inheritance:'bool' =False  ) -> typing.Union[bool]:
    r'''
				Returns whether `class` (or its ancestry if `no_inheritance` is `false`) has a method called `method` or not.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not method is None)
    assert isinstance(method, (str, StringName)), 'method must be str or StringName'
    assert isinstance(no_inheritance, bool), 'no_inheritance must be bool'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(method, (str, StringName)))
    py_stringname_method = method if isinstance(method, StringName) else c_utils.py_string_to_string_name(method)


    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([py_stringname_class_._ptr, py_stringname_method._ptr, no_inheritance]))
    return _ret


  @functools.native_method
  def class_get_method_argument_count(self, class_:'object'   , method:'object'   , no_inheritance:'bool' =False  ) -> typing.Union[int]:
    r'''
				Returns the number of arguments of the method `method` of `class` or its ancestry if `no_inheritance` is `false`.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not method is None)
    assert isinstance(method, (str, StringName)), 'method must be str or StringName'
    assert isinstance(no_inheritance, bool), 'no_inheritance must be bool'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(method, (str, StringName)))
    py_stringname_method = method if isinstance(method, StringName) else c_utils.py_string_to_string_name(method)


    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([py_stringname_class_._ptr, py_stringname_method._ptr, no_inheritance]))
    return _ret


  @functools.native_method
  def class_get_method_list(self, class_:'object'   , no_inheritance:'bool' =False  ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns an array with all the methods of `class` or its ancestry if `no_inheritance` is `false`. Every element of the array is a `Dictionary` with the following keys: `args`, `default_args`, `flags`, `id`, `name`, `return: (class_name, hint, hint_string, name, type, usage)`.
				**Note:** In exported release builds the debug info is not available, so the returned dictionaries will contain only method names.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert isinstance(no_inheritance, bool), 'no_inheritance must be bool'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)


    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(68,tuple([py_stringname_class_._ptr, no_inheritance]))
    return _ret


  @functools.native_method
  def class_call_static(self, class_:'object'   , method:'object'   , *varargs) -> typing.Union[typing.Any]:
    r'''
				Calls a static method on a class.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not method is None)
    assert isinstance(method, (str, StringName)), 'method must be str or StringName'

    for arg in varargs:
      if not (type(arg).__name__ in py4godot.variant_types.core_types or isinstance(arg, classes.Object.Object)):
        raise ValueError(
            f"Unsupported type in varargs: {type(arg).__name__}. "
            "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
            "and built-in types int, float, and bool."
        )



    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(method, (str, StringName)))
    py_stringname_method = method if isinstance(method, StringName) else c_utils.py_string_to_string_name(method)

    _ret = None
    _ret = self._ptr.call_with_return(69,tuple([py_stringname_class_._ptr, py_stringname_method._ptr, *varargs]))
    return _ret


  @functools.native_method
  def class_get_integer_constant_list(self, class_:'object'   , no_inheritance:'bool' =False  ) -> typing.Union['PackedStringArray']:
    r'''
				Returns an array with the names all the integer constants of `class` or its ancestry.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert isinstance(no_inheritance, bool), 'no_inheritance must be bool'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)


    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(70,tuple([py_stringname_class_._ptr, no_inheritance]))
    return _ret


  @functools.native_method
  def class_has_integer_constant(self, class_:'object'   , name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns whether `class` or its ancestry has an integer constant called `name` or not.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(71,tuple([py_stringname_class_._ptr, py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def class_get_integer_constant(self, class_:'object'   , name:'object'   ) -> typing.Union[int]:
    r'''
				Returns the value of the integer constant `name` of `class` or its ancestry. Always returns 0 when the constant could not be found.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(72,tuple([py_stringname_class_._ptr, py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def class_has_enum(self, class_:'object'   , name:'object'   , no_inheritance:'bool' =False  ) -> typing.Union[bool]:
    r'''
				Returns whether `class` or its ancestry has an enum called `name` or not.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(no_inheritance, bool), 'no_inheritance must be bool'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    _ret = 0
    _ret = self._ptr.call_with_return(73,tuple([py_stringname_class_._ptr, py_stringname_name._ptr, no_inheritance]))
    return _ret


  @functools.native_method
  def class_get_enum_list(self, class_:'object'   , no_inheritance:'bool' =False  ) -> typing.Union['PackedStringArray']:
    r'''
				Returns an array with all the enums of `class` or its ancestry.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert isinstance(no_inheritance, bool), 'no_inheritance must be bool'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)


    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(74,tuple([py_stringname_class_._ptr, no_inheritance]))
    return _ret


  @functools.native_method
  def class_get_enum_constants(self, class_:'object'   , enum:'object'   , no_inheritance:'bool' =False  ) -> typing.Union['PackedStringArray']:
    r'''
				Returns an array with all the keys in `enum` of `class` or its ancestry.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not enum is None)
    assert isinstance(enum, (str, StringName)), 'enum must be str or StringName'
    assert isinstance(no_inheritance, bool), 'no_inheritance must be bool'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(enum, (str, StringName)))
    py_stringname_enum = enum if isinstance(enum, StringName) else c_utils.py_string_to_string_name(enum)


    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(75,tuple([py_stringname_class_._ptr, py_stringname_enum._ptr, no_inheritance]))
    return _ret


  @functools.native_method
  def class_get_integer_constant_enum(self, class_:'object'   , name:'object'   , no_inheritance:'bool' =False  ) -> typing.Union['StringName']:
    r'''
				Returns which enum the integer constant `name` of `class` or its ancestry belongs to.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(no_inheritance, bool), 'no_inheritance must be bool'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(76,tuple([py_stringname_class_._ptr, py_stringname_name._ptr, no_inheritance]))
    return str(_ret)


  @functools.native_method
  def is_class_enum_bitfield(self, class_:'object'   , enum:'object'   , no_inheritance:'bool' =False  ) -> typing.Union[bool]:
    r'''
				Returns whether `class` (or its ancestor classes if `no_inheritance` is `false`) has an enum called `enum` that is a bitfield.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'
    assert(not enum is None)
    assert isinstance(enum, (str, StringName)), 'enum must be str or StringName'
    assert isinstance(no_inheritance, bool), 'no_inheritance must be bool'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)
    assert(isinstance(enum, (str, StringName)))
    py_stringname_enum = enum if isinstance(enum, StringName) else c_utils.py_string_to_string_name(enum)


    _ret = 0
    _ret = self._ptr.call_with_return(77,tuple([py_stringname_class_._ptr, py_stringname_enum._ptr, no_inheritance]))
    return _ret


  @functools.native_method
  def is_class_enabled(self, class_:'object'   ) -> typing.Union[bool]:
    r'''
				Returns whether this `class` is enabled or not.
			'''

    assert(not class_ is None)
    assert isinstance(class_, (str, StringName)), 'class_ must be str or StringName'





    assert(isinstance(class_, (str, StringName)))
    py_stringname_class_ = class_ if isinstance(class_, StringName) else c_utils.py_string_to_string_name(class_)

    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([py_stringname_class_._ptr]))
    return _ret



register_cast_function('ClassDB', ClassDB.cast)
register_class('ClassDB', ClassDB)
