# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
import typing
from py4godot.wrappers.wrappers import CPPStringWrapper

class ConstantString(String):

  @staticmethod
  def new0():
    _class = ConstantString.construct_without_init()
    _class._ptr = constructor(1032, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'str' ):
    assert(not from_ is None)
    assert isinstance(from_, (str, String)), 'from_ must be str or String'

    _class = ConstantString.construct_without_init()
    assert(isinstance(from_, (str, String)))
    py_string_from_ = from_ if isinstance(from_, StringName) else c_utils.py_string_to_string(from_)

    _class.py_string_from_ = py_string_from_
    _class._ptr = constructor(1032, 1, tuple([py_string_from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'StringName' ):
    assert(not from_ is None)
    assert isinstance(from_, (str, StringName)), 'from_ must be str or StringName'

    _class = ConstantString.construct_without_init()
    assert(isinstance(from_, (str, StringName)))
    py_stringname_from_ = from_ if isinstance(from_, StringName) else c_utils.py_string_to_string_name(from_)

    _class.py_stringname_from_ =py_stringname_from_
    _class._ptr = constructor(1032, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(from_:'NodePath' ):
    assert(not from_ is None)
    assert isinstance(from_, (str, NodePath)), 'from_ must be str or NodePath'

    _class = ConstantString.construct_without_init()
    assert(isinstance(from_, (str, NodePath)))
    py_nodepath_from_ = from_ if isinstance(from_,NodePath) else NodePath.new2(from_)

    _class.py_nodepath_from_ = py_nodepath_from_
    _class._ptr = constructor(1032, 3, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1032,0, ())

  def generate_wrapper(self):
    return CPPStringWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantString.__new__(ConstantString)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'String'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(110, ())

from py4godot.wrappers.wrappers import CPPVector2Wrapper

class ConstantVector2(Vector2):

  @staticmethod
  def new0():
    _class = ConstantVector2.construct_without_init()
    _class._ptr = constructor(1033, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Vector2' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector2), 'from_ must be Vector2'

    _class = ConstantVector2.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1033, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Vector2i' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector2i), 'from_ must be Vector2i'

    _class = ConstantVector2.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1033, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(x:'float' , y:'float' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'

    _class = ConstantVector2.construct_without_init()





    _class._ptr = constructor(1033, 3, tuple([x, y]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1033,0, ())

  def generate_wrapper(self):
    return CPPVector2Wrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantVector2.__new__(ConstantVector2)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Vector2'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(47, ())

  @property
  def x(self) -> float:
    _ret = self._ptr.call_with_return(48, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_x(self) -> None:
    _ret = self._ptr.call_with_return(48, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @x.setter
  def x(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_x(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def y(self) -> float:
    _ret = self._ptr.call_with_return(50, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_y(self) -> None:
    _ret = self._ptr.call_with_return(50, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @y.setter
  def y(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_y(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPVector2iWrapper

class ConstantVector2i(Vector2i):

  @staticmethod
  def new0():
    _class = ConstantVector2i.construct_without_init()
    _class._ptr = constructor(1034, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Vector2i' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector2i), 'from_ must be Vector2i'

    _class = ConstantVector2i.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1034, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Vector2' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector2), 'from_ must be Vector2'

    _class = ConstantVector2i.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1034, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(x:'int' , y:'int' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'

    _class = ConstantVector2i.construct_without_init()





    _class._ptr = constructor(1034, 3, tuple([x, y]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1034,0, ())

  def generate_wrapper(self):
    return CPPVector2iWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantVector2i.__new__(ConstantVector2i)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Vector2i'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(17, ())

  @property
  def x(self) -> int:
    _ret = self._ptr.call_with_return(18, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_x(self) -> None:
    _ret = self._ptr.call_with_return(18, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @x.setter
  def x(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_x(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def y(self) -> int:
    _ret = self._ptr.call_with_return(20, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_y(self) -> None:
    _ret = self._ptr.call_with_return(20, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @y.setter
  def y(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_y(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPRect2Wrapper

class ConstantRect2(Rect2):

  @staticmethod
  def new0():
    _class = ConstantRect2.construct_without_init()
    _class._ptr = constructor(1035, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Rect2' ):
    assert(not from_ is None)
    assert isinstance(from_, Rect2), 'from_ must be Rect2'

    _class = ConstantRect2.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1035, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Rect2i' ):
    assert(not from_ is None)
    assert isinstance(from_, Rect2i), 'from_ must be Rect2i'

    _class = ConstantRect2.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1035, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(position:'Vector2' , size:'Vector2' ):
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'
    assert(not size is None)
    assert isinstance(size, Vector2), 'size must be Vector2'

    _class = ConstantRect2.construct_without_init()



    _class.__position__ = position
    _class.__size__ = size
    _class._ptr = constructor(1035, 3, tuple([position._ptr, size._ptr]))
    return _class
  @staticmethod
  def new4(x:'float' , y:'float' , width:'float' , height:'float' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'

    _class = ConstantRect2.construct_without_init()









    _class._ptr = constructor(1035, 4, tuple([x, y, width, height]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1035,0, ())

  def generate_wrapper(self):
    return CPPRect2Wrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantRect2.__new__(ConstantRect2)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Rect2'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(16, ())

  @property
  def position(self) -> Vector2:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(17, tuple())
    return _ret
  def get_position(self) -> None:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(17, tuple())
    return _ret

  @position.setter
  def position(self, value: 'Vector2' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_position(self, value: 'Vector2' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def size(self) -> Vector2:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(19, tuple())
    return _ret
  def get_size(self) -> None:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(19, tuple())
    return _ret

  @size.setter
  def size(self, value: 'Vector2' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_size(self, value: 'Vector2' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPRect2iWrapper

class ConstantRect2i(Rect2i):

  @staticmethod
  def new0():
    _class = ConstantRect2i.construct_without_init()
    _class._ptr = constructor(1036, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Rect2i' ):
    assert(not from_ is None)
    assert isinstance(from_, Rect2i), 'from_ must be Rect2i'

    _class = ConstantRect2i.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1036, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Rect2' ):
    assert(not from_ is None)
    assert isinstance(from_, Rect2), 'from_ must be Rect2'

    _class = ConstantRect2i.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1036, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(position:'Vector2i' , size:'Vector2i' ):
    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'

    _class = ConstantRect2i.construct_without_init()



    _class.__position__ = position
    _class.__size__ = size
    _class._ptr = constructor(1036, 3, tuple([position._ptr, size._ptr]))
    return _class
  @staticmethod
  def new4(x:'int' , y:'int' , width:'int' , height:'int' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'

    _class = ConstantRect2i.construct_without_init()









    _class._ptr = constructor(1036, 4, tuple([x, y, width, height]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1036,0, ())

  def generate_wrapper(self):
    return CPPRect2iWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantRect2i.__new__(ConstantRect2i)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Rect2i'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(13, ())

  @property
  def position(self) -> Vector2i:
    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14, tuple())
    return _ret
  def get_position(self) -> None:
    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14, tuple())
    return _ret

  @position.setter
  def position(self, value: 'Vector2i' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_position(self, value: 'Vector2i' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def size(self) -> Vector2i:
    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16, tuple())
    return _ret
  def get_size(self) -> None:
    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16, tuple())
    return _ret

  @size.setter
  def size(self, value: 'Vector2i' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_size(self, value: 'Vector2i' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPVector3Wrapper

class ConstantVector3(Vector3):

  @staticmethod
  def new0():
    _class = ConstantVector3.construct_without_init()
    _class._ptr = constructor(1037, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Vector3' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector3), 'from_ must be Vector3'

    _class = ConstantVector3.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1037, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Vector3i' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector3i), 'from_ must be Vector3i'

    _class = ConstantVector3.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1037, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(x:'float' , y:'float' , z:'float' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(z, (int, float)), 'z must be int or float'

    _class = ConstantVector3.construct_without_init()







    _class._ptr = constructor(1037, 3, tuple([x, y, z]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1037,0, ())

  def generate_wrapper(self):
    return CPPVector3Wrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantVector3.__new__(ConstantVector3)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Vector3'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(47, ())

  @property
  def x(self) -> float:
    _ret = self._ptr.call_with_return(48, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_x(self) -> None:
    _ret = self._ptr.call_with_return(48, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @x.setter
  def x(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_x(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def y(self) -> float:
    _ret = self._ptr.call_with_return(50, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_y(self) -> None:
    _ret = self._ptr.call_with_return(50, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @y.setter
  def y(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_y(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def z(self) -> float:
    _ret = self._ptr.call_with_return(52, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_z(self) -> None:
    _ret = self._ptr.call_with_return(52, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @z.setter
  def z(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_z(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPVector3iWrapper

class ConstantVector3i(Vector3i):

  @staticmethod
  def new0():
    _class = ConstantVector3i.construct_without_init()
    _class._ptr = constructor(1038, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Vector3i' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector3i), 'from_ must be Vector3i'

    _class = ConstantVector3i.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1038, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Vector3' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector3), 'from_ must be Vector3'

    _class = ConstantVector3i.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1038, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(x:'int' , y:'int' , z:'int' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(z, (int, float)), 'z must be int or float'

    _class = ConstantVector3i.construct_without_init()







    _class._ptr = constructor(1038, 3, tuple([x, y, z]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1038,0, ())

  def generate_wrapper(self):
    return CPPVector3iWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantVector3i.__new__(ConstantVector3i)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Vector3i'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(16, ())

  @property
  def x(self) -> int:
    _ret = self._ptr.call_with_return(17, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_x(self) -> None:
    _ret = self._ptr.call_with_return(17, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @x.setter
  def x(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_x(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def y(self) -> int:
    _ret = self._ptr.call_with_return(19, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_y(self) -> None:
    _ret = self._ptr.call_with_return(19, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @y.setter
  def y(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_y(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def z(self) -> int:
    _ret = self._ptr.call_with_return(21, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_z(self) -> None:
    _ret = self._ptr.call_with_return(21, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @z.setter
  def z(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_z(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPTransform2DWrapper

class ConstantTransform2D(Transform2D):

  @staticmethod
  def new0():
    _class = ConstantTransform2D.construct_without_init()
    _class._ptr = constructor(1039, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Transform2D' ):
    assert(not from_ is None)
    assert isinstance(from_, Transform2D), 'from_ must be Transform2D'

    _class = ConstantTransform2D.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1039, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(rotation:'float' , position:'Vector2' ):
    assert isinstance(rotation, (int, float)), 'rotation must be int or float'
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'

    _class = ConstantTransform2D.construct_without_init()




    _class.__position__ = position
    _class._ptr = constructor(1039, 2, tuple([rotation, position._ptr]))
    return _class
  @staticmethod
  def new3(rotation:'float' , scale:'Vector2' , skew:'float' , position:'Vector2' ):
    assert isinstance(rotation, (int, float)), 'rotation must be int or float'
    assert(not scale is None)
    assert isinstance(scale, Vector2), 'scale must be Vector2'
    assert isinstance(skew, (int, float)), 'skew must be int or float'
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'

    _class = ConstantTransform2D.construct_without_init()






    _class.__scale__ = scale

    _class.__position__ = position
    _class._ptr = constructor(1039, 3, tuple([rotation, scale._ptr, skew, position._ptr]))
    return _class
  @staticmethod
  def new4(x_axis:'Vector2' , y_axis:'Vector2' , origin:'Vector2' ):
    assert(not x_axis is None)
    assert isinstance(x_axis, Vector2), 'x_axis must be Vector2'
    assert(not y_axis is None)
    assert isinstance(y_axis, Vector2), 'y_axis must be Vector2'
    assert(not origin is None)
    assert isinstance(origin, Vector2), 'origin must be Vector2'

    _class = ConstantTransform2D.construct_without_init()




    _class.__x_axis__ = x_axis
    _class.__y_axis__ = y_axis
    _class.__origin__ = origin
    _class._ptr = constructor(1039, 4, tuple([x_axis._ptr, y_axis._ptr, origin._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1039,0, ())

  def generate_wrapper(self):
    return CPPTransform2DWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantTransform2D.__new__(ConstantTransform2D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Transform2D'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(21, ())

  @property
  def x(self) -> Vector2:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22, tuple())
    return _ret
  def get_x(self) -> None:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22, tuple())
    return _ret

  @x.setter
  def x(self, value: 'Vector2' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_x(self, value: 'Vector2' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def y(self) -> Vector2:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(24, tuple())
    return _ret
  def get_y(self) -> None:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(24, tuple())
    return _ret

  @y.setter
  def y(self, value: 'Vector2' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_y(self, value: 'Vector2' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def origin(self) -> Vector2:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(26, tuple())
    return _ret
  def get_origin(self) -> None:
    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(26, tuple())
    return _ret

  @origin.setter
  def origin(self, value: 'Vector2' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_origin(self, value: 'Vector2' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPVector4Wrapper

class ConstantVector4(Vector4):

  @staticmethod
  def new0():
    _class = ConstantVector4.construct_without_init()
    _class._ptr = constructor(1040, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Vector4' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector4), 'from_ must be Vector4'

    _class = ConstantVector4.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1040, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Vector4i' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector4i), 'from_ must be Vector4i'

    _class = ConstantVector4.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1040, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(x:'float' , y:'float' , z:'float' , w:'float' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(z, (int, float)), 'z must be int or float'
    assert isinstance(w, (int, float)), 'w must be int or float'

    _class = ConstantVector4.construct_without_init()









    _class._ptr = constructor(1040, 3, tuple([x, y, z, w]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1040,0, ())

  def generate_wrapper(self):
    return CPPVector4Wrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantVector4.__new__(ConstantVector4)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Vector4'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(32, ())

  @property
  def x(self) -> float:
    _ret = self._ptr.call_with_return(33, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_x(self) -> None:
    _ret = self._ptr.call_with_return(33, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @x.setter
  def x(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_x(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def y(self) -> float:
    _ret = self._ptr.call_with_return(35, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_y(self) -> None:
    _ret = self._ptr.call_with_return(35, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @y.setter
  def y(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_y(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def z(self) -> float:
    _ret = self._ptr.call_with_return(37, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_z(self) -> None:
    _ret = self._ptr.call_with_return(37, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @z.setter
  def z(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_z(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def w(self) -> float:
    _ret = self._ptr.call_with_return(39, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_w(self) -> None:
    _ret = self._ptr.call_with_return(39, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @w.setter
  def w(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_w(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPVector4iWrapper

class ConstantVector4i(Vector4i):

  @staticmethod
  def new0():
    _class = ConstantVector4i.construct_without_init()
    _class._ptr = constructor(1041, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Vector4i' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector4i), 'from_ must be Vector4i'

    _class = ConstantVector4i.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1041, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Vector4' ):
    assert(not from_ is None)
    assert isinstance(from_, Vector4), 'from_ must be Vector4'

    _class = ConstantVector4i.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1041, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(x:'int' , y:'int' , z:'int' , w:'int' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(z, (int, float)), 'z must be int or float'
    assert isinstance(w, (int, float)), 'w must be int or float'

    _class = ConstantVector4i.construct_without_init()









    _class._ptr = constructor(1041, 3, tuple([x, y, z, w]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1041,0, ())

  def generate_wrapper(self):
    return CPPVector4iWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantVector4i.__new__(ConstantVector4i)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Vector4i'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(16, ())

  @property
  def x(self) -> int:
    _ret = self._ptr.call_with_return(17, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_x(self) -> None:
    _ret = self._ptr.call_with_return(17, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @x.setter
  def x(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_x(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def y(self) -> int:
    _ret = self._ptr.call_with_return(19, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_y(self) -> None:
    _ret = self._ptr.call_with_return(19, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @y.setter
  def y(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_y(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def z(self) -> int:
    _ret = self._ptr.call_with_return(21, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_z(self) -> None:
    _ret = self._ptr.call_with_return(21, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @z.setter
  def z(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_z(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def w(self) -> int:
    _ret = self._ptr.call_with_return(23, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_w(self) -> None:
    _ret = self._ptr.call_with_return(23, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @w.setter
  def w(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_w(self, value: 'int' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPPlaneWrapper

class ConstantPlane(Plane):

  @staticmethod
  def new0():
    _class = ConstantPlane.construct_without_init()
    _class._ptr = constructor(1042, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Plane' ):
    assert(not from_ is None)
    assert isinstance(from_, Plane), 'from_ must be Plane'

    _class = ConstantPlane.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1042, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(normal:'Vector3' ):
    assert(not normal is None)
    assert isinstance(normal, Vector3), 'normal must be Vector3'

    _class = ConstantPlane.construct_without_init()


    _class.__normal__ = normal
    _class._ptr = constructor(1042, 2, tuple([normal._ptr]))
    return _class
  @staticmethod
  def new3(normal:'Vector3' , d:'float' ):
    assert(not normal is None)
    assert isinstance(normal, Vector3), 'normal must be Vector3'
    assert isinstance(d, (int, float)), 'd must be int or float'

    _class = ConstantPlane.construct_without_init()



    _class.__normal__ = normal

    _class._ptr = constructor(1042, 3, tuple([normal._ptr, d]))
    return _class
  @staticmethod
  def new4(normal:'Vector3' , point:'Vector3' ):
    assert(not normal is None)
    assert isinstance(normal, Vector3), 'normal must be Vector3'
    assert(not point is None)
    assert isinstance(point, Vector3), 'point must be Vector3'

    _class = ConstantPlane.construct_without_init()



    _class.__normal__ = normal
    _class.__point__ = point
    _class._ptr = constructor(1042, 4, tuple([normal._ptr, point._ptr]))
    return _class
  @staticmethod
  def new5(point1:'Vector3' , point2:'Vector3' , point3:'Vector3' ):
    assert(not point1 is None)
    assert isinstance(point1, Vector3), 'point1 must be Vector3'
    assert(not point2 is None)
    assert isinstance(point2, Vector3), 'point2 must be Vector3'
    assert(not point3 is None)
    assert isinstance(point3, Vector3), 'point3 must be Vector3'

    _class = ConstantPlane.construct_without_init()




    _class.__point1__ = point1
    _class.__point2__ = point2
    _class.__point3__ = point3
    _class._ptr = constructor(1042, 5, tuple([point1._ptr, point2._ptr, point3._ptr]))
    return _class
  @staticmethod
  def new6(a:'float' , b:'float' , c:'float' , d:'float' ):
    assert isinstance(a, (int, float)), 'a must be int or float'
    assert isinstance(b, (int, float)), 'b must be int or float'
    assert isinstance(c, (int, float)), 'c must be int or float'
    assert isinstance(d, (int, float)), 'd must be int or float'

    _class = ConstantPlane.construct_without_init()









    _class._ptr = constructor(1042, 6, tuple([a, b, c, d]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1042,0, ())

  def generate_wrapper(self):
    return CPPPlaneWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantPlane.__new__(ConstantPlane)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Plane'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(11, ())

  @property
  def normal(self) -> Vector3:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20, tuple())
    return _ret
  def get_normal(self) -> None:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20, tuple())
    return _ret

  @normal.setter
  def normal(self, value: 'Vector3' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_normal(self, value: 'Vector3' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def d(self) -> float:
    _ret = self._ptr.call_with_return(18, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_d(self) -> None:
    _ret = self._ptr.call_with_return(18, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @d.setter
  def d(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_d(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPQuaternionWrapper

class ConstantQuaternion(Quaternion):

  @staticmethod
  def new0():
    _class = ConstantQuaternion.construct_without_init()
    _class._ptr = constructor(1043, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Quaternion' ):
    assert(not from_ is None)
    assert isinstance(from_, Quaternion), 'from_ must be Quaternion'

    _class = ConstantQuaternion.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1043, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Basis' ):
    assert(not from_ is None)
    assert isinstance(from_, Basis), 'from_ must be Basis'

    _class = ConstantQuaternion.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1043, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(axis:'Vector3' , angle:'float' ):
    assert(not axis is None)
    assert isinstance(axis, Vector3), 'axis must be Vector3'
    assert isinstance(angle, (int, float)), 'angle must be int or float'

    _class = ConstantQuaternion.construct_without_init()



    _class.__axis__ = axis

    _class._ptr = constructor(1043, 3, tuple([axis._ptr, angle]))
    return _class
  @staticmethod
  def new4(arc_from:'Vector3' , arc_to:'Vector3' ):
    assert(not arc_from is None)
    assert isinstance(arc_from, Vector3), 'arc_from must be Vector3'
    assert(not arc_to is None)
    assert isinstance(arc_to, Vector3), 'arc_to must be Vector3'

    _class = ConstantQuaternion.construct_without_init()



    _class.__arc_from__ = arc_from
    _class.__arc_to__ = arc_to
    _class._ptr = constructor(1043, 4, tuple([arc_from._ptr, arc_to._ptr]))
    return _class
  @staticmethod
  def new5(x:'float' , y:'float' , z:'float' , w:'float' ):
    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'
    assert isinstance(z, (int, float)), 'z must be int or float'
    assert isinstance(w, (int, float)), 'w must be int or float'

    _class = ConstantQuaternion.construct_without_init()









    _class._ptr = constructor(1043, 5, tuple([x, y, z, w]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1043,0, ())

  def generate_wrapper(self):
    return CPPQuaternionWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantQuaternion.__new__(ConstantQuaternion)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Quaternion'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(18, ())

  @property
  def x(self) -> float:
    _ret = self._ptr.call_with_return(19, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_x(self) -> None:
    _ret = self._ptr.call_with_return(19, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @x.setter
  def x(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_x(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def y(self) -> float:
    _ret = self._ptr.call_with_return(21, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_y(self) -> None:
    _ret = self._ptr.call_with_return(21, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @y.setter
  def y(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_y(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def z(self) -> float:
    _ret = self._ptr.call_with_return(23, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_z(self) -> None:
    _ret = self._ptr.call_with_return(23, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @z.setter
  def z(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_z(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def w(self) -> float:
    _ret = self._ptr.call_with_return(25, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_w(self) -> None:
    _ret = self._ptr.call_with_return(25, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @w.setter
  def w(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_w(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPAABBWrapper

class ConstantAABB(AABB):

  @staticmethod
  def new0():
    _class = ConstantAABB.construct_without_init()
    _class._ptr = constructor(1044, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'AABB' ):
    assert(not from_ is None)
    assert isinstance(from_, AABB), 'from_ must be AABB'

    _class = ConstantAABB.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1044, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(position:'Vector3' , size:'Vector3' ):
    assert(not position is None)
    assert isinstance(position, Vector3), 'position must be Vector3'
    assert(not size is None)
    assert isinstance(size, Vector3), 'size must be Vector3'

    _class = ConstantAABB.construct_without_init()



    _class.__position__ = position
    _class.__size__ = size
    _class._ptr = constructor(1044, 2, tuple([position._ptr, size._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1044,0, ())

  def generate_wrapper(self):
    return CPPAABBWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantAABB.__new__(ConstantAABB)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AABB'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(25, ())

  @property
  def position(self) -> Vector3:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(26, tuple())
    return _ret
  def get_position(self) -> None:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(26, tuple())
    return _ret

  @position.setter
  def position(self, value: 'Vector3' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_position(self, value: 'Vector3' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def size(self) -> Vector3:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(28, tuple())
    return _ret
  def get_size(self) -> None:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(28, tuple())
    return _ret

  @size.setter
  def size(self, value: 'Vector3' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_size(self, value: 'Vector3' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPBasisWrapper

class ConstantBasis(Basis):

  @staticmethod
  def new0():
    _class = ConstantBasis.construct_without_init()
    _class._ptr = constructor(1045, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Basis' ):
    assert(not from_ is None)
    assert isinstance(from_, Basis), 'from_ must be Basis'

    _class = ConstantBasis.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1045, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Quaternion' ):
    assert(not from_ is None)
    assert isinstance(from_, Quaternion), 'from_ must be Quaternion'

    _class = ConstantBasis.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1045, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(axis:'Vector3' , angle:'float' ):
    assert(not axis is None)
    assert isinstance(axis, Vector3), 'axis must be Vector3'
    assert isinstance(angle, (int, float)), 'angle must be int or float'

    _class = ConstantBasis.construct_without_init()



    _class.__axis__ = axis

    _class._ptr = constructor(1045, 3, tuple([axis._ptr, angle]))
    return _class
  @staticmethod
  def new4(x_axis:'Vector3' , y_axis:'Vector3' , z_axis:'Vector3' ):
    assert(not x_axis is None)
    assert isinstance(x_axis, Vector3), 'x_axis must be Vector3'
    assert(not y_axis is None)
    assert isinstance(y_axis, Vector3), 'y_axis must be Vector3'
    assert(not z_axis is None)
    assert isinstance(z_axis, Vector3), 'z_axis must be Vector3'

    _class = ConstantBasis.construct_without_init()




    _class.__x_axis__ = x_axis
    _class.__y_axis__ = y_axis
    _class.__z_axis__ = z_axis
    _class._ptr = constructor(1045, 4, tuple([x_axis._ptr, y_axis._ptr, z_axis._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1045,0, ())

  def generate_wrapper(self):
    return CPPBasisWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantBasis.__new__(ConstantBasis)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Basis'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(17, ())

  @property
  def x(self) -> Vector3:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18, tuple())
    return _ret
  def get_x(self) -> None:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18, tuple())
    return _ret

  @x.setter
  def x(self, value: 'Vector3' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_x(self, value: 'Vector3' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def y(self) -> Vector3:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20, tuple())
    return _ret
  def get_y(self) -> None:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20, tuple())
    return _ret

  @y.setter
  def y(self, value: 'Vector3' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_y(self, value: 'Vector3' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def z(self) -> Vector3:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22, tuple())
    return _ret
  def get_z(self) -> None:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22, tuple())
    return _ret

  @z.setter
  def z(self, value: 'Vector3' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_z(self, value: 'Vector3' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPTransform3DWrapper

class ConstantTransform3D(Transform3D):

  @staticmethod
  def new0():
    _class = ConstantTransform3D.construct_without_init()
    _class._ptr = constructor(1046, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Transform3D' ):
    assert(not from_ is None)
    assert isinstance(from_, Transform3D), 'from_ must be Transform3D'

    _class = ConstantTransform3D.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1046, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(basis:'Basis' , origin:'Vector3' ):
    assert(not basis is None)
    assert isinstance(basis, Basis), 'basis must be Basis'
    assert(not origin is None)
    assert isinstance(origin, Vector3), 'origin must be Vector3'

    _class = ConstantTransform3D.construct_without_init()



    _class.__basis__ = basis
    _class.__origin__ = origin
    _class._ptr = constructor(1046, 2, tuple([basis._ptr, origin._ptr]))
    return _class
  @staticmethod
  def new3(x_axis:'Vector3' , y_axis:'Vector3' , z_axis:'Vector3' , origin:'Vector3' ):
    assert(not x_axis is None)
    assert isinstance(x_axis, Vector3), 'x_axis must be Vector3'
    assert(not y_axis is None)
    assert isinstance(y_axis, Vector3), 'y_axis must be Vector3'
    assert(not z_axis is None)
    assert isinstance(z_axis, Vector3), 'z_axis must be Vector3'
    assert(not origin is None)
    assert isinstance(origin, Vector3), 'origin must be Vector3'

    _class = ConstantTransform3D.construct_without_init()





    _class.__x_axis__ = x_axis
    _class.__y_axis__ = y_axis
    _class.__z_axis__ = z_axis
    _class.__origin__ = origin
    _class._ptr = constructor(1046, 3, tuple([x_axis._ptr, y_axis._ptr, z_axis._ptr, origin._ptr]))
    return _class
  @staticmethod
  def new4(from_:'Projection' ):
    assert(not from_ is None)
    assert isinstance(from_, Projection), 'from_ must be Projection'

    _class = ConstantTransform3D.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1046, 4, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1046,0, ())

  def generate_wrapper(self):
    return CPPTransform3DWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantTransform3D.__new__(ConstantTransform3D)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Transform3D'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(13, ())

  @property
  def basis(self) -> Basis:
    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14, tuple())
    return _ret
  def get_basis(self) -> None:
    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(14, tuple())
    return _ret

  @basis.setter
  def basis(self, value: 'Basis' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_basis(self, value: 'Basis' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def origin(self) -> Vector3:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16, tuple())
    return _ret
  def get_origin(self) -> None:
    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16, tuple())
    return _ret

  @origin.setter
  def origin(self, value: 'Vector3' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_origin(self, value: 'Vector3' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPProjectionWrapper

class ConstantProjection(Projection):

  @staticmethod
  def new0():
    _class = ConstantProjection.construct_without_init()
    _class._ptr = constructor(1047, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Projection' ):
    assert(not from_ is None)
    assert isinstance(from_, Projection), 'from_ must be Projection'

    _class = ConstantProjection.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1047, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Transform3D' ):
    assert(not from_ is None)
    assert isinstance(from_, Transform3D), 'from_ must be Transform3D'

    _class = ConstantProjection.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1047, 2, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new3(x_axis:'Vector4' , y_axis:'Vector4' , z_axis:'Vector4' , w_axis:'Vector4' ):
    assert(not x_axis is None)
    assert isinstance(x_axis, Vector4), 'x_axis must be Vector4'
    assert(not y_axis is None)
    assert isinstance(y_axis, Vector4), 'y_axis must be Vector4'
    assert(not z_axis is None)
    assert isinstance(z_axis, Vector4), 'z_axis must be Vector4'
    assert(not w_axis is None)
    assert isinstance(w_axis, Vector4), 'w_axis must be Vector4'

    _class = ConstantProjection.construct_without_init()





    _class.__x_axis__ = x_axis
    _class.__y_axis__ = y_axis
    _class.__z_axis__ = z_axis
    _class.__w_axis__ = w_axis
    _class._ptr = constructor(1047, 3, tuple([x_axis._ptr, y_axis._ptr, z_axis._ptr, w_axis._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1047,0, ())

  def generate_wrapper(self):
    return CPPProjectionWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantProjection.__new__(ConstantProjection)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Projection'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(15, ())

  @property
  def x(self) -> Vector4:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16, tuple())
    return _ret
  def get_x(self) -> None:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(16, tuple())
    return _ret

  @x.setter
  def x(self, value: 'Vector4' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_x(self, value: 'Vector4' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def y(self) -> Vector4:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18, tuple())
    return _ret
  def get_y(self) -> None:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(18, tuple())
    return _ret

  @y.setter
  def y(self, value: 'Vector4' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_y(self, value: 'Vector4' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def z(self) -> Vector4:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20, tuple())
    return _ret
  def get_z(self) -> None:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(20, tuple())
    return _ret

  @z.setter
  def z(self, value: 'Vector4' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_z(self, value: 'Vector4' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def w(self) -> Vector4:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22, tuple())
    return _ret
  def get_w(self) -> None:
    _ret = Vector4.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(22, tuple())
    return _ret

  @w.setter
  def w(self, value: 'Vector4' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_w(self, value: 'Vector4' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPColorWrapper

class ConstantColor(Color):

  @staticmethod
  def new0():
    _class = ConstantColor.construct_without_init()
    _class._ptr = constructor(1048, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Color' ):
    assert(not from_ is None)
    assert isinstance(from_, Color), 'from_ must be Color'

    _class = ConstantColor.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1048, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Color' , alpha:'float' ):
    assert(not from_ is None)
    assert isinstance(from_, Color), 'from_ must be Color'
    assert isinstance(alpha, (int, float)), 'alpha must be int or float'

    _class = ConstantColor.construct_without_init()



    _class.__from___ = from_

    _class._ptr = constructor(1048, 2, tuple([from_._ptr, alpha]))
    return _class
  @staticmethod
  def new3(r:'float' , g:'float' , b:'float' ):
    assert isinstance(r, (int, float)), 'r must be int or float'
    assert isinstance(g, (int, float)), 'g must be int or float'
    assert isinstance(b, (int, float)), 'b must be int or float'

    _class = ConstantColor.construct_without_init()







    _class._ptr = constructor(1048, 3, tuple([r, g, b]))
    return _class
  @staticmethod
  def new4(r:'float' , g:'float' , b:'float' , a:'float' ):
    assert isinstance(r, (int, float)), 'r must be int or float'
    assert isinstance(g, (int, float)), 'g must be int or float'
    assert isinstance(b, (int, float)), 'b must be int or float'
    assert isinstance(a, (int, float)), 'a must be int or float'

    _class = ConstantColor.construct_without_init()









    _class._ptr = constructor(1048, 4, tuple([r, g, b, a]))
    return _class
  @staticmethod
  def new5(code:'str' ):
    assert(not code is None)
    assert isinstance(code, (str, String)), 'code must be str or String'

    _class = ConstantColor.construct_without_init()
    assert(isinstance(code, (str, String)))
    py_string_code = code if isinstance(code, StringName) else c_utils.py_string_to_string(code)

    _class.py_string_code = py_string_code
    _class._ptr = constructor(1048, 5, tuple([py_string_code._ptr]))
    return _class
  @staticmethod
  def new6(code:'str' , alpha:'float' ):
    assert(not code is None)
    assert isinstance(code, (str, String)), 'code must be str or String'
    assert isinstance(alpha, (int, float)), 'alpha must be int or float'

    _class = ConstantColor.construct_without_init()
    assert(isinstance(code, (str, String)))
    py_string_code = code if isinstance(code, StringName) else c_utils.py_string_to_string(code)


    _class.py_string_code = py_string_code

    _class._ptr = constructor(1048, 6, tuple([py_string_code._ptr, alpha]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1048,0, ())

  def generate_wrapper(self):
    return CPPColorWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantColor.__new__(ConstantColor)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Color'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(17, ())

  @property
  def r(self) -> float:
    _ret = self._ptr.call_with_return(18, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_r(self) -> None:
    _ret = self._ptr.call_with_return(18, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @r.setter
  def r(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_r(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def g(self) -> float:
    _ret = self._ptr.call_with_return(20, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_g(self) -> None:
    _ret = self._ptr.call_with_return(20, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @g.setter
  def g(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_g(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def b(self) -> float:
    _ret = self._ptr.call_with_return(22, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_b(self) -> None:
    _ret = self._ptr.call_with_return(22, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @b.setter
  def b(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_b(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  @property
  def a(self) -> float:
    _ret = self._ptr.call_with_return(24, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret
  def get_a(self) -> None:
    _ret = self._ptr.call_with_return(24, tuple())
    c_utils.decref(_ret) # This needs to be decrefed, as it comes from C++ with one ref too much
    return _ret

  @a.setter
  def a(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
  def set_a(self, value: 'float' ):
    raise RuntimeError('Setting a property of a constant value is not possible')
from py4godot.wrappers.wrappers import CPPStringNameWrapper

class ConstantStringName(StringName):

  @staticmethod
  def new0():
    _class = ConstantStringName.construct_without_init()
    _class._ptr = constructor(1049, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'object' ):
    assert(not from_ is None)
    assert isinstance(from_, (str, StringName)), 'from_ must be str or StringName'

    _class = ConstantStringName.construct_without_init()
    assert(isinstance(from_, (str, StringName)))
    py_stringname_from_ = from_ if isinstance(from_, StringName) else c_utils.py_string_to_string_name(from_)

    _class.py_stringname_from_ =py_stringname_from_
    _class._ptr = constructor(1049, 1, tuple([py_stringname_from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'str' ):
    assert(not from_ is None)
    assert isinstance(from_, (str, String)), 'from_ must be str or String'

    _class = ConstantStringName.construct_without_init()
    assert(isinstance(from_, (str, String)))
    py_string_from_ = from_ if isinstance(from_, StringName) else c_utils.py_string_to_string(from_)

    _class.py_string_from_ = py_string_from_
    _class._ptr = constructor(1049, 2, tuple([py_string_from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1049,0, ())

  def generate_wrapper(self):
    return CPPStringNameWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantStringName.__new__(ConstantStringName)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'StringName'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(110, ())

from py4godot.wrappers.wrappers import CPPNodePathWrapper

class ConstantNodePath(NodePath):

  @staticmethod
  def new0():
    _class = ConstantNodePath.construct_without_init()
    _class._ptr = constructor(1050, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'object' ):
    assert(not from_ is None)
    assert isinstance(from_, (str, NodePath)), 'from_ must be str or NodePath'

    _class = ConstantNodePath.construct_without_init()
    assert(isinstance(from_, (str, NodePath)))
    py_nodepath_from_ = from_ if isinstance(from_,NodePath) else NodePath.new2(from_)

    _class.py_nodepath_from_ = py_nodepath_from_
    _class._ptr = constructor(1050, 1, tuple([py_nodepath_from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'str' ):
    assert(not from_ is None)
    assert isinstance(from_, (str, String)), 'from_ must be str or String'

    _class = ConstantNodePath.construct_without_init()
    assert(isinstance(from_, (str, String)))
    py_string_from_ = from_ if isinstance(from_, StringName) else c_utils.py_string_to_string(from_)

    _class.py_string_from_ = py_string_from_
    _class._ptr = constructor(1050, 2, tuple([py_string_from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1050,0, ())

  def generate_wrapper(self):
    return CPPNodePathWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantNodePath.__new__(ConstantNodePath)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'NodePath'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(11, ())

from py4godot.wrappers.wrappers import CPPRIDWrapper

class ConstantRID(RID):

  @staticmethod
  def new0():
    _class = ConstantRID.construct_without_init()
    _class._ptr = constructor(1051, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'RID' ):
    assert(not from_ is None)
    assert isinstance(from_, RID), 'from_ must be RID'

    _class = ConstantRID.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1051, 1, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1051,0, ())

  def generate_wrapper(self):
    return CPPRIDWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantRID.__new__(ConstantRID)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'RID'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(2, ())

from py4godot.wrappers.wrappers import CPPCallableWrapper

class ConstantCallable(Callable):

  @staticmethod
  def new0():
    _class = ConstantCallable.construct_without_init()
    _class._ptr = constructor(1052, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Callable' ):
    assert(not from_ is None)
    assert isinstance(from_, Callable), 'from_ must be Callable'

    _class = ConstantCallable.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1052, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(object_:'Object' , method:'object' ):
    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not method is None)
    assert isinstance(method, (str, StringName)), 'method must be str or StringName'

    _class = ConstantCallable.construct_without_init()

    assert(isinstance(method, (str, StringName)))
    py_stringname_method = method if isinstance(method, StringName) else c_utils.py_string_to_string_name(method)


    _class.py_stringname_method =py_stringname_method
    _class._ptr = constructor(1052, 2, tuple([object_._ptr, py_stringname_method._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1052,0, ())

  def generate_wrapper(self):
    return CPPCallableWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantCallable.__new__(ConstantCallable)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Callable'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(20, ())

from py4godot.wrappers.wrappers import CPPSignalWrapper

class ConstantSignal(Signal):

  @staticmethod
  def new0():
    _class = ConstantSignal.construct_without_init()
    _class._ptr = constructor(1053, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Signal' ):
    assert(not from_ is None)
    assert isinstance(from_, Signal), 'from_ must be Signal'

    _class = ConstantSignal.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1053, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(object_:'Object' , signal:'object' ):
    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not signal is None)
    assert isinstance(signal, (str, StringName)), 'signal must be str or StringName'

    _class = ConstantSignal.construct_without_init()

    assert(isinstance(signal, (str, StringName)))
    py_stringname_signal = signal if isinstance(signal, StringName) else c_utils.py_string_to_string_name(signal)


    _class.py_stringname_signal =py_stringname_signal
    _class._ptr = constructor(1053, 2, tuple([object_._ptr, py_stringname_signal._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1053,0, ())

  def generate_wrapper(self):
    return CPPSignalWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantSignal.__new__(ConstantSignal)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Signal'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(10, ())

from py4godot.wrappers.wrappers import CPPDictionaryWrapper

class ConstantDictionary(Dictionary):

  @staticmethod
  def new0():
    _class = ConstantDictionary.construct_without_init()
    _class._ptr = constructor(1054, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Dictionary' ):
    assert(not from_ is None)
    assert isinstance(from_, Dictionary), 'from_ must be Dictionary'

    _class = ConstantDictionary.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1054, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(base:'Dictionary' , key_type:'int' , key_class_name:'object' , key_script:'object' , value_type:'int' , value_class_name:'object' , value_script:'object' ):
    assert(not base is None)
    assert isinstance(base, Dictionary), 'base must be Dictionary'
    assert isinstance(key_type, (int, float)), 'key_type must be int or float'
    assert(not key_class_name is None)
    assert isinstance(key_class_name, (str, StringName)), 'key_class_name must be str or StringName'
    
    assert isinstance(value_type, (int, float)), 'value_type must be int or float'
    assert(not value_class_name is None)
    assert isinstance(value_class_name, (str, StringName)), 'value_class_name must be str or StringName'
    

    _class = ConstantDictionary.construct_without_init()


    assert(isinstance(key_class_name, (str, StringName)))
    py_stringname_key_class_name = key_class_name if isinstance(key_class_name, StringName) else c_utils.py_string_to_string_name(key_class_name)


    assert(isinstance(value_class_name, (str, StringName)))
    py_stringname_value_class_name = value_class_name if isinstance(value_class_name, StringName) else c_utils.py_string_to_string_name(value_class_name)


    _class.__base__ = base

    _class.py_stringname_key_class_name =py_stringname_key_class_name


    _class.py_stringname_value_class_name =py_stringname_value_class_name

    _class._ptr = constructor(1054, 2, tuple([base._ptr, key_type, py_stringname_key_class_name._ptr, key_script, value_type, py_stringname_value_class_name._ptr, value_script]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1054,0, ())

  def generate_wrapper(self):
    return CPPDictionaryWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantDictionary.__new__(ConstantDictionary)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Dictionary'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(34, ())

from py4godot.wrappers.wrappers import CPPArrayWrapper

class ConstantArray(Array):

  @staticmethod
  def new0():
    _class = ConstantArray.construct_without_init()
    _class._ptr = constructor(1055, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = ConstantArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1055, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(base:'Array' , type:'int' , class_name:'object' , script:'object' ):
    assert(not base is None)
    assert isinstance(base, Array), 'base must be Array'
    assert isinstance(type, (int, float)), 'type must be int or float'
    assert(not class_name is None)
    assert isinstance(class_name, (str, StringName)), 'class_name must be str or StringName'
    

    _class = ConstantArray.construct_without_init()


    assert(isinstance(class_name, (str, StringName)))
    py_stringname_class_name = class_name if isinstance(class_name, StringName) else c_utils.py_string_to_string_name(class_name)


    _class.__base__ = base

    _class.py_stringname_class_name =py_stringname_class_name

    _class._ptr = constructor(1055, 2, tuple([base._ptr, type, py_stringname_class_name._ptr, script]))
    return _class
  @staticmethod
  def new3(from_:'PackedByteArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedByteArray), 'from_ must be PackedByteArray'

    _class = ConstantArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1055, 3, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new4(from_:'PackedInt32Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedInt32Array), 'from_ must be PackedInt32Array'

    _class = ConstantArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1055, 4, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new5(from_:'PackedInt64Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedInt64Array), 'from_ must be PackedInt64Array'

    _class = ConstantArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1055, 5, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new6(from_:'PackedFloat32Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedFloat32Array), 'from_ must be PackedFloat32Array'

    _class = ConstantArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1055, 6, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new7(from_:'PackedFloat64Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedFloat64Array), 'from_ must be PackedFloat64Array'

    _class = ConstantArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1055, 7, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new8(from_:'PackedStringArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedStringArray), 'from_ must be PackedStringArray'

    _class = ConstantArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1055, 8, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new9(from_:'PackedVector2Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector2Array), 'from_ must be PackedVector2Array'

    _class = ConstantArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1055, 9, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new10(from_:'PackedVector3Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector3Array), 'from_ must be PackedVector3Array'

    _class = ConstantArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1055, 10, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new11(from_:'PackedColorArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedColorArray), 'from_ must be PackedColorArray'

    _class = ConstantArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1055, 11, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new12(from_:'PackedVector4Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector4Array), 'from_ must be PackedVector4Array'

    _class = ConstantArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1055, 12, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1055,0, ())

  def generate_wrapper(self):
    return CPPArrayWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantArray.__new__(ConstantArray)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(51, ())

from py4godot.wrappers.wrappers import CPPPackedByteArrayWrapper

class ConstantPackedByteArray(PackedByteArray):

  @staticmethod
  def new0():
    _class = ConstantPackedByteArray.construct_without_init()
    _class._ptr = constructor(1056, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedByteArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedByteArray), 'from_ must be PackedByteArray'

    _class = ConstantPackedByteArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1056, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = ConstantPackedByteArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1056, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1056,0, ())

  def generate_wrapper(self):
    return CPPPackedByteArrayWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantPackedByteArray.__new__(ConstantPackedByteArray)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedByteArray'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(69, ())

from py4godot.wrappers.wrappers import CPPPackedInt32ArrayWrapper

class ConstantPackedInt32Array(PackedInt32Array):

  @staticmethod
  def new0():
    _class = ConstantPackedInt32Array.construct_without_init()
    _class._ptr = constructor(1057, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedInt32Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedInt32Array), 'from_ must be PackedInt32Array'

    _class = ConstantPackedInt32Array.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1057, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = ConstantPackedInt32Array.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1057, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1057,0, ())

  def generate_wrapper(self):
    return CPPPackedInt32ArrayWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantPackedInt32Array.__new__(ConstantPackedInt32Array)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedInt32Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())

from py4godot.wrappers.wrappers import CPPPackedInt64ArrayWrapper

class ConstantPackedInt64Array(PackedInt64Array):

  @staticmethod
  def new0():
    _class = ConstantPackedInt64Array.construct_without_init()
    _class._ptr = constructor(1058, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedInt64Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedInt64Array), 'from_ must be PackedInt64Array'

    _class = ConstantPackedInt64Array.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1058, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = ConstantPackedInt64Array.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1058, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1058,0, ())

  def generate_wrapper(self):
    return CPPPackedInt64ArrayWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantPackedInt64Array.__new__(ConstantPackedInt64Array)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedInt64Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())

from py4godot.wrappers.wrappers import CPPPackedFloat32ArrayWrapper

class ConstantPackedFloat32Array(PackedFloat32Array):

  @staticmethod
  def new0():
    _class = ConstantPackedFloat32Array.construct_without_init()
    _class._ptr = constructor(1059, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedFloat32Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedFloat32Array), 'from_ must be PackedFloat32Array'

    _class = ConstantPackedFloat32Array.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1059, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = ConstantPackedFloat32Array.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1059, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1059,0, ())

  def generate_wrapper(self):
    return CPPPackedFloat32ArrayWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantPackedFloat32Array.__new__(ConstantPackedFloat32Array)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedFloat32Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())

from py4godot.wrappers.wrappers import CPPPackedFloat64ArrayWrapper

class ConstantPackedFloat64Array(PackedFloat64Array):

  @staticmethod
  def new0():
    _class = ConstantPackedFloat64Array.construct_without_init()
    _class._ptr = constructor(1060, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedFloat64Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedFloat64Array), 'from_ must be PackedFloat64Array'

    _class = ConstantPackedFloat64Array.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1060, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = ConstantPackedFloat64Array.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1060, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1060,0, ())

  def generate_wrapper(self):
    return CPPPackedFloat64ArrayWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantPackedFloat64Array.__new__(ConstantPackedFloat64Array)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedFloat64Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())

from py4godot.wrappers.wrappers import CPPPackedStringArrayWrapper

class ConstantPackedStringArray(PackedStringArray):

  @staticmethod
  def new0():
    _class = ConstantPackedStringArray.construct_without_init()
    _class._ptr = constructor(1061, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedStringArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedStringArray), 'from_ must be PackedStringArray'

    _class = ConstantPackedStringArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1061, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = ConstantPackedStringArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1061, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1061,0, ())

  def generate_wrapper(self):
    return CPPPackedStringArrayWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantPackedStringArray.__new__(ConstantPackedStringArray)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedStringArray'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())

from py4godot.wrappers.wrappers import CPPPackedVector2ArrayWrapper

class ConstantPackedVector2Array(PackedVector2Array):

  @staticmethod
  def new0():
    _class = ConstantPackedVector2Array.construct_without_init()
    _class._ptr = constructor(1062, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedVector2Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector2Array), 'from_ must be PackedVector2Array'

    _class = ConstantPackedVector2Array.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1062, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = ConstantPackedVector2Array.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1062, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1062,0, ())

  def generate_wrapper(self):
    return CPPPackedVector2ArrayWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantPackedVector2Array.__new__(ConstantPackedVector2Array)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedVector2Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())

from py4godot.wrappers.wrappers import CPPPackedVector3ArrayWrapper

class ConstantPackedVector3Array(PackedVector3Array):

  @staticmethod
  def new0():
    _class = ConstantPackedVector3Array.construct_without_init()
    _class._ptr = constructor(1063, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedVector3Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector3Array), 'from_ must be PackedVector3Array'

    _class = ConstantPackedVector3Array.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1063, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = ConstantPackedVector3Array.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1063, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1063,0, ())

  def generate_wrapper(self):
    return CPPPackedVector3ArrayWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantPackedVector3Array.__new__(ConstantPackedVector3Array)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedVector3Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())

from py4godot.wrappers.wrappers import CPPPackedColorArrayWrapper

class ConstantPackedColorArray(PackedColorArray):

  @staticmethod
  def new0():
    _class = ConstantPackedColorArray.construct_without_init()
    _class._ptr = constructor(1064, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedColorArray' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedColorArray), 'from_ must be PackedColorArray'

    _class = ConstantPackedColorArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1064, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = ConstantPackedColorArray.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1064, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1064,0, ())

  def generate_wrapper(self):
    return CPPPackedColorArrayWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantPackedColorArray.__new__(ConstantPackedColorArray)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedColorArray'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())

from py4godot.wrappers.wrappers import CPPPackedVector4ArrayWrapper

class ConstantPackedVector4Array(PackedVector4Array):

  @staticmethod
  def new0():
    _class = ConstantPackedVector4Array.construct_without_init()
    _class._ptr = constructor(1065, 0, tuple([]))
    return _class
  @staticmethod
  def new1(from_:'PackedVector4Array' ):
    assert(not from_ is None)
    assert isinstance(from_, PackedVector4Array), 'from_ must be PackedVector4Array'

    _class = ConstantPackedVector4Array.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1065, 1, tuple([from_._ptr]))
    return _class
  @staticmethod
  def new2(from_:'Array' ):
    assert(not from_ is None)
    assert isinstance(from_, Array), 'from_ must be Array'

    _class = ConstantPackedVector4Array.construct_without_init()


    _class.__from___ = from_
    _class._ptr = constructor(1065, 2, tuple([from_._ptr]))
    return _class

  def __init__(self):
    self.shouldBeDeleted = True
    self._ptr =  constructor(1065,0, ())

  def generate_wrapper(self):
    return CPPPackedVector4ArrayWrapper()
  @staticmethod
  def construct_without_init():
    cls = ConstantPackedVector4Array.__new__(ConstantPackedVector4Array)
    cls.shouldBeDeleted = True
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PackedVector4Array'

  def __del__(self):
    if hasattr( self, 'shouldBeDeleted') and self.shouldBeDeleted:
      self._ptr.call_with_return(23, ())

core_classes = {String,Dictionary,PackedVector3Array,Rect2i,PackedVector2Array,Vector2,Vector3i,Plane,PackedFloat64Array,PackedColorArray,Color,Vector4i,PackedInt32Array,PackedVector4Array,StringName,PackedByteArray,Projection,Transform2D,Callable,AABB,Vector2i,NodePath,RID,PackedFloat32Array,Rect2,Array,Transform3D,Signal,Quaternion,PackedInt64Array,PackedStringArray,Vector3,Basis,Vector4,}
