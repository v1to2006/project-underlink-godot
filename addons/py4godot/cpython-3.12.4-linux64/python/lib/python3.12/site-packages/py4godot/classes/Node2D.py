# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Node as py4godot_node 
import py4godot.classes.CanvasItem as py4godot_canvasitem 
from py4godot.wrappers.wrappers import CPPNode2DWrapper


class Node2D(py4godot_canvasitem.CanvasItem):
  r'''
		A 2D game object, with a transform (position, rotation, and scale). All 2D nodes, including physics objects and sprites, inherit from Node2D. Use Node2D as a parent node to move, scale and rotate children in a 2D project. Also gives control of the node's render order.
		**Note:** Since both `Node2D` and `Control` inherit from `CanvasItem`, they share several concepts from the class such as the `CanvasItem.z_index` and `CanvasItem.visible` properties.
	'''

  @staticmethod
  def constructor():
    class_ = Node2D.construct_without_init()
    class_._ptr = constructor(515,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Node2D.construct_without_init()
    class_._ptr = constructor(515,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPNode2DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(515,0, ())


  def generate_wrapper(self):
    return CPPNode2DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Node2D.__new__(Node2D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Node2D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Node2D.construct_without_init()
    cls._ptr = CPPNode2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Node2D.construct_without_init()
    cls._ptr = CPPNode2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def position(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_position()
    return _ret
  @position.setter
  def position(self,  value:'Vector2'):
    self.set_position(value)
  @property
  def rotation(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_rotation()
    return _ret
  @rotation.setter
  def rotation(self,  value:'float'):
    self.set_rotation(value)
  @property
  def rotation_degrees(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_rotation_degrees()
    return _ret
  @rotation_degrees.setter
  def rotation_degrees(self,  value:'float'):
    self.set_rotation_degrees(value)
  @property
  def scale(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_scale()
    return _ret
  @scale.setter
  def scale(self,  value:'Vector2'):
    self.set_scale(value)
  @property
  def skew(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_skew()
    return _ret
  @skew.setter
  def skew(self,  value:'float'):
    self.set_skew(value)
  @property
  def transform(self) -> typing.Union['Transform2D']:
    r''''''
    _ret = self. get_transform()
    return _ret
  @transform.setter
  def transform(self,  value:'Transform2D'):
    self.set_transform(value)
  @property
  def global_position(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_global_position()
    return _ret
  @global_position.setter
  def global_position(self,  value:'Vector2'):
    self.set_global_position(value)
  @property
  def global_rotation(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_global_rotation()
    return _ret
  @global_rotation.setter
  def global_rotation(self,  value:'float'):
    self.set_global_rotation(value)
  @property
  def global_rotation_degrees(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_global_rotation_degrees()
    return _ret
  @global_rotation_degrees.setter
  def global_rotation_degrees(self,  value:'float'):
    self.set_global_rotation_degrees(value)
  @property
  def global_scale(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_global_scale()
    return _ret
  @global_scale.setter
  def global_scale(self,  value:'Vector2'):
    self.set_global_scale(value)
  @property
  def global_skew(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_global_skew()
    return _ret
  @global_skew.setter
  def global_skew(self,  value:'float'):
    self.set_global_skew(value)
  @property
  def global_transform(self) -> typing.Union['Transform2D']:
    r''''''
    _ret = self. get_global_transform()
    return _ret
  @global_transform.setter
  def global_transform(self,  value:'Transform2D'):
    self.set_global_transform(value)
  @functools.native_method
  def set_position(self, position:'Vector2'   ) -> None:
    r''''''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'


    self.py__position = position






    self._ptr.call_with_return(270,tuple([position._ptr]))

  @functools.native_method
  def set_rotation(self, radians:'float'   ) -> None:
    r''''''

    assert isinstance(radians, (int, float)), 'radians must be int or float'


    self.py__rotation = radians






    self._ptr.call_with_return(271,tuple([radians]))

  @functools.native_method
  def set_rotation_degrees(self, degrees:'float'   ) -> None:
    r''''''

    assert isinstance(degrees, (int, float)), 'degrees must be int or float'


    self.py__rotation_degrees = degrees






    self._ptr.call_with_return(272,tuple([degrees]))

  @functools.native_method
  def set_skew(self, radians:'float'   ) -> None:
    r''''''

    assert isinstance(radians, (int, float)), 'radians must be int or float'


    self.py__skew = radians






    self._ptr.call_with_return(273,tuple([radians]))

  @functools.native_method
  def set_scale(self, scale:'Vector2'   ) -> None:
    r''''''

    assert(not scale is None)
    assert isinstance(scale, Vector2), 'scale must be Vector2'


    self.py__scale = scale






    self._ptr.call_with_return(274,tuple([scale._ptr]))

  @functools.native_method
  def get_position(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(275,tuple([]))

    return _ret


  @functools.native_method
  def get_rotation(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(276,tuple([]))

    return _ret


  @functools.native_method
  def get_rotation_degrees(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(277,tuple([]))

    return _ret


  @functools.native_method
  def get_skew(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(278,tuple([]))

    return _ret


  @functools.native_method
  def get_scale(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(279,tuple([]))

    return _ret


  @functools.native_method
  def rotate(self, radians:'float'   ) -> None:
    r'''
				Applies a rotation to the node, in radians, starting from its current rotation. This is equivalent to `rotation += radians`.
			'''

    assert isinstance(radians, (int, float)), 'radians must be int or float'







    self._ptr.call_with_return(280,tuple([radians]))

  @functools.native_method
  def move_local_x(self, delta:'float'   , scaled:'bool' =False  ) -> None:
    r'''
				Applies a local translation on the node's X axis with the amount specified in `delta`. If `scaled` is `false`, normalizes the movement to occur independently of the node's `scale`.
			'''

    assert isinstance(delta, (int, float)), 'delta must be int or float'
    assert isinstance(scaled, bool), 'scaled must be bool'








    self._ptr.call_with_return(281,tuple([delta, scaled]))

  @functools.native_method
  def move_local_y(self, delta:'float'   , scaled:'bool' =False  ) -> None:
    r'''
				Applies a local translation on the node's Y axis with the amount specified in `delta`. If `scaled` is `false`, normalizes the movement to occur independently of the node's `scale`.
			'''

    assert isinstance(delta, (int, float)), 'delta must be int or float'
    assert isinstance(scaled, bool), 'scaled must be bool'








    self._ptr.call_with_return(282,tuple([delta, scaled]))

  @functools.native_method
  def translate(self, offset:'Vector2'   ) -> None:
    r'''
				Translates the node by the given `offset` in local coordinates. This is equivalent to `position += offset`.
			'''

    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'







    self._ptr.call_with_return(283,tuple([offset._ptr]))

  @functools.native_method
  def global_translate(self, offset:'Vector2'   ) -> None:
    r'''
				Adds the `offset` vector to the node's global position.
			'''

    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'







    self._ptr.call_with_return(284,tuple([offset._ptr]))

  @functools.native_method
  def apply_scale(self, ratio:'Vector2'   ) -> None:
    r'''
				Multiplies the current scale by the `ratio` vector.
			'''

    assert(not ratio is None)
    assert isinstance(ratio, Vector2), 'ratio must be Vector2'







    self._ptr.call_with_return(285,tuple([ratio._ptr]))

  @functools.native_method
  def set_global_position(self, position:'Vector2'   ) -> None:
    r''''''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'


    self.py__global_position = position






    self._ptr.call_with_return(286,tuple([position._ptr]))

  @functools.native_method
  def get_global_position(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(287,tuple([]))

    return _ret


  @functools.native_method
  def set_global_rotation(self, radians:'float'   ) -> None:
    r''''''

    assert isinstance(radians, (int, float)), 'radians must be int or float'


    self.py__global_rotation = radians






    self._ptr.call_with_return(288,tuple([radians]))

  @functools.native_method
  def set_global_rotation_degrees(self, degrees:'float'   ) -> None:
    r''''''

    assert isinstance(degrees, (int, float)), 'degrees must be int or float'


    self.py__global_rotation_degrees = degrees






    self._ptr.call_with_return(289,tuple([degrees]))

  @functools.native_method
  def get_global_rotation(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(290,tuple([]))

    return _ret


  @functools.native_method
  def get_global_rotation_degrees(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(291,tuple([]))

    return _ret


  @functools.native_method
  def set_global_skew(self, radians:'float'   ) -> None:
    r''''''

    assert isinstance(radians, (int, float)), 'radians must be int or float'


    self.py__global_skew = radians






    self._ptr.call_with_return(292,tuple([radians]))

  @functools.native_method
  def get_global_skew(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(293,tuple([]))

    return _ret


  @functools.native_method
  def set_global_scale(self, scale:'Vector2'   ) -> None:
    r''''''

    assert(not scale is None)
    assert isinstance(scale, Vector2), 'scale must be Vector2'


    self.py__global_scale = scale






    self._ptr.call_with_return(294,tuple([scale._ptr]))

  @functools.native_method
  def get_global_scale(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(295,tuple([]))

    return _ret


  @functools.native_method
  def set_transform(self, xform:'Transform2D'   ) -> None:
    r''''''

    assert(not xform is None)
    assert isinstance(xform, Transform2D), 'xform must be Transform2D'


    self.py__transform = xform






    self._ptr.call_with_return(296,tuple([xform._ptr]))

  @functools.native_method
  def set_global_transform(self, xform:'Transform2D'   ) -> None:
    r''''''

    assert(not xform is None)
    assert isinstance(xform, Transform2D), 'xform must be Transform2D'


    self.py__global_transform = xform






    self._ptr.call_with_return(297,tuple([xform._ptr]))

  @functools.native_method
  def look_at(self, point:'Vector2'   ) -> None:
    r'''
				Rotates the node so that its local +X axis points towards the `point`, which is expected to use global coordinates. This method is a combination of both `rotate` and `get_angle_to`.
				`point` should not be the same as the node's position, otherwise the node always looks to the right.
			'''

    assert(not point is None)
    assert isinstance(point, Vector2), 'point must be Vector2'







    self._ptr.call_with_return(298,tuple([point._ptr]))

  @functools.native_method
  def get_angle_to(self, point:'Vector2'   ) -> typing.Union[float]:
    r'''
				Returns the angle between the node and the `point` in radians. See also `look_at`.
				`url=https://raw.githubusercontent.com/godotengine/godot-docs/master/img/node2d_get_angle_to.png`Illustration of the returned angle.`/url`
			'''

    assert(not point is None)
    assert isinstance(point, Vector2), 'point must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(299,tuple([point._ptr]))
    return _ret


  @functools.native_method
  def to_local(self, global_point:'Vector2'   ) -> typing.Union['Vector2']:
    r'''
				Transforms the provided global position into a position in local coordinate space. The output will be local relative to the `Node2D` it is called on. e.g. It is appropriate for determining the positions of child nodes, but it is not appropriate for determining its own position relative to its parent.
			'''

    assert(not global_point is None)
    assert isinstance(global_point, Vector2), 'global_point must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(300,tuple([global_point._ptr]))
    return _ret


  @functools.native_method
  def to_global(self, local_point:'Vector2'   ) -> typing.Union['Vector2']:
    r'''
				Transforms the provided local position into a position in global coordinate space. The input is expected to be local relative to the `Node2D` it is called on. e.g. Applying this method to the positions of child nodes will correctly transform their positions into the global coordinate space, but applying it to a node's own position will give an incorrect result, as it will incorporate the node's own transformation into its global position.
			'''

    assert(not local_point is None)
    assert isinstance(local_point, Vector2), 'local_point must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(301,tuple([local_point._ptr]))
    return _ret


  @functools.native_method
  def get_relative_transform_to_parent(self, parent:'py4godot_node.Node'   ) -> typing.Union['Transform2D']:
    r'''
				Returns the `Transform2D` relative to this node's parent.
			'''

    assert(not parent is None)
    assert isinstance(parent, get_class('Node')), 'parent must be Node'







    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(302,tuple([parent._ptr]))
    return _ret



register_cast_function('Node2D', Node2D.cast)
register_class('Node2D', Node2D)
