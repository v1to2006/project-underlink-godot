# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Object as py4godot_object 
from py4godot.wrappers.wrappers import CPPUndoRedoWrapper

class MergeMode:
  MERGE_DISABLE = 0
  MERGE_ENDS = 1
  MERGE_ALL = 2


class UndoRedo(py4godot_object.Object):
  r'''
		UndoRedo works by registering methods and property changes inside "actions". You can create an action, then provide ways to do and undo this action using function calls and property changes, then commit the action.
		When an action is committed, all of the `do_*` methods will run. If the `undo` method is used, the `undo_*` methods will run. If the `redo` method is used, once again, all of the `do_*` methods will run.
		Here's an example on how to add an action:
		
		```gdscript
		var undo_redo = UndoRedo.new()

		func do_something():
			pass # Put your code here.

		func undo_something():
			pass # Put here the code that reverts what's done by "do_something()".

		func _on_my_button_pressed():
			var node = get_node("MyNode2D")
			undo_redo.create_action("Move the node")
			undo_redo.add_do_method(do_something)
			undo_redo.add_undo_method(undo_something)
			undo_redo.add_do_property(node, "position", Vector2(100, 100))
			undo_redo.add_undo_property(node, "position", node.position)
			undo_redo.commit_action()
		```
		
		
		Before calling any of the `add_(un)do_*` methods, you need to first call `create_action`. Afterwards you need to call `commit_action`.
		If you don't need to register a method, you can leave `add_do_method` and `add_undo_method` out; the same goes for properties. You can also register more than one method/property.
		If you are making an `EditorPlugin` and want to integrate into the editor's undo history, use `EditorUndoRedoManager` instead.
		If you are registering multiple properties/method which depend on one another, be aware that by default undo operation are called in the same order they have been added. Therefore instead of grouping do operation with their undo operations it is better to group do on one side and undo on the other as shown below.
		
		```gdscript
		undo_redo.create_action("Add object")

		# DO
		undo_redo.add_do_method(_create_object)
		undo_redo.add_do_method(_add_object_to_singleton)

		# UNDO
		undo_redo.add_undo_method(_remove_object_from_singleton)
		undo_redo.add_undo_method(_destroy_that_object)

		undo_redo.commit_action()
		```
		
		
	'''

  @staticmethod
  def constructor():
    class_ = UndoRedo.construct_without_init()
    class_._ptr = constructor(858,0, ())
    return class_
  @staticmethod
  def new():
    class_ = UndoRedo.construct_without_init()
    class_._ptr = constructor(858,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPUndoRedoWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(858,0, ())


  def generate_wrapper(self):
    return CPPUndoRedoWrapper()
  def init_signals(self):
    super().init_signals()
    version_changed_name = utils.py_string_to_string_name("version_changed")
    self.version_changed = signals.BuiltinSignal(self, version_changed_name)

  @staticmethod
  def construct_without_init():
    cls = UndoRedo.__new__(UndoRedo)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'UndoRedo'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = UndoRedo.construct_without_init()
    cls._ptr = CPPUndoRedoWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = UndoRedo.construct_without_init()
    cls._ptr = CPPUndoRedoWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def max_steps(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_steps()
    return _ret
  @max_steps.setter
  def max_steps(self,  value:'int'):
    self.set_max_steps(value)
  @functools.native_method
  def create_action(self, name:'str'   , merge_mode:'int'  =0, backward_undo_ops:'bool' =False  ) -> None:
    r'''
				Create a new action. After this is called, do all your calls to `add_do_method`, `add_undo_method`, `add_do_property`, and `add_undo_property`, then commit the action with `commit_action`.
				The way actions are merged is dictated by `merge_mode`.
				The way undo operation are ordered in actions is dictated by `backward_undo_ops`. When `backward_undo_ops` is `false` undo option are ordered in the same order they were added. Which means the first operation to be added will be the first to be undone.
			'''


    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert isinstance(merge_mode, (int, float)), 'merge_mode must be int or float'
    assert isinstance(backward_undo_ops, bool), 'backward_undo_ops must be bool'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)



    self._ptr.call_with_return(49,tuple([py_string_name._ptr, merge_mode, backward_undo_ops]))

  @functools.native_method
  def commit_action(self, execute:'bool' =True  ) -> None:
    r'''
				Commit the action. If `execute` is `true` (which it is by default), all "do" methods/properties are called/set when this function is called.
			'''

    assert isinstance(execute, bool), 'execute must be bool'







    self._ptr.call_with_return(50,tuple([execute]))

  @functools.native_method
  def is_committing_action(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the `UndoRedo` is currently committing the action, i.e. running its "do" method or property change (see `commit_action`).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(51,tuple([]))
    return _ret


  @functools.native_method
  def add_do_method(self, callable:'Callable'   ) -> None:
    r'''
				Register a `Callable` that will be called when the action is committed.
			'''

    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'







    self._ptr.call_with_return(52,tuple([callable._ptr]))

  @functools.native_method
  def add_undo_method(self, callable:'Callable'   ) -> None:
    r'''
				Register a `Callable` that will be called when the action is undone.
			'''

    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'







    self._ptr.call_with_return(53,tuple([callable._ptr]))

  @functools.native_method
  def add_do_property(self, object_:'py4godot_object.Object'   , property:'object'   , value:'object'   ) -> None:
    r'''
				Register a `property` that would change its value to `value` when the action is committed.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not property is None)
    assert isinstance(property, (str, StringName)), 'property must be str or StringName'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(property, (str, StringName)))
    py_stringname_property = property if isinstance(property, StringName) else c_utils.py_string_to_string_name(property)


    self._ptr.call_with_return(54,tuple([object_._ptr, py_stringname_property._ptr, value]))

  @functools.native_method
  def add_undo_property(self, object_:'py4godot_object.Object'   , property:'object'   , value:'object'   ) -> None:
    r'''
				Register a `property` that would change its value to `value` when the action is undone.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not property is None)
    assert isinstance(property, (str, StringName)), 'property must be str or StringName'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(property, (str, StringName)))
    py_stringname_property = property if isinstance(property, StringName) else c_utils.py_string_to_string_name(property)


    self._ptr.call_with_return(55,tuple([object_._ptr, py_stringname_property._ptr, value]))

  @functools.native_method
  def add_do_reference(self, object_:'py4godot_object.Object'   ) -> None:
    r'''
				Register a reference to an object that will be erased if the "do" history is deleted. This is useful for objects added by the "do" action and removed by the "undo" action.
				When the "do" history is deleted, if the object is a `RefCounted`, it will be unreferenced. Otherwise, it will be freed. Do not use for resources.
				```gdscript
				var node = Node2D.new()
				undo_redo.create_action("Add node")
				undo_redo.add_do_method(add_child.bind(node))
				undo_redo.add_do_reference(node)
				undo_redo.add_undo_method(remove_child.bind(node))
				undo_redo.commit_action()
				```
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'







    self._ptr.call_with_return(56,tuple([object_._ptr]))

  @functools.native_method
  def add_undo_reference(self, object_:'py4godot_object.Object'   ) -> None:
    r'''
				Register a reference to an object that will be erased if the "undo" history is deleted. This is useful for objects added by the "undo" action and removed by the "do" action.
				When the "undo" history is deleted, if the object is a `RefCounted`, it will be unreferenced. Otherwise, it will be freed. Do not use for resources.
				```gdscript
				var node = $Node2D
				undo_redo.create_action("Remove node")
				undo_redo.add_do_method(remove_child.bind(node))
				undo_redo.add_undo_method(add_child.bind(node))
				undo_redo.add_undo_reference(node)
				undo_redo.commit_action()
				```
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'







    self._ptr.call_with_return(57,tuple([object_._ptr]))

  @functools.native_method
  def start_force_keep_in_merge_ends(self) -> None:
    r'''
				Marks the next "do" and "undo" operations to be processed even if the action gets merged with another in the `constant MERGE_ENDS` mode. Return to normal operation using `end_force_keep_in_merge_ends`.
			'''




    self._ptr.call_with_return(58,tuple([]))

  @functools.native_method
  def end_force_keep_in_merge_ends(self) -> None:
    r'''
				Stops marking operations as to be processed even if the action gets merged with another in the `constant MERGE_ENDS` mode. See `start_force_keep_in_merge_ends`.
			'''




    self._ptr.call_with_return(59,tuple([]))

  @functools.native_method
  def get_history_count(self) -> typing.Union[int]:
    r'''
				Returns how many elements are in the history.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(60,tuple([]))
    return _ret


  @functools.native_method
  def get_current_action(self) -> typing.Union[int]:
    r'''
				Gets the index of the current action.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(61,tuple([]))
    return _ret


  @functools.native_method
  def get_action_name(self, id:'int'   ) -> typing.Union[str]:
    r'''
				Gets the action name from its index.
			'''

    assert isinstance(id, (int, float)), 'id must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([id]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def clear_history(self, increase_version:'bool' =True  ) -> None:
    r'''
				Clear the undo/redo history and associated references.
				Passing `false` to `increase_version` will prevent the version number from increasing when the history is cleared.
			'''

    assert isinstance(increase_version, bool), 'increase_version must be bool'







    self._ptr.call_with_return(63,tuple([increase_version]))

  @functools.native_method
  def get_current_action_name(self) -> typing.Union[str]:
    r'''
				Gets the name of the current action, equivalent to `get_action_name(get_current_action())`.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(64,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def has_undo(self) -> typing.Union[bool]:
    r'''
				Returns `true` if an "undo" action is available.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(65,tuple([]))
    return _ret


  @functools.native_method
  def has_redo(self) -> typing.Union[bool]:
    r'''
				Returns `true` if a "redo" action is available.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([]))
    return _ret


  @functools.native_method
  def get_version(self) -> typing.Union[int]:
    r'''
				Gets the version. Every time a new action is committed, the `UndoRedo`'s version number is increased automatically.
				This is useful mostly to check if something changed from a saved version.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([]))
    return _ret


  @functools.native_method
  def set_max_steps(self, max_steps:'int'   ) -> None:
    r''''''

    assert isinstance(max_steps, (int, float)), 'max_steps must be int or float'


    self.py__max_steps = max_steps






    self._ptr.call_with_return(68,tuple([max_steps]))

  @functools.native_method
  def get_max_steps(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(69,tuple([]))

    return _ret


  @functools.native_method
  def redo(self) -> typing.Union[bool]:
    r'''
				Redo the last action.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(70,tuple([]))
    return _ret


  @functools.native_method
  def undo(self) -> typing.Union[bool]:
    r'''
				Undo the last action.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(71,tuple([]))
    return _ret



register_cast_function('UndoRedo', UndoRedo.cast)
register_class('UndoRedo', UndoRedo)
