# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.NavigationPathQueryParameters2D as py4godot_navigationpathqueryparameters2d 
  import py4godot.classes.NavigationPathQueryResult2D as py4godot_navigationpathqueryresult2d 
import py4godot.classes.Node as py4godot_node 
from py4godot.wrappers.wrappers import CPPNavigationAgent2DWrapper


class NavigationAgent2D(py4godot_node.Node):
  r'''
		A 2D agent used to pathfind to a position while avoiding static and dynamic obstacles. The calculation can be used by the parent node to dynamically move it along the path. Requires navigation data to work correctly.
		Dynamic obstacles are avoided using RVO collision avoidance. Avoidance is computed before physics, so the pathfinding information can be used safely in the physics step.
		**Note:** After setting the `target_position` property, the `get_next_path_position` method must be used once every physics frame to update the internal path logic of the navigation agent. The vector position it returns should be used as the next movement position for the agent's parent node.
		**Note:** Several methods of this class, such as `get_next_path_position`, can trigger a new path calculation. Calling these in your callback to an agent's signal, such as `signal waypoint_reached`, can cause infinite recursion. It is recommended to call these methods in the physics step or, alternatively, delay their call until the end of the frame (see `Object.call_deferred` or `constant Object.CONNECT_DEFERRED`).
	'''

  @staticmethod
  def constructor():
    class_ = NavigationAgent2D.construct_without_init()
    class_._ptr = constructor(494,0, ())
    return class_
  @staticmethod
  def new():
    class_ = NavigationAgent2D.construct_without_init()
    class_._ptr = constructor(494,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPNavigationAgent2DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(494,0, ())


  def generate_wrapper(self):
    return CPPNavigationAgent2DWrapper()
  def init_signals(self):
    super().init_signals()
    path_changed_name = utils.py_string_to_string_name("path_changed")
    self.path_changed = signals.BuiltinSignal(self, path_changed_name)
    target_reached_name = utils.py_string_to_string_name("target_reached")
    self.target_reached = signals.BuiltinSignal(self, target_reached_name)
    waypoint_reached_name = utils.py_string_to_string_name("waypoint_reached")
    self.waypoint_reached = signals.BuiltinSignal(self, waypoint_reached_name)
    link_reached_name = utils.py_string_to_string_name("link_reached")
    self.link_reached = signals.BuiltinSignal(self, link_reached_name)
    navigation_finished_name = utils.py_string_to_string_name("navigation_finished")
    self.navigation_finished = signals.BuiltinSignal(self, navigation_finished_name)
    velocity_computed_name = utils.py_string_to_string_name("velocity_computed")
    self.velocity_computed = signals.BuiltinSignal(self, velocity_computed_name)

  @staticmethod
  def construct_without_init():
    cls = NavigationAgent2D.__new__(NavigationAgent2D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'NavigationAgent2D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = NavigationAgent2D.construct_without_init()
    cls._ptr = CPPNavigationAgent2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = NavigationAgent2D.construct_without_init()
    cls._ptr = CPPNavigationAgent2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def target_position(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_target_position()
    return _ret
  @target_position.setter
  def target_position(self,  value:'Vector2'):
    self.set_target_position(value)
  @property
  def path_desired_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_path_desired_distance()
    return _ret
  @path_desired_distance.setter
  def path_desired_distance(self,  value:'float'):
    self.set_path_desired_distance(value)
  @property
  def target_desired_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_target_desired_distance()
    return _ret
  @target_desired_distance.setter
  def target_desired_distance(self,  value:'float'):
    self.set_target_desired_distance(value)
  @property
  def path_max_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_path_max_distance()
    return _ret
  @path_max_distance.setter
  def path_max_distance(self,  value:'float'):
    self.set_path_max_distance(value)
  @property
  def navigation_layers(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_navigation_layers()
    return _ret
  @navigation_layers.setter
  def navigation_layers(self,  value:'int'):
    self.set_navigation_layers(value)
  @property
  def pathfinding_algorithm(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_pathfinding_algorithm()
    return _ret
  @pathfinding_algorithm.setter
  def pathfinding_algorithm(self,  value:'int'):
    self.set_pathfinding_algorithm(value)
  @property
  def path_postprocessing(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_path_postprocessing()
    return _ret
  @path_postprocessing.setter
  def path_postprocessing(self,  value:'int'):
    self.set_path_postprocessing(value)
  @property
  def path_metadata_flags(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_path_metadata_flags()
    return _ret
  @path_metadata_flags.setter
  def path_metadata_flags(self,  value:'int'):
    self.set_path_metadata_flags(value)
  @property
  def simplify_path(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_simplify_path()
    return _ret
  @simplify_path.setter
  def simplify_path(self,  value:'bool'):
    self.set_simplify_path(value)
  @property
  def simplify_epsilon(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_simplify_epsilon()
    return _ret
  @simplify_epsilon.setter
  def simplify_epsilon(self,  value:'float'):
    self.set_simplify_epsilon(value)
  @property
  def path_return_max_length(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_path_return_max_length()
    return _ret
  @path_return_max_length.setter
  def path_return_max_length(self,  value:'float'):
    self.set_path_return_max_length(value)
  @property
  def path_return_max_radius(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_path_return_max_radius()
    return _ret
  @path_return_max_radius.setter
  def path_return_max_radius(self,  value:'float'):
    self.set_path_return_max_radius(value)
  @property
  def path_search_max_polygons(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_path_search_max_polygons()
    return _ret
  @path_search_max_polygons.setter
  def path_search_max_polygons(self,  value:'int'):
    self.set_path_search_max_polygons(value)
  @property
  def path_search_max_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_path_search_max_distance()
    return _ret
  @path_search_max_distance.setter
  def path_search_max_distance(self,  value:'float'):
    self.set_path_search_max_distance(value)
  @property
  def avoidance_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_avoidance_enabled()
    return _ret
  @avoidance_enabled.setter
  def avoidance_enabled(self,  value:'bool'):
    self.set_avoidance_enabled(value)
  @property
  def velocity(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_velocity()
    return _ret
  @velocity.setter
  def velocity(self,  value:'Vector2'):
    self.set_velocity(value)
  @property
  def radius(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_radius()
    return _ret
  @radius.setter
  def radius(self,  value:'float'):
    self.set_radius(value)
  @property
  def neighbor_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_neighbor_distance()
    return _ret
  @neighbor_distance.setter
  def neighbor_distance(self,  value:'float'):
    self.set_neighbor_distance(value)
  @property
  def max_neighbors(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_neighbors()
    return _ret
  @max_neighbors.setter
  def max_neighbors(self,  value:'int'):
    self.set_max_neighbors(value)
  @property
  def time_horizon_agents(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_time_horizon_agents()
    return _ret
  @time_horizon_agents.setter
  def time_horizon_agents(self,  value:'float'):
    self.set_time_horizon_agents(value)
  @property
  def time_horizon_obstacles(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_time_horizon_obstacles()
    return _ret
  @time_horizon_obstacles.setter
  def time_horizon_obstacles(self,  value:'float'):
    self.set_time_horizon_obstacles(value)
  @property
  def max_speed(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_max_speed()
    return _ret
  @max_speed.setter
  def max_speed(self,  value:'float'):
    self.set_max_speed(value)
  @property
  def avoidance_layers(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_avoidance_layers()
    return _ret
  @avoidance_layers.setter
  def avoidance_layers(self,  value:'int'):
    self.set_avoidance_layers(value)
  @property
  def avoidance_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_avoidance_mask()
    return _ret
  @avoidance_mask.setter
  def avoidance_mask(self,  value:'int'):
    self.set_avoidance_mask(value)
  @property
  def avoidance_priority(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_avoidance_priority()
    return _ret
  @avoidance_priority.setter
  def avoidance_priority(self,  value:'float'):
    self.set_avoidance_priority(value)
  @property
  def debug_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_debug_enabled()
    return _ret
  @debug_enabled.setter
  def debug_enabled(self,  value:'bool'):
    self.set_debug_enabled(value)
  @property
  def debug_use_custom(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_debug_use_custom()
    return _ret
  @debug_use_custom.setter
  def debug_use_custom(self,  value:'bool'):
    self.set_debug_use_custom(value)
  @property
  def debug_path_custom_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_debug_path_custom_color()
    return _ret
  @debug_path_custom_color.setter
  def debug_path_custom_color(self,  value:'Color'):
    self.set_debug_path_custom_color(value)
  @property
  def debug_path_custom_point_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_debug_path_custom_point_size()
    return _ret
  @debug_path_custom_point_size.setter
  def debug_path_custom_point_size(self,  value:'float'):
    self.set_debug_path_custom_point_size(value)
  @property
  def debug_path_custom_line_width(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_debug_path_custom_line_width()
    return _ret
  @debug_path_custom_line_width.setter
  def debug_path_custom_line_width(self,  value:'float'):
    self.set_debug_path_custom_line_width(value)
  @functools.native_method
  def get_rid(self) -> typing.Union['RID']:
    r'''
				Returns the `RID` of this agent on the `NavigationServer2D`.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(180,tuple([]))
    return _ret


  @functools.native_method
  def set_avoidance_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__avoidance_enabled = enabled






    self._ptr.call_with_return(181,tuple([enabled]))

  @functools.native_method
  def get_avoidance_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(182,tuple([]))

    return _ret


  @functools.native_method
  def set_path_desired_distance(self, desired_distance:'float'   ) -> None:
    r''''''

    assert isinstance(desired_distance, (int, float)), 'desired_distance must be int or float'


    self.py__path_desired_distance = desired_distance






    self._ptr.call_with_return(183,tuple([desired_distance]))

  @functools.native_method
  def get_path_desired_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(184,tuple([]))

    return _ret


  @functools.native_method
  def set_target_desired_distance(self, desired_distance:'float'   ) -> None:
    r''''''

    assert isinstance(desired_distance, (int, float)), 'desired_distance must be int or float'


    self.py__target_desired_distance = desired_distance






    self._ptr.call_with_return(185,tuple([desired_distance]))

  @functools.native_method
  def get_target_desired_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(186,tuple([]))

    return _ret


  @functools.native_method
  def set_radius(self, radius:'float'   ) -> None:
    r''''''

    assert isinstance(radius, (int, float)), 'radius must be int or float'


    self.py__radius = radius






    self._ptr.call_with_return(187,tuple([radius]))

  @functools.native_method
  def get_radius(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(188,tuple([]))

    return _ret


  @functools.native_method
  def set_neighbor_distance(self, neighbor_distance:'float'   ) -> None:
    r''''''

    assert isinstance(neighbor_distance, (int, float)), 'neighbor_distance must be int or float'


    self.py__neighbor_distance = neighbor_distance






    self._ptr.call_with_return(189,tuple([neighbor_distance]))

  @functools.native_method
  def get_neighbor_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(190,tuple([]))

    return _ret


  @functools.native_method
  def set_max_neighbors(self, max_neighbors:'int'   ) -> None:
    r''''''

    assert isinstance(max_neighbors, (int, float)), 'max_neighbors must be int or float'


    self.py__max_neighbors = max_neighbors






    self._ptr.call_with_return(191,tuple([max_neighbors]))

  @functools.native_method
  def get_max_neighbors(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(192,tuple([]))

    return _ret


  @functools.native_method
  def set_time_horizon_agents(self, time_horizon:'float'   ) -> None:
    r''''''

    assert isinstance(time_horizon, (int, float)), 'time_horizon must be int or float'


    self.py__time_horizon_agents = time_horizon






    self._ptr.call_with_return(193,tuple([time_horizon]))

  @functools.native_method
  def get_time_horizon_agents(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(194,tuple([]))

    return _ret


  @functools.native_method
  def set_time_horizon_obstacles(self, time_horizon:'float'   ) -> None:
    r''''''

    assert isinstance(time_horizon, (int, float)), 'time_horizon must be int or float'


    self.py__time_horizon_obstacles = time_horizon






    self._ptr.call_with_return(195,tuple([time_horizon]))

  @functools.native_method
  def get_time_horizon_obstacles(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(196,tuple([]))

    return _ret


  @functools.native_method
  def set_max_speed(self, max_speed:'float'   ) -> None:
    r''''''

    assert isinstance(max_speed, (int, float)), 'max_speed must be int or float'


    self.py__max_speed = max_speed






    self._ptr.call_with_return(197,tuple([max_speed]))

  @functools.native_method
  def get_max_speed(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(198,tuple([]))

    return _ret


  @functools.native_method
  def set_path_max_distance(self, max_speed:'float'   ) -> None:
    r''''''

    assert isinstance(max_speed, (int, float)), 'max_speed must be int or float'


    self.py__path_max_distance = max_speed






    self._ptr.call_with_return(199,tuple([max_speed]))

  @functools.native_method
  def get_path_max_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(200,tuple([]))

    return _ret


  @functools.native_method
  def set_navigation_layers(self, navigation_layers:'int'   ) -> None:
    r''''''

    assert isinstance(navigation_layers, (int, float)), 'navigation_layers must be int or float'


    self.py__navigation_layers = navigation_layers






    self._ptr.call_with_return(201,tuple([navigation_layers]))

  @functools.native_method
  def get_navigation_layers(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(202,tuple([]))

    return _ret


  @functools.native_method
  def set_navigation_layer_value(self, layer_number:'int'   , value:'bool'   ) -> None:
    r'''
				Based on `value`, enables or disables the specified layer in the `navigation_layers` bitmask, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'








    self._ptr.call_with_return(203,tuple([layer_number, value]))

  @functools.native_method
  def get_navigation_layer_value(self, layer_number:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether or not the specified layer of the `navigation_layers` bitmask is enabled, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(204,tuple([layer_number]))
    return _ret


  @functools.native_method
  def set_pathfinding_algorithm(self, pathfinding_algorithm:'int'  ) -> None:
    r''''''

    assert isinstance(pathfinding_algorithm, (int, float)), 'pathfinding_algorithm must be int or float'


    self.py__pathfinding_algorithm = pathfinding_algorithm






    self._ptr.call_with_return(205,tuple([pathfinding_algorithm]))

  @functools.native_method
  def get_pathfinding_algorithm(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(206,tuple([]))

    return _ret


  @functools.native_method
  def set_path_postprocessing(self, path_postprocessing:'int'  ) -> None:
    r''''''

    assert isinstance(path_postprocessing, (int, float)), 'path_postprocessing must be int or float'


    self.py__path_postprocessing = path_postprocessing






    self._ptr.call_with_return(207,tuple([path_postprocessing]))

  @functools.native_method
  def get_path_postprocessing(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(208,tuple([]))

    return _ret


  @functools.native_method
  def set_path_metadata_flags(self, flags:'int'   ) -> None:
    r''''''

    assert isinstance(flags, (int, float)), 'flags must be int or float'


    self.py__path_metadata_flags = flags






    self._ptr.call_with_return(209,tuple([flags]))

  @functools.native_method
  def get_path_metadata_flags(self) -> typing.Union[int]:
    r''''''




    _ret
    _ret = self._ptr.call_with_return(210,tuple([]))

    return _ret


  @functools.native_method
  def set_navigation_map(self, navigation_map:'RID'   ) -> None:
    r'''
				Sets the `RID` of the navigation map this NavigationAgent node should use and also updates the `agent` on the NavigationServer.
			'''

    assert(not navigation_map is None)
    assert isinstance(navigation_map, RID), 'navigation_map must be RID'







    self._ptr.call_with_return(211,tuple([navigation_map._ptr]))

  @functools.native_method
  def get_navigation_map(self) -> typing.Union['RID']:
    r'''
				Returns the `RID` of the navigation map for this NavigationAgent node. This function returns always the map set on the NavigationAgent node and not the map of the abstract agent on the NavigationServer. If the agent map is changed directly with the NavigationServer API the NavigationAgent node will not be aware of the map change. Use `set_navigation_map` to change the navigation map for the NavigationAgent and also update the agent on the NavigationServer.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(212,tuple([]))
    return _ret


  @functools.native_method
  def set_target_position(self, position:'Vector2'   ) -> None:
    r''''''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'


    self.py__target_position = position






    self._ptr.call_with_return(213,tuple([position._ptr]))

  @functools.native_method
  def get_target_position(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(214,tuple([]))

    return _ret


  @functools.native_method
  def set_simplify_path(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__simplify_path = enabled






    self._ptr.call_with_return(215,tuple([enabled]))

  @functools.native_method
  def get_simplify_path(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(216,tuple([]))

    return _ret


  @functools.native_method
  def set_simplify_epsilon(self, epsilon:'float'   ) -> None:
    r''''''

    assert isinstance(epsilon, (int, float)), 'epsilon must be int or float'


    self.py__simplify_epsilon = epsilon






    self._ptr.call_with_return(217,tuple([epsilon]))

  @functools.native_method
  def get_simplify_epsilon(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(218,tuple([]))

    return _ret


  @functools.native_method
  def set_path_return_max_length(self, length:'float'   ) -> None:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'


    self.py__path_return_max_length = length






    self._ptr.call_with_return(219,tuple([length]))

  @functools.native_method
  def get_path_return_max_length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(220,tuple([]))

    return _ret


  @functools.native_method
  def set_path_return_max_radius(self, radius:'float'   ) -> None:
    r''''''

    assert isinstance(radius, (int, float)), 'radius must be int or float'


    self.py__path_return_max_radius = radius






    self._ptr.call_with_return(221,tuple([radius]))

  @functools.native_method
  def get_path_return_max_radius(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(222,tuple([]))

    return _ret


  @functools.native_method
  def set_path_search_max_polygons(self, max_polygons:'int'   ) -> None:
    r''''''

    assert isinstance(max_polygons, (int, float)), 'max_polygons must be int or float'


    self.py__path_search_max_polygons = max_polygons






    self._ptr.call_with_return(223,tuple([max_polygons]))

  @functools.native_method
  def get_path_search_max_polygons(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(224,tuple([]))

    return _ret


  @functools.native_method
  def set_path_search_max_distance(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__path_search_max_distance = distance






    self._ptr.call_with_return(225,tuple([distance]))

  @functools.native_method
  def get_path_search_max_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(226,tuple([]))

    return _ret


  @functools.native_method
  def get_path_length(self) -> typing.Union[float]:
    r'''
				Returns the length of the currently calculated path. The returned value is `0.0`, if the path is still calculating or no calculation has been requested yet.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(227,tuple([]))
    return _ret


  @functools.native_method
  def get_next_path_position(self) -> typing.Union['Vector2']:
    r'''
				Returns the next position in global coordinates that can be moved to, making sure that there are no static objects in the way. If the agent does not have a navigation path, it will return the position of the agent's parent. The use of this function once every physics frame is required to update the internal path logic of the NavigationAgent.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(228,tuple([]))
    return _ret


  @functools.native_method
  def set_velocity_forced(self, velocity:'Vector2'   ) -> None:
    r'''
				Replaces the internal velocity in the collision avoidance simulation with `velocity`. When an agent is teleported to a new position this function should be used in the same frame. If called frequently this function can get agents stuck.
			'''

    assert(not velocity is None)
    assert isinstance(velocity, Vector2), 'velocity must be Vector2'







    self._ptr.call_with_return(229,tuple([velocity._ptr]))

  @functools.native_method
  def set_velocity(self, velocity:'Vector2'   ) -> None:
    r''''''

    assert(not velocity is None)
    assert isinstance(velocity, Vector2), 'velocity must be Vector2'


    self.py__velocity = velocity






    self._ptr.call_with_return(230,tuple([velocity._ptr]))

  @functools.native_method
  def get_velocity(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(231,tuple([]))

    return _ret


  @functools.native_method
  def distance_to_target(self) -> typing.Union[float]:
    r'''
				Returns the distance to the target position, using the agent's global position. The user must set `target_position` in order for this to be accurate.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(232,tuple([]))
    return _ret


  @functools.native_method
  def get_current_navigation_result(self) -> typing.Union['py4godot_navigationpathqueryresult2d.NavigationPathQueryResult2D']:
    r'''
				Returns the path query result for the path the agent is currently following.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: NavigationPathQueryResult2D
    _ret._ptr = self._ptr.call_with_return(233,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_current_navigation_path(self) -> typing.Union['PackedVector2Array']:
    r'''
				Returns this agent's current path from start to finish in global coordinates. The path only updates when the target position is changed or the agent requires a repath. The path array is not intended to be used in direct path movement as the agent has its own internal path logic that would get corrupted by changing the path array manually. Use the intended `get_next_path_position` once every physics frame to receive the next path point for the agents movement as this function also updates the internal path logic.
			'''




    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(234,tuple([]))
    return _ret


  @functools.native_method
  def get_current_navigation_path_index(self) -> typing.Union[int]:
    r'''
				Returns which index the agent is currently on in the navigation path's `PackedVector2Array`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(235,tuple([]))
    return _ret


  @functools.native_method
  def is_target_reached(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the agent reached the target, i.e. the agent moved within `target_desired_distance` of the `target_position`. It may not always be possible to reach the target but it should always be possible to reach the final position. See `get_final_position`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(236,tuple([]))
    return _ret


  @functools.native_method
  def is_target_reachable(self) -> typing.Union[bool]:
    r'''
				Returns `true` if `get_final_position` is within `target_desired_distance` of the `target_position`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(237,tuple([]))
    return _ret


  @functools.native_method
  def is_navigation_finished(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the agent's navigation has finished. If the target is reachable, navigation ends when the target is reached. If the target is unreachable, navigation ends when the last waypoint of the path is reached.
				**Note:** While `true` prefer to stop calling update functions like `get_next_path_position`. This avoids jittering the standing agent due to calling repeated path updates.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(238,tuple([]))
    return _ret


  @functools.native_method
  def get_final_position(self) -> typing.Union['Vector2']:
    r'''
				Returns the reachable final position of the current navigation path in global coordinates. This position can change if the agent needs to update the navigation path which makes the agent emit the `signal path_changed` signal.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(239,tuple([]))
    return _ret


  @functools.native_method
  def set_avoidance_layers(self, layers:'int'   ) -> None:
    r''''''

    assert isinstance(layers, (int, float)), 'layers must be int or float'


    self.py__avoidance_layers = layers






    self._ptr.call_with_return(240,tuple([layers]))

  @functools.native_method
  def get_avoidance_layers(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(241,tuple([]))

    return _ret


  @functools.native_method
  def set_avoidance_mask(self, mask:'int'   ) -> None:
    r''''''

    assert isinstance(mask, (int, float)), 'mask must be int or float'


    self.py__avoidance_mask = mask






    self._ptr.call_with_return(242,tuple([mask]))

  @functools.native_method
  def get_avoidance_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(243,tuple([]))

    return _ret


  @functools.native_method
  def set_avoidance_layer_value(self, layer_number:'int'   , value:'bool'   ) -> None:
    r'''
				Based on `value`, enables or disables the specified layer in the `avoidance_layers` bitmask, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'








    self._ptr.call_with_return(244,tuple([layer_number, value]))

  @functools.native_method
  def get_avoidance_layer_value(self, layer_number:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether or not the specified layer of the `avoidance_layers` bitmask is enabled, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(245,tuple([layer_number]))
    return _ret


  @functools.native_method
  def set_avoidance_mask_value(self, mask_number:'int'   , value:'bool'   ) -> None:
    r'''
				Based on `value`, enables or disables the specified mask in the `avoidance_mask` bitmask, given a `mask_number` between 1 and 32.
			'''

    assert isinstance(mask_number, (int, float)), 'mask_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'








    self._ptr.call_with_return(246,tuple([mask_number, value]))

  @functools.native_method
  def get_avoidance_mask_value(self, mask_number:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether or not the specified mask of the `avoidance_mask` bitmask is enabled, given a `mask_number` between 1 and 32.
			'''

    assert isinstance(mask_number, (int, float)), 'mask_number must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(247,tuple([mask_number]))
    return _ret


  @functools.native_method
  def set_avoidance_priority(self, priority:'float'   ) -> None:
    r''''''

    assert isinstance(priority, (int, float)), 'priority must be int or float'


    self.py__avoidance_priority = priority






    self._ptr.call_with_return(248,tuple([priority]))

  @functools.native_method
  def get_avoidance_priority(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(249,tuple([]))

    return _ret


  @functools.native_method
  def set_debug_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__debug_enabled = enabled






    self._ptr.call_with_return(250,tuple([enabled]))

  @functools.native_method
  def get_debug_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(251,tuple([]))

    return _ret


  @functools.native_method
  def set_debug_use_custom(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__debug_use_custom = enabled






    self._ptr.call_with_return(252,tuple([enabled]))

  @functools.native_method
  def get_debug_use_custom(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(253,tuple([]))

    return _ret


  @functools.native_method
  def set_debug_path_custom_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__debug_path_custom_color = color






    self._ptr.call_with_return(254,tuple([color._ptr]))

  @functools.native_method
  def get_debug_path_custom_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(255,tuple([]))

    return _ret


  @functools.native_method
  def set_debug_path_custom_point_size(self, point_size:'float'   ) -> None:
    r''''''

    assert isinstance(point_size, (int, float)), 'point_size must be int or float'


    self.py__debug_path_custom_point_size = point_size






    self._ptr.call_with_return(256,tuple([point_size]))

  @functools.native_method
  def get_debug_path_custom_point_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(257,tuple([]))

    return _ret


  @functools.native_method
  def set_debug_path_custom_line_width(self, line_width:'float'   ) -> None:
    r''''''

    assert isinstance(line_width, (int, float)), 'line_width must be int or float'


    self.py__debug_path_custom_line_width = line_width






    self._ptr.call_with_return(258,tuple([line_width]))

  @functools.native_method
  def get_debug_path_custom_line_width(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(259,tuple([]))

    return _ret



register_cast_function('NavigationAgent2D', NavigationAgent2D.cast)
register_class('NavigationAgent2D', NavigationAgent2D)
