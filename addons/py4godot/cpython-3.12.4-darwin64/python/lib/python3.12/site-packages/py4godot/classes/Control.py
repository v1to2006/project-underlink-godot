# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.StreamPeerBuffer as py4godot_streampeerbuffer 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.ResourceImporterImageFont as py4godot_resourceimporterimagefont 
  import py4godot.classes.VisualShaderNodeParameterRef as py4godot_visualshadernodeparameterref 
  import py4godot.classes.Tree as py4godot_tree 
  import py4godot.classes.AudioEffectFilter as py4godot_audioeffectfilter 
  import py4godot.classes.AnimationNode as py4godot_animationnode 
  import py4godot.classes.OpenXRFutureResult as py4godot_openxrfutureresult 
  import py4godot.classes.WorldEnvironment as py4godot_worldenvironment 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.SpriteBase3D as py4godot_spritebase3d 
  import py4godot.classes.ColorPalette as py4godot_colorpalette 
  import py4godot.classes.AnimationMixer as py4godot_animationmixer 
  import py4godot.classes.KinematicCollision2D as py4godot_kinematiccollision2d 
  import py4godot.classes.Thread as py4godot_thread 
  import py4godot.classes.ORMMaterial3D as py4godot_ormmaterial3d 
  import py4godot.classes.OpenXRCompositionLayer as py4godot_openxrcompositionlayer 
  import py4godot.classes.OpenXRAPIExtension as py4godot_openxrapiextension 
  import py4godot.classes.StyleBoxLine as py4godot_styleboxline 
  import py4godot.classes.VisualShaderNodeParticleEmitter as py4godot_visualshadernodeparticleemitter 
  import py4godot.classes.CollisionObject3D as py4godot_collisionobject3d 
  import py4godot.classes.ParallaxBackground as py4godot_parallaxbackground 
  import py4godot.classes.RemoteTransform3D as py4godot_remotetransform3d 
  import py4godot.classes.Mesh as py4godot_mesh 
  import py4godot.classes.EditorExportPlatformIOS as py4godot_editorexportplatformios 
  import py4godot.classes.GPUParticles2D as py4godot_gpuparticles2d 
  import py4godot.classes.EditorNode3DGizmoPlugin as py4godot_editornode3dgizmoplugin 
  import py4godot.classes.ResourceImporterScene as py4godot_resourceimporterscene 
  import py4godot.classes.EditorExportPlatformExtension as py4godot_editorexportplatformextension 
  import py4godot.classes.FogMaterial as py4godot_fogmaterial 
  import py4godot.classes.Noise as py4godot_noise 
  import py4godot.classes.StaticBody2D as py4godot_staticbody2d 
  import py4godot.classes.OS as py4godot_os 
  import py4godot.classes.TriangleMesh as py4godot_trianglemesh 
  import py4godot.classes.AudioStreamPlaybackResampled as py4godot_audiostreamplaybackresampled 
  import py4godot.classes.ScriptExtension as py4godot_scriptextension 
  import py4godot.classes.VisualShaderNodeIntConstant as py4godot_visualshadernodeintconstant 
  import py4godot.classes.PinJoint3D as py4godot_pinjoint3d 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.PropertyTweener as py4godot_propertytweener 
  import py4godot.classes.CompressedTexture2DArray as py4godot_compressedtexture2darray 
  import py4godot.classes.ResourceImporterTextureAtlas as py4godot_resourceimportertextureatlas 
  import py4godot.classes.AudioStreamPlayer2D as py4godot_audiostreamplayer2d 
  import py4godot.classes.Curve3D as py4godot_curve3d 
  import py4godot.classes.GLTFDocumentExtensionConvertImporterMesh as py4godot_gltfdocumentextensionconvertimportermesh 
  import py4godot.classes.EditorNode3DGizmo as py4godot_editornode3dgizmo 
  import py4godot.classes.CSGMesh3D as py4godot_csgmesh3d 
  import py4godot.classes.Light2D as py4godot_light2d 
  import py4godot.classes.OpenXRCompositionLayerCylinder as py4godot_openxrcompositionlayercylinder 
  import py4godot.classes.SurfaceTool as py4godot_surfacetool 
  import py4godot.classes.RenderSceneDataRD as py4godot_renderscenedatard 
  import py4godot.classes.VisualShaderNodeSwitch as py4godot_visualshadernodeswitch 
  import py4godot.classes.SubtweenTweener as py4godot_subtweentweener 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.SkeletonModification2DStackHolder as py4godot_skeletonmodification2dstackholder 
  import py4godot.classes.RenderDataExtension as py4godot_renderdataextension 
  import py4godot.classes.AudioStreamWAV as py4godot_audiostreamwav 
  import py4godot.classes.AudioEffectSpectrumAnalyzer as py4godot_audioeffectspectrumanalyzer 
  import py4godot.classes.Texture as py4godot_texture 
  import py4godot.classes.AudioEffectChorus as py4godot_audioeffectchorus 
  import py4godot.classes.AnimatableBody2D as py4godot_animatablebody2d 
  import py4godot.classes.Generic6DOFJoint3D as py4godot_generic6dofjoint3d 
  import py4godot.classes.PhysicsDirectBodyState2D as py4godot_physicsdirectbodystate2d 
  import py4godot.classes.RenderingDevice as py4godot_renderingdevice 
  import py4godot.classes.SkeletonModification2D as py4godot_skeletonmodification2d 
  import py4godot.classes.XROrigin3D as py4godot_xrorigin3d 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.AudioListener3D as py4godot_audiolistener3d 
  import py4godot.classes.IntervalTweener as py4godot_intervaltweener 
  import py4godot.classes.Camera3D as py4godot_camera3d 
  import py4godot.classes.AudioEffectDelay as py4godot_audioeffectdelay 
  import py4godot.classes.OpenXRAnalogThresholdModifier as py4godot_openxranalogthresholdmodifier 
  import py4godot.classes.EditorSceneFormatImporterGLTF as py4godot_editorsceneformatimportergltf 
  import py4godot.classes.VisualShaderNodeTextureSDF as py4godot_visualshadernodetexturesdf 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.GridMap as py4godot_gridmap 
  import py4godot.classes.VisualShaderNodeParticleConeVelocity as py4godot_visualshadernodeparticleconevelocity 
  import py4godot.classes.RayCast2D as py4godot_raycast2d 
  import py4godot.classes.XRHandTracker as py4godot_xrhandtracker 
  import py4godot.classes.RDTextureView as py4godot_rdtextureview 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.X509Certificate as py4godot_x509certificate 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.LightmapGIData as py4godot_lightmapgidata 
  import py4godot.classes.HMACContext as py4godot_hmaccontext 
  import py4godot.classes.ScriptCreateDialog as py4godot_scriptcreatedialog 
  import py4godot.classes.SpringBoneCollisionSphere3D as py4godot_springbonecollisionsphere3d 
  import py4godot.classes.PlaceholderCubemapArray as py4godot_placeholdercubemaparray 
  import py4godot.classes.Area2D as py4godot_area2d 
  import py4godot.classes.NavigationMeshGenerator as py4godot_navigationmeshgenerator 
  import py4godot.classes.SpriteFrames as py4godot_spriteframes 
  import py4godot.classes.AudioEffectLimiter as py4godot_audioeffectlimiter 
  import py4godot.classes.PlaceholderMaterial as py4godot_placeholdermaterial 
  import py4godot.classes.HeightMapShape3D as py4godot_heightmapshape3d 
  import py4godot.classes.FBXDocument as py4godot_fbxdocument 
  import py4godot.classes.VisualShaderNodeTexture3DParameter as py4godot_visualshadernodetexture3dparameter 
  import py4godot.classes.AnimationNodeTimeSeek as py4godot_animationnodetimeseek 
  import py4godot.classes.Polygon2D as py4godot_polygon2d 
  import py4godot.classes.OccluderInstance3D as py4godot_occluderinstance3d 
  import py4godot.classes.GLTFMesh as py4godot_gltfmesh 
  import py4godot.classes.OpenXRHapticBase as py4godot_openxrhapticbase 
  import py4godot.classes.WorldBoundaryShape3D as py4godot_worldboundaryshape3d 
  import py4godot.classes.ResourceUID as py4godot_resourceuid 
  import py4godot.classes.CapsuleMesh as py4godot_capsulemesh 
  import py4godot.classes.RDShaderSPIRV as py4godot_rdshaderspirv 
  import py4godot.classes.CanvasItemMaterial as py4godot_canvasitemmaterial 
  import py4godot.classes.PhysicsServer3D as py4godot_physicsserver3d 
  import py4godot.classes.PhysicsDirectBodyState3D as py4godot_physicsdirectbodystate3d 
  import py4godot.classes.ImmediateMesh as py4godot_immediatemesh 
  import py4godot.classes.PolygonPathFinder as py4godot_polygonpathfinder 
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.CharacterBody3D as py4godot_characterbody3d 
  import py4godot.classes.AudioServer as py4godot_audioserver 
  import py4godot.classes.CanvasGroup as py4godot_canvasgroup 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.PlaneMesh as py4godot_planemesh 
  import py4godot.classes.RectangleShape2D as py4godot_rectangleshape2d 
  import py4godot.classes.TLSOptions as py4godot_tlsoptions 
  import py4godot.classes.LookAtModifier3D as py4godot_lookatmodifier3d 
  import py4godot.classes.ResourceImporterOBJ as py4godot_resourceimporterobj 
  import py4godot.classes.OfflineMultiplayerPeer as py4godot_offlinemultiplayerpeer 
  import py4godot.classes.GPUParticlesCollisionSphere3D as py4godot_gpuparticlescollisionsphere3d 
  import py4godot.classes.VisibleOnScreenNotifier3D as py4godot_visibleonscreennotifier3d 
  import py4godot.classes.DirAccess as py4godot_diraccess 
  import py4godot.classes.Viewport as py4godot_viewport 
  import py4godot.classes.SpotLight3D as py4godot_spotlight3d 
  import py4godot.classes.VisualShaderNodeScreenUVToSDF as py4godot_visualshadernodescreenuvtosdf 
  import py4godot.classes.VisualShaderNodeGlobalExpression as py4godot_visualshadernodeglobalexpression 
  import py4godot.classes.TCPServer as py4godot_tcpserver 
  import py4godot.classes.TextLine as py4godot_textline 
  import py4godot.classes.VisualShaderNodeProximityFade as py4godot_visualshadernodeproximityfade 
  import py4godot.classes.VisualShaderNodeTexture2DParameter as py4godot_visualshadernodetexture2dparameter 
  import py4godot.classes.SpringBoneCollisionCapsule3D as py4godot_springbonecollisioncapsule3d 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.XRCamera3D as py4godot_xrcamera3d 
  import py4godot.classes.EditorScript as py4godot_editorscript 
  import py4godot.classes.NavigationRegion3D as py4godot_navigationregion3d 
  import py4godot.classes.AudioStreamPlayer3D as py4godot_audiostreamplayer3d 
  import py4godot.classes.Shortcut as py4godot_shortcut 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.Path2D as py4godot_path2d 
  import py4godot.classes.EditorExportPlatformWeb as py4godot_editorexportplatformweb 
  import py4godot.classes.AudioEffectHighShelfFilter as py4godot_audioeffecthighshelffilter 
  import py4godot.classes.VisualShaderNodeVaryingSetter as py4godot_visualshadernodevaryingsetter 
  import py4godot.classes.StyleBoxFlat as py4godot_styleboxflat 
  import py4godot.classes.UPNP as py4godot_upnp 
  import py4godot.classes.VisualShaderNodeVectorBase as py4godot_visualshadernodevectorbase 
  import py4godot.classes.PhysicsDirectSpaceState2D as py4godot_physicsdirectspacestate2d 
  import py4godot.classes.ResourceSaver as py4godot_resourcesaver 
  import py4godot.classes.InputEventMouseButton as py4godot_inputeventmousebutton 
  import py4godot.classes.SphereOccluder3D as py4godot_sphereoccluder3d 
  import py4godot.classes.JNISingleton as py4godot_jnisingleton 
  import py4godot.classes.AudioBusLayout as py4godot_audiobuslayout 
  import py4godot.classes.AudioEffectPitchShift as py4godot_audioeffectpitchshift 
  import py4godot.classes.AnimationRootNode as py4godot_animationrootnode 
  import py4godot.classes.Lightmapper as py4godot_lightmapper 
  import py4godot.classes.VisualShaderNodeCubemapParameter as py4godot_visualshadernodecubemapparameter 
  import py4godot.classes.EditorInterface as py4godot_editorinterface 
  import py4godot.classes.Input as py4godot_input 
  import py4godot.classes.MeshLibrary as py4godot_meshlibrary 
  import py4godot.classes.ResourceImporter as py4godot_resourceimporter 
  import py4godot.classes.NavigationObstacle2D as py4godot_navigationobstacle2d 
  import py4godot.classes.ShaderInclude as py4godot_shaderinclude 
  import py4godot.classes.AnimationNodeSub2 as py4godot_animationnodesub2 
  import py4godot.classes.PhysicalSkyMaterial as py4godot_physicalskymaterial 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.AudioEffectEQ6 as py4godot_audioeffecteq6 
  import py4godot.classes.PacketPeerStream as py4godot_packetpeerstream 
  import py4godot.classes.WorldBoundaryShape2D as py4godot_worldboundaryshape2d 
  import py4godot.classes.TextureCubemapRD as py4godot_texturecubemaprd 
  import py4godot.classes.Texture3D as py4godot_texture3d 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.TextServerExtension as py4godot_textserverextension 
  import py4godot.classes.CapsuleShape2D as py4godot_capsuleshape2d 
  import py4godot.classes.ConvexPolygonShape3D as py4godot_convexpolygonshape3d 
  import py4godot.classes.SliderJoint3D as py4godot_sliderjoint3d 
  import py4godot.classes.AudioEffectEQ21 as py4godot_audioeffecteq21 
  import py4godot.classes.Node3DGizmo as py4godot_node3dgizmo 
  import py4godot.classes.JavaScriptBridge as py4godot_javascriptbridge 
  import py4godot.classes.OmniLight3D as py4godot_omnilight3d 
  import py4godot.classes.VisualShaderNodeVec2Constant as py4godot_visualshadernodevec2constant 
  import py4godot.classes.EditorResourcePreviewGenerator as py4godot_editorresourcepreviewgenerator 
  import py4godot.classes.Sprite2D as py4godot_sprite2d 
  import py4godot.classes.VisualShaderNodeReroute as py4godot_visualshadernodereroute 
  import py4godot.classes.CharFXTransform as py4godot_charfxtransform 
  import py4godot.classes.AnimationNodeTransition as py4godot_animationnodetransition 
  import py4godot.classes.Font as py4godot_font 
  import py4godot.classes.EditorInspectorPlugin as py4godot_editorinspectorplugin 
  import py4godot.classes.StyleBox as py4godot_stylebox 
  import py4godot.classes.CameraServer as py4godot_cameraserver 
  import py4godot.classes.ResourceImporterOggVorbis as py4godot_resourceimporteroggvorbis 
  import py4godot.classes.OpenXRExtensionWrapper as py4godot_openxrextensionwrapper 
  import py4godot.classes.AudioStreamPolyphonic as py4godot_audiostreampolyphonic 
  import py4godot.classes.CollisionShape2D as py4godot_collisionshape2d 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.EditorPaths as py4godot_editorpaths 
  import py4godot.classes.JavaClassWrapper as py4godot_javaclasswrapper 
  import py4godot.classes.VisualShaderNodeFloatConstant as py4godot_visualshadernodefloatconstant 
  import py4godot.classes.PacketPeer as py4godot_packetpeer 
  import py4godot.classes.SceneTreeTimer as py4godot_scenetreetimer 
  import py4godot.classes.TextParagraph as py4godot_textparagraph 
  import py4godot.classes.TileSetScenesCollectionSource as py4godot_tilesetscenescollectionsource 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.PlaceholderCubemap as py4godot_placeholdercubemap 
  import py4godot.classes.EditorExportPlatformVisionOS as py4godot_editorexportplatformvisionos 
  import py4godot.classes.ZIPPacker as py4godot_zippacker 
  import py4godot.classes.CollisionShape3D as py4godot_collisionshape3d 
  import py4godot.classes.GraphNode as py4godot_graphnode 
  import py4godot.classes.RDShaderFile as py4godot_rdshaderfile 
  import py4godot.classes.EditorCommandPalette as py4godot_editorcommandpalette 
  import py4godot.classes.AudioEffectEQ10 as py4godot_audioeffecteq10 
  import py4godot.classes.MainLoop as py4godot_mainloop 
  import py4godot.classes.VisualShaderNodeUIntFunc as py4godot_visualshadernodeuintfunc 
  import py4godot.classes.OpenXRHand as py4godot_openxrhand 
  import py4godot.classes.NavigationPathQueryParameters2D as py4godot_navigationpathqueryparameters2d 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.MeshDataTool as py4godot_meshdatatool 
  import py4godot.classes.PhysicsDirectSpaceState3D as py4godot_physicsdirectspacestate3d 
  import py4godot.classes.GPUParticlesAttractorVectorField3D as py4godot_gpuparticlesattractorvectorfield3d 
  import py4godot.classes.XRHandModifier3D as py4godot_xrhandmodifier3d 
  import py4godot.classes.AnimationNodeSync as py4godot_animationnodesync 
  import py4godot.classes.InputEventPanGesture as py4godot_inputeventpangesture 
  import py4godot.classes.FBXState as py4godot_fbxstate 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.ResourceImporterSVG as py4godot_resourceimportersvg 
  import py4godot.classes.VisualShaderNodeTransformDecompose as py4godot_visualshadernodetransformdecompose 
  import py4godot.classes.AudioStreamMicrophone as py4godot_audiostreammicrophone 
  import py4godot.classes.StandardMaterial3D as py4godot_standardmaterial3d 
  import py4godot.classes.RDPipelineMultisampleState as py4godot_rdpipelinemultisamplestate 
  import py4godot.classes.PhysicsDirectBodyState3DExtension as py4godot_physicsdirectbodystate3dextension 
  import py4godot.classes.GLTFPhysicsShape as py4godot_gltfphysicsshape 
  import py4godot.classes.MultiplayerSpawner as py4godot_multiplayerspawner 
  import py4godot.classes.NavigationAgent2D as py4godot_navigationagent2d 
  import py4godot.classes.RegEx as py4godot_regex 
  import py4godot.classes.FoldableContainer as py4godot_foldablecontainer 
  import py4godot.classes.ResourceFormatLoader as py4godot_resourceformatloader 
  import py4godot.classes.NavigationMeshSourceGeometryData2D as py4godot_navigationmeshsourcegeometrydata2d 
  import py4godot.classes.AnimationNodeStateMachineTransition as py4godot_animationnodestatemachinetransition 
  import py4godot.classes.MultiMeshInstance2D as py4godot_multimeshinstance2d 
  import py4godot.classes.GPUParticlesCollisionHeightField3D as py4godot_gpuparticlescollisionheightfield3d 
  import py4godot.classes.PhysicsRayQueryParameters2D as py4godot_physicsrayqueryparameters2d 
  import py4godot.classes.DirectionalLight3D as py4godot_directionallight3d 
  import py4godot.classes.Area3D as py4godot_area3d 
  import py4godot.classes.CylinderShape3D as py4godot_cylindershape3d 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.InputEventMagnifyGesture as py4godot_inputeventmagnifygesture 
  import py4godot.classes.EditorSelection as py4godot_editorselection 
  import py4godot.classes.Shape2D as py4godot_shape2d 
  import py4godot.classes.Camera2D as py4godot_camera2d 
  import py4godot.classes.AudioStreamPlayer as py4godot_audiostreamplayer 
  import py4godot.classes.ENetPacketPeer as py4godot_enetpacketpeer 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
  import py4godot.classes.GDExtensionManager as py4godot_gdextensionmanager 
  import py4godot.classes.VisualShaderNodeIntParameter as py4godot_visualshadernodeintparameter 
  import py4godot.classes.BoxShape3D as py4godot_boxshape3d 
  import py4godot.classes.Performance as py4godot_performance 
  import py4godot.classes.VisualShaderNodeRandomRange as py4godot_visualshadernoderandomrange 
  import py4godot.classes.EditorSceneFormatImporter as py4godot_editorsceneformatimporter 
  import py4godot.classes.AnimationNodeStateMachine as py4godot_animationnodestatemachine 
  import py4godot.classes.EditorExportPlatformPC as py4godot_editorexportplatformpc 
  import py4godot.classes.ImageFormatLoader as py4godot_imageformatloader 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.RichTextLabel as py4godot_richtextlabel 
  import py4godot.classes.VisualShaderNodeFrame as py4godot_visualshadernodeframe 
  import py4godot.classes.Marshalls as py4godot_marshalls 
  import py4godot.classes.LightmapProbe as py4godot_lightmapprobe 
  import py4godot.classes.VisualShaderNodeCompare as py4godot_visualshadernodecompare 
  import py4godot.classes.MultiplayerSynchronizer as py4godot_multiplayersynchronizer 
  import py4godot.classes.MeshInstance3D as py4godot_meshinstance3d 
  import py4godot.classes.VisualShaderNodeMix as py4godot_visualshadernodemix 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.AudioStreamSynchronized as py4godot_audiostreamsynchronized 
  import py4godot.classes.LightOccluder2D as py4godot_lightoccluder2d 
  import py4godot.classes.StreamPeerTLS as py4godot_streampeertls 
  import py4godot.classes.Script as py4godot_script 
  import py4godot.classes.Curve2D as py4godot_curve2d 
  import py4godot.classes.BoxMesh as py4godot_boxmesh 
  import py4godot.classes.PointMesh as py4godot_pointmesh 
  import py4godot.classes.AudioListener2D as py4godot_audiolistener2d 
  import py4godot.classes.SceneReplicationConfig as py4godot_scenereplicationconfig 
  import py4godot.classes.NavigationPathQueryParameters3D as py4godot_navigationpathqueryparameters3d 
  import py4godot.classes.VisualShaderNodeTransformConstant as py4godot_visualshadernodetransformconstant 
  import py4godot.classes.StyleBoxEmpty as py4godot_styleboxempty 
  import py4godot.classes.PacketPeerUDP as py4godot_packetpeerudp 
  import py4godot.classes.Container as py4godot_container 
  import py4godot.classes.VisualShaderNodeCustom as py4godot_visualshadernodecustom 
  import py4godot.classes.VisualShaderNodeTextureParameter as py4godot_visualshadernodetextureparameter 
  import py4godot.classes.GLTFBufferView as py4godot_gltfbufferview 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.PrimitiveMesh as py4godot_primitivemesh 
  import py4godot.classes.Theme as py4godot_theme 
  import py4godot.classes.CSGCylinder3D as py4godot_csgcylinder3d 
  import py4godot.classes.VisualShaderNodeFloatParameter as py4godot_visualshadernodefloatparameter 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.VisualShaderNodeParameter as py4godot_visualshadernodeparameter 
  import py4godot.classes.VisualShaderNodeVectorLen as py4godot_visualshadernodevectorlen 
  import py4godot.classes.EditorExportPlugin as py4godot_editorexportplugin 
  import py4godot.classes.RenderSceneBuffersExtension as py4godot_renderscenebuffersextension 
  import py4godot.classes.OpenXRCompositionLayerEquirect as py4godot_openxrcompositionlayerequirect 
  import py4godot.classes.AudioSamplePlayback as py4godot_audiosampleplayback 
  import py4godot.classes.AnimationNodeStateMachinePlayback as py4godot_animationnodestatemachineplayback 
  import py4godot.classes.VisualShaderNodeOutput as py4godot_visualshadernodeoutput 
  import py4godot.classes.EditorSceneFormatImporterUFBX as py4godot_editorsceneformatimporterufbx 
  import py4godot.classes.RetargetModifier3D as py4godot_retargetmodifier3d 
  import py4godot.classes.NativeMenu as py4godot_nativemenu 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.VideoStreamPlayback as py4godot_videostreamplayback 
  import py4godot.classes.GPUParticlesAttractorSphere3D as py4godot_gpuparticlesattractorsphere3d 
  import py4godot.classes.AudioEffectSpectrumAnalyzerInstance as py4godot_audioeffectspectrumanalyzerinstance 
  import py4godot.classes.RenderingServer as py4godot_renderingserver 
  import py4godot.classes.InputEventJoypadMotion as py4godot_inputeventjoypadmotion 
  import py4godot.classes.AudioEffectReverb as py4godot_audioeffectreverb 
  import py4godot.classes.Vector3iTypedArray as py4godot_vector3itypedarray 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.AimModifier3D as py4godot_aimmodifier3d 
  import py4godot.classes.XRController3D as py4godot_xrcontroller3d 
  import py4godot.classes.PhysicsTestMotionParameters2D as py4godot_physicstestmotionparameters2d 
  import py4godot.classes.PinJoint2D as py4godot_pinjoint2d 
  import py4godot.classes.VisualShaderNodeFaceForward as py4godot_visualshadernodefaceforward 
  import py4godot.classes.AudioEffect as py4godot_audioeffect 
  import py4godot.classes.ReflectionProbe as py4godot_reflectionprobe 
  import py4godot.classes.InputEvent as py4godot_inputevent 
  import py4godot.classes.XRAnchor3D as py4godot_xranchor3d 
  import py4godot.classes.HingeJoint3D as py4godot_hingejoint3d 
  import py4godot.classes.EditorSettings as py4godot_editorsettings 
  import py4godot.classes.VisualShaderNodeColorConstant as py4godot_visualshadernodecolorconstant 
  import py4godot.classes.GLTFState as py4godot_gltfstate 
  import py4godot.classes.CharacterBody2D as py4godot_characterbody2d 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.AudioEffectHighPassFilter as py4godot_audioeffecthighpassfilter 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.GPUParticlesAttractorBox3D as py4godot_gpuparticlesattractorbox3d 
  import py4godot.classes.Bone2D as py4godot_bone2d 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.VisualShaderNodeFloatOp as py4godot_visualshadernodefloatop 
  import py4godot.classes.ResourceImporterBitMap as py4godot_resourceimporterbitmap 
  import py4godot.classes.BoneConstraint3D as py4godot_boneconstraint3d 
  import py4godot.classes.VisualShaderNodeVec3Constant as py4godot_visualshadernodevec3constant 
  import py4godot.classes.RenderData as py4godot_renderdata 
  import py4godot.classes.VisibleOnScreenNotifier2D as py4godot_visibleonscreennotifier2d 
  import py4godot.classes.VoxelGI as py4godot_voxelgi 
  import py4godot.classes.InputEventGesture as py4godot_inputeventgesture 
  import py4godot.classes.EditorTranslationParserPlugin as py4godot_editortranslationparserplugin 
  import py4godot.classes.PolygonOccluder3D as py4godot_polygonoccluder3d 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.RDShaderSource as py4godot_rdshadersource 
  import py4godot.classes.InstancePlaceholder as py4godot_instanceplaceholder 
  import py4godot.classes.LightmapperRD as py4godot_lightmapperrd 
  import py4godot.classes.EditorScenePostImportPlugin as py4godot_editorscenepostimportplugin 
  import py4godot.classes.EditorContextMenuPlugin as py4godot_editorcontextmenuplugin 
  import py4godot.classes.VisualShaderNodeBillboard as py4godot_visualshadernodebillboard 
  import py4godot.classes.SeparationRayShape3D as py4godot_separationrayshape3d 
  import py4godot.classes.VisualShaderNodeTextureParameterTriplanar as py4godot_visualshadernodetextureparametertriplanar 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.ResourceImporterWAV as py4godot_resourceimporterwav 
  import py4godot.classes.PhysicsBody3D as py4godot_physicsbody3d 
  import py4godot.classes.OpenXRBindingModifier as py4godot_openxrbindingmodifier 
  import py4godot.classes.AnimationNodeAnimation as py4godot_animationnodeanimation 
  import py4godot.classes.OggPacketSequencePlayback as py4godot_oggpacketsequenceplayback 
  import py4godot.classes.VisualShaderNodeGroupBase as py4godot_visualshadernodegroupbase 
  import py4godot.classes.StaticBody3D as py4godot_staticbody3d 
  import py4godot.classes.PathFollow2D as py4godot_pathfollow2d 
  import py4godot.classes.BackBufferCopy as py4godot_backbuffercopy 
  import py4godot.classes.OpenXRInterface as py4godot_openxrinterface 
  import py4godot.classes.FramebufferCacheRD as py4godot_framebuffercacherd 
  import py4godot.classes.AnimationNodeBlend3 as py4godot_animationnodeblend3 
  import py4godot.classes.InputEventMouse as py4godot_inputeventmouse 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.VisualShaderNodeParticleBoxEmitter as py4godot_visualshadernodeparticleboxemitter 
  import py4godot.classes.PacketPeerExtension as py4godot_packetpeerextension 
  import py4godot.classes.CSGTorus3D as py4godot_csgtorus3d 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.OpenXRRenderModelExtension as py4godot_openxrrendermodelextension 
  import py4godot.classes.EditorFileDialog as py4godot_editorfiledialog 
  import py4godot.classes.EditorExportPlatform as py4godot_editorexportplatform 
  import py4godot.classes.CodeHighlighter as py4godot_codehighlighter 
  import py4godot.classes.VisualShaderNodeVec3Parameter as py4godot_visualshadernodevec3parameter 
  import py4godot.classes.RenderSceneBuffers as py4godot_renderscenebuffers 
  import py4godot.classes.ConcavePolygonShape2D as py4godot_concavepolygonshape2d 
  import py4godot.classes.OpenXRInteractionProfile as py4godot_openxrinteractionprofile 
  import py4godot.classes.OpenXRFutureExtension as py4godot_openxrfutureextension 
  import py4godot.classes.InputEventShortcut as py4godot_inputeventshortcut 
  import py4godot.classes.StatusIndicator as py4godot_statusindicator 
  import py4godot.classes.FastNoiseLite as py4godot_fastnoiselite 
  import py4godot.classes.CallbackTweener as py4godot_callbacktweener 
  import py4godot.classes.AStarGrid2D as py4godot_astargrid2d 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.TouchScreenButton as py4godot_touchscreenbutton 
  import py4godot.classes.VisualShaderNodeWorldPositionFromDepth as py4godot_visualshadernodeworldpositionfromdepth 
  import py4godot.classes.ResourceImporterLayeredTexture as py4godot_resourceimporterlayeredtexture 
  import py4godot.classes.VisualShaderNodeVaryingGetter as py4godot_visualshadernodevaryinggetter 
  import py4godot.classes.PopupPanel as py4godot_popuppanel 
  import py4godot.classes.AnimationNodeBlendTree as py4godot_animationnodeblendtree 
  import py4godot.classes.RDSamplerState as py4godot_rdsamplerstate 
  import py4godot.classes.AudioStreamRandomizer as py4godot_audiostreamrandomizer 
  import py4godot.classes.GridMapEditorPlugin as py4godot_gridmapeditorplugin 
  import py4godot.classes.MethodTweener as py4godot_methodtweener 
  import py4godot.classes.GDExtension as py4godot_gdextension 
  import py4godot.classes.PanoramaSkyMaterial as py4godot_panoramaskymaterial 
  import py4godot.classes.RDTextureFormat as py4godot_rdtextureformat 
  import py4godot.classes.DisplayServer as py4godot_displayserver 
  import py4godot.classes.CPUParticles3D as py4godot_cpuparticles3d 
  import py4godot.classes.Popup as py4godot_popup 
  import py4godot.classes.UndoRedo as py4godot_undoredo 
  import py4godot.classes.CompressedCubemapArray as py4godot_compressedcubemaparray 
  import py4godot.classes.NavigationServer2D as py4godot_navigationserver2d 
  import py4godot.classes.VisualShaderNodeComment as py4godot_visualshadernodecomment 
  import py4godot.classes.StreamPeerGZIP as py4godot_streampeergzip 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.ResourceImporterImage as py4godot_resourceimporterimage 
  import py4godot.classes.StreamPeerExtension as py4godot_streampeerextension 
  import py4godot.classes.MultiMeshInstance3D as py4godot_multimeshinstance3d 
  import py4godot.classes.AudioEffectCompressor as py4godot_audioeffectcompressor 
  import py4godot.classes.VisualShaderNodeIntOp as py4godot_visualshadernodeintop 
  import py4godot.classes.RDAttachmentFormat as py4godot_rdattachmentformat 
  import py4godot.classes.PackedScene as py4godot_packedscene 
  import py4godot.classes.AudioSample as py4godot_audiosample 
  import py4godot.classes.SpringArm3D as py4godot_springarm3d 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.WebXRInterface as py4godot_webxrinterface 
  import py4godot.classes.NodePathTypedArray as py4godot_nodepathtypedarray 
  import py4godot.classes.RigidBody3D as py4godot_rigidbody3d 
  import py4godot.classes.PhysicsPointQueryParameters2D as py4godot_physicspointqueryparameters2d 
  import py4godot.classes.EditorFileSystemImportFormatSupportQuery as py4godot_editorfilesystemimportformatsupportquery 
  import py4godot.classes.CollisionObject2D as py4godot_collisionobject2d 
  import py4godot.classes.Logger as py4godot_logger 
  import py4godot.classes.Sprite3D as py4godot_sprite3d 
  import py4godot.classes.SoftBody3D as py4godot_softbody3d 
  import py4godot.classes.EditorSyntaxHighlighter as py4godot_editorsyntaxhighlighter 
  import py4godot.classes.WorkerThreadPool as py4godot_workerthreadpool 
  import py4godot.classes.VisualShaderNodeRotationByAxis as py4godot_visualshadernoderotationbyaxis 
  import py4godot.classes.VisualShaderNodeVec2Parameter as py4godot_visualshadernodevec2parameter 
  import py4godot.classes.RefCounted as py4godot_refcounted 
  import py4godot.classes.PopupMenu as py4godot_popupmenu 
  import py4godot.classes.PhysicsShapeQueryParameters2D as py4godot_physicsshapequeryparameters2d 
  import py4godot.classes.AnimationNodeOneShot as py4godot_animationnodeoneshot 
  import py4godot.classes.ResourceImporterShaderFile as py4godot_resourceimportershaderfile 
  import py4godot.classes.SystemFont as py4godot_systemfont 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.UPNPDevice as py4godot_upnpdevice 
  import py4godot.classes.NavigationAgent3D as py4godot_navigationagent3d 
  import py4godot.classes.VisualShaderNodeSample3D as py4godot_visualshadernodesample3d 
  import py4godot.classes.Path3D as py4godot_path3d 
  import py4godot.classes.VisualShaderNodeBooleanParameter as py4godot_visualshadernodebooleanparameter 
  import py4godot.classes.GLTFAnimation as py4godot_gltfanimation 
  import py4godot.classes.EditorExportPreset as py4godot_editorexportpreset 
  import py4godot.classes.SkeletonProfileHumanoid as py4godot_skeletonprofilehumanoid 
  import py4godot.classes.OpenXRActionBindingModifier as py4godot_openxractionbindingmodifier 
  import py4godot.classes.ImageTexture3D as py4godot_imagetexture3d 
  import py4godot.classes.TabContainer as py4godot_tabcontainer 
  import py4godot.classes.DirectionalLight2D as py4godot_directionallight2d 
  import py4godot.classes.VehicleBody3D as py4godot_vehiclebody3d 
  import py4godot.classes.CSGShape3D as py4godot_csgshape3d 
  import py4godot.classes.VisualShaderNodeSmoothStep as py4godot_visualshadernodesmoothstep 
  import py4godot.classes.AudioEffectPhaser as py4godot_audioeffectphaser 
  import py4godot.classes.ProceduralSkyMaterial as py4godot_proceduralskymaterial 
  import py4godot.classes.TreeItem as py4godot_treeitem 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.VisualShaderNodeParticleOutput as py4godot_visualshadernodeparticleoutput 
  import py4godot.classes.AudioStreamPlaybackInteractive as py4godot_audiostreamplaybackinteractive 
  import py4godot.classes.AudioEffectHardLimiter as py4godot_audioeffecthardlimiter 
  import py4godot.classes.GDScriptSyntaxHighlighter as py4godot_gdscriptsyntaxhighlighter 
  import py4godot.classes.RemoteTransform2D as py4godot_remotetransform2d 
  import py4godot.classes.TileMap as py4godot_tilemap 
  import py4godot.classes.AudioEffectInstance as py4godot_audioeffectinstance 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.EditorExportPlatformMacOS as py4godot_editorexportplatformmacos 
  import py4godot.classes.TextEdit as py4godot_textedit 
  import py4godot.classes.SkeletonModifier3D as py4godot_skeletonmodifier3d 
  import py4godot.classes.AnimatedSprite3D as py4godot_animatedsprite3d 
  import py4godot.classes.Cubemap as py4godot_cubemap 
  import py4godot.classes.PhysicsServer2D as py4godot_physicsserver2d 
  import py4godot.classes.OpenXRActionMap as py4godot_openxractionmap 
  import py4godot.classes.OpenXRIPBindingModifier as py4godot_openxripbindingmodifier 
  import py4godot.classes.PhysicalBone3D as py4godot_physicalbone3d 
  import py4godot.classes.RDPipelineRasterizationState as py4godot_rdpipelinerasterizationstate 
  import py4godot.classes.EditorFileSystemDirectory as py4godot_editorfilesystemdirectory 
  import py4godot.classes.CSGSphere3D as py4godot_csgsphere3d 
  import py4godot.classes.RDFramebufferPass as py4godot_rdframebufferpass 
  import py4godot.classes.XRServer as py4godot_xrserver 
  import py4godot.classes.EncodedObjectAsID as py4godot_encodedobjectasid 
  import py4godot.classes.SpringBoneCollision3D as py4godot_springbonecollision3d 
  import py4godot.classes.OpenXRInteractionProfileMetadata as py4godot_openxrinteractionprofilemetadata 
  import py4godot.classes.VisualShader as py4godot_visualshader 
  import py4godot.classes.UDPServer as py4godot_udpserver 
  import py4godot.classes.Object as py4godot_object 
  import py4godot.classes.VideoStreamTheora as py4godot_videostreamtheora 
  import py4godot.classes.DampedSpringJoint2D as py4godot_dampedspringjoint2d 
  import py4godot.classes.Material as py4godot_material 
  import py4godot.classes.VisualShaderNodeParticleRandomness as py4godot_visualshadernodeparticlerandomness 
  import py4godot.classes.TextServerAdvanced as py4godot_textserveradvanced 
  import py4godot.classes.StreamPeer as py4godot_streampeer 
  import py4godot.classes.PhysicsTestMotionResult2D as py4godot_physicstestmotionresult2d 
  import py4godot.classes.GLTFCamera as py4godot_gltfcamera 
  import py4godot.classes.TextServerDummy as py4godot_textserverdummy 
  import py4godot.classes.Curve as py4godot_curve 
  import py4godot.classes.Expression as py4godot_expression 
  import py4godot.classes.SkeletonModificationStack2D as py4godot_skeletonmodificationstack2d 
  import py4godot.classes.VisualShaderNodeTransformVecMult as py4godot_visualshadernodetransformvecmult 
  import py4godot.classes.XRNode3D as py4godot_xrnode3d 
  import py4godot.classes.VisualShaderNodeLinearSceneDepth as py4godot_visualshadernodelinearscenedepth 
  import py4godot.classes.MovieWriter as py4godot_moviewriter 
  import py4godot.classes.RenderSceneBuffersConfiguration as py4godot_renderscenebuffersconfiguration 
  import py4godot.classes.VisualShaderNodeColorParameter as py4godot_visualshadernodecolorparameter 
  import py4godot.classes.AudioEffectBandPassFilter as py4godot_audioeffectbandpassfilter 
  import py4godot.classes.AudioEffectCapture as py4godot_audioeffectcapture 
  import py4godot.classes.ResourceImporterBMFont as py4godot_resourceimporterbmfont 
  import py4godot.classes.SceneMultiplayer as py4godot_scenemultiplayer 
  import py4godot.classes.JSON as py4godot_json 
  import py4godot.classes.RandomNumberGenerator as py4godot_randomnumbergenerator 
  import py4godot.classes.VisualShaderNodeFloatFunc as py4godot_visualshadernodefloatfunc 
  import py4godot.classes.Geometry3D as py4godot_geometry3d 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.RegExMatch as py4godot_regexmatch 
  import py4godot.classes.ZIPReader as py4godot_zipreader 
  import py4godot.classes.AudioStream as py4godot_audiostream 
  import py4godot.classes.MobileVRInterface as py4godot_mobilevrinterface 
  import py4godot.classes.Compositor as py4godot_compositor 
  import py4godot.classes.FontFile as py4godot_fontfile 
  import py4godot.classes.PCKPacker as py4godot_pckpacker 
  import py4godot.classes.BaseMaterial3D as py4godot_basematerial3d 
  import py4godot.classes.WeakRef as py4godot_weakref 
  import py4godot.classes.GPUParticles3D as py4godot_gpuparticles3d 
  import py4godot.classes.StreamPeerTCP as py4godot_streampeertcp 
  import py4godot.classes.PhysicsMaterial as py4godot_physicsmaterial 
  import py4godot.classes.VisualShaderNodeConstant as py4godot_visualshadernodeconstant 
  import py4godot.classes.AnimationNodeOutput as py4godot_animationnodeoutput 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.GLTFDocumentExtension as py4godot_gltfdocumentextension 
  import py4godot.classes.AudioStreamGeneratorPlayback as py4godot_audiostreamgeneratorplayback 
  import py4godot.classes.TextureLayeredRD as py4godot_texturelayeredrd 
  import py4godot.classes.VisualShaderNodeVectorCompose as py4godot_visualshadernodevectorcompose 
  import py4godot.classes.CSGPolygon3D as py4godot_csgpolygon3d 
  import py4godot.classes.VisualShaderNodeVectorDecompose as py4godot_visualshadernodevectordecompose 
  import py4godot.classes.FileDialog as py4godot_filedialog 
  import py4godot.classes.RDPipelineSpecializationConstant as py4godot_rdpipelinespecializationconstant 
  import py4godot.classes.VisualShaderNodeDotProduct as py4godot_visualshadernodedotproduct 
  import py4godot.classes.OpenXRDpadBindingModifier as py4godot_openxrdpadbindingmodifier 
  import py4godot.classes.VisualShaderNodeExpression as py4godot_visualshadernodeexpression 
  import py4godot.classes.CameraAttributesPractical as py4godot_cameraattributespractical 
  import py4godot.classes.ImageFormatLoaderExtension as py4godot_imageformatloaderextension 
  import py4godot.classes.TextureLayered as py4godot_texturelayered 
  import py4godot.classes.NavigationPathQueryResult2D as py4godot_navigationpathqueryresult2d 
  import py4godot.classes.CollisionPolygon2D as py4godot_collisionpolygon2d 
  import py4godot.classes.InputEventScreenTouch as py4godot_inputeventscreentouch 
  import py4godot.classes.MeshInstance2D as py4godot_meshinstance2d 
  import py4godot.classes.VisualShaderNodeDistanceFade as py4godot_visualshadernodedistancefade 
  import py4godot.classes.GLTFNode as py4godot_gltfnode 
  import py4godot.classes.Image as py4godot_image 
  import py4godot.classes.CanvasModulate as py4godot_canvasmodulate 
  import py4godot.classes.CSGCombiner3D as py4godot_csgcombiner3d 
  import py4godot.classes.PhysicsDirectSpaceState3DExtension as py4godot_physicsdirectspacestate3dextension 
  import py4godot.classes.MultiplayerPeer as py4godot_multiplayerpeer 
  import py4godot.classes.XRFaceTracker as py4godot_xrfacetracker 
  import py4godot.classes.VisualShaderNodeTexture as py4godot_visualshadernodetexture 
  import py4godot.classes.PointLight2D as py4godot_pointlight2d 
  import py4godot.classes.TextMesh as py4godot_textmesh 
  import py4godot.classes.IP as py4godot_ip 
  import py4godot.classes.TileSet as py4godot_tileset 
  import py4godot.classes.WebRTCPeerConnectionExtension as py4godot_webrtcpeerconnectionextension 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.Texture2DArrayRD as py4godot_texture2darrayrd 
  import py4godot.classes.CubemapArray as py4godot_cubemaparray 
  import py4godot.classes.VoxelGIData as py4godot_voxelgidata 
  import py4godot.classes.OpenXRActionSet as py4godot_openxractionset 
  import py4godot.classes.VisualShaderNodeResizableBase as py4godot_visualshadernoderesizablebase 
  import py4godot.classes.SkeletonIK3D as py4godot_skeletonik3d 
  import py4godot.classes.SeparationRayShape2D as py4godot_separationrayshape2d 
  import py4godot.classes.InputEventMIDI as py4godot_inputeventmidi 
  import py4godot.classes.ArrayMesh as py4godot_arraymesh 
  import py4godot.classes.PhysicsTestMotionParameters3D as py4godot_physicstestmotionparameters3d 
  import py4godot.classes.EditorResourcePreview as py4godot_editorresourcepreview 
  import py4godot.classes.VisualShaderNodeColorFunc as py4godot_visualshadernodecolorfunc 
  import py4godot.classes.SceneState as py4godot_scenestate 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.InputEventScreenDrag as py4godot_inputeventscreendrag 
  import py4godot.classes.EditorUndoRedoManager as py4godot_editorundoredomanager 
  import py4godot.classes.OpenXRVisibilityMask as py4godot_openxrvisibilitymask 
  import py4godot.classes.OccluderPolygon2D as py4godot_occluderpolygon2d 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.VisualShaderNodeTransformParameter as py4godot_visualshadernodetransformparameter 
  import py4godot.classes.VisualShaderNodeParticleMeshEmitter as py4godot_visualshadernodeparticlemeshemitter 
  import py4godot.classes.Environment as py4godot_environment 
  import py4godot.classes.TextServer as py4godot_textserver 
  import py4godot.classes.VisualInstance3D as py4godot_visualinstance3d 
  import py4godot.classes.AudioEffectPanner as py4godot_audioeffectpanner 
  import py4godot.classes.XRPositionalTracker as py4godot_xrpositionaltracker 
  import py4godot.classes.HTTPRequest as py4godot_httprequest 
  import py4godot.classes.TorusMesh as py4godot_torusmesh 
  import py4godot.classes.PackedDataContainerRef as py4godot_packeddatacontainerref 
  import py4godot.classes.ShaderGlobalsOverride as py4godot_shaderglobalsoverride 
  import py4godot.classes.EditorExportPlatformAppleEmbedded as py4godot_editorexportplatformappleembedded 
  import py4godot.classes.XRInterface as py4godot_xrinterface 
  import py4godot.classes.AnimationTree as py4godot_animationtree 
  import py4godot.classes.NoiseTexture3D as py4godot_noisetexture3d 
  import py4godot.classes.NavigationObstacle3D as py4godot_navigationobstacle3d 
  import py4godot.classes.EditorScenePostImport as py4godot_editorscenepostimport 
  import py4godot.classes.GPUParticlesCollisionSDF3D as py4godot_gpuparticlescollisionsdf3d 
  import py4godot.classes.ParticleProcessMaterial as py4godot_particleprocessmaterial 
  import py4godot.classes.XRFaceModifier3D as py4godot_xrfacemodifier3d 
  import py4godot.classes.NavigationMesh as py4godot_navigationmesh 
  import py4godot.classes.VisualShaderNodeClamp as py4godot_visualshadernodeclamp 
  import py4godot.classes.AudioEffectNotchFilter as py4godot_audioeffectnotchfilter 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.MultiplayerAPIExtension as py4godot_multiplayerapiextension 
  import py4godot.classes.OpenXRHapticVibration as py4godot_openxrhapticvibration 
  import py4godot.classes.VisualShaderNodeDerivativeFunc as py4godot_visualshadernodederivativefunc 
  import py4godot.classes.AnimationNodeAdd3 as py4godot_animationnodeadd3 
  import py4godot.classes.VisualShaderNodeParticleMultiplyByAxisAngle as py4godot_visualshadernodeparticlemultiplybyaxisangle 
  import py4godot.classes.VisualShaderNodeUIntParameter as py4godot_visualshadernodeuintparameter 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.PackedDataContainer as py4godot_packeddatacontainer 
  import py4godot.classes.ResourceImporterDynamicFont as py4godot_resourceimporterdynamicfont 
  import py4godot.classes.VisualShaderNodeInput as py4godot_visualshadernodeinput 
  import py4godot.classes.AnimationNodeExtension as py4godot_animationnodeextension 
  import py4godot.classes.BoneAttachment3D as py4godot_boneattachment3d 
  import py4godot.classes.AudioStreamPlayback as py4godot_audiostreamplayback 
  import py4godot.classes.MultiplayerPeerExtension as py4godot_multiplayerpeerextension 
  import py4godot.classes.ArrayOccluder3D as py4godot_arrayoccluder3d 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.NavigationLink3D as py4godot_navigationlink3d 
  import py4godot.classes.Skeleton2D as py4godot_skeleton2d 
  import py4godot.classes.SubViewport as py4godot_subviewport 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.ModifierBoneTarget3D as py4godot_modifierbonetarget3d 
  import py4godot.classes.VisualShaderNodeVectorFunc as py4godot_visualshadernodevectorfunc 
  import py4godot.classes.PhysicalBoneSimulator3D as py4godot_physicalbonesimulator3d 
  import py4godot.classes.EditorExportPlatformWindows as py4godot_editorexportplatformwindows 
  import py4godot.classes.NavigationRegion2D as py4godot_navigationregion2d 
  import py4godot.classes.VisibleOnScreenEnabler2D as py4godot_visibleonscreenenabler2d 
  import py4godot.classes.VisualShaderNodeStep as py4godot_visualshadernodestep 
  import py4godot.classes.AnimatedSprite2D as py4godot_animatedsprite2d 
  import py4godot.classes.GLTFSkeleton as py4godot_gltfskeleton 
  import py4godot.classes.QuadMesh as py4godot_quadmesh 
  import py4godot.classes.Parallax2D as py4godot_parallax2d 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.InputEventKey as py4godot_inputeventkey 
  import py4godot.classes.MeshConvexDecompositionSettings as py4godot_meshconvexdecompositionsettings 
  import py4godot.classes.VisualShaderNodeUIntConstant as py4godot_visualshadernodeuintconstant 
  import py4godot.classes.PlaceholderTextureLayered as py4godot_placeholdertexturelayered 
  import py4godot.classes.VisualShaderNodeParticleEmit as py4godot_visualshadernodeparticleemit 
  import py4godot.classes.PhysicsServer2DManager as py4godot_physicsserver2dmanager 
  import py4godot.classes.RenderSceneDataExtension as py4godot_renderscenedataextension 
  import py4godot.classes.ConvertTransformModifier3D as py4godot_converttransformmodifier3d 
  import py4godot.classes.GeometryInstance3D as py4godot_geometryinstance3d 
  import py4godot.classes.EditorImportPlugin as py4godot_editorimportplugin 
  import py4godot.classes.VisualShaderNodeRemap as py4godot_visualshadernoderemap 
  import py4godot.classes.CSGBox3D as py4godot_csgbox3d 
  import py4godot.classes.MultiMesh as py4godot_multimesh 
  import py4godot.classes.EditorResourceTooltipPlugin as py4godot_editorresourcetooltipplugin 
  import py4godot.classes.OpenXRExtensionWrapperExtension as py4godot_openxrextensionwrapperextension 
  import py4godot.classes.ConcavePolygonShape3D as py4godot_concavepolygonshape3d 
  import py4godot.classes.PhysicsShapeQueryParameters3D as py4godot_physicsshapequeryparameters3d 
  import py4godot.classes.SkeletonModification2DCCDIK as py4godot_skeletonmodification2dccdik 
  import py4godot.classes.SphereShape3D as py4godot_sphereshape3d 
  import py4godot.classes.TextureCubemapArrayRD as py4godot_texturecubemaparrayrd 
  import py4godot.classes.GLTFSkin as py4godot_gltfskin 
  import py4godot.classes.EngineDebugger as py4godot_enginedebugger 
  import py4godot.classes.CapsuleShape3D as py4godot_capsuleshape3d 
  import py4godot.classes.EngineProfiler as py4godot_engineprofiler 
  import py4godot.classes.SkeletonModification2DPhysicalBones as py4godot_skeletonmodification2dphysicalbones 
  import py4godot.classes.CopyTransformModifier3D as py4godot_copytransformmodifier3d 
  import py4godot.classes.RDPipelineColorBlendState as py4godot_rdpipelinecolorblendstate 
  import py4godot.classes.RDPipelineColorBlendStateAttachment as py4godot_rdpipelinecolorblendstateattachment 
  import py4godot.classes.AudioStreamMP3 as py4godot_audiostreammp3 
  import py4godot.classes.WebSocketMultiplayerPeer as py4godot_websocketmultiplayerpeer 
  import py4godot.classes.Tweener as py4godot_tweener 
  import py4godot.classes.VisualShaderNodeBooleanConstant as py4godot_visualshadernodebooleanconstant 
  import py4godot.classes.SkinReference as py4godot_skinreference 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.RenderDataRD as py4godot_renderdatard 
  import py4godot.classes.Texture2DArray as py4godot_texture2darray 
  import py4godot.classes.VisualShaderNodeIs as py4godot_visualshadernodeis 
  import py4godot.classes.OpenXRAction as py4godot_openxraction 
  import py4godot.classes.CPUParticles2D as py4godot_cpuparticles2d 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.Geometry2D as py4godot_geometry2d 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.PhysicsPointQueryParameters3D as py4godot_physicspointqueryparameters3d 
  import py4godot.classes.AudioEffectRecord as py4godot_audioeffectrecord 
  import py4godot.classes.Node as py4godot_node 
  import py4godot.classes.VisualShaderNodeSDFRaymarch as py4godot_visualshadernodesdfraymarch 
  import py4godot.classes.Line2D as py4godot_line2d 
  import py4godot.classes.Skeleton3D as py4godot_skeleton3d 
  import py4godot.classes.RDPipelineDepthStencilState as py4godot_rdpipelinedepthstencilstate 
  import py4godot.classes.GraphElement as py4godot_graphelement 
  import py4godot.classes.VisualShaderNodeUVFunc as py4godot_visualshadernodeuvfunc 
  import py4godot.classes.Sky as py4godot_sky 
  import py4godot.classes.World2D as py4godot_world2d 
  import py4godot.classes.CylinderMesh as py4godot_cylindermesh 
  import py4godot.classes.BoxOccluder3D as py4godot_boxoccluder3d 
  import py4godot.classes.VisualShaderNodeVec4Constant as py4godot_visualshadernodevec4constant 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.EditorFeatureProfile as py4godot_editorfeatureprofile 
  import py4godot.classes.EditorDebuggerSession as py4godot_editordebuggersession 
  import py4godot.classes.VisualShaderNodeIntFunc as py4godot_visualshadernodeintfunc 
  import py4godot.classes.AudioStreamPlaybackPlaylist as py4godot_audiostreamplaybackplaylist 
  import py4godot.classes.GPUParticlesCollision3D as py4godot_gpuparticlescollision3d 
  import py4godot.classes.AudioStreamInteractive as py4godot_audiostreaminteractive 
  import py4godot.classes.Texture3DRD as py4godot_texture3drd 
  import py4godot.classes.NavigationServer3D as py4godot_navigationserver3d 
  import py4godot.classes.ButtonGroup as py4godot_buttongroup 
  import py4godot.classes.CollisionPolygon3D as py4godot_collisionpolygon3d 
  import py4godot.classes.ConvexPolygonShape2D as py4godot_convexpolygonshape2d 
  import py4godot.classes.Crypto as py4godot_crypto 
  import py4godot.classes.InputEventAction as py4godot_inputeventaction 
  import py4godot.classes.VisualShaderNodeTransformOp as py4godot_visualshadernodetransformop 
  import py4godot.classes.Tween as py4godot_tween 
  import py4godot.classes.InputEventJoypadButton as py4godot_inputeventjoypadbutton 
  import py4godot.classes.VisualShaderNodeSDFToScreenUV as py4godot_visualshadernodesdftoscreenuv 
  import py4godot.classes.GLTFDocument as py4godot_gltfdocument 
  import py4godot.classes.VisualShaderNodeColorOp as py4godot_visualshadernodecolorop 
  import py4godot.classes.VisualShaderNodeOuterProduct as py4godot_visualshadernodeouterproduct 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.TileSetSource as py4godot_tilesetsource 
  import py4godot.classes.Shape3D as py4godot_shape3d 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.PhysicsDirectBodyState2DExtension as py4godot_physicsdirectbodystate2dextension 
  import py4godot.classes.SkeletonProfile as py4godot_skeletonprofile 
  import py4godot.classes.WebRTCDataChannel as py4godot_webrtcdatachannel 
  import py4godot.classes.OptimizedTranslation as py4godot_optimizedtranslation 
  import py4godot.classes.GLTFSpecGloss as py4godot_gltfspecgloss 
  import py4godot.classes.XRControllerTracker as py4godot_xrcontrollertracker 
  import py4godot.classes.XRTracker as py4godot_xrtracker 
  import py4godot.classes.Engine as py4godot_engine 
  import py4godot.classes.VisualShaderNodeTexture3D as py4godot_visualshadernodetexture3d 
  import py4godot.classes.LabelSettings as py4godot_labelsettings 
  import py4godot.classes.GrooveJoint2D as py4godot_groovejoint2d 
  import py4godot.classes.Marker2D as py4godot_marker2d 
  import py4godot.classes.Mutex as py4godot_mutex 
  import py4godot.classes.AudioEffectBandLimitFilter as py4godot_audioeffectbandlimitfilter 
  import py4godot.classes.WebRTCPeerConnection as py4godot_webrtcpeerconnection 
  import py4godot.classes.AudioStreamPlaylist as py4godot_audiostreamplaylist 
  import py4godot.classes.EditorVCSInterface as py4godot_editorvcsinterface 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.PhysicsTestMotionResult3D as py4godot_physicstestmotionresult3d 
  import py4godot.classes.DTLSServer as py4godot_dtlsserver 
  import py4godot.classes.CryptoKey as py4godot_cryptokey 
  import py4godot.classes.CameraAttributes as py4godot_cameraattributes 
  import py4godot.classes.CameraFeed as py4godot_camerafeed 
  import py4godot.classes.ShapeCast2D as py4godot_shapecast2d 
  import py4godot.classes.GLTFLight as py4godot_gltflight 
  import py4godot.classes.EditorPlugin as py4godot_editorplugin 
  import py4godot.classes.GLTFTextureSampler as py4godot_gltftexturesampler 
  import py4godot.classes.RenderSceneData as py4godot_renderscenedata 
  import py4godot.classes.InputEventFromWindow as py4godot_inputeventfromwindow 
  import py4godot.classes.BitMap as py4godot_bitmap 
  import py4godot.classes.ClassDB as py4godot_classdb 
  import py4godot.classes.EditorFileSystem as py4godot_editorfilesystem 
  import py4godot.classes.Window as py4godot_window 
  import py4godot.classes.NavigationLink2D as py4godot_navigationlink2d 
  import py4godot.classes.XRVRS as py4godot_xrvrs 
  import py4godot.classes.ResourceFormatSaver as py4godot_resourceformatsaver 
  import py4godot.classes.Translation as py4godot_translation 
  import py4godot.classes.VisualShaderNodeCubemap as py4godot_visualshadernodecubemap 
  import py4godot.classes.InputEventMouseMotion as py4godot_inputeventmousemotion 
  import py4godot.classes.EditorSceneFormatImporterFBX2GLTF as py4godot_editorsceneformatimporterfbx2gltf 
  import py4godot.classes.VisualShaderNodeTexture2DArray as py4godot_visualshadernodetexture2darray 
  import py4godot.classes.RayCast3D as py4godot_raycast3d 
  import py4godot.classes.NavigationPolygon as py4godot_navigationpolygon 
  import py4godot.classes.AStar2D as py4godot_astar2d 
  import py4godot.classes.AnimationPlayer as py4godot_animationplayer 
  import py4godot.classes.XRBodyTracker as py4godot_xrbodytracker 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.SceneTree as py4godot_scenetree 
  import py4godot.classes.ENetConnection as py4godot_enetconnection 
  import py4godot.classes.ConfirmationDialog as py4godot_confirmationdialog 
  import py4godot.classes.AnimationLibrary as py4godot_animationlibrary 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.World3D as py4godot_world3d 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.AudioStreamPlaybackPolyphonic as py4godot_audiostreamplaybackpolyphonic 
  import py4godot.classes.ImageTextureLayered as py4godot_imagetexturelayered 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.FileAccess as py4godot_fileaccess 
  import py4godot.classes.AESContext as py4godot_aescontext 
  import py4godot.classes.VisualShaderNodeUIntOp as py4godot_visualshadernodeuintop 
  import py4godot.classes.AudioStreamPlaybackSynchronized as py4godot_audiostreamplaybacksynchronized 
  import py4godot.classes.ResourcePreloader as py4godot_resourcepreloader 
  import py4godot.classes.TileSetAtlasSource as py4godot_tilesetatlassource 
  import py4godot.classes.JSONRPC as py4godot_jsonrpc 
  import py4godot.classes.AnimationNodeBlend2 as py4godot_animationnodeblend2 
  import py4godot.classes.EditorDebuggerPlugin as py4godot_editordebuggerplugin 
  import py4godot.classes.AudioEffectLowPassFilter as py4godot_audioeffectlowpassfilter 
  import py4godot.classes.AnimationNodeBlendSpace1D as py4godot_animationnodeblendspace1d 
  import py4godot.classes.AnimationNodeBlendSpace2D as py4godot_animationnodeblendspace2d 
  import py4godot.classes.SpringBoneCollisionPlane3D as py4godot_springbonecollisionplane3d 
  import py4godot.classes.TranslationDomain as py4godot_translationdomain 
  import py4godot.classes.HTTPClient as py4godot_httpclient 
  import py4godot.classes.FontVariation as py4godot_fontvariation 
  import py4godot.classes.ImporterMesh as py4godot_importermesh 
  import py4godot.classes.PhysicsServer2DExtension as py4godot_physicsserver2dextension 
  import py4godot.classes.RDVertexAttribute as py4godot_rdvertexattribute 
  import py4godot.classes.TileMapPattern as py4godot_tilemappattern 
  import py4godot.classes.ImporterMeshInstance3D as py4godot_importermeshinstance3d 
  import py4godot.classes.VisualShaderNodeParticleAccelerator as py4godot_visualshadernodeparticleaccelerator 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.AnimatableBody3D as py4godot_animatablebody3d 
  import py4godot.classes.PrismMesh as py4godot_prismmesh 
  import py4godot.classes.JavaObject as py4godot_javaobject 
  import py4godot.classes.InputEventWithModifiers as py4godot_inputeventwithmodifiers 
  import py4godot.classes.Decal as py4godot_decal 
  import py4godot.classes.PhysicsDirectSpaceState2DExtension as py4godot_physicsdirectspacestate2dextension 
  import py4godot.classes.CompressedTextureLayered as py4godot_compressedtexturelayered 
  import py4godot.classes.VisualShaderNodeDeterminant as py4godot_visualshadernodedeterminant 
  import py4godot.classes.AnimationNodeTimeScale as py4godot_animationnodetimescale 
  import py4godot.classes.VisualShaderNode as py4godot_visualshadernode 
  import py4godot.classes.PhysicsRayQueryParameters3D as py4godot_physicsrayqueryparameters3d 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.Time as py4godot_time 
  import py4godot.classes.FogVolume as py4godot_fogvolume 
  import py4godot.classes.PathFollow3D as py4godot_pathfollow3d 
  import py4godot.classes.MissingResource as py4godot_missingresource 
  import py4godot.classes.Timer as py4godot_timer 
  import py4godot.classes.TubeTrailMesh as py4godot_tubetrailmesh 
  import py4godot.classes.ConfigFile as py4godot_configfile 
  import py4godot.classes.VisualShaderNodeTexture2DArrayParameter as py4godot_visualshadernodetexture2darrayparameter 
  import py4godot.classes.VisualShaderNodeTransformFunc as py4godot_visualshadernodetransformfunc 
  import py4godot.classes.PhysicsBody2D as py4godot_physicsbody2d 
  import py4godot.classes.RigidBody2D as py4godot_rigidbody2d 
  import py4godot.classes.VisualShaderNodeMultiplyAdd as py4godot_visualshadernodemultiplyadd 
  import py4godot.classes.VisualShaderNodeVectorRefract as py4godot_visualshadernodevectorrefract 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.TextServerManager as py4godot_textservermanager 
  import py4godot.classes.VisualShaderNodeParticleRingEmitter as py4godot_visualshadernodeparticleringemitter 
  import py4godot.classes.CanvasLayer as py4godot_canvaslayer 
  import py4godot.classes.SphereMesh as py4godot_spheremesh 
  import py4godot.classes.MultiplayerAPI as py4godot_multiplayerapi 
  import py4godot.classes.ResourceLoader as py4godot_resourceloader 
  import py4godot.classes.NavigationMeshSourceGeometryData3D as py4godot_navigationmeshsourcegeometrydata3d 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.AudioStreamGenerator as py4godot_audiostreamgenerator 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.PhysicsServer3DRenderingServerHandler as py4godot_physicsserver3drenderingserverhandler 
  import py4godot.classes.GLTFAccessor as py4godot_gltfaccessor 
  import py4godot.classes.StyleBoxTexture as py4godot_styleboxtexture 
  import py4godot.classes.SegmentShape2D as py4godot_segmentshape2d 
  import py4godot.classes.MissingNode as py4godot_missingnode 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.XMLParser as py4godot_xmlparser 
  import py4godot.classes.WebSocketPeer as py4godot_websocketpeer 
  import py4godot.classes.EditorResourceConversionPlugin as py4godot_editorresourceconversionplugin 
  import py4godot.classes.VisualShaderNodeVarying as py4godot_visualshadernodevarying 
  import py4godot.classes.Joint3D as py4godot_joint3d 
  import py4godot.classes.TranslationServer as py4godot_translationserver 
  import py4godot.classes.PlaceholderMesh as py4godot_placeholdermesh 
  import py4godot.classes.SkeletonModification2DLookAt as py4godot_skeletonmodification2dlookat 
  import py4godot.classes.ShaderMaterial as py4godot_shadermaterial 
  import py4godot.classes.RichTextEffect as py4godot_richtexteffect 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.QuadOccluder3D as py4godot_quadoccluder3d 
  import py4godot.classes.ConeTwistJoint3D as py4godot_conetwistjoint3d 
  import py4godot.classes.ScriptBacktrace as py4godot_scriptbacktrace 
  import py4godot.classes.ScriptLanguage as py4godot_scriptlanguage 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.OpenXRRenderModel as py4godot_openxrrendermodel 
  import py4godot.classes.TabBar as py4godot_tabbar 
  import py4godot.classes.CircleShape2D as py4godot_circleshape2d 
  import py4godot.classes.Resource as py4godot_resource 
  import py4godot.classes.EditorSceneFormatImporterBlend as py4godot_editorsceneformatimporterblend 
  import py4godot.classes.AcceptDialog as py4godot_acceptdialog 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.VisualShaderNodeVectorDistance as py4godot_visualshadernodevectordistance 
  import py4godot.classes.Node2D as py4godot_node2d 
  import py4godot.classes.JavaScriptObject as py4godot_javascriptobject 
  import py4godot.classes.WebRTCDataChannelExtension as py4godot_webrtcdatachannelextension 
  import py4godot.classes.OpenXRIPBinding as py4godot_openxripbinding 
  import py4godot.classes.GDScript as py4godot_gdscript 
  import py4godot.classes.VisualShaderNodeScreenNormalWorldSpace as py4godot_visualshadernodescreennormalworldspace 
  import py4godot.classes.VisualShaderNodeCurveXYZTexture as py4godot_visualshadernodecurvexyztexture 
  import py4godot.classes.LightmapGI as py4godot_lightmapgi 
  import py4godot.classes.Semaphore as py4godot_semaphore 
  import py4godot.classes.XRPose as py4godot_xrpose 
  import py4godot.classes.OggPacketSequence as py4godot_oggpacketsequence 
  import py4godot.classes.SyntaxHighlighter as py4godot_syntaxhighlighter 
  import py4godot.classes.ShapeCast3D as py4godot_shapecast3d 
  import py4godot.classes.Skin as py4godot_skin 
  import py4godot.classes.AudioStreamOggVorbis as py4godot_audiostreamoggvorbis 
  import py4godot.classes.TileMapLayer as py4godot_tilemaplayer 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.VisualShaderNodeIf as py4godot_visualshadernodeif 
  import py4godot.classes.CompositorEffect as py4godot_compositoreffect 
  import py4godot.classes.SkeletonModification2DJiggle as py4godot_skeletonmodification2djiggle 
  import py4godot.classes.VideoStream as py4godot_videostream 
  import py4godot.classes.PhysicsServer3DManager as py4godot_physicsserver3dmanager 
  import py4godot.classes.KinematicCollision3D as py4godot_kinematiccollision3d 
  import py4godot.classes.ShaderIncludeDB as py4godot_shaderincludedb 
  import py4godot.classes.ResourceImporterTexture as py4godot_resourceimportertexture 
  import py4godot.classes.VisualShaderNodeCurveTexture as py4godot_visualshadernodecurvetexture 
  import py4godot.classes.OpenXRCompositionLayerQuad as py4godot_openxrcompositionlayerquad 
  import py4godot.classes.GPUParticlesAttractor3D as py4godot_gpuparticlesattractor3d 
  import py4godot.classes.AudioEffectStereoEnhance as py4godot_audioeffectstereoenhance 
  import py4godot.classes.GLTFTexture as py4godot_gltftexture 
  import py4godot.classes.AudioEffectLowShelfFilter as py4godot_audioeffectlowshelffilter 
  import py4godot.classes.VisualShaderNodeUVPolarCoord as py4godot_visualshadernodeuvpolarcoord 
  import py4godot.classes.RenderSceneBuffersRD as py4godot_renderscenebuffersrd 
  import py4godot.classes.JavaClass as py4godot_javaclass 
  import py4godot.classes.Shader as py4godot_shader 
  import py4godot.classes.PlaceholderTexture3D as py4godot_placeholdertexture3d 
  import py4godot.classes.InputMap as py4godot_inputmap 
  import py4godot.classes.Marker3D as py4godot_marker3d 
  import py4godot.classes.SkeletonModification2DTwoBoneIK as py4godot_skeletonmodification2dtwoboneik 
  import py4godot.classes.UniformSetCacheRD as py4godot_uniformsetcacherd 
  import py4godot.classes.FoldableGroup as py4godot_foldablegroup 
  import py4godot.classes.EditorExportPlatformLinuxBSD as py4godot_editorexportplatformlinuxbsd 
  import py4godot.classes.Gradient as py4godot_gradient 
  import py4godot.classes.VisualShaderNodeParticleSphereEmitter as py4godot_visualshadernodeparticlesphereemitter 
  import py4godot.classes.XRBodyModifier3D as py4godot_xrbodymodifier3d 
  import py4godot.classes.HashingContext as py4godot_hashingcontext 
  import py4godot.classes.XRInterfaceExtension as py4godot_xrinterfaceextension 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.WebRTCMultiplayerPeer as py4godot_webrtcmultiplayerpeer 
  import py4godot.classes.AudioEffectDistortion as py4godot_audioeffectdistortion 
  import py4godot.classes.BoneMap as py4godot_bonemap 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.NavigationPathQueryResult3D as py4godot_navigationpathqueryresult3d 
  import py4godot.classes.CSGPrimitive3D as py4godot_csgprimitive3d 
  import py4godot.classes.PhysicsServer3DExtension as py4godot_physicsserver3dextension 
  import py4godot.classes.PlaceholderTexture2DArray as py4godot_placeholdertexture2darray 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.VehicleWheel3D as py4godot_vehiclewheel3d 
  import py4godot.classes.GLTFObjectModelProperty as py4godot_gltfobjectmodelproperty 
  import py4godot.classes.ResourceImporterMP3 as py4godot_resourceimportermp3 
  import py4godot.classes.ScriptLanguageExtension as py4godot_scriptlanguageextension 
  import py4godot.classes.Node3D as py4godot_node3d 
  import py4godot.classes.VisibleOnScreenEnabler3D as py4godot_visibleonscreenenabler3d 
  import py4godot.classes.CameraAttributesPhysical as py4godot_cameraattributesphysical 
  import py4godot.classes.VisualShaderNodeVectorOp as py4godot_visualshadernodevectorop 
  import py4godot.classes.CompressedCubemap as py4godot_compressedcubemap 
  import py4godot.classes.RDUniform as py4godot_rduniform 
  import py4godot.classes.SpringBoneSimulator3D as py4godot_springbonesimulator3d 
  import py4godot.classes.CompressedTexture3D as py4godot_compressedtexture3d 
  import py4godot.classes.ThemeDB as py4godot_themedb 
  import py4godot.classes.PacketPeerDTLS as py4godot_packetpeerdtls 
  import py4godot.classes.AudioEffectAmplify as py4godot_audioeffectamplify 
  import py4godot.classes.ProjectSettings as py4godot_projectsettings 
  import py4godot.classes.AnimationNodeAdd2 as py4godot_animationnodeadd2 
  import py4godot.classes.GPUParticlesCollisionBox3D as py4godot_gpuparticlescollisionbox3d 
  import py4godot.classes.OpenXRRenderModelManager as py4godot_openxrrendermodelmanager 
  import py4godot.classes.VisualShaderNodeFresnel as py4godot_visualshadernodefresnel 
  import py4godot.classes.Animation as py4godot_animation 
  import py4godot.classes.EditorExportPlatformAndroid as py4godot_editorexportplatformandroid 
  import py4godot.classes.Occluder3D as py4godot_occluder3d 
  import py4godot.classes.Label3D as py4godot_label3d 
  import py4godot.classes.Light3D as py4godot_light3d 
  import py4godot.classes.RibbonTrailMesh as py4godot_ribbontrailmesh 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.PhysicalBone2D as py4godot_physicalbone2d 
  import py4godot.classes.ResourceImporterCSVTranslation as py4godot_resourceimportercsvtranslation 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.SkeletonModification2DFABRIK as py4godot_skeletonmodification2dfabrik 
  import py4godot.classes.Joint2D as py4godot_joint2d 
  import py4godot.classes.ENetMultiplayerPeer as py4godot_enetmultiplayerpeer 
  import py4godot.classes.AStar3D as py4godot_astar3d 
  import py4godot.classes.ParallaxLayer as py4godot_parallaxlayer 
  import py4godot.classes.RootMotionView as py4godot_rootmotionview 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.GLTFPhysicsBody as py4godot_gltfphysicsbody 
  import py4godot.classes.AudioEffectEQ as py4godot_audioeffecteq 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.VisualShaderNodeTextureSDFNormal as py4godot_visualshadernodetexturesdfnormal 
  import py4godot.classes.VisualShaderNodeTransformCompose as py4godot_visualshadernodetransformcompose 
  import py4godot.classes.TileData as py4godot_tiledata 
  import py4godot.classes.AudioStreamPlaybackOggVorbis as py4godot_audiostreamplaybackoggvorbis 
  import py4godot.classes.VisualShaderNodeVec4Parameter as py4godot_visualshadernodevec4parameter 
import py4godot.classes.Vector3iTypedArray as py4godot_vector3itypedarray 
import py4godot.classes.NodePathTypedArray as py4godot_nodepathtypedarray 
import py4godot.classes.CanvasItem as py4godot_canvasitem 
from py4godot.wrappers.wrappers import CPPControlWrapper

class FocusMode:
  FOCUS_NONE = 0
  FOCUS_CLICK = 1
  FOCUS_ALL = 2
  FOCUS_ACCESSIBILITY = 3
class FocusBehaviorRecursive:
  FOCUS_BEHAVIOR_INHERITED = 0
  FOCUS_BEHAVIOR_DISABLED = 1
  FOCUS_BEHAVIOR_ENABLED = 2
class MouseBehaviorRecursive:
  MOUSE_BEHAVIOR_INHERITED = 0
  MOUSE_BEHAVIOR_DISABLED = 1
  MOUSE_BEHAVIOR_ENABLED = 2
class CursorShape:
  CURSOR_ARROW = 0
  CURSOR_IBEAM = 1
  CURSOR_POINTING_HAND = 2
  CURSOR_CROSS = 3
  CURSOR_WAIT = 4
  CURSOR_BUSY = 5
  CURSOR_DRAG = 6
  CURSOR_CAN_DROP = 7
  CURSOR_FORBIDDEN = 8
  CURSOR_VSIZE = 9
  CURSOR_HSIZE = 10
  CURSOR_BDIAGSIZE = 11
  CURSOR_FDIAGSIZE = 12
  CURSOR_MOVE = 13
  CURSOR_VSPLIT = 14
  CURSOR_HSPLIT = 15
  CURSOR_HELP = 16
class LayoutPreset:
  PRESET_TOP_LEFT = 0
  PRESET_TOP_RIGHT = 1
  PRESET_BOTTOM_LEFT = 2
  PRESET_BOTTOM_RIGHT = 3
  PRESET_CENTER_LEFT = 4
  PRESET_CENTER_TOP = 5
  PRESET_CENTER_RIGHT = 6
  PRESET_CENTER_BOTTOM = 7
  PRESET_CENTER = 8
  PRESET_LEFT_WIDE = 9
  PRESET_TOP_WIDE = 10
  PRESET_RIGHT_WIDE = 11
  PRESET_BOTTOM_WIDE = 12
  PRESET_VCENTER_WIDE = 13
  PRESET_HCENTER_WIDE = 14
  PRESET_FULL_RECT = 15
class LayoutPresetMode:
  PRESET_MODE_MINSIZE = 0
  PRESET_MODE_KEEP_WIDTH = 1
  PRESET_MODE_KEEP_HEIGHT = 2
  PRESET_MODE_KEEP_SIZE = 3
class SizeFlags:
  SIZE_SHRINK_BEGIN = 0
  SIZE_FILL = 1
  SIZE_EXPAND = 2
  SIZE_EXPAND_FILL = 3
  SIZE_SHRINK_CENTER = 4
  SIZE_SHRINK_END = 8
class MouseFilter:
  MOUSE_FILTER_STOP = 0
  MOUSE_FILTER_PASS = 1
  MOUSE_FILTER_IGNORE = 2
class GrowDirection:
  GROW_DIRECTION_BEGIN = 0
  GROW_DIRECTION_END = 1
  GROW_DIRECTION_BOTH = 2
class Anchor:
  ANCHOR_BEGIN = 0
  ANCHOR_END = 1
class LayoutDirection:
  LAYOUT_DIRECTION_INHERITED = 0
  LAYOUT_DIRECTION_APPLICATION_LOCALE = 1
  LAYOUT_DIRECTION_LTR = 2
  LAYOUT_DIRECTION_RTL = 3
  LAYOUT_DIRECTION_SYSTEM_LOCALE = 4
  LAYOUT_DIRECTION_MAX = 5
  LAYOUT_DIRECTION_LOCALE = 1
class TextDirection:
  TEXT_DIRECTION_INHERITED = 3
  TEXT_DIRECTION_AUTO = 0
  TEXT_DIRECTION_LTR = 1
  TEXT_DIRECTION_RTL = 2


class Control(py4godot_canvasitem.CanvasItem):
  r'''
		Base class for all UI-related nodes. `Control` features a bounding rectangle that defines its extents, an anchor position relative to its parent control or the current viewport, and offsets relative to the anchor. The offsets update automatically when the node, any of its parents, or the screen size change.
		For more information on Godot's UI system, anchors, offsets, and containers, see the related tutorials in the manual. To build flexible UIs, you'll need a mix of UI elements that inherit from `Control` and `Container` nodes.
		**Note:** Since both `Node2D` and `Control` inherit from `CanvasItem`, they share several concepts from the class such as the `CanvasItem.z_index` and `CanvasItem.visible` properties.
		**User Interface nodes and input**
		Godot propagates input events via viewports. Each `Viewport` is responsible for propagating `InputEvent`s to their child nodes. As the `SceneTree.root` is a `Window`, this already happens automatically for all UI elements in your game.
		Input events are propagated through the `SceneTree` from the root node to all child nodes by calling `Node._input`. For UI elements specifically, it makes more sense to override the virtual method `_gui_input`, which filters out unrelated input events, such as by checking z-order, `mouse_filter`, focus, or if the event was inside of the control's bounding box.
		Call `accept_event` so no other node receives the event. Once you accept an input, it becomes handled so `Node._unhandled_input` will not process it.
		Only one `Control` node can be in focus. Only the node in focus will receive events. To get the focus, call `grab_focus`. `Control` nodes lose focus when another node grabs it, or if you hide the node in focus. Focus will not be represented visually if gained via mouse/touch input, only appearing with keyboard/gamepad input (for accessibility), or via `grab_focus`.
		Set `mouse_filter` to `constant MOUSE_FILTER_IGNORE` to tell a `Control` node to ignore mouse or touch events. You'll need it if you place an icon on top of a button.
		`Theme` resources change the control's appearance. The `theme` of a `Control` node affects all of its direct and indirect children (as long as a chain of controls is uninterrupted). To override some of the theme items, call one of the `add_theme_*_override` methods, like `add_theme_font_override`. You can also override theme items in the Inspector.
		**Note:** Theme items are _not_ `Object` properties. This means you can't access their values using `Object.get` and `Object.set`. Instead, use the `get_theme_*` and `add_theme_*_override` methods provided by this class.
	'''
  NOTIFICATION_RESIZED:typing.ClassVar[int]

  NOTIFICATION_MOUSE_ENTER:typing.ClassVar[int]

  NOTIFICATION_MOUSE_EXIT:typing.ClassVar[int]

  NOTIFICATION_MOUSE_ENTER_SELF:typing.ClassVar[int]

  NOTIFICATION_MOUSE_EXIT_SELF:typing.ClassVar[int]

  NOTIFICATION_FOCUS_ENTER:typing.ClassVar[int]

  NOTIFICATION_FOCUS_EXIT:typing.ClassVar[int]

  NOTIFICATION_THEME_CHANGED:typing.ClassVar[int]

  NOTIFICATION_SCROLL_BEGIN:typing.ClassVar[int]

  NOTIFICATION_SCROLL_END:typing.ClassVar[int]

  NOTIFICATION_LAYOUT_DIRECTION_CHANGED:typing.ClassVar[int]

  @staticmethod
  def constructor():
    class_ = Control.construct_without_init()
    class_._ptr = constructor(239,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Control.construct_without_init()
    class_._ptr = constructor(239,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPControlWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(239,0, ())


  def generate_wrapper(self):
    return CPPControlWrapper()
  def init_signals(self):
    super().init_signals()
    resized_name = utils.py_string_to_string_name("resized")
    self.resized = signals.BuiltinSignal(self, resized_name)
    gui_input_name = utils.py_string_to_string_name("gui_input")
    self.gui_input = signals.BuiltinSignal(self, gui_input_name)
    mouse_entered_name = utils.py_string_to_string_name("mouse_entered")
    self.mouse_entered = signals.BuiltinSignal(self, mouse_entered_name)
    mouse_exited_name = utils.py_string_to_string_name("mouse_exited")
    self.mouse_exited = signals.BuiltinSignal(self, mouse_exited_name)
    focus_entered_name = utils.py_string_to_string_name("focus_entered")
    self.focus_entered = signals.BuiltinSignal(self, focus_entered_name)
    focus_exited_name = utils.py_string_to_string_name("focus_exited")
    self.focus_exited = signals.BuiltinSignal(self, focus_exited_name)
    size_flags_changed_name = utils.py_string_to_string_name("size_flags_changed")
    self.size_flags_changed = signals.BuiltinSignal(self, size_flags_changed_name)
    minimum_size_changed_name = utils.py_string_to_string_name("minimum_size_changed")
    self.minimum_size_changed = signals.BuiltinSignal(self, minimum_size_changed_name)
    theme_changed_name = utils.py_string_to_string_name("theme_changed")
    self.theme_changed = signals.BuiltinSignal(self, theme_changed_name)

  @staticmethod
  def construct_without_init():
    cls = Control.__new__(Control)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Control'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Control.construct_without_init()
    cls._ptr = CPPControlWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Control.construct_without_init()
    cls._ptr = CPPControlWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def clip_contents(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_clipping_contents()
    return _ret
  @clip_contents.setter
  def clip_contents(self,  value:'bool'):
    self.set_clip_contents(value)
  @property
  def custom_minimum_size(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_custom_minimum_size()
    return _ret
  @custom_minimum_size.setter
  def custom_minimum_size(self,  value:'Vector2'):
    self.set_custom_minimum_size(value)
  @property
  def layout_direction(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_layout_direction()
    return _ret
  @layout_direction.setter
  def layout_direction(self,  value:'int'):
    self.set_layout_direction(value)
  @property
  def layout_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. _get_layout_mode()
    return _ret
  @layout_mode.setter
  def layout_mode(self,  value:'int'):
    self._set_layout_mode(value)
  @property
  def anchors_preset(self) -> typing.Union[int]:
    r''''''
    _ret = self. _get_anchors_layout_preset()
    return _ret
  @anchors_preset.setter
  def anchors_preset(self,  value:'int'):
    self._set_anchors_layout_preset(value)
  @property
  def anchor_left(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_anchor(0)
    return _ret
  @anchor_left.setter
  def anchor_left(self,  value:'float'):
    self._set_anchor(0, value)
  @property
  def anchor_top(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_anchor(1)
    return _ret
  @anchor_top.setter
  def anchor_top(self,  value:'float'):
    self._set_anchor(1, value)
  @property
  def anchor_right(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_anchor(2)
    return _ret
  @anchor_right.setter
  def anchor_right(self,  value:'float'):
    self._set_anchor(2, value)
  @property
  def anchor_bottom(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_anchor(3)
    return _ret
  @anchor_bottom.setter
  def anchor_bottom(self,  value:'float'):
    self._set_anchor(3, value)
  @property
  def offset_left(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_offset(0)
    return _ret
  @offset_left.setter
  def offset_left(self,  value:'float'):
    self.set_offset(0, value)
  @property
  def offset_top(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_offset(1)
    return _ret
  @offset_top.setter
  def offset_top(self,  value:'float'):
    self.set_offset(1, value)
  @property
  def offset_right(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_offset(2)
    return _ret
  @offset_right.setter
  def offset_right(self,  value:'float'):
    self.set_offset(2, value)
  @property
  def offset_bottom(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_offset(3)
    return _ret
  @offset_bottom.setter
  def offset_bottom(self,  value:'float'):
    self.set_offset(3, value)
  @property
  def grow_horizontal(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_h_grow_direction()
    return _ret
  @grow_horizontal.setter
  def grow_horizontal(self,  value:'int'):
    self.set_h_grow_direction(value)
  @property
  def grow_vertical(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_v_grow_direction()
    return _ret
  @grow_vertical.setter
  def grow_vertical(self,  value:'int'):
    self.set_v_grow_direction(value)
  @property
  def size(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_size()
    return _ret
  @size.setter
  def size(self,  value:'Vector2'):
    self._set_size(value)
  @property
  def position(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_position()
    return _ret
  @position.setter
  def position(self,  value:'Vector2'):
    self._set_position(value)
  @property
  def global_position(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_global_position()
    return _ret
  @global_position.setter
  def global_position(self,  value:'Vector2'):
    self._set_global_position(value)
  @property
  def rotation(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_rotation()
    return _ret
  @rotation.setter
  def rotation(self,  value:'float'):
    self.set_rotation(value)
  @property
  def rotation_degrees(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_rotation_degrees()
    return _ret
  @rotation_degrees.setter
  def rotation_degrees(self,  value:'float'):
    self.set_rotation_degrees(value)
  @property
  def scale(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_scale()
    return _ret
  @scale.setter
  def scale(self,  value:'Vector2'):
    self.set_scale(value)
  @property
  def pivot_offset(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_pivot_offset()
    return _ret
  @pivot_offset.setter
  def pivot_offset(self,  value:'Vector2'):
    self.set_pivot_offset(value)
  @property
  def size_flags_horizontal(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_h_size_flags()
    return _ret
  @size_flags_horizontal.setter
  def size_flags_horizontal(self,  value:'int'):
    self.set_h_size_flags(value)
  @property
  def size_flags_vertical(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_v_size_flags()
    return _ret
  @size_flags_vertical.setter
  def size_flags_vertical(self,  value:'int'):
    self.set_v_size_flags(value)
  @property
  def size_flags_stretch_ratio(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_stretch_ratio()
    return _ret
  @size_flags_stretch_ratio.setter
  def size_flags_stretch_ratio(self,  value:'float'):
    self.set_stretch_ratio(value)
  @property
  def localize_numeral_system(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_localizing_numeral_system()
    return _ret
  @localize_numeral_system.setter
  def localize_numeral_system(self,  value:'bool'):
    self.set_localize_numeral_system(value)
  @property
  def auto_translate(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_auto_translating()
    return _ret
  @auto_translate.setter
  def auto_translate(self,  value:'bool'):
    self.set_auto_translate(value)
  @property
  def tooltip_text(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_tooltip_text()
    return _ret
  @tooltip_text.setter
  def tooltip_text(self,  value:'str'):
    self.set_tooltip_text(value)
  @property
  def tooltip_auto_translate_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tooltip_auto_translate_mode()
    return _ret
  @tooltip_auto_translate_mode.setter
  def tooltip_auto_translate_mode(self,  value:'int'):
    self.set_tooltip_auto_translate_mode(value)
  @property
  def focus_neighbor_left(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_focus_neighbor(0)
    return _ret
  @focus_neighbor_left.setter
  def focus_neighbor_left(self,  value:'object'):
    self.set_focus_neighbor(0, value)
  @property
  def focus_neighbor_top(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_focus_neighbor(1)
    return _ret
  @focus_neighbor_top.setter
  def focus_neighbor_top(self,  value:'object'):
    self.set_focus_neighbor(1, value)
  @property
  def focus_neighbor_right(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_focus_neighbor(2)
    return _ret
  @focus_neighbor_right.setter
  def focus_neighbor_right(self,  value:'object'):
    self.set_focus_neighbor(2, value)
  @property
  def focus_neighbor_bottom(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_focus_neighbor(3)
    return _ret
  @focus_neighbor_bottom.setter
  def focus_neighbor_bottom(self,  value:'object'):
    self.set_focus_neighbor(3, value)
  @property
  def focus_next(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_focus_next()
    return _ret
  @focus_next.setter
  def focus_next(self,  value:'object'):
    self.set_focus_next(value)
  @property
  def focus_previous(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_focus_previous()
    return _ret
  @focus_previous.setter
  def focus_previous(self,  value:'object'):
    self.set_focus_previous(value)
  @property
  def focus_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_focus_mode()
    return _ret
  @focus_mode.setter
  def focus_mode(self,  value:'int'):
    self.set_focus_mode(value)
  @property
  def focus_behavior_recursive(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_focus_behavior_recursive()
    return _ret
  @focus_behavior_recursive.setter
  def focus_behavior_recursive(self,  value:'int'):
    self.set_focus_behavior_recursive(value)
  @property
  def mouse_filter(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_mouse_filter()
    return _ret
  @mouse_filter.setter
  def mouse_filter(self,  value:'int'):
    self.set_mouse_filter(value)
  @property
  def mouse_behavior_recursive(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_mouse_behavior_recursive()
    return _ret
  @mouse_behavior_recursive.setter
  def mouse_behavior_recursive(self,  value:'int'):
    self.set_mouse_behavior_recursive(value)
  @property
  def mouse_force_pass_scroll_events(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_force_pass_scroll_events()
    return _ret
  @mouse_force_pass_scroll_events.setter
  def mouse_force_pass_scroll_events(self,  value:'bool'):
    self.set_force_pass_scroll_events(value)
  @property
  def mouse_default_cursor_shape(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_default_cursor_shape()
    return _ret
  @mouse_default_cursor_shape.setter
  def mouse_default_cursor_shape(self,  value:'int'):
    self.set_default_cursor_shape(value)
  @property
  def shortcut_context(self) -> typing.Any:
    r''''''
    _ret = self. get_shortcut_context()
    return _ret
  @shortcut_context.setter
  def shortcut_context(self,  value:'py4godot_object.Object'):
    self.set_shortcut_context(value)
  @property
  def accessibility_name(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_accessibility_name()
    return _ret
  @accessibility_name.setter
  def accessibility_name(self,  value:'str'):
    self.set_accessibility_name(value)
  @property
  def accessibility_description(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_accessibility_description()
    return _ret
  @accessibility_description.setter
  def accessibility_description(self,  value:'str'):
    self.set_accessibility_description(value)
  @property
  def accessibility_live(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_accessibility_live()
    return _ret
  @accessibility_live.setter
  def accessibility_live(self,  value:'int'):
    self.set_accessibility_live(value)
  @property
  def accessibility_controls_nodes(self) -> typing.Union['py4godot_nodepathtypedarray.NodePathTypedArray']:
    r''''''
    _ret = self. get_accessibility_controls_nodes()
    return _ret
  @accessibility_controls_nodes.setter
  def accessibility_controls_nodes(self, value:'Array'):
    self.set_accessibility_controls_nodes(value)
  @property
  def accessibility_described_by_nodes(self) -> typing.Union['py4godot_nodepathtypedarray.NodePathTypedArray']:
    r''''''
    _ret = self. get_accessibility_described_by_nodes()
    return _ret
  @accessibility_described_by_nodes.setter
  def accessibility_described_by_nodes(self, value:'Array'):
    self.set_accessibility_described_by_nodes(value)
  @property
  def accessibility_labeled_by_nodes(self) -> typing.Union['py4godot_nodepathtypedarray.NodePathTypedArray']:
    r''''''
    _ret = self. get_accessibility_labeled_by_nodes()
    return _ret
  @accessibility_labeled_by_nodes.setter
  def accessibility_labeled_by_nodes(self, value:'Array'):
    self.set_accessibility_labeled_by_nodes(value)
  @property
  def accessibility_flow_to_nodes(self) -> typing.Union['py4godot_nodepathtypedarray.NodePathTypedArray']:
    r''''''
    _ret = self. get_accessibility_flow_to_nodes()
    return _ret
  @accessibility_flow_to_nodes.setter
  def accessibility_flow_to_nodes(self, value:'Array'):
    self.set_accessibility_flow_to_nodes(value)
  @property
  def theme(self) -> typing.Union['py4godot_theme.Theme']:
    r''''''
    _ret = self. get_theme()
    return _ret
  @theme.setter
  def theme(self,  value:'py4godot_object.Object'):
    self.set_theme(value)
  @property
  def theme_type_variation(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_theme_type_variation()
    return _ret
  @theme_type_variation.setter
  def theme_type_variation(self,  value:'str'):
    self.set_theme_type_variation(value)
  @functools.native_method
  def _has_point(self, point:'Vector2'   ) -> typing.Union[bool]:
    r'''
				Virtual method to be implemented by the user. Returns whether the given `point` is inside this control.
				If not overridden, default behavior is checking if the point is within control's Rect.
				**Note:** If you want to check if a point is inside the control, you can use `Rect2(Vector2.ZERO, size).has_point(point)`.
			'''

    assert(not point is None)
    assert isinstance(point, Vector2), 'point must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(270,tuple([point._ptr]))
    return _ret


  @functools.native_method
  def _structured_text_parser(self, args:'Array'   , text:'str'   ) -> typing.Union['py4godot_vector3itypedarray.Vector3iTypedArray']:
    r'''
				User defined BiDi algorithm override function.
				Returns an `Array` of `Vector3i` text ranges and text base directions, in the left-to-right order. Ranges should cover full source `text` without overlaps. BiDi algorithm will be used on each range separately.
			'''

    assert(not args is None)
    assert isinstance(args, Array), 'args must be Array'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'






    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = py4godot_vector3itypedarray.Vector3iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(271,tuple([args._ptr, py_string_text._ptr]))
    return _ret


  @functools.native_method
  def _get_minimum_size(self) -> typing.Union['Vector2']:
    r'''
				Virtual method to be implemented by the user. Returns the minimum size for this control. Alternative to `custom_minimum_size` for controlling minimum size via code. The actual minimum size will be the max value of these two (in each axis separately).
				If not overridden, defaults to `constant Vector2.ZERO`.
				**Note:** This method will not be called when the script is attached to a `Control` node that already overrides its minimum size (e.g. `Label`, `Button`, `PanelContainer` etc.). It can only be used with most basic GUI nodes, like `Control`, `Container`, `Panel` etc.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(272,tuple([]))
    return _ret


  @functools.native_method
  def _get_tooltip(self, at_position:'Vector2'   ) -> typing.Union[str]:
    r'''
				Virtual method to be implemented by the user. Returns the tooltip text for the position `at_position` in control's local coordinates, which will typically appear when the cursor is resting over this control. See `get_tooltip`.
				**Note:** If this method returns an empty `String` and `_make_custom_tooltip` is not overridden, no tooltip is displayed.
			'''

    assert(not at_position is None)
    assert isinstance(at_position, Vector2), 'at_position must be Vector2'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(273,tuple([at_position._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _get_drag_data(self, at_position:'Vector2'   ) -> typing.Union[typing.Any]:
    r'''
				Godot calls this method to get data that can be dragged and dropped onto controls that expect drop data. Returns `null` if there is no data to drag. Controls that want to receive drop data should implement `_can_drop_data` and `_drop_data`. `at_position` is local to this control. Drag may be forced with `force_drag`.
				A preview that will follow the mouse that should represent the data can be set with `set_drag_preview`. A good time to set the preview is in this method.
				**Note:** If the drag was initiated by a keyboard shortcut or `accessibility_drag`, `at_position` is set to `constant Vector2.INF`, and the currently selected item/text position should be used as the drag position.
				
				```gdscript
				func _get_drag_data(position):
					var mydata = make_data() # This is your custom method generating the drag data.
					set_drag_preview(make_preview(mydata)) # This is your custom method generating the preview of the drag data.
					return mydata
				```
				
				
			'''

    assert(not at_position is None)
    assert isinstance(at_position, Vector2), 'at_position must be Vector2'







    _ret = None
    _ret = self._ptr.call_with_return(274,tuple([at_position._ptr]))
    return _ret


  @functools.native_method
  def _can_drop_data(self, at_position:'Vector2'   , data:'object'   ) -> typing.Union[bool]:
    r'''
				Godot calls this method to test if `data` from a control's `_get_drag_data` can be dropped at `at_position`. `at_position` is local to this control.
				This method should only be used to test the data. Process the data in `_drop_data`.
				**Note:** If the drag was initiated by a keyboard shortcut or `accessibility_drag`, `at_position` is set to `constant Vector2.INF`, and the currently selected item/text position should be used as the drop position.
				
				```gdscript
				func _can_drop_data(position, data):
					# Check position if it is relevant to you
					# Otherwise, just check data
					return typeof(data) == TYPE_DICTIONARY and data.has("expected")
				```
				
				
			'''

    assert(not at_position is None)
    assert isinstance(at_position, Vector2), 'at_position must be Vector2'
    

    if not (type(data).__name__ in py4godot.variant_types.core_types or isinstance(data, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'data': "
                f"{type(data).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = 0
    _ret = self._ptr.call_with_return(275,tuple([at_position._ptr, data]))
    return _ret


  @functools.native_method
  def _drop_data(self, at_position:'Vector2'   , data:'object'   ) -> None:
    r'''
				Godot calls this method to pass you the `data` from a control's `_get_drag_data` result. Godot first calls `_can_drop_data` to test if `data` is allowed to drop at `at_position` where `at_position` is local to this control.
				**Note:** If the drag was initiated by a keyboard shortcut or `accessibility_drag`, `at_position` is set to `constant Vector2.INF`, and the currently selected item/text position should be used as the drop position.
				
				```gdscript
				func _can_drop_data(position, data):
					return typeof(data) == TYPE_DICTIONARY and data.has("color")

				func _drop_data(position, data):
					var color = data`"color"`
				```
				
				
			'''

    assert(not at_position is None)
    assert isinstance(at_position, Vector2), 'at_position must be Vector2'
    

    if not (type(data).__name__ in py4godot.variant_types.core_types or isinstance(data, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'data': "
                f"{type(data).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    self._ptr.call_with_return(276,tuple([at_position._ptr, data]))

  @functools.native_method
  def _make_custom_tooltip(self, for_text:'str'   ) -> typing.Any:
    r'''
				Virtual method to be implemented by the user. Returns a `Control` node that should be used as a tooltip instead of the default one. `for_text` is the return value of `get_tooltip`.
				The returned node must be of type `Control` or Control-derived. It can have child nodes of any type. It is freed when the tooltip disappears, so make sure you always provide a new instance (if you want to use a pre-existing node from your scene tree, you can duplicate it and pass the duplicated instance). When `null` or a non-Control node is returned, the default tooltip will be used instead.
				The returned node will be added as child to a `PopupPanel`, so you should only provide the contents of that panel. That `PopupPanel` can be themed using `Theme.set_stylebox` for the type `"TooltipPanel"` (see `tooltip_text` for an example).
				**Note:** The tooltip is shrunk to minimal size. If you want to ensure it's fully visible, you might want to set its `custom_minimum_size` to some non-zero value.
				**Note:** The node (and any relevant children) should have their `CanvasItem.visible` set to `true` when returned, otherwise, the viewport that instantiates it will not be able to calculate its minimum size reliably.
				**Note:** If overridden, this method is called even if `get_tooltip` returns an empty string. When this happens with the default tooltip, it is not displayed. To copy this behavior, return `null` in this method when `for_text` is empty.
				**Example:** Use a constructed node as a tooltip:
				
				```gdscript
				func _make_custom_tooltip(for_text):
					var label = Label.new()
					label.text = for_text
					return label
				```
				
				
				**Example:** Use a scene instance as a tooltip:
				
				```gdscript
				func _make_custom_tooltip(for_text):
					var tooltip = preload("res://some_tooltip_scene.tscn").instantiate()
					tooltip.get_node("Label").text = for_text
					return tooltip
				```
				
				
			'''

    assert(not for_text is None)
    assert isinstance(for_text, (str, String)), 'for_text must be str or String'





    assert(isinstance(for_text, (str, String)))
    py_string_for_text = for_text if isinstance(for_text, StringName) else c_utils.py_string_to_string(for_text)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Object
    _ret._ptr = self._ptr.call_with_return(277,tuple([py_string_for_text._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def _accessibility_get_contextual_info(self) -> typing.Union[str]:
    r'''
				Return the description of the keyboard shortcuts and other contextual help for this control.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(278,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _get_accessibility_container_name(self, node:'py4godot_node.Node'   ) -> typing.Union[str]:
    r'''
				Override this method to return a human-readable description of the position of the child `node` in the custom container, added to the `accessibility_name`.
			'''

    assert(not node is None)
    assert isinstance(node, get_class('Node')), 'node must be Node'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(279,tuple([node._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _gui_input(self, event:'py4godot_inputevent.InputEvent'   ) -> None:
    r'''
				Virtual method to be implemented by the user. Override this method to handle and accept inputs on UI elements. See also `accept_event`.
				**Example:** Click on the control to print a message:
				
				```gdscript
				func _gui_input(event):
					if event is InputEventMouseButton:
						if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
							print("I've been clicked D:")
				```
				
				
				If the `event` inherits `InputEventMouse`, this method will **not** be called when:
				- the control's `mouse_filter` is set to `constant MOUSE_FILTER_IGNORE`;
				- the control is obstructed by another control on top, that doesn't have `mouse_filter` set to `constant MOUSE_FILTER_IGNORE`;
				- the control's parent has `mouse_filter` set to `constant MOUSE_FILTER_STOP` or has accepted the event;
				- the control's parent has `clip_contents` enabled and the `event`'s position is outside the parent's rectangle;
				- the `event`'s position is outside the control (see `_has_point`).
				**Note:** The `event`'s position is relative to this control's origin.
			'''

    assert(not event is None)
    assert isinstance(event, get_class('InputEvent')), 'event must be InputEvent'







    self._ptr.call_with_return(280,tuple([event._ptr]))

  @functools.native_method
  def accept_event(self) -> None:
    r'''
				Marks an input event as handled. Once you accept an input event, it stops propagating, even to nodes listening to `Node._unhandled_input` or `Node._unhandled_key_input`.
				**Note:** This does not affect the methods in `Input`, only the way events are propagated.
			'''




    self._ptr.call_with_return(281,tuple([]))

  @functools.native_method
  def get_minimum_size(self) -> typing.Union['Vector2']:
    r'''
				Returns the minimum size for this control. See `custom_minimum_size`.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(282,tuple([]))
    return _ret


  @functools.native_method
  def get_combined_minimum_size(self) -> typing.Union['Vector2']:
    r'''
				Returns combined minimum size from `custom_minimum_size` and `get_minimum_size`.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(283,tuple([]))
    return _ret


  @functools.native_method
  def set_anchors_preset(self, preset:'int'  , keep_offsets:'bool' =False  ) -> None:
    r'''
				Sets the anchors to a `preset` from `enum Control.LayoutPreset` enum. This is the code equivalent to using the Layout menu in the 2D editor.
				If `keep_offsets` is `true`, control's position will also be updated.
			'''

    assert isinstance(preset, (int, float)), 'preset must be int or float'
    assert isinstance(keep_offsets, bool), 'keep_offsets must be bool'








    self._ptr.call_with_return(284,tuple([preset, keep_offsets]))

  @functools.native_method
  def set_offsets_preset(self, preset:'int'  , resize_mode:'int'  =0, margin:'int' =0  ) -> None:
    r'''
				Sets the offsets to a `preset` from `enum Control.LayoutPreset` enum. This is the code equivalent to using the Layout menu in the 2D editor.
				Use parameter `resize_mode` with constants from `enum Control.LayoutPresetMode` to better determine the resulting size of the `Control`. Constant size will be ignored if used with presets that change size, e.g. `constant PRESET_LEFT_WIDE`.
				Use parameter `margin` to determine the gap between the `Control` and the edges.
			'''


    assert isinstance(preset, (int, float)), 'preset must be int or float'
    assert isinstance(resize_mode, (int, float)), 'resize_mode must be int or float'
    assert isinstance(margin, (int, float)), 'margin must be int or float'









    self._ptr.call_with_return(285,tuple([preset, resize_mode, margin]))

  @functools.native_method
  def set_anchors_and_offsets_preset(self, preset:'int'  , resize_mode:'int'  =0, margin:'int' =0  ) -> None:
    r'''
				Sets both anchor preset and offset preset. See `set_anchors_preset` and `set_offsets_preset`.
			'''


    assert isinstance(preset, (int, float)), 'preset must be int or float'
    assert isinstance(resize_mode, (int, float)), 'resize_mode must be int or float'
    assert isinstance(margin, (int, float)), 'margin must be int or float'









    self._ptr.call_with_return(286,tuple([preset, resize_mode, margin]))

  @functools.native_method
  def set_anchor(self, side:'int'  , anchor:'float'   , keep_offset:'bool' =False  , push_opposite_anchor:'bool' =True  ) -> None:
    r'''
				Sets the anchor for the specified `enum Side` to `anchor`. A setter method for `anchor_bottom`, `anchor_left`, `anchor_right` and `anchor_top`.
				If `keep_offset` is `true`, offsets aren't updated after this operation.
				If `push_opposite_anchor` is `true` and the opposite anchor overlaps this anchor, the opposite one will have its value overridden. For example, when setting left anchor to 1 and the right anchor has value of 0.5, the right anchor will also get value of 1. If `push_opposite_anchor` was `false`, the left anchor would get value 0.5.
			'''

    assert isinstance(side, (int, float)), 'side must be int or float'
    assert isinstance(anchor, (int, float)), 'anchor must be int or float'
    assert isinstance(keep_offset, bool), 'keep_offset must be bool'
    assert isinstance(push_opposite_anchor, bool), 'push_opposite_anchor must be bool'










    self._ptr.call_with_return(287,tuple([side, anchor, keep_offset, push_opposite_anchor]))

  @functools.native_method
  def get_anchor(self, side:'int'  ) -> typing.Union[float]:
    r'''
				Returns the anchor for the specified `enum Side`. A getter method for `anchor_bottom`, `anchor_left`, `anchor_right` and `anchor_top`.
			'''

    assert isinstance(side, (int, float)), 'side must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(288,tuple([side]))

    return _ret


  @functools.native_method
  def set_offset(self, side:'int'  , offset:'float'   ) -> None:
    r'''
				Sets the offset for the specified `enum Side` to `offset`. A setter method for `offset_bottom`, `offset_left`, `offset_right` and `offset_top`.
			'''

    assert isinstance(side, (int, float)), 'side must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'


    self.py__offset_left = side







    self._ptr.call_with_return(289,tuple([side, offset]))

  @functools.native_method
  def get_offset(self, offset:'int'  ) -> typing.Union[float]:
    r'''
				Returns the offset for the specified `enum Side`. A getter method for `offset_bottom`, `offset_left`, `offset_right` and `offset_top`.
			'''

    assert isinstance(offset, (int, float)), 'offset must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(290,tuple([offset]))

    return _ret


  @functools.native_method
  def set_anchor_and_offset(self, side:'int'  , anchor:'float'   , offset:'float'   , push_opposite_anchor:'bool' =False  ) -> None:
    r'''
				Works the same as `set_anchor`, but instead of `keep_offset` argument and automatic update of offset, it allows to set the offset yourself (see `set_offset`).
			'''

    assert isinstance(side, (int, float)), 'side must be int or float'
    assert isinstance(anchor, (int, float)), 'anchor must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert isinstance(push_opposite_anchor, bool), 'push_opposite_anchor must be bool'










    self._ptr.call_with_return(291,tuple([side, anchor, offset, push_opposite_anchor]))

  @functools.native_method
  def set_begin(self, position:'Vector2'   ) -> None:
    r'''
				Sets `offset_left` and `offset_top` at the same time. Equivalent of changing `position`.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'







    self._ptr.call_with_return(292,tuple([position._ptr]))

  @functools.native_method
  def set_end(self, position:'Vector2'   ) -> None:
    r'''
				Sets `offset_right` and `offset_bottom` at the same time.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'







    self._ptr.call_with_return(293,tuple([position._ptr]))

  @functools.native_method
  def set_position(self, position:'Vector2'   , keep_offsets:'bool' =False  ) -> None:
    r'''
				Sets the `position` to given `position`.
				If `keep_offsets` is `true`, control's anchors will be updated instead of offsets.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'
    assert isinstance(keep_offsets, bool), 'keep_offsets must be bool'








    self._ptr.call_with_return(294,tuple([position._ptr, keep_offsets]))

  @functools.native_method
  def set_size(self, size:'Vector2'   , keep_offsets:'bool' =False  ) -> None:
    r'''
				Sets the size (see `size`).
				If `keep_offsets` is `true`, control's anchors will be updated instead of offsets.
			'''

    assert(not size is None)
    assert isinstance(size, Vector2), 'size must be Vector2'
    assert isinstance(keep_offsets, bool), 'keep_offsets must be bool'








    self._ptr.call_with_return(295,tuple([size._ptr, keep_offsets]))

  @functools.native_method
  def reset_size(self) -> None:
    r'''
				Resets the size to `get_combined_minimum_size`. This is equivalent to calling `set_size(Vector2())` (or any size below the minimum).
			'''




    self._ptr.call_with_return(296,tuple([]))

  @functools.native_method
  def set_custom_minimum_size(self, size:'Vector2'   ) -> None:
    r''''''

    assert(not size is None)
    assert isinstance(size, Vector2), 'size must be Vector2'


    self.py__custom_minimum_size = size






    self._ptr.call_with_return(297,tuple([size._ptr]))

  @functools.native_method
  def set_global_position(self, position:'Vector2'   , keep_offsets:'bool' =False  ) -> None:
    r'''
				Sets the `global_position` to given `position`.
				If `keep_offsets` is `true`, control's anchors will be updated instead of offsets.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'
    assert isinstance(keep_offsets, bool), 'keep_offsets must be bool'








    self._ptr.call_with_return(298,tuple([position._ptr, keep_offsets]))

  @functools.native_method
  def set_rotation(self, radians:'float'   ) -> None:
    r''''''

    assert isinstance(radians, (int, float)), 'radians must be int or float'


    self.py__rotation = radians






    self._ptr.call_with_return(299,tuple([radians]))

  @functools.native_method
  def set_rotation_degrees(self, degrees:'float'   ) -> None:
    r''''''

    assert isinstance(degrees, (int, float)), 'degrees must be int or float'


    self.py__rotation_degrees = degrees






    self._ptr.call_with_return(300,tuple([degrees]))

  @functools.native_method
  def set_scale(self, scale:'Vector2'   ) -> None:
    r''''''

    assert(not scale is None)
    assert isinstance(scale, Vector2), 'scale must be Vector2'


    self.py__scale = scale






    self._ptr.call_with_return(301,tuple([scale._ptr]))

  @functools.native_method
  def set_pivot_offset(self, pivot_offset:'Vector2'   ) -> None:
    r''''''

    assert(not pivot_offset is None)
    assert isinstance(pivot_offset, Vector2), 'pivot_offset must be Vector2'


    self.py__pivot_offset = pivot_offset






    self._ptr.call_with_return(302,tuple([pivot_offset._ptr]))

  @functools.native_method
  def get_begin(self) -> typing.Union['Vector2']:
    r'''
				Returns `offset_left` and `offset_top`. See also `position`.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(303,tuple([]))
    return _ret


  @functools.native_method
  def get_end(self) -> typing.Union['Vector2']:
    r'''
				Returns `offset_right` and `offset_bottom`.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(304,tuple([]))
    return _ret


  @functools.native_method
  def get_position(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(305,tuple([]))

    return _ret


  @functools.native_method
  def get_size(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(306,tuple([]))

    return _ret


  @functools.native_method
  def get_rotation(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(307,tuple([]))

    return _ret


  @functools.native_method
  def get_rotation_degrees(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(308,tuple([]))

    return _ret


  @functools.native_method
  def get_scale(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(309,tuple([]))

    return _ret


  @functools.native_method
  def get_pivot_offset(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(310,tuple([]))

    return _ret


  @functools.native_method
  def get_custom_minimum_size(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(311,tuple([]))

    return _ret


  @functools.native_method
  def get_parent_area_size(self) -> typing.Union['Vector2']:
    r'''
				Returns the width/height occupied in the parent control.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(312,tuple([]))
    return _ret


  @functools.native_method
  def get_global_position(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(313,tuple([]))

    return _ret


  @functools.native_method
  def get_screen_position(self) -> typing.Union['Vector2']:
    r'''
				Returns the position of this `Control` in global screen coordinates (i.e. taking window position into account). Mostly useful for editor plugins.
				Equivalent to `get_screen_transform().origin` (see `CanvasItem.get_screen_transform`).
				**Example:** Show a popup at the mouse position:
				```gdscript
				popup_menu.position = get_screen_position() + get_screen_transform().basis_xform(get_local_mouse_position())

				# The above code is equivalent to:
				popup_menu.position = get_screen_transform() * get_local_mouse_position()

				popup_menu.reset_size()
				popup_menu.popup()
				```
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(314,tuple([]))
    return _ret


  @functools.native_method
  def get_rect(self) -> typing.Union['Rect2']:
    r'''
				Returns the position and size of the control in the coordinate system of the containing node. See `position`, `scale` and `size`.
				**Note:** If `rotation` is not the default rotation, the resulting size is not meaningful.
				**Note:** Setting `Viewport.gui_snap_controls_to_pixels` to `true` can lead to rounding inaccuracies between the displayed control and the returned `Rect2`.
			'''




    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(315,tuple([]))
    return _ret


  @functools.native_method
  def get_global_rect(self) -> typing.Union['Rect2']:
    r'''
				Returns the position and size of the control relative to the containing canvas. See `global_position` and `size`.
				**Note:** If the node itself or any parent `CanvasItem` between the node and the canvas have a non default rotation or skew, the resulting size is likely not meaningful.
				**Note:** Setting `Viewport.gui_snap_controls_to_pixels` to `true` can lead to rounding inaccuracies between the displayed control and the returned `Rect2`.
			'''




    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(316,tuple([]))
    return _ret


  @functools.native_method
  def set_focus_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__focus_mode = mode






    self._ptr.call_with_return(317,tuple([mode]))

  @functools.native_method
  def get_focus_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(318,tuple([]))

    return _ret


  @functools.native_method
  def get_focus_mode_with_override(self) -> typing.Union[int]:
    r'''
				Returns the `focus_mode`, but takes the `focus_behavior_recursive` into account. If `focus_behavior_recursive` is set to `constant FOCUS_BEHAVIOR_DISABLED`, or it is set to `constant FOCUS_BEHAVIOR_INHERITED` and its ancestor is set to `constant FOCUS_BEHAVIOR_DISABLED`, then this returns `constant FOCUS_NONE`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(319,tuple([]))
    return _ret


  @functools.native_method
  def set_focus_behavior_recursive(self, focus_behavior_recursive:'int'  ) -> None:
    r''''''

    assert isinstance(focus_behavior_recursive, (int, float)), 'focus_behavior_recursive must be int or float'


    self.py__focus_behavior_recursive = focus_behavior_recursive






    self._ptr.call_with_return(320,tuple([focus_behavior_recursive]))

  @functools.native_method
  def get_focus_behavior_recursive(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(321,tuple([]))

    return _ret


  @functools.native_method
  def has_focus(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this is the current focused control. See `focus_mode`.
				If `ignore_hidden_focus` is `true`, controls that have their focus hidden will always return `false`. Hidden focus happens automatically when controls gain focus via mouse input, or manually using `grab_focus` with `hide_focus` set to `true`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(322,tuple([]))
    return _ret


  @functools.native_method
  def grab_focus(self) -> None:
    r'''
				Steal the focus from another control and become the focused control (see `focus_mode`).
				If `hide_focus` is `true`, the control will not visually show its focused state. Has no effect for `LineEdit` and `TextEdit` when `ProjectSettings.gui/common/show_focus_state_on_pointer_event` is set to `Control Supports Keyboard Input`, or for any control when it is set to `Always`.
				**Note:** Using this method together with `Callable.call_deferred` makes it more reliable, especially when called inside `Node._ready`.
			'''




    self._ptr.call_with_return(323,tuple([]))

  @functools.native_method
  def release_focus(self) -> None:
    r'''
				Give up the focus. No other control will be able to receive input.
			'''




    self._ptr.call_with_return(324,tuple([]))

  @functools.native_method
  def find_prev_valid_focus(self) -> typing.Any:
    r'''
				Finds the previous (above in the tree) `Control` that can receive the focus.
			'''




    _ret = Control.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(325,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def find_next_valid_focus(self) -> typing.Any:
    r'''
				Finds the next (below in the tree) `Control` that can receive the focus.
			'''




    _ret = Control.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(326,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def find_valid_focus_neighbor(self, side:'int'  ) -> typing.Any:
    r'''
				Finds the next `Control` that can receive the focus on the specified `enum Side`.
				**Note:** This is different from `get_focus_neighbor`, which returns the path of a specified focus neighbor.
			'''

    assert isinstance(side, (int, float)), 'side must be int or float'







    _ret = Control.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(327,tuple([side]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_h_size_flags(self, flags:'int'   ) -> None:
    r''''''

    assert isinstance(flags, (int, float)), 'flags must be int or float'


    self.py__size_flags_horizontal = flags






    self._ptr.call_with_return(328,tuple([flags]))

  @functools.native_method
  def get_h_size_flags(self) -> typing.Union[int]:
    r''''''




    _ret
    _ret = self._ptr.call_with_return(329,tuple([]))

    return _ret


  @functools.native_method
  def set_stretch_ratio(self, ratio:'float'   ) -> None:
    r''''''

    assert isinstance(ratio, (int, float)), 'ratio must be int or float'


    self.py__size_flags_stretch_ratio = ratio






    self._ptr.call_with_return(330,tuple([ratio]))

  @functools.native_method
  def get_stretch_ratio(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(331,tuple([]))

    return _ret


  @functools.native_method
  def set_v_size_flags(self, flags:'int'   ) -> None:
    r''''''

    assert isinstance(flags, (int, float)), 'flags must be int or float'


    self.py__size_flags_vertical = flags






    self._ptr.call_with_return(332,tuple([flags]))

  @functools.native_method
  def get_v_size_flags(self) -> typing.Union[int]:
    r''''''




    _ret
    _ret = self._ptr.call_with_return(333,tuple([]))

    return _ret


  @functools.native_method
  def set_theme(self, theme:'py4godot_theme.Theme'   ) -> None:
    r''''''

    assert(not theme is None)
    assert isinstance(theme, get_class('Theme')), 'theme must be Theme'


    self.py__theme = theme






    self._ptr.call_with_return(334,tuple([theme._ptr]))

  @functools.native_method
  def get_theme(self) -> typing.Union['py4godot_theme.Theme']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Theme
    _ret._ptr = self._ptr.call_with_return(335,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_theme_type_variation(self, theme_type:'object'   ) -> None:
    r''''''

    assert(not theme_type is None)
    assert isinstance(theme_type, (str, StringName)), 'theme_type must be str or StringName'


    self.py__theme_type_variation = theme_type



    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)


    self._ptr.call_with_return(336,tuple([py_stringname_theme_type._ptr]))

  @functools.native_method
  def get_theme_type_variation(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(337,tuple([]))

    return str(_ret)


  @functools.native_method
  def begin_bulk_theme_override(self) -> None:
    r'''
				Prevents `*_theme_*_override` methods from emitting `constant NOTIFICATION_THEME_CHANGED` until `end_bulk_theme_override` is called.
			'''




    self._ptr.call_with_return(338,tuple([]))

  @functools.native_method
  def end_bulk_theme_override(self) -> None:
    r'''
				Ends a bulk theme override update. See `begin_bulk_theme_override`.
			'''




    self._ptr.call_with_return(339,tuple([]))

  @functools.native_method
  def add_theme_icon_override(self, name:'object'   , texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Creates a local override for a theme icon with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with `remove_theme_icon_override`.
				See also `get_theme_icon`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(340,tuple([py_stringname_name._ptr, texture._ptr]))

  @functools.native_method
  def add_theme_stylebox_override(self, name:'object'   , stylebox:'py4godot_stylebox.StyleBox'   ) -> None:
    r'''
				Creates a local override for a theme `StyleBox` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with `remove_theme_stylebox_override`.
				See also `get_theme_stylebox`.
				**Example:** Modify a property in a `StyleBox` by duplicating it:
				
				```gdscript
				# The snippet below assumes the child node "MyButton" has a StyleBoxFlat assigned.
				# Resources are shared across instances, so we need to duplicate it
				# to avoid modifying the appearance of all other buttons.
				var new_stylebox_normal = $MyButton.get_theme_stylebox("normal").duplicate()
				new_stylebox_normal.border_width_top = 3
				new_stylebox_normal.border_color = Color(0, 1, 0.5)
				$MyButton.add_theme_stylebox_override("normal", new_stylebox_normal)
				# Remove the stylebox override.
				$MyButton.remove_theme_stylebox_override("normal")
				```
				
				
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not stylebox is None)
    assert isinstance(stylebox, get_class('StyleBox')), 'stylebox must be StyleBox'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(341,tuple([py_stringname_name._ptr, stylebox._ptr]))

  @functools.native_method
  def add_theme_font_override(self, name:'object'   , font:'py4godot_font.Font'   ) -> None:
    r'''
				Creates a local override for a theme `Font` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with `remove_theme_font_override`.
				See also `get_theme_font`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(342,tuple([py_stringname_name._ptr, font._ptr]))

  @functools.native_method
  def add_theme_font_size_override(self, name:'object'   , font_size:'int'   ) -> None:
    r'''
				Creates a local override for a theme font size with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with `remove_theme_font_size_override`.
				See also `get_theme_font_size`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(343,tuple([py_stringname_name._ptr, font_size]))

  @functools.native_method
  def add_theme_color_override(self, name:'object'   , color:'Color'   ) -> None:
    r'''
				Creates a local override for a theme `Color` with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with `remove_theme_color_override`.
				See also `get_theme_color`.
				**Example:** Override a `Label`'s color and reset it later:
				
				```gdscript
				# Given the child Label node "MyLabel", override its font color with a custom value.
				$MyLabel.add_theme_color_override("font_color", Color(1, 0.5, 0))
				# Reset the font color of the child label.
				$MyLabel.remove_theme_color_override("font_color")
				# Alternatively it can be overridden with the default value from the Label type.
				$MyLabel.add_theme_color_override("font_color", get_theme_color("font_color", "Label"))
				```
				
				
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(344,tuple([py_stringname_name._ptr, color._ptr]))

  @functools.native_method
  def add_theme_constant_override(self, name:'object'   , constant:'int'   ) -> None:
    r'''
				Creates a local override for a theme constant with the specified `name`. Local overrides always take precedence when fetching theme items for the control. An override can be removed with `remove_theme_constant_override`.
				See also `get_theme_constant`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(constant, (int, float)), 'constant must be int or float'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(345,tuple([py_stringname_name._ptr, constant]))

  @functools.native_method
  def remove_theme_icon_override(self, name:'object'   ) -> None:
    r'''
				Removes a local override for a theme icon with the specified `name` previously added by `add_theme_icon_override` or via the Inspector dock.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(346,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def remove_theme_stylebox_override(self, name:'object'   ) -> None:
    r'''
				Removes a local override for a theme `StyleBox` with the specified `name` previously added by `add_theme_stylebox_override` or via the Inspector dock.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(347,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def remove_theme_font_override(self, name:'object'   ) -> None:
    r'''
				Removes a local override for a theme `Font` with the specified `name` previously added by `add_theme_font_override` or via the Inspector dock.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(348,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def remove_theme_font_size_override(self, name:'object'   ) -> None:
    r'''
				Removes a local override for a theme font size with the specified `name` previously added by `add_theme_font_size_override` or via the Inspector dock.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(349,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def remove_theme_color_override(self, name:'object'   ) -> None:
    r'''
				Removes a local override for a theme `Color` with the specified `name` previously added by `add_theme_color_override` or via the Inspector dock.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(350,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def remove_theme_constant_override(self, name:'object'   ) -> None:
    r'''
				Removes a local override for a theme constant with the specified `name` previously added by `add_theme_constant_override` or via the Inspector dock.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(351,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def get_theme_icon(self, name:'object'   , theme_type:'object' = None  ) -> typing.Any:
    r'''
				Returns an icon from the first matching `Theme` in the tree if that `Theme` has an icon item with the specified `name` and `theme_type`.
				See `get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(352,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_theme_stylebox(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union['py4godot_styleboxtexture.StyleBoxTexture','py4godot_stylebox.StyleBox','py4godot_styleboxempty.StyleBoxEmpty','py4godot_styleboxflat.StyleBoxFlat','py4godot_styleboxline.StyleBoxLine']:
    r'''
				Returns a `StyleBox` from the first matching `Theme` in the tree if that `Theme` has a stylebox item with the specified `name` and `theme_type`.
				See `get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: StyleBox
    _ret._ptr = self._ptr.call_with_return(353,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_theme_font(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union['py4godot_systemfont.SystemFont','py4godot_fontfile.FontFile','py4godot_fontvariation.FontVariation','py4godot_font.Font']:
    r'''
				Returns a `Font` from the first matching `Theme` in the tree if that `Theme` has a font item with the specified `name` and `theme_type`.
				See `get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Font
    _ret._ptr = self._ptr.call_with_return(354,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_theme_font_size(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[int]:
    r'''
				Returns a font size from the first matching `Theme` in the tree if that `Theme` has a font size item with the specified `name` and `theme_type`.
				See `get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(355,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def get_theme_color(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union['Color']:
    r'''
				Returns a `Color` from the first matching `Theme` in the tree if that `Theme` has a color item with the specified `name` and `theme_type`. If `theme_type` is omitted the class name of the current control is used as the type, or `theme_type_variation` if it is defined. If the type is a class name its parent classes are also checked, in order of inheritance. If the type is a variation its base types are checked, in order of dependency, then the control's class name and its parent classes are checked.
				For the current control its local overrides are considered first (see `add_theme_color_override`), then its assigned `theme`. After the current control, each parent control and its assigned `theme` are considered; controls without a `theme` assigned are skipped. If no matching `Theme` is found in the tree, the custom project `Theme` (see `ProjectSettings.gui/theme/custom`) and the default `Theme` are used (see `ThemeDB`).
				
				```gdscript
				func _ready():
					# Get the font color defined for the current Control's class, if it exists.
					modulate = get_theme_color("font_color")
					# Get the font color defined for the Button class.
					modulate = get_theme_color("font_color", "Button")
				```
				
				
			'''
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(356,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def get_theme_constant(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[int]:
    r'''
				Returns a constant from the first matching `Theme` in the tree if that `Theme` has a constant item with the specified `name` and `theme_type`.
				See `get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(357,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_theme_icon_override(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a local override for a theme icon with the specified `name` in this `Control` node.
				See `add_theme_icon_override`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(358,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def has_theme_stylebox_override(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a local override for a theme `StyleBox` with the specified `name` in this `Control` node.
				See `add_theme_stylebox_override`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(359,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def has_theme_font_override(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a local override for a theme `Font` with the specified `name` in this `Control` node.
				See `add_theme_font_override`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(360,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def has_theme_font_size_override(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a local override for a theme font size with the specified `name` in this `Control` node.
				See `add_theme_font_size_override`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(361,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def has_theme_color_override(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a local override for a theme `Color` with the specified `name` in this `Control` node.
				See `add_theme_color_override`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(362,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def has_theme_constant_override(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a local override for a theme constant with the specified `name` in this `Control` node.
				See `add_theme_constant_override`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(363,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def has_theme_icon(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a matching `Theme` in the tree that has an icon item with the specified `name` and `theme_type`.
				See `get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(364,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_theme_stylebox(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a matching `Theme` in the tree that has a stylebox item with the specified `name` and `theme_type`.
				See `get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(365,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_theme_font(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a matching `Theme` in the tree that has a font item with the specified `name` and `theme_type`.
				See `get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(366,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_theme_font_size(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a matching `Theme` in the tree that has a font size item with the specified `name` and `theme_type`.
				See `get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(367,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_theme_color(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a matching `Theme` in the tree that has a color item with the specified `name` and `theme_type`.
				See `get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(368,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def has_theme_constant(self, name:'object'   , theme_type:'object' = None  ) -> typing.Union[bool]:
    r'''
				Returns `true` if there is a matching `Theme` in the tree that has a constant item with the specified `name` and `theme_type`.
				See `get_theme_color` for details.
			'''
    if theme_type is None:
      theme_type = StringName.new0()

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(theme_type, (str, StringName)))
    py_stringname_theme_type = theme_type if isinstance(theme_type, StringName) else c_utils.py_string_to_string_name(theme_type)

    _ret = 0
    _ret = self._ptr.call_with_return(369,tuple([py_stringname_name._ptr, py_stringname_theme_type._ptr]))
    return _ret


  @functools.native_method
  def get_theme_default_base_scale(self) -> typing.Union[float]:
    r'''
				Returns the default base scale value from the first matching `Theme` in the tree if that `Theme` has a valid `Theme.default_base_scale` value.
				See `get_theme_color` for details.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(370,tuple([]))
    return _ret


  @functools.native_method
  def get_theme_default_font(self) -> typing.Union['py4godot_systemfont.SystemFont','py4godot_fontfile.FontFile','py4godot_fontvariation.FontVariation','py4godot_font.Font']:
    r'''
				Returns the default font from the first matching `Theme` in the tree if that `Theme` has a valid `Theme.default_font` value.
				See `get_theme_color` for details.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Font
    _ret._ptr = self._ptr.call_with_return(371,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_theme_default_font_size(self) -> typing.Union[int]:
    r'''
				Returns the default font size value from the first matching `Theme` in the tree if that `Theme` has a valid `Theme.default_font_size` value.
				See `get_theme_color` for details.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(372,tuple([]))
    return _ret


  @functools.native_method
  def get_parent_control(self) -> typing.Any:
    r'''
				Returns the parent control node.
			'''




    _ret = Control.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(373,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_h_grow_direction(self, direction:'int'  ) -> None:
    r''''''

    assert isinstance(direction, (int, float)), 'direction must be int or float'


    self.py__grow_horizontal = direction






    self._ptr.call_with_return(374,tuple([direction]))

  @functools.native_method
  def get_h_grow_direction(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(375,tuple([]))

    return _ret


  @functools.native_method
  def set_v_grow_direction(self, direction:'int'  ) -> None:
    r''''''

    assert isinstance(direction, (int, float)), 'direction must be int or float'


    self.py__grow_vertical = direction






    self._ptr.call_with_return(376,tuple([direction]))

  @functools.native_method
  def get_v_grow_direction(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(377,tuple([]))

    return _ret


  @functools.native_method
  def set_tooltip_auto_translate_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__tooltip_auto_translate_mode = mode






    self._ptr.call_with_return(378,tuple([mode]))

  @functools.native_method
  def get_tooltip_auto_translate_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(379,tuple([]))

    return _ret


  @functools.native_method
  def set_tooltip_text(self, hint:'str'   ) -> None:
    r''''''

    assert(not hint is None)
    assert isinstance(hint, (str, String)), 'hint must be str or String'


    self.py__tooltip_text = hint



    assert(isinstance(hint, (str, String)))
    py_string_hint = hint if isinstance(hint, StringName) else c_utils.py_string_to_string(hint)

    py__string_hint = utils.py_string_to_string(hint)
    py__string_hint.shouldBeDeleted = False


    self._ptr.call_with_return(380,tuple([py__string_hint._ptr]))

  @functools.native_method
  def get_tooltip_text(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(381,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_tooltip(self, at_position:'Vector2' = None  ) -> typing.Union[str]:
    r'''
				Returns the tooltip text for the position `at_position` in control's local coordinates, which will typically appear when the cursor is resting over this control. By default, it returns `tooltip_text`.
				This method can be overridden to customize its behavior. See `_get_tooltip`.
				**Note:** If this method returns an empty `String` and `_make_custom_tooltip` is not overridden, no tooltip is displayed.
			'''
    if at_position is None:
      at_position = Vector2.new0()








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(382,tuple([at_position._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_default_cursor_shape(self, shape:'int'  ) -> None:
    r''''''

    assert isinstance(shape, (int, float)), 'shape must be int or float'


    self.py__mouse_default_cursor_shape = shape






    self._ptr.call_with_return(383,tuple([shape]))

  @functools.native_method
  def get_default_cursor_shape(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(384,tuple([]))

    return _ret


  @functools.native_method
  def get_cursor_shape(self, position:'Vector2' = None  ) -> typing.Union[int]:
    r'''
				Returns the mouse cursor shape for this control when hovered over `position` in local coordinates. For most controls, this is the same as `mouse_default_cursor_shape`, but some built-in controls implement more complex logic.
			'''
    if position is None:
      position = Vector2.new0()








    _ret:int
    _ret = self._ptr.call_with_return(385,tuple([position._ptr]))
    return _ret


  @functools.native_method
  def set_focus_neighbor(self, side:'int'  , neighbor:'object'   ) -> None:
    r'''
				Sets the focus neighbor for the specified `enum Side` to the `Control` at `neighbor` node path. A setter method for `focus_neighbor_bottom`, `focus_neighbor_left`, `focus_neighbor_right` and `focus_neighbor_top`.
			'''

    assert isinstance(side, (int, float)), 'side must be int or float'
    assert(not neighbor is None)
    assert isinstance(neighbor, (str, NodePath)), 'neighbor must be str or NodePath'


    self.py__focus_neighbor_left = side




    assert(isinstance(neighbor, (str, NodePath)))
    py_nodepath_neighbor = neighbor if isinstance(neighbor,NodePath) else NodePath.new2(neighbor)


    self._ptr.call_with_return(386,tuple([side, py_nodepath_neighbor._ptr]))

  @functools.native_method
  def get_focus_neighbor(self, side:'int'  ) -> typing.Union['NodePath']:
    r'''
				Returns the focus neighbor for the specified `enum Side`. A getter method for `focus_neighbor_bottom`, `focus_neighbor_left`, `focus_neighbor_right` and `focus_neighbor_top`.
				**Note:** To find the next `Control` on the specific `enum Side`, even if a neighbor is not assigned, use `find_valid_focus_neighbor`.
			'''

    assert isinstance(side, (int, float)), 'side must be int or float'







    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(387,tuple([side]))

    return _ret


  @functools.native_method
  def set_focus_next(self, next:'object'   ) -> None:
    r''''''

    assert(not next is None)
    assert isinstance(next, (str, NodePath)), 'next must be str or NodePath'


    self.py__focus_next = next



    assert(isinstance(next, (str, NodePath)))
    py_nodepath_next = next if isinstance(next,NodePath) else NodePath.new2(next)


    self._ptr.call_with_return(388,tuple([py_nodepath_next._ptr]))

  @functools.native_method
  def get_focus_next(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(389,tuple([]))

    return _ret


  @functools.native_method
  def set_focus_previous(self, previous:'object'   ) -> None:
    r''''''

    assert(not previous is None)
    assert isinstance(previous, (str, NodePath)), 'previous must be str or NodePath'


    self.py__focus_previous = previous



    assert(isinstance(previous, (str, NodePath)))
    py_nodepath_previous = previous if isinstance(previous,NodePath) else NodePath.new2(previous)


    self._ptr.call_with_return(390,tuple([py_nodepath_previous._ptr]))

  @functools.native_method
  def get_focus_previous(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(391,tuple([]))

    return _ret


  @functools.native_method
  def force_drag(self, data:'object'   , preview:'Control'   ) -> None:
    r'''
				Forces drag and bypasses `_get_drag_data` and `set_drag_preview` by passing `data` and `preview`. Drag will start even if the mouse is neither over nor pressed on this control.
				The methods `_can_drop_data` and `_drop_data` must be implemented on controls that want to receive drop data.
			'''

    
    assert(not preview is None)
    assert isinstance(preview, get_class('Control')), 'preview must be Control'

    if not (type(data).__name__ in py4godot.variant_types.core_types or isinstance(data, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'data': "
                f"{type(data).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    self._ptr.call_with_return(392,tuple([data, preview._ptr]))

  @functools.native_method
  def accessibility_drag(self) -> None:
    r'''
				Starts drag-and-drop operation without using a mouse.
			'''




    self._ptr.call_with_return(393,tuple([]))

  @functools.native_method
  def accessibility_drop(self) -> None:
    r'''
				Ends drag-and-drop operation without using a mouse.
			'''




    self._ptr.call_with_return(394,tuple([]))

  @functools.native_method
  def set_accessibility_name(self, name:'str'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'


    self.py__accessibility_name = name



    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    py__string_name = utils.py_string_to_string(name)
    py__string_name.shouldBeDeleted = False


    self._ptr.call_with_return(395,tuple([py__string_name._ptr]))

  @functools.native_method
  def get_accessibility_name(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(396,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_accessibility_description(self, description:'str'   ) -> None:
    r''''''

    assert(not description is None)
    assert isinstance(description, (str, String)), 'description must be str or String'


    self.py__accessibility_description = description



    assert(isinstance(description, (str, String)))
    py_string_description = description if isinstance(description, StringName) else c_utils.py_string_to_string(description)

    py__string_description = utils.py_string_to_string(description)
    py__string_description.shouldBeDeleted = False


    self._ptr.call_with_return(397,tuple([py__string_description._ptr]))

  @functools.native_method
  def get_accessibility_description(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(398,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_accessibility_live(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__accessibility_live = mode






    self._ptr.call_with_return(399,tuple([mode]))

  @functools.native_method
  def get_accessibility_live(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(400,tuple([]))

    return _ret


  @functools.native_method
  def set_accessibility_controls_nodes(self, node_path:'py4godot_nodepathtypedarray.NodePathTypedArray'   ) -> None:
    r''''''

    assert isinstance(node_path, Array), 'node_path must be Array'


    self.py__accessibility_controls_nodes = node_path






    self._ptr.call_with_return(401,tuple([node_path._ptr]))

  @functools.native_method
  def get_accessibility_controls_nodes(self) -> typing.Union['py4godot_nodepathtypedarray.NodePathTypedArray']:
    r''''''




    _ret = py4godot_nodepathtypedarray.NodePathTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(402,tuple([]))

    return _ret


  @functools.native_method
  def set_accessibility_described_by_nodes(self, node_path:'py4godot_nodepathtypedarray.NodePathTypedArray'   ) -> None:
    r''''''

    assert isinstance(node_path, Array), 'node_path must be Array'


    self.py__accessibility_described_by_nodes = node_path






    self._ptr.call_with_return(403,tuple([node_path._ptr]))

  @functools.native_method
  def get_accessibility_described_by_nodes(self) -> typing.Union['py4godot_nodepathtypedarray.NodePathTypedArray']:
    r''''''




    _ret = py4godot_nodepathtypedarray.NodePathTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(404,tuple([]))

    return _ret


  @functools.native_method
  def set_accessibility_labeled_by_nodes(self, node_path:'py4godot_nodepathtypedarray.NodePathTypedArray'   ) -> None:
    r''''''

    assert isinstance(node_path, Array), 'node_path must be Array'


    self.py__accessibility_labeled_by_nodes = node_path






    self._ptr.call_with_return(405,tuple([node_path._ptr]))

  @functools.native_method
  def get_accessibility_labeled_by_nodes(self) -> typing.Union['py4godot_nodepathtypedarray.NodePathTypedArray']:
    r''''''




    _ret = py4godot_nodepathtypedarray.NodePathTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(406,tuple([]))

    return _ret


  @functools.native_method
  def set_accessibility_flow_to_nodes(self, node_path:'py4godot_nodepathtypedarray.NodePathTypedArray'   ) -> None:
    r''''''

    assert isinstance(node_path, Array), 'node_path must be Array'


    self.py__accessibility_flow_to_nodes = node_path






    self._ptr.call_with_return(407,tuple([node_path._ptr]))

  @functools.native_method
  def get_accessibility_flow_to_nodes(self) -> typing.Union['py4godot_nodepathtypedarray.NodePathTypedArray']:
    r''''''




    _ret = py4godot_nodepathtypedarray.NodePathTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(408,tuple([]))

    return _ret


  @functools.native_method
  def set_mouse_filter(self, filter:'int'  ) -> None:
    r''''''

    assert isinstance(filter, (int, float)), 'filter must be int or float'


    self.py__mouse_filter = filter






    self._ptr.call_with_return(409,tuple([filter]))

  @functools.native_method
  def get_mouse_filter(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(410,tuple([]))

    return _ret


  @functools.native_method
  def get_mouse_filter_with_override(self) -> typing.Union[int]:
    r'''
				Returns the `mouse_filter`, but takes the `mouse_behavior_recursive` into account. If `mouse_behavior_recursive` is set to `constant MOUSE_BEHAVIOR_DISABLED`, or it is set to `constant MOUSE_BEHAVIOR_INHERITED` and its ancestor is set to `constant MOUSE_BEHAVIOR_DISABLED`, then this returns `constant MOUSE_FILTER_IGNORE`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(411,tuple([]))
    return _ret


  @functools.native_method
  def set_mouse_behavior_recursive(self, mouse_behavior_recursive:'int'  ) -> None:
    r''''''

    assert isinstance(mouse_behavior_recursive, (int, float)), 'mouse_behavior_recursive must be int or float'


    self.py__mouse_behavior_recursive = mouse_behavior_recursive






    self._ptr.call_with_return(412,tuple([mouse_behavior_recursive]))

  @functools.native_method
  def get_mouse_behavior_recursive(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(413,tuple([]))

    return _ret


  @functools.native_method
  def set_force_pass_scroll_events(self, force_pass_scroll_events:'bool'   ) -> None:
    r''''''

    assert isinstance(force_pass_scroll_events, bool), 'force_pass_scroll_events must be bool'


    self.py__mouse_force_pass_scroll_events = force_pass_scroll_events






    self._ptr.call_with_return(414,tuple([force_pass_scroll_events]))

  @functools.native_method
  def is_force_pass_scroll_events(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(415,tuple([]))

    return _ret


  @functools.native_method
  def set_clip_contents(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__clip_contents = enable






    self._ptr.call_with_return(416,tuple([enable]))

  @functools.native_method
  def is_clipping_contents(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(417,tuple([]))

    return _ret


  @functools.native_method
  def grab_click_focus(self) -> None:
    r'''
				Creates an `InputEventMouseButton` that attempts to click the control. If the event is received, the control gains focus.
				
				```gdscript
				func _process(delta):
					grab_click_focus() # When clicking another Control node, this node will be clicked instead.
				```
				
				
			'''




    self._ptr.call_with_return(418,tuple([]))

  @functools.native_method
  def set_drag_forwarding(self, drag_func:'Callable'   , can_drop_func:'Callable'   , drop_func:'Callable'   ) -> None:
    r'''
				Sets the given callables to be used instead of the control's own drag-and-drop virtual methods. If a callable is empty, its respective virtual method is used as normal.
				The arguments for each callable should be exactly the same as their respective virtual methods, which would be:
				- `drag_func` corresponds to `_get_drag_data` and requires a `Vector2`;
				- `can_drop_func` corresponds to `_can_drop_data` and requires both a `Vector2` and a `Variant`;
				- `drop_func` corresponds to `_drop_data` and requires both a `Vector2` and a `Variant`.
			'''

    assert(not drag_func is None)
    assert isinstance(drag_func, Callable), 'drag_func must be Callable'
    assert(not can_drop_func is None)
    assert isinstance(can_drop_func, Callable), 'can_drop_func must be Callable'
    assert(not drop_func is None)
    assert isinstance(drop_func, Callable), 'drop_func must be Callable'









    self._ptr.call_with_return(419,tuple([drag_func._ptr, can_drop_func._ptr, drop_func._ptr]))

  @functools.native_method
  def set_drag_preview(self, control:'Control'   ) -> None:
    r'''
				Shows the given control at the mouse pointer. A good time to call this method is in `_get_drag_data`. The control must not be in the scene tree. You should not free the control, and you should not keep a reference to the control beyond the duration of the drag. It will be deleted automatically after the drag has ended.
				
				```gdscript
				@export var color = Color(1, 0, 0, 1)

				func _get_drag_data(position):
					# Use a control that is not in the tree
					var cpb = ColorPickerButton.new()
					cpb.color = color
					cpb.size = Vector2(50, 50)
					set_drag_preview(cpb)
					return color
				```
				
				
			'''

    assert(not control is None)
    assert isinstance(control, get_class('Control')), 'control must be Control'







    self._ptr.call_with_return(420,tuple([control._ptr]))

  @functools.native_method
  def is_drag_successful(self) -> typing.Union[bool]:
    r'''
				Returns `true` if a drag operation is successful. Alternative to `Viewport.gui_is_drag_successful`.
				Best used with `constant Node.NOTIFICATION_DRAG_END`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(421,tuple([]))
    return _ret


  @functools.native_method
  def warp_mouse(self, position:'Vector2'   ) -> None:
    r'''
				Moves the mouse cursor to `position`, relative to `position` of this `Control`.
				**Note:** `warp_mouse` is only supported on Windows, macOS and Linux. It has no effect on Android, iOS and Web.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'







    self._ptr.call_with_return(422,tuple([position._ptr]))

  @functools.native_method
  def set_shortcut_context(self, node:'py4godot_node.Node'   ) -> None:
    r''''''

    assert(not node is None)
    assert isinstance(node, get_class('Node')), 'node must be Node'


    self.py__shortcut_context = node






    self._ptr.call_with_return(423,tuple([node._ptr]))

  @functools.native_method
  def get_shortcut_context(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Node
    _ret._ptr = self._ptr.call_with_return(424,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def update_minimum_size(self) -> None:
    r'''
				Invalidates the size cache in this node and in parent nodes up to top level. Intended to be used with `get_minimum_size` when the return value is changed. Setting `custom_minimum_size` directly calls this method automatically.
			'''




    self._ptr.call_with_return(425,tuple([]))

  @functools.native_method
  def set_layout_direction(self, direction:'int'  ) -> None:
    r''''''

    assert isinstance(direction, (int, float)), 'direction must be int or float'


    self.py__layout_direction = direction






    self._ptr.call_with_return(426,tuple([direction]))

  @functools.native_method
  def get_layout_direction(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(427,tuple([]))

    return _ret


  @functools.native_method
  def is_layout_rtl(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the layout is right-to-left. See also `layout_direction`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(428,tuple([]))
    return _ret


  @functools.native_method
  def set_auto_translate(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__auto_translate = enable






    self._ptr.call_with_return(429,tuple([enable]))

  @functools.native_method
  def is_auto_translating(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(430,tuple([]))

    return _ret


  @functools.native_method
  def set_localize_numeral_system(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__localize_numeral_system = enable






    self._ptr.call_with_return(431,tuple([enable]))

  @functools.native_method
  def is_localizing_numeral_system(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(432,tuple([]))

    return _ret



register_cast_function('Control', Control.cast)
register_class('Control', Control)
