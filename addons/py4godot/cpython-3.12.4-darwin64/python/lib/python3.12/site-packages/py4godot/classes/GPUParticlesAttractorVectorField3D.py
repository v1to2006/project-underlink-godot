# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.CompressedTexture3D as py4godot_compressedtexture3d 
  import py4godot.classes.NoiseTexture3D as py4godot_noisetexture3d 
  import py4godot.classes.PlaceholderTexture3D as py4godot_placeholdertexture3d 
  import py4godot.classes.ImageTexture3D as py4godot_imagetexture3d 
  import py4godot.classes.Texture3D as py4godot_texture3d 
  import py4godot.classes.Texture3DRD as py4godot_texture3drd 
import py4godot.classes.GPUParticlesAttractor3D as py4godot_gpuparticlesattractor3d 
from py4godot.wrappers.wrappers import CPPGPUParticlesAttractorVectorField3DWrapper


class GPUParticlesAttractorVectorField3D(py4godot_gpuparticlesattractor3d.GPUParticlesAttractor3D):
  r'''
		A box-shaped attractor with varying directions and strengths defined in it that influences particles from `GPUParticles3D` nodes.
		Unlike `GPUParticlesAttractorBox3D`, `GPUParticlesAttractorVectorField3D` uses a `texture` to affect attraction strength within the box. This can be used to create complex attraction scenarios where particles travel in different directions depending on their location. This can be useful for weather effects such as sandstorms.
		Particle attractors work in real-time and can be moved, rotated and scaled during gameplay. Unlike collision shapes, non-uniform scaling of attractors is also supported.
		**Note:** Particle attractors only affect `GPUParticles3D`, not `CPUParticles3D`.
	'''

  @staticmethod
  def constructor():
    class_ = GPUParticlesAttractorVectorField3D.construct_without_init()
    class_._ptr = constructor(369,0, ())
    return class_
  @staticmethod
  def new():
    class_ = GPUParticlesAttractorVectorField3D.construct_without_init()
    class_._ptr = constructor(369,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPGPUParticlesAttractorVectorField3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(369,0, ())


  def generate_wrapper(self):
    return CPPGPUParticlesAttractorVectorField3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = GPUParticlesAttractorVectorField3D.__new__(GPUParticlesAttractorVectorField3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'GPUParticlesAttractorVectorField3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = GPUParticlesAttractorVectorField3D.construct_without_init()
    cls._ptr = CPPGPUParticlesAttractorVectorField3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = GPUParticlesAttractorVectorField3D.construct_without_init()
    cls._ptr = CPPGPUParticlesAttractorVectorField3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def size(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_size()
    return _ret
  @size.setter
  def size(self,  value:'Vector3'):
    self.set_size(value)
  @property
  def texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture()
    return _ret
  @texture.setter
  def texture(self,  value:'py4godot_object.Object'):
    self.set_texture(value)
  @functools.native_method
  def set_size(self, size:'Vector3'   ) -> None:
    r''''''

    assert(not size is None)
    assert isinstance(size, Vector3), 'size must be Vector3'


    self.py__size = size






    self._ptr.call_with_return(272,tuple([size._ptr]))

  @functools.native_method
  def get_size(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(273,tuple([]))

    return _ret


  @functools.native_method
  def set_texture(self, texture:'py4godot_texture3d.Texture3D'   ) -> None:
    r''''''

    assert(not texture is None)
    assert isinstance(texture, get_class('Texture3D')), 'texture must be Texture3D'


    self.py__texture = texture






    self._ptr.call_with_return(274,tuple([texture._ptr]))

  @functools.native_method
  def get_texture(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture3D
    _ret._ptr = self._ptr.call_with_return(275,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('GPUParticlesAttractorVectorField3D', GPUParticlesAttractorVectorField3D.cast)
register_class('GPUParticlesAttractorVectorField3D', GPUParticlesAttractorVectorField3D)
