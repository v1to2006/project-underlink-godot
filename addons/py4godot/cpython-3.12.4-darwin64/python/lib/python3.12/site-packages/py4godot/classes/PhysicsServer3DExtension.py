# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.RIDTypedArray as py4godot_ridtypedarray 
  import py4godot.classes.PhysicsDirectSpaceState3DExtension as py4godot_physicsdirectspacestate3dextension 
  import py4godot.classes.PhysicsDirectSpaceState3D as py4godot_physicsdirectspacestate3d 
  import py4godot.classes.PhysicsDirectBodyState3DExtension as py4godot_physicsdirectbodystate3dextension 
  import py4godot.classes.PhysicsDirectBodyState3D as py4godot_physicsdirectbodystate3d 
  import py4godot.classes.PhysicsServer3DRenderingServerHandler as py4godot_physicsserver3drenderingserverhandler 
import py4godot.classes.RIDTypedArray as py4godot_ridtypedarray 
import py4godot.classes.PhysicsServer3D as py4godot_physicsserver3d 
from py4godot.wrappers.wrappers import CPPPhysicsServer3DExtensionWrapper


class PhysicsServer3DExtension(py4godot_physicsserver3d.PhysicsServer3D):
  r'''
		This class extends `PhysicsServer3D` by providing additional virtual methods that can be overridden. When these methods are overridden, they will be called instead of the internal methods of the physics server.
		Intended for use with GDExtension to create custom implementations of `PhysicsServer3D`.
	'''

  @staticmethod
  def constructor():
    class_ = PhysicsServer3DExtension.construct_without_init()
    class_._ptr = constructor(608,0, ())
    return class_
  @staticmethod
  def new():
    class_ = PhysicsServer3DExtension.construct_without_init()
    class_._ptr = constructor(608,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPPhysicsServer3DExtensionWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(608,0, ())


  def generate_wrapper(self):
    return CPPPhysicsServer3DExtensionWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = PhysicsServer3DExtension.__new__(PhysicsServer3DExtension)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PhysicsServer3DExtension'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = PhysicsServer3DExtension.construct_without_init()
    cls._ptr = CPPPhysicsServer3DExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = PhysicsServer3DExtension.construct_without_init()
    cls._ptr = CPPPhysicsServer3DExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _world_boundary_shape_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(224,tuple([]))
    return _ret


  @functools.native_method
  def _separation_ray_shape_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(225,tuple([]))
    return _ret


  @functools.native_method
  def _sphere_shape_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(226,tuple([]))
    return _ret


  @functools.native_method
  def _box_shape_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(227,tuple([]))
    return _ret


  @functools.native_method
  def _capsule_shape_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(228,tuple([]))
    return _ret


  @functools.native_method
  def _cylinder_shape_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(229,tuple([]))
    return _ret


  @functools.native_method
  def _convex_polygon_shape_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(230,tuple([]))
    return _ret


  @functools.native_method
  def _concave_polygon_shape_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(231,tuple([]))
    return _ret


  @functools.native_method
  def _heightmap_shape_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(232,tuple([]))
    return _ret


  @functools.native_method
  def _custom_shape_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(233,tuple([]))
    return _ret


  @functools.native_method
  def _shape_set_data(self, shape:'RID'   , data:'object'   ) -> None:
    r'''
'''

    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'
    

    if not (type(data).__name__ in py4godot.variant_types.core_types or isinstance(data, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'data': "
                f"{type(data).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    self._ptr.call_with_return(234,tuple([shape._ptr, data]))

  @functools.native_method
  def _shape_set_custom_solver_bias(self, shape:'RID'   , bias:'float'   ) -> None:
    r'''
'''

    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'
    assert isinstance(bias, (int, float)), 'bias must be int or float'








    self._ptr.call_with_return(235,tuple([shape._ptr, bias]))

  @functools.native_method
  def _shape_set_margin(self, shape:'RID'   , margin:'float'   ) -> None:
    r'''
'''

    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'
    assert isinstance(margin, (int, float)), 'margin must be int or float'








    self._ptr.call_with_return(236,tuple([shape._ptr, margin]))

  @functools.native_method
  def _shape_get_margin(self, shape:'RID'   ) -> typing.Union[float]:
    r'''
'''

    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(237,tuple([shape._ptr]))
    return _ret


  @functools.native_method
  def _shape_get_type(self, shape:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(238,tuple([shape._ptr]))
    return _ret


  @functools.native_method
  def _shape_get_data(self, shape:'RID'   ) -> typing.Union[typing.Any]:
    r'''
'''

    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'







    _ret = None
    _ret = self._ptr.call_with_return(239,tuple([shape._ptr]))
    return _ret


  @functools.native_method
  def _shape_get_custom_solver_bias(self, shape:'RID'   ) -> typing.Union[float]:
    r'''
'''

    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(240,tuple([shape._ptr]))
    return _ret


  @functools.native_method
  def _space_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(241,tuple([]))
    return _ret


  @functools.native_method
  def _space_set_active(self, space:'RID'   , active:'bool'   ) -> None:
    r'''
'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'
    assert isinstance(active, bool), 'active must be bool'








    self._ptr.call_with_return(242,tuple([space._ptr, active]))

  @functools.native_method
  def _space_is_active(self, space:'RID'   ) -> typing.Union[bool]:
    r'''
'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(243,tuple([space._ptr]))
    return _ret


  @functools.native_method
  def _space_set_param(self, space:'RID'   , param:'int'  , value:'float'   ) -> None:
    r'''
'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'









    self._ptr.call_with_return(244,tuple([space._ptr, param, value]))

  @functools.native_method
  def _space_get_param(self, space:'RID'   , param:'int'  ) -> typing.Union[float]:
    r'''
'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(245,tuple([space._ptr, param]))
    return _ret


  @functools.native_method
  def _space_get_direct_state(self, space:'RID'   ) -> typing.Union['py4godot_physicsdirectspacestate3d.PhysicsDirectSpaceState3D','py4godot_physicsdirectspacestate3dextension.PhysicsDirectSpaceState3DExtension']:
    r'''
'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: PhysicsDirectSpaceState3D
    _ret._ptr = self._ptr.call_with_return(246,tuple([space._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def _space_set_debug_contacts(self, space:'RID'   , max_contacts:'int'   ) -> None:
    r'''
'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'
    assert isinstance(max_contacts, (int, float)), 'max_contacts must be int or float'








    self._ptr.call_with_return(247,tuple([space._ptr, max_contacts]))

  @functools.native_method
  def _space_get_contacts(self, space:'RID'   ) -> typing.Union['PackedVector3Array']:
    r'''
'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'







    _ret = PackedVector3Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(248,tuple([space._ptr]))
    return _ret


  @functools.native_method
  def _space_get_contact_count(self, space:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(249,tuple([space._ptr]))
    return _ret


  @functools.native_method
  def _area_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(250,tuple([]))
    return _ret


  @functools.native_method
  def _area_set_space(self, area:'RID'   , space:'RID'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'








    self._ptr.call_with_return(251,tuple([area._ptr, space._ptr]))

  @functools.native_method
  def _area_get_space(self, area:'RID'   ) -> typing.Union['RID']:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(252,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def _area_add_shape(self, area:'RID'   , shape:'RID'   , transform:'Transform3D'   , disabled:'bool'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'
    assert isinstance(disabled, bool), 'disabled must be bool'










    self._ptr.call_with_return(253,tuple([area._ptr, shape._ptr, transform._ptr, disabled]))

  @functools.native_method
  def _area_set_shape(self, area:'RID'   , shape_idx:'int'   , shape:'RID'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'
    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'









    self._ptr.call_with_return(254,tuple([area._ptr, shape_idx, shape._ptr]))

  @functools.native_method
  def _area_set_shape_transform(self, area:'RID'   , shape_idx:'int'   , transform:'Transform3D'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'









    self._ptr.call_with_return(255,tuple([area._ptr, shape_idx, transform._ptr]))

  @functools.native_method
  def _area_set_shape_disabled(self, area:'RID'   , shape_idx:'int'   , disabled:'bool'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'
    assert isinstance(disabled, bool), 'disabled must be bool'









    self._ptr.call_with_return(256,tuple([area._ptr, shape_idx, disabled]))

  @functools.native_method
  def _area_get_shape_count(self, area:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(257,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def _area_get_shape(self, area:'RID'   , shape_idx:'int'   ) -> typing.Union['RID']:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(258,tuple([area._ptr, shape_idx]))
    return _ret


  @functools.native_method
  def _area_get_shape_transform(self, area:'RID'   , shape_idx:'int'   ) -> typing.Union['Transform3D']:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'








    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(259,tuple([area._ptr, shape_idx]))
    return _ret


  @functools.native_method
  def _area_remove_shape(self, area:'RID'   , shape_idx:'int'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'








    self._ptr.call_with_return(260,tuple([area._ptr, shape_idx]))

  @functools.native_method
  def _area_clear_shapes(self, area:'RID'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    self._ptr.call_with_return(261,tuple([area._ptr]))

  @functools.native_method
  def _area_attach_object_instance_id(self, area:'RID'   , id:'int'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(id, (int, float)), 'id must be int or float'








    self._ptr.call_with_return(262,tuple([area._ptr, id]))

  @functools.native_method
  def _area_get_object_instance_id(self, area:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(263,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def _area_set_param(self, area:'RID'   , param:'int'  , value:'object'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    self._ptr.call_with_return(264,tuple([area._ptr, param, value]))

  @functools.native_method
  def _area_set_transform(self, area:'RID'   , transform:'Transform3D'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'








    self._ptr.call_with_return(265,tuple([area._ptr, transform._ptr]))

  @functools.native_method
  def _area_get_param(self, area:'RID'   , param:'int'  ) -> typing.Union[typing.Any]:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(266,tuple([area._ptr, param]))
    return _ret


  @functools.native_method
  def _area_get_transform(self, area:'RID'   ) -> typing.Union['Transform3D']:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(267,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def _area_set_collision_layer(self, area:'RID'   , layer:'int'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(layer, (int, float)), 'layer must be int or float'








    self._ptr.call_with_return(268,tuple([area._ptr, layer]))

  @functools.native_method
  def _area_get_collision_layer(self, area:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(269,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def _area_set_collision_mask(self, area:'RID'   , mask:'int'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'








    self._ptr.call_with_return(270,tuple([area._ptr, mask]))

  @functools.native_method
  def _area_get_collision_mask(self, area:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(271,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def _area_set_monitorable(self, area:'RID'   , monitorable:'bool'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(monitorable, bool), 'monitorable must be bool'








    self._ptr.call_with_return(272,tuple([area._ptr, monitorable]))

  @functools.native_method
  def _area_set_ray_pickable(self, area:'RID'   , enable:'bool'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert isinstance(enable, bool), 'enable must be bool'








    self._ptr.call_with_return(273,tuple([area._ptr, enable]))

  @functools.native_method
  def _area_set_monitor_callback(self, area:'RID'   , callback:'Callable'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'








    self._ptr.call_with_return(274,tuple([area._ptr, callback._ptr]))

  @functools.native_method
  def _area_set_area_monitor_callback(self, area:'RID'   , callback:'Callable'   ) -> None:
    r'''
'''

    assert(not area is None)
    assert isinstance(area, RID), 'area must be RID'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'








    self._ptr.call_with_return(275,tuple([area._ptr, callback._ptr]))

  @functools.native_method
  def _body_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(276,tuple([]))
    return _ret


  @functools.native_method
  def _body_set_space(self, body:'RID'   , space:'RID'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'








    self._ptr.call_with_return(277,tuple([body._ptr, space._ptr]))

  @functools.native_method
  def _body_get_space(self, body:'RID'   ) -> typing.Union['RID']:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(278,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_mode(self, body:'RID'   , mode:'int'  ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(mode, (int, float)), 'mode must be int or float'








    self._ptr.call_with_return(279,tuple([body._ptr, mode]))

  @functools.native_method
  def _body_get_mode(self, body:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(280,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_add_shape(self, body:'RID'   , shape:'RID'   , transform:'Transform3D'   , disabled:'bool'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'
    assert isinstance(disabled, bool), 'disabled must be bool'










    self._ptr.call_with_return(281,tuple([body._ptr, shape._ptr, transform._ptr, disabled]))

  @functools.native_method
  def _body_set_shape(self, body:'RID'   , shape_idx:'int'   , shape:'RID'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'
    assert(not shape is None)
    assert isinstance(shape, RID), 'shape must be RID'









    self._ptr.call_with_return(282,tuple([body._ptr, shape_idx, shape._ptr]))

  @functools.native_method
  def _body_set_shape_transform(self, body:'RID'   , shape_idx:'int'   , transform:'Transform3D'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'









    self._ptr.call_with_return(283,tuple([body._ptr, shape_idx, transform._ptr]))

  @functools.native_method
  def _body_set_shape_disabled(self, body:'RID'   , shape_idx:'int'   , disabled:'bool'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'
    assert isinstance(disabled, bool), 'disabled must be bool'









    self._ptr.call_with_return(284,tuple([body._ptr, shape_idx, disabled]))

  @functools.native_method
  def _body_get_shape_count(self, body:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(285,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_get_shape(self, body:'RID'   , shape_idx:'int'   ) -> typing.Union['RID']:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(286,tuple([body._ptr, shape_idx]))
    return _ret


  @functools.native_method
  def _body_get_shape_transform(self, body:'RID'   , shape_idx:'int'   ) -> typing.Union['Transform3D']:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'








    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(287,tuple([body._ptr, shape_idx]))
    return _ret


  @functools.native_method
  def _body_remove_shape(self, body:'RID'   , shape_idx:'int'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(shape_idx, (int, float)), 'shape_idx must be int or float'








    self._ptr.call_with_return(288,tuple([body._ptr, shape_idx]))

  @functools.native_method
  def _body_clear_shapes(self, body:'RID'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    self._ptr.call_with_return(289,tuple([body._ptr]))

  @functools.native_method
  def _body_attach_object_instance_id(self, body:'RID'   , id:'int'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(id, (int, float)), 'id must be int or float'








    self._ptr.call_with_return(290,tuple([body._ptr, id]))

  @functools.native_method
  def _body_get_object_instance_id(self, body:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(291,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_enable_continuous_collision_detection(self, body:'RID'   , enable:'bool'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(enable, bool), 'enable must be bool'








    self._ptr.call_with_return(292,tuple([body._ptr, enable]))

  @functools.native_method
  def _body_is_continuous_collision_detection_enabled(self, body:'RID'   ) -> typing.Union[bool]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(293,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_collision_layer(self, body:'RID'   , layer:'int'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(layer, (int, float)), 'layer must be int or float'








    self._ptr.call_with_return(294,tuple([body._ptr, layer]))

  @functools.native_method
  def _body_get_collision_layer(self, body:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(295,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_collision_mask(self, body:'RID'   , mask:'int'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'








    self._ptr.call_with_return(296,tuple([body._ptr, mask]))

  @functools.native_method
  def _body_get_collision_mask(self, body:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(297,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_collision_priority(self, body:'RID'   , priority:'float'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(priority, (int, float)), 'priority must be int or float'








    self._ptr.call_with_return(298,tuple([body._ptr, priority]))

  @functools.native_method
  def _body_get_collision_priority(self, body:'RID'   ) -> typing.Union[float]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(299,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_user_flags(self, body:'RID'   , flags:'int'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(flags, (int, float)), 'flags must be int or float'








    self._ptr.call_with_return(300,tuple([body._ptr, flags]))

  @functools.native_method
  def _body_get_user_flags(self, body:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(301,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_param(self, body:'RID'   , param:'int'  , value:'object'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    self._ptr.call_with_return(302,tuple([body._ptr, param, value]))

  @functools.native_method
  def _body_get_param(self, body:'RID'   , param:'int'  ) -> typing.Union[typing.Any]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(303,tuple([body._ptr, param]))
    return _ret


  @functools.native_method
  def _body_reset_mass_properties(self, body:'RID'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    self._ptr.call_with_return(304,tuple([body._ptr]))

  @functools.native_method
  def _body_set_state(self, body:'RID'   , state:'int'  , value:'object'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(state, (int, float)), 'state must be int or float'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    self._ptr.call_with_return(305,tuple([body._ptr, state, value]))

  @functools.native_method
  def _body_get_state(self, body:'RID'   , state:'int'  ) -> typing.Union[typing.Any]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(state, (int, float)), 'state must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(306,tuple([body._ptr, state]))
    return _ret


  @functools.native_method
  def _body_apply_central_impulse(self, body:'RID'   , impulse:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not impulse is None)
    assert isinstance(impulse, Vector3), 'impulse must be Vector3'








    self._ptr.call_with_return(307,tuple([body._ptr, impulse._ptr]))

  @functools.native_method
  def _body_apply_impulse(self, body:'RID'   , impulse:'Vector3'   , position:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not impulse is None)
    assert isinstance(impulse, Vector3), 'impulse must be Vector3'
    assert(not position is None)
    assert isinstance(position, Vector3), 'position must be Vector3'









    self._ptr.call_with_return(308,tuple([body._ptr, impulse._ptr, position._ptr]))

  @functools.native_method
  def _body_apply_torque_impulse(self, body:'RID'   , impulse:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not impulse is None)
    assert isinstance(impulse, Vector3), 'impulse must be Vector3'








    self._ptr.call_with_return(309,tuple([body._ptr, impulse._ptr]))

  @functools.native_method
  def _body_apply_central_force(self, body:'RID'   , force:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'








    self._ptr.call_with_return(310,tuple([body._ptr, force._ptr]))

  @functools.native_method
  def _body_apply_force(self, body:'RID'   , force:'Vector3'   , position:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'
    assert(not position is None)
    assert isinstance(position, Vector3), 'position must be Vector3'









    self._ptr.call_with_return(311,tuple([body._ptr, force._ptr, position._ptr]))

  @functools.native_method
  def _body_apply_torque(self, body:'RID'   , torque:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not torque is None)
    assert isinstance(torque, Vector3), 'torque must be Vector3'








    self._ptr.call_with_return(312,tuple([body._ptr, torque._ptr]))

  @functools.native_method
  def _body_add_constant_central_force(self, body:'RID'   , force:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'








    self._ptr.call_with_return(313,tuple([body._ptr, force._ptr]))

  @functools.native_method
  def _body_add_constant_force(self, body:'RID'   , force:'Vector3'   , position:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'
    assert(not position is None)
    assert isinstance(position, Vector3), 'position must be Vector3'









    self._ptr.call_with_return(314,tuple([body._ptr, force._ptr, position._ptr]))

  @functools.native_method
  def _body_add_constant_torque(self, body:'RID'   , torque:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not torque is None)
    assert isinstance(torque, Vector3), 'torque must be Vector3'








    self._ptr.call_with_return(315,tuple([body._ptr, torque._ptr]))

  @functools.native_method
  def _body_set_constant_force(self, body:'RID'   , force:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'








    self._ptr.call_with_return(316,tuple([body._ptr, force._ptr]))

  @functools.native_method
  def _body_get_constant_force(self, body:'RID'   ) -> typing.Union['Vector3']:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(317,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_constant_torque(self, body:'RID'   , torque:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not torque is None)
    assert isinstance(torque, Vector3), 'torque must be Vector3'








    self._ptr.call_with_return(318,tuple([body._ptr, torque._ptr]))

  @functools.native_method
  def _body_get_constant_torque(self, body:'RID'   ) -> typing.Union['Vector3']:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(319,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_axis_velocity(self, body:'RID'   , axis_velocity:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not axis_velocity is None)
    assert isinstance(axis_velocity, Vector3), 'axis_velocity must be Vector3'








    self._ptr.call_with_return(320,tuple([body._ptr, axis_velocity._ptr]))

  @functools.native_method
  def _body_set_axis_lock(self, body:'RID'   , axis:'int'  , lock:'bool'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(axis, (int, float)), 'axis must be int or float'
    assert isinstance(lock, bool), 'lock must be bool'









    self._ptr.call_with_return(321,tuple([body._ptr, axis, lock]))

  @functools.native_method
  def _body_is_axis_locked(self, body:'RID'   , axis:'int'  ) -> typing.Union[bool]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(axis, (int, float)), 'axis must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(322,tuple([body._ptr, axis]))
    return _ret


  @functools.native_method
  def _body_add_collision_exception(self, body:'RID'   , excepted_body:'RID'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not excepted_body is None)
    assert isinstance(excepted_body, RID), 'excepted_body must be RID'








    self._ptr.call_with_return(323,tuple([body._ptr, excepted_body._ptr]))

  @functools.native_method
  def _body_remove_collision_exception(self, body:'RID'   , excepted_body:'RID'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not excepted_body is None)
    assert isinstance(excepted_body, RID), 'excepted_body must be RID'








    self._ptr.call_with_return(324,tuple([body._ptr, excepted_body._ptr]))

  @functools.native_method
  def _body_get_collision_exceptions(self, body:'RID'   ) -> typing.Union['py4godot_ridtypedarray.RIDTypedArray']:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = py4godot_ridtypedarray.RIDTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(325,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_max_contacts_reported(self, body:'RID'   , amount:'int'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(amount, (int, float)), 'amount must be int or float'








    self._ptr.call_with_return(326,tuple([body._ptr, amount]))

  @functools.native_method
  def _body_get_max_contacts_reported(self, body:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(327,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_contacts_reported_depth_threshold(self, body:'RID'   , threshold:'float'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(threshold, (int, float)), 'threshold must be int or float'








    self._ptr.call_with_return(328,tuple([body._ptr, threshold]))

  @functools.native_method
  def _body_get_contacts_reported_depth_threshold(self, body:'RID'   ) -> typing.Union[float]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(329,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_omit_force_integration(self, body:'RID'   , enable:'bool'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(enable, bool), 'enable must be bool'








    self._ptr.call_with_return(330,tuple([body._ptr, enable]))

  @functools.native_method
  def _body_is_omitting_force_integration(self, body:'RID'   ) -> typing.Union[bool]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(331,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _body_set_state_sync_callback(self, body:'RID'   , callable:'Callable'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'








    self._ptr.call_with_return(332,tuple([body._ptr, callable._ptr]))

  @functools.native_method
  def _body_set_force_integration_callback(self, body:'RID'   , callable:'Callable'   , userdata:'object'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'
    

    if not (type(userdata).__name__ in py4godot.variant_types.core_types or isinstance(userdata, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'userdata': "
                f"{type(userdata).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    self._ptr.call_with_return(333,tuple([body._ptr, callable._ptr, userdata]))

  @functools.native_method
  def _body_set_ray_pickable(self, body:'RID'   , enable:'bool'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(enable, bool), 'enable must be bool'








    self._ptr.call_with_return(334,tuple([body._ptr, enable]))

  @functools.native_method
  def _body_get_direct_state(self, body:'RID'   ) -> typing.Union['py4godot_physicsdirectbodystate3d.PhysicsDirectBodyState3D','py4godot_physicsdirectbodystate3dextension.PhysicsDirectBodyState3DExtension']:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: PhysicsDirectBodyState3D
    _ret._ptr = self._ptr.call_with_return(335,tuple([body._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def _soft_body_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(336,tuple([]))
    return _ret


  @functools.native_method
  def _soft_body_update_rendering_server(self, body:'RID'   , rendering_server_handler:'py4godot_physicsserver3drenderingserverhandler.PhysicsServer3DRenderingServerHandler'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not rendering_server_handler is None)
    assert isinstance(rendering_server_handler, get_class('PhysicsServer3DRenderingServerHandler')), 'rendering_server_handler must be PhysicsServer3DRenderingServerHandler'








    self._ptr.call_with_return(337,tuple([body._ptr, rendering_server_handler._ptr]))

  @functools.native_method
  def _soft_body_set_space(self, body:'RID'   , space:'RID'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not space is None)
    assert isinstance(space, RID), 'space must be RID'








    self._ptr.call_with_return(338,tuple([body._ptr, space._ptr]))

  @functools.native_method
  def _soft_body_get_space(self, body:'RID'   ) -> typing.Union['RID']:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(339,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _soft_body_set_ray_pickable(self, body:'RID'   , enable:'bool'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(enable, bool), 'enable must be bool'








    self._ptr.call_with_return(340,tuple([body._ptr, enable]))

  @functools.native_method
  def _soft_body_set_collision_layer(self, body:'RID'   , layer:'int'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(layer, (int, float)), 'layer must be int or float'








    self._ptr.call_with_return(341,tuple([body._ptr, layer]))

  @functools.native_method
  def _soft_body_get_collision_layer(self, body:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(342,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _soft_body_set_collision_mask(self, body:'RID'   , mask:'int'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(mask, (int, float)), 'mask must be int or float'








    self._ptr.call_with_return(343,tuple([body._ptr, mask]))

  @functools.native_method
  def _soft_body_get_collision_mask(self, body:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(344,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _soft_body_add_collision_exception(self, body:'RID'   , body_b:'RID'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not body_b is None)
    assert isinstance(body_b, RID), 'body_b must be RID'








    self._ptr.call_with_return(345,tuple([body._ptr, body_b._ptr]))

  @functools.native_method
  def _soft_body_remove_collision_exception(self, body:'RID'   , body_b:'RID'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not body_b is None)
    assert isinstance(body_b, RID), 'body_b must be RID'








    self._ptr.call_with_return(346,tuple([body._ptr, body_b._ptr]))

  @functools.native_method
  def _soft_body_get_collision_exceptions(self, body:'RID'   ) -> typing.Union['py4godot_ridtypedarray.RIDTypedArray']:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = py4godot_ridtypedarray.RIDTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(347,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _soft_body_set_state(self, body:'RID'   , state:'int'  , variant:'object'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(state, (int, float)), 'state must be int or float'
    

    if not (type(variant).__name__ in py4godot.variant_types.core_types or isinstance(variant, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'variant': "
                f"{type(variant).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    self._ptr.call_with_return(348,tuple([body._ptr, state, variant]))

  @functools.native_method
  def _soft_body_get_state(self, body:'RID'   , state:'int'  ) -> typing.Union[typing.Any]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(state, (int, float)), 'state must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(349,tuple([body._ptr, state]))
    return _ret


  @functools.native_method
  def _soft_body_set_transform(self, body:'RID'   , transform:'Transform3D'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform3D), 'transform must be Transform3D'








    self._ptr.call_with_return(350,tuple([body._ptr, transform._ptr]))

  @functools.native_method
  def _soft_body_set_simulation_precision(self, body:'RID'   , simulation_precision:'int'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(simulation_precision, (int, float)), 'simulation_precision must be int or float'








    self._ptr.call_with_return(351,tuple([body._ptr, simulation_precision]))

  @functools.native_method
  def _soft_body_get_simulation_precision(self, body:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(352,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _soft_body_set_total_mass(self, body:'RID'   , total_mass:'float'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(total_mass, (int, float)), 'total_mass must be int or float'








    self._ptr.call_with_return(353,tuple([body._ptr, total_mass]))

  @functools.native_method
  def _soft_body_get_total_mass(self, body:'RID'   ) -> typing.Union[float]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(354,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _soft_body_set_linear_stiffness(self, body:'RID'   , linear_stiffness:'float'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(linear_stiffness, (int, float)), 'linear_stiffness must be int or float'








    self._ptr.call_with_return(355,tuple([body._ptr, linear_stiffness]))

  @functools.native_method
  def _soft_body_get_linear_stiffness(self, body:'RID'   ) -> typing.Union[float]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(356,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _soft_body_set_shrinking_factor(self, body:'RID'   , shrinking_factor:'float'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(shrinking_factor, (int, float)), 'shrinking_factor must be int or float'








    self._ptr.call_with_return(357,tuple([body._ptr, shrinking_factor]))

  @functools.native_method
  def _soft_body_get_shrinking_factor(self, body:'RID'   ) -> typing.Union[float]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(358,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _soft_body_set_pressure_coefficient(self, body:'RID'   , pressure_coefficient:'float'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(pressure_coefficient, (int, float)), 'pressure_coefficient must be int or float'








    self._ptr.call_with_return(359,tuple([body._ptr, pressure_coefficient]))

  @functools.native_method
  def _soft_body_get_pressure_coefficient(self, body:'RID'   ) -> typing.Union[float]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(360,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _soft_body_set_damping_coefficient(self, body:'RID'   , damping_coefficient:'float'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(damping_coefficient, (int, float)), 'damping_coefficient must be int or float'








    self._ptr.call_with_return(361,tuple([body._ptr, damping_coefficient]))

  @functools.native_method
  def _soft_body_get_damping_coefficient(self, body:'RID'   ) -> typing.Union[float]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(362,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _soft_body_set_drag_coefficient(self, body:'RID'   , drag_coefficient:'float'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(drag_coefficient, (int, float)), 'drag_coefficient must be int or float'








    self._ptr.call_with_return(363,tuple([body._ptr, drag_coefficient]))

  @functools.native_method
  def _soft_body_get_drag_coefficient(self, body:'RID'   ) -> typing.Union[float]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(364,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _soft_body_set_mesh(self, body:'RID'   , mesh:'RID'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not mesh is None)
    assert isinstance(mesh, RID), 'mesh must be RID'








    self._ptr.call_with_return(365,tuple([body._ptr, mesh._ptr]))

  @functools.native_method
  def _soft_body_get_bounds(self, body:'RID'   ) -> typing.Union['AABB']:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(366,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def _soft_body_move_point(self, body:'RID'   , point_index:'int'   , global_position:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(point_index, (int, float)), 'point_index must be int or float'
    assert(not global_position is None)
    assert isinstance(global_position, Vector3), 'global_position must be Vector3'









    self._ptr.call_with_return(367,tuple([body._ptr, point_index, global_position._ptr]))

  @functools.native_method
  def _soft_body_get_point_global_position(self, body:'RID'   , point_index:'int'   ) -> typing.Union['Vector3']:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(point_index, (int, float)), 'point_index must be int or float'








    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(368,tuple([body._ptr, point_index]))
    return _ret


  @functools.native_method
  def _soft_body_remove_all_pinned_points(self, body:'RID'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    self._ptr.call_with_return(369,tuple([body._ptr]))

  @functools.native_method
  def _soft_body_pin_point(self, body:'RID'   , point_index:'int'   , pin:'bool'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(point_index, (int, float)), 'point_index must be int or float'
    assert isinstance(pin, bool), 'pin must be bool'









    self._ptr.call_with_return(370,tuple([body._ptr, point_index, pin]))

  @functools.native_method
  def _soft_body_is_point_pinned(self, body:'RID'   , point_index:'int'   ) -> typing.Union[bool]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(point_index, (int, float)), 'point_index must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(371,tuple([body._ptr, point_index]))
    return _ret


  @functools.native_method
  def _soft_body_apply_point_impulse(self, body:'RID'   , point_index:'int'   , impulse:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(point_index, (int, float)), 'point_index must be int or float'
    assert(not impulse is None)
    assert isinstance(impulse, Vector3), 'impulse must be Vector3'









    self._ptr.call_with_return(372,tuple([body._ptr, point_index, impulse._ptr]))

  @functools.native_method
  def _soft_body_apply_point_force(self, body:'RID'   , point_index:'int'   , force:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert isinstance(point_index, (int, float)), 'point_index must be int or float'
    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'









    self._ptr.call_with_return(373,tuple([body._ptr, point_index, force._ptr]))

  @functools.native_method
  def _soft_body_apply_central_impulse(self, body:'RID'   , impulse:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not impulse is None)
    assert isinstance(impulse, Vector3), 'impulse must be Vector3'








    self._ptr.call_with_return(374,tuple([body._ptr, impulse._ptr]))

  @functools.native_method
  def _soft_body_apply_central_force(self, body:'RID'   , force:'Vector3'   ) -> None:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'
    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'








    self._ptr.call_with_return(375,tuple([body._ptr, force._ptr]))

  @functools.native_method
  def _joint_create(self) -> typing.Union['RID']:
    r'''
'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(376,tuple([]))
    return _ret


  @functools.native_method
  def _joint_clear(self, joint:'RID'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'







    self._ptr.call_with_return(377,tuple([joint._ptr]))

  @functools.native_method
  def _joint_make_pin(self, joint:'RID'   , body_A:'RID'   , local_A:'Vector3'   , body_B:'RID'   , local_B:'Vector3'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert(not body_A is None)
    assert isinstance(body_A, RID), 'body_A must be RID'
    assert(not local_A is None)
    assert isinstance(local_A, Vector3), 'local_A must be Vector3'
    assert(not body_B is None)
    assert isinstance(body_B, RID), 'body_B must be RID'
    assert(not local_B is None)
    assert isinstance(local_B, Vector3), 'local_B must be Vector3'











    self._ptr.call_with_return(378,tuple([joint._ptr, body_A._ptr, local_A._ptr, body_B._ptr, local_B._ptr]))

  @functools.native_method
  def _pin_joint_set_param(self, joint:'RID'   , param:'int'  , value:'float'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'









    self._ptr.call_with_return(379,tuple([joint._ptr, param, value]))

  @functools.native_method
  def _pin_joint_get_param(self, joint:'RID'   , param:'int'  ) -> typing.Union[float]:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(380,tuple([joint._ptr, param]))
    return _ret


  @functools.native_method
  def _pin_joint_set_local_a(self, joint:'RID'   , local_A:'Vector3'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert(not local_A is None)
    assert isinstance(local_A, Vector3), 'local_A must be Vector3'








    self._ptr.call_with_return(381,tuple([joint._ptr, local_A._ptr]))

  @functools.native_method
  def _pin_joint_get_local_a(self, joint:'RID'   ) -> typing.Union['Vector3']:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(382,tuple([joint._ptr]))
    return _ret


  @functools.native_method
  def _pin_joint_set_local_b(self, joint:'RID'   , local_B:'Vector3'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert(not local_B is None)
    assert isinstance(local_B, Vector3), 'local_B must be Vector3'








    self._ptr.call_with_return(383,tuple([joint._ptr, local_B._ptr]))

  @functools.native_method
  def _pin_joint_get_local_b(self, joint:'RID'   ) -> typing.Union['Vector3']:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(384,tuple([joint._ptr]))
    return _ret


  @functools.native_method
  def _joint_make_hinge(self, joint:'RID'   , body_A:'RID'   , hinge_A:'Transform3D'   , body_B:'RID'   , hinge_B:'Transform3D'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert(not body_A is None)
    assert isinstance(body_A, RID), 'body_A must be RID'
    assert(not hinge_A is None)
    assert isinstance(hinge_A, Transform3D), 'hinge_A must be Transform3D'
    assert(not body_B is None)
    assert isinstance(body_B, RID), 'body_B must be RID'
    assert(not hinge_B is None)
    assert isinstance(hinge_B, Transform3D), 'hinge_B must be Transform3D'











    self._ptr.call_with_return(385,tuple([joint._ptr, body_A._ptr, hinge_A._ptr, body_B._ptr, hinge_B._ptr]))

  @functools.native_method
  def _joint_make_hinge_simple(self, joint:'RID'   , body_A:'RID'   , pivot_A:'Vector3'   , axis_A:'Vector3'   , body_B:'RID'   , pivot_B:'Vector3'   , axis_B:'Vector3'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert(not body_A is None)
    assert isinstance(body_A, RID), 'body_A must be RID'
    assert(not pivot_A is None)
    assert isinstance(pivot_A, Vector3), 'pivot_A must be Vector3'
    assert(not axis_A is None)
    assert isinstance(axis_A, Vector3), 'axis_A must be Vector3'
    assert(not body_B is None)
    assert isinstance(body_B, RID), 'body_B must be RID'
    assert(not pivot_B is None)
    assert isinstance(pivot_B, Vector3), 'pivot_B must be Vector3'
    assert(not axis_B is None)
    assert isinstance(axis_B, Vector3), 'axis_B must be Vector3'













    self._ptr.call_with_return(386,tuple([joint._ptr, body_A._ptr, pivot_A._ptr, axis_A._ptr, body_B._ptr, pivot_B._ptr, axis_B._ptr]))

  @functools.native_method
  def _hinge_joint_set_param(self, joint:'RID'   , param:'int'  , value:'float'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'









    self._ptr.call_with_return(387,tuple([joint._ptr, param, value]))

  @functools.native_method
  def _hinge_joint_get_param(self, joint:'RID'   , param:'int'  ) -> typing.Union[float]:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(388,tuple([joint._ptr, param]))
    return _ret


  @functools.native_method
  def _hinge_joint_set_flag(self, joint:'RID'   , flag:'int'  , enabled:'bool'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(flag, (int, float)), 'flag must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'









    self._ptr.call_with_return(389,tuple([joint._ptr, flag, enabled]))

  @functools.native_method
  def _hinge_joint_get_flag(self, joint:'RID'   , flag:'int'  ) -> typing.Union[bool]:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(flag, (int, float)), 'flag must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(390,tuple([joint._ptr, flag]))
    return _ret


  @functools.native_method
  def _joint_make_slider(self, joint:'RID'   , body_A:'RID'   , local_ref_A:'Transform3D'   , body_B:'RID'   , local_ref_B:'Transform3D'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert(not body_A is None)
    assert isinstance(body_A, RID), 'body_A must be RID'
    assert(not local_ref_A is None)
    assert isinstance(local_ref_A, Transform3D), 'local_ref_A must be Transform3D'
    assert(not body_B is None)
    assert isinstance(body_B, RID), 'body_B must be RID'
    assert(not local_ref_B is None)
    assert isinstance(local_ref_B, Transform3D), 'local_ref_B must be Transform3D'











    self._ptr.call_with_return(391,tuple([joint._ptr, body_A._ptr, local_ref_A._ptr, body_B._ptr, local_ref_B._ptr]))

  @functools.native_method
  def _slider_joint_set_param(self, joint:'RID'   , param:'int'  , value:'float'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'









    self._ptr.call_with_return(392,tuple([joint._ptr, param, value]))

  @functools.native_method
  def _slider_joint_get_param(self, joint:'RID'   , param:'int'  ) -> typing.Union[float]:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(393,tuple([joint._ptr, param]))
    return _ret


  @functools.native_method
  def _joint_make_cone_twist(self, joint:'RID'   , body_A:'RID'   , local_ref_A:'Transform3D'   , body_B:'RID'   , local_ref_B:'Transform3D'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert(not body_A is None)
    assert isinstance(body_A, RID), 'body_A must be RID'
    assert(not local_ref_A is None)
    assert isinstance(local_ref_A, Transform3D), 'local_ref_A must be Transform3D'
    assert(not body_B is None)
    assert isinstance(body_B, RID), 'body_B must be RID'
    assert(not local_ref_B is None)
    assert isinstance(local_ref_B, Transform3D), 'local_ref_B must be Transform3D'











    self._ptr.call_with_return(394,tuple([joint._ptr, body_A._ptr, local_ref_A._ptr, body_B._ptr, local_ref_B._ptr]))

  @functools.native_method
  def _cone_twist_joint_set_param(self, joint:'RID'   , param:'int'  , value:'float'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'









    self._ptr.call_with_return(395,tuple([joint._ptr, param, value]))

  @functools.native_method
  def _cone_twist_joint_get_param(self, joint:'RID'   , param:'int'  ) -> typing.Union[float]:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(param, (int, float)), 'param must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(396,tuple([joint._ptr, param]))
    return _ret


  @functools.native_method
  def _joint_make_generic_6dof(self, joint:'RID'   , body_A:'RID'   , local_ref_A:'Transform3D'   , body_B:'RID'   , local_ref_B:'Transform3D'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert(not body_A is None)
    assert isinstance(body_A, RID), 'body_A must be RID'
    assert(not local_ref_A is None)
    assert isinstance(local_ref_A, Transform3D), 'local_ref_A must be Transform3D'
    assert(not body_B is None)
    assert isinstance(body_B, RID), 'body_B must be RID'
    assert(not local_ref_B is None)
    assert isinstance(local_ref_B, Transform3D), 'local_ref_B must be Transform3D'











    self._ptr.call_with_return(397,tuple([joint._ptr, body_A._ptr, local_ref_A._ptr, body_B._ptr, local_ref_B._ptr]))

  @functools.native_method
  def _generic_6dof_joint_set_param(self, joint:'RID'   , axis:'int'  , param:'int'  , value:'float'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(axis, (int, float)), 'axis must be int or float'
    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'










    self._ptr.call_with_return(398,tuple([joint._ptr, axis, param, value]))

  @functools.native_method
  def _generic_6dof_joint_get_param(self, joint:'RID'   , axis:'int'  , param:'int'  ) -> typing.Union[float]:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(axis, (int, float)), 'axis must be int or float'
    assert isinstance(param, (int, float)), 'param must be int or float'









    _ret = 0
    _ret = self._ptr.call_with_return(399,tuple([joint._ptr, axis, param]))
    return _ret


  @functools.native_method
  def _generic_6dof_joint_set_flag(self, joint:'RID'   , axis:'int'  , flag:'int'  , enable:'bool'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(axis, (int, float)), 'axis must be int or float'
    assert isinstance(flag, (int, float)), 'flag must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'










    self._ptr.call_with_return(400,tuple([joint._ptr, axis, flag, enable]))

  @functools.native_method
  def _generic_6dof_joint_get_flag(self, joint:'RID'   , axis:'int'  , flag:'int'  ) -> typing.Union[bool]:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(axis, (int, float)), 'axis must be int or float'
    assert isinstance(flag, (int, float)), 'flag must be int or float'









    _ret = 0
    _ret = self._ptr.call_with_return(401,tuple([joint._ptr, axis, flag]))
    return _ret


  @functools.native_method
  def _joint_get_type(self, joint:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(402,tuple([joint._ptr]))
    return _ret


  @functools.native_method
  def _joint_set_solver_priority(self, joint:'RID'   , priority:'int'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(priority, (int, float)), 'priority must be int or float'








    self._ptr.call_with_return(403,tuple([joint._ptr, priority]))

  @functools.native_method
  def _joint_get_solver_priority(self, joint:'RID'   ) -> typing.Union[int]:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(404,tuple([joint._ptr]))
    return _ret


  @functools.native_method
  def _joint_disable_collisions_between_bodies(self, joint:'RID'   , disable:'bool'   ) -> None:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'
    assert isinstance(disable, bool), 'disable must be bool'








    self._ptr.call_with_return(405,tuple([joint._ptr, disable]))

  @functools.native_method
  def _joint_is_disabled_collisions_between_bodies(self, joint:'RID'   ) -> typing.Union[bool]:
    r'''
'''

    assert(not joint is None)
    assert isinstance(joint, RID), 'joint must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(406,tuple([joint._ptr]))
    return _ret


  @functools.native_method
  def _free_rid(self, rid:'RID'   ) -> None:
    r'''
'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    self._ptr.call_with_return(407,tuple([rid._ptr]))

  @functools.native_method
  def _set_active(self, active:'bool'   ) -> None:
    r'''
'''

    assert isinstance(active, bool), 'active must be bool'







    self._ptr.call_with_return(408,tuple([active]))

  @functools.native_method
  def _init(self) -> None:
    r'''
'''




    self._ptr.call_with_return(409,tuple([]))

  @functools.native_method
  def _step(self, step:'float'   ) -> None:
    r'''
'''

    assert isinstance(step, (int, float)), 'step must be int or float'







    self._ptr.call_with_return(410,tuple([step]))

  @functools.native_method
  def _sync(self) -> None:
    r'''
'''




    self._ptr.call_with_return(411,tuple([]))

  @functools.native_method
  def _flush_queries(self) -> None:
    r'''
'''




    self._ptr.call_with_return(412,tuple([]))

  @functools.native_method
  def _end_sync(self) -> None:
    r'''
'''




    self._ptr.call_with_return(413,tuple([]))

  @functools.native_method
  def _finish(self) -> None:
    r'''
'''




    self._ptr.call_with_return(414,tuple([]))

  @functools.native_method
  def _is_flushing_queries(self) -> typing.Union[bool]:
    r'''
'''




    _ret = 0
    _ret = self._ptr.call_with_return(415,tuple([]))
    return _ret


  @functools.native_method
  def _get_process_info(self, process_info:'int'  ) -> typing.Union[int]:
    r'''
'''

    assert isinstance(process_info, (int, float)), 'process_info must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(416,tuple([process_info]))
    return _ret


  @functools.native_method
  def body_test_motion_is_excluding_body(self, body:'RID'   ) -> typing.Union[bool]:
    r'''
'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(417,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def body_test_motion_is_excluding_object(self, object_:'int'   ) -> typing.Union[bool]:
    r'''
'''

    assert isinstance(object_, (int, float)), 'object_ must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(418,tuple([object_]))
    return _ret



register_cast_function('PhysicsServer3DExtension', PhysicsServer3DExtension.cast)
register_class('PhysicsServer3DExtension', PhysicsServer3DExtension)
