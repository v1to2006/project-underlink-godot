# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.HashingContext as py4godot_hashingcontext 
  import py4godot.classes.X509Certificate as py4godot_x509certificate 
  import py4godot.classes.CryptoKey as py4godot_cryptokey 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPCryptoWrapper


class Crypto(py4godot_refcounted.RefCounted):
  r'''
		The Crypto class provides access to advanced cryptographic functionalities.
		Currently, this includes asymmetric key encryption/decryption, signing/verification, and generating cryptographically secure random bytes, RSA keys, HMAC digests, and self-signed `X509Certificate`s.
		
		```gdscript
		var crypto = Crypto.new()

		# Generate new RSA key.
		var key = crypto.generate_rsa(4096)

		# Generate new self-signed certificate with the given key.
		var cert = crypto.generate_self_signed_certificate(key, "CN=mydomain.com,O=My Game Company,C=IT")

		# Save key and certificate in the user folder.
		key.save("user://generated.key")
		cert.save("user://generated.crt")

		# Encryption
		var data = "Some data"
		var encrypted = crypto.encrypt(key, data.to_utf8_buffer())

		# Decryption
		var decrypted = crypto.decrypt(key, encrypted)

		# Signing
		var signature = crypto.sign(HashingContext.HASH_SHA256, data.sha256_buffer(), key)

		# Verifying
		var verified = crypto.verify(HashingContext.HASH_SHA256, data.sha256_buffer(), signature, key)

		# Checks
		assert(verified)
		assert(data.to_utf8_buffer() == decrypted)
		```
		
		
	'''

  @staticmethod
  def constructor():
    class_ = Crypto.construct_without_init()
    class_._ptr = constructor(244,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Crypto.construct_without_init()
    class_._ptr = constructor(244,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPCryptoWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(244,0, ())


  def generate_wrapper(self):
    return CPPCryptoWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Crypto.__new__(Crypto)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Crypto'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(62, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Crypto.construct_without_init()
    cls._ptr = CPPCryptoWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Crypto.construct_without_init()
    cls._ptr = CPPCryptoWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def generate_random_bytes(self, size:'int'   ) -> typing.Union['PackedByteArray']:
    r'''
				Generates a `PackedByteArray` of cryptographically secure random bytes with given `size`.
			'''

    assert isinstance(size, (int, float)), 'size must be int or float'







    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([size]))
    return _ret


  @functools.native_method
  def generate_rsa(self, size:'int'   ) -> typing.Union['py4godot_cryptokey.CryptoKey']:
    r'''
				Generates an RSA `CryptoKey` that can be used for creating self-signed certificates and passed to `StreamPeerTLS.accept_stream`.
			'''

    assert isinstance(size, (int, float)), 'size must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: CryptoKey
    _ret._ptr = self._ptr.call_with_return(54,tuple([size]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def generate_self_signed_certificate(self, key:'py4godot_cryptokey.CryptoKey'   , issuer_name:'str' ="CN=myserver,O=myorganisation,C=IT"  , not_before:'str' ="20140101000000"  , not_after:'str' ="20340101000000"  ) -> typing.Union['py4godot_x509certificate.X509Certificate']:
    r'''
				Generates a self-signed `X509Certificate` from the given `CryptoKey` and `issuer_name`. The certificate validity will be defined by `not_before` and `not_after` (first valid date and last valid date). The `issuer_name` must contain at least "CN=" (common name, i.e. the domain name), "O=" (organization, i.e. your company name), "C=" (country, i.e. 2 lettered ISO-3166 code of the country the organization is based in).
				A small example to generate an RSA key and an X509 self-signed certificate.
				
				```gdscript
				var crypto = Crypto.new()
				# Generate 4096 bits RSA key.
				var key = crypto.generate_rsa(4096)
				# Generate self-signed certificate using the given key.
				var cert = crypto.generate_self_signed_certificate(key, "CN=example.com,O=A Game Company,C=IT")
				```
				
				
			'''
    if issuer_name is None:
      issuer_name = String.new0()
    if not_before is None:
      not_before = String.new0()
    if not_after is None:
      not_after = String.new0()

    assert(not key is None)
    assert isinstance(key, get_class('CryptoKey')), 'key must be CryptoKey'






    assert(isinstance(issuer_name, (str, String)))
    py_string_issuer_name = issuer_name if isinstance(issuer_name, StringName) else c_utils.py_string_to_string(issuer_name)
    assert(isinstance(not_before, (str, String)))
    py_string_not_before = not_before if isinstance(not_before, StringName) else c_utils.py_string_to_string(not_before)
    assert(isinstance(not_after, (str, String)))
    py_string_not_after = not_after if isinstance(not_after, StringName) else c_utils.py_string_to_string(not_after)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: X509Certificate
    _ret._ptr = self._ptr.call_with_return(55,tuple([key._ptr, py_string_issuer_name._ptr, py_string_not_before._ptr, py_string_not_after._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def sign(self, hash_type:'int'  , hash:'PackedByteArray'   , key:'py4godot_cryptokey.CryptoKey'   ) -> typing.Union['PackedByteArray']:
    r'''
				Sign a given `hash` of type `hash_type` with the provided private `key`.
			'''

    assert isinstance(hash_type, (int, float)), 'hash_type must be int or float'
    assert(not hash is None)
    assert isinstance(hash, PackedByteArray), 'hash must be PackedByteArray'
    assert(not key is None)
    assert isinstance(key, get_class('CryptoKey')), 'key must be CryptoKey'









    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(56,tuple([hash_type, hash._ptr, key._ptr]))
    return _ret


  @functools.native_method
  def verify(self, hash_type:'int'  , hash:'PackedByteArray'   , signature:'PackedByteArray'   , key:'py4godot_cryptokey.CryptoKey'   ) -> typing.Union[bool]:
    r'''
				Verify that a given `signature` for `hash` of type `hash_type` against the provided public `key`.
			'''

    assert isinstance(hash_type, (int, float)), 'hash_type must be int or float'
    assert(not hash is None)
    assert isinstance(hash, PackedByteArray), 'hash must be PackedByteArray'
    assert(not signature is None)
    assert isinstance(signature, PackedByteArray), 'signature must be PackedByteArray'
    assert(not key is None)
    assert isinstance(key, get_class('CryptoKey')), 'key must be CryptoKey'










    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([hash_type, hash._ptr, signature._ptr, key._ptr]))
    return _ret


  @functools.native_method
  def encrypt(self, key:'py4godot_cryptokey.CryptoKey'   , plaintext:'PackedByteArray'   ) -> typing.Union['PackedByteArray']:
    r'''
				Encrypt the given `plaintext` with the provided public `key`.
				**Note:** The maximum size of accepted plaintext is limited by the key size.
			'''

    assert(not key is None)
    assert isinstance(key, get_class('CryptoKey')), 'key must be CryptoKey'
    assert(not plaintext is None)
    assert isinstance(plaintext, PackedByteArray), 'plaintext must be PackedByteArray'








    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([key._ptr, plaintext._ptr]))
    return _ret


  @functools.native_method
  def decrypt(self, key:'py4godot_cryptokey.CryptoKey'   , ciphertext:'PackedByteArray'   ) -> typing.Union['PackedByteArray']:
    r'''
				Decrypt the given `ciphertext` with the provided private `key`.
				**Note:** The maximum size of accepted ciphertext is limited by the key size.
			'''

    assert(not key is None)
    assert isinstance(key, get_class('CryptoKey')), 'key must be CryptoKey'
    assert(not ciphertext is None)
    assert isinstance(ciphertext, PackedByteArray), 'ciphertext must be PackedByteArray'








    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(59,tuple([key._ptr, ciphertext._ptr]))
    return _ret


  @functools.native_method
  def hmac_digest(self, hash_type:'int'  , key:'PackedByteArray'   , msg:'PackedByteArray'   ) -> typing.Union['PackedByteArray']:
    r'''
				Generates an `url=https://en.wikipedia.org/wiki/HMAC`HMAC`/url` digest of `msg` using `key`. The `hash_type` parameter is the hashing algorithm that is used for the inner and outer hashes.
				Currently, only `constant HashingContext.HASH_SHA256` and `constant HashingContext.HASH_SHA1` are supported.
			'''

    assert isinstance(hash_type, (int, float)), 'hash_type must be int or float'
    assert(not key is None)
    assert isinstance(key, PackedByteArray), 'key must be PackedByteArray'
    assert(not msg is None)
    assert isinstance(msg, PackedByteArray), 'msg must be PackedByteArray'









    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([hash_type, key._ptr, msg._ptr]))
    return _ret


  @functools.native_method
  def constant_time_compare(self, trusted:'PackedByteArray'   , received:'PackedByteArray'   ) -> typing.Union[bool]:
    r'''
				Compares two `PackedByteArray`s for equality without leaking timing information in order to prevent timing attacks.
				See `url=https://paragonie.com/blog/2015/11/preventing-timing-attacks-on-string-comparison-with-double-hmac-strategy`this blog post`/url` for more information.
			'''

    assert(not trusted is None)
    assert isinstance(trusted, PackedByteArray), 'trusted must be PackedByteArray'
    assert(not received is None)
    assert isinstance(received, PackedByteArray), 'received must be PackedByteArray'








    _ret = 0
    _ret = self._ptr.call_with_return(61,tuple([trusted._ptr, received._ptr]))
    return _ret



register_cast_function('Crypto', Crypto.cast)
register_class('Crypto', Crypto)
