# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.StringTypedArray as py4godot_stringtypedarray 
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.StringTypedArray as py4godot_stringtypedarray 
import py4godot.classes.Object as py4godot_object 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
from py4godot.wrappers.wrappers import CPPEditorVCSInterfaceWrapper

class ChangeType:
  CHANGE_TYPE_NEW = 0
  CHANGE_TYPE_MODIFIED = 1
  CHANGE_TYPE_RENAMED = 2
  CHANGE_TYPE_DELETED = 3
  CHANGE_TYPE_TYPECHANGE = 4
  CHANGE_TYPE_UNMERGED = 5
class TreeArea:
  TREE_AREA_COMMIT = 0
  TREE_AREA_STAGED = 1
  TREE_AREA_UNSTAGED = 2


class EditorVCSInterface(py4godot_object.Object):
  r'''
		Defines the API that the editor uses to extract information from the underlying VCS. The implementation of this API is included in VCS plugins, which are GDExtension plugins that inherit `EditorVCSInterface` and are attached (on demand) to the singleton instance of `EditorVCSInterface`. Instead of performing the task themselves, all the virtual functions listed below are calling the internally overridden functions in the VCS plugins to provide a plug-n-play experience. A custom VCS plugin is supposed to inherit from `EditorVCSInterface` and override each of these virtual functions.
	'''

  @staticmethod
  def constructor():
    class_ = EditorVCSInterface.construct_without_init()
    class_._ptr = constructor(318,0, ())
    return class_
  @staticmethod
  def new():
    class_ = EditorVCSInterface.construct_without_init()
    class_._ptr = constructor(318,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEditorVCSInterfaceWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(318,0, ())


  def generate_wrapper(self):
    return CPPEditorVCSInterfaceWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = EditorVCSInterface.__new__(EditorVCSInterface)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorVCSInterface'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorVCSInterface.construct_without_init()
    cls._ptr = CPPEditorVCSInterfaceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorVCSInterface.construct_without_init()
    cls._ptr = CPPEditorVCSInterfaceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _initialize(self, project_path:'str'   ) -> typing.Union[bool]:
    r'''
				Initializes the VCS plugin when called from the editor. Returns whether or not the plugin was successfully initialized. A VCS project is initialized at `project_path`.
			'''

    assert(not project_path is None)
    assert isinstance(project_path, (str, String)), 'project_path must be str or String'





    assert(isinstance(project_path, (str, String)))
    py_string_project_path = project_path if isinstance(project_path, StringName) else c_utils.py_string_to_string(project_path)

    _ret = 0
    _ret = self._ptr.call_with_return(49,tuple([py_string_project_path._ptr]))
    return _ret


  @functools.native_method
  def _set_credentials(self, username:'str'   , password:'str'   , ssh_public_key_path:'str'   , ssh_private_key_path:'str'   , ssh_passphrase:'str'   ) -> None:
    r'''
				Set user credentials in the underlying VCS. `username` and `password` are used only during HTTPS authentication unless not already mentioned in the remote URL. `ssh_public_key_path`, `ssh_private_key_path`, and `ssh_passphrase` are only used during SSH authentication.
			'''

    assert(not username is None)
    assert isinstance(username, (str, String)), 'username must be str or String'
    assert(not password is None)
    assert isinstance(password, (str, String)), 'password must be str or String'
    assert(not ssh_public_key_path is None)
    assert isinstance(ssh_public_key_path, (str, String)), 'ssh_public_key_path must be str or String'
    assert(not ssh_private_key_path is None)
    assert isinstance(ssh_private_key_path, (str, String)), 'ssh_private_key_path must be str or String'
    assert(not ssh_passphrase is None)
    assert isinstance(ssh_passphrase, (str, String)), 'ssh_passphrase must be str or String'





    assert(isinstance(username, (str, String)))
    py_string_username = username if isinstance(username, StringName) else c_utils.py_string_to_string(username)
    assert(isinstance(password, (str, String)))
    py_string_password = password if isinstance(password, StringName) else c_utils.py_string_to_string(password)
    assert(isinstance(ssh_public_key_path, (str, String)))
    py_string_ssh_public_key_path = ssh_public_key_path if isinstance(ssh_public_key_path, StringName) else c_utils.py_string_to_string(ssh_public_key_path)
    assert(isinstance(ssh_private_key_path, (str, String)))
    py_string_ssh_private_key_path = ssh_private_key_path if isinstance(ssh_private_key_path, StringName) else c_utils.py_string_to_string(ssh_private_key_path)
    assert(isinstance(ssh_passphrase, (str, String)))
    py_string_ssh_passphrase = ssh_passphrase if isinstance(ssh_passphrase, StringName) else c_utils.py_string_to_string(ssh_passphrase)

    self._ptr.call_with_return(50,tuple([py_string_username._ptr, py_string_password._ptr, py_string_ssh_public_key_path._ptr, py_string_ssh_private_key_path._ptr, py_string_ssh_passphrase._ptr]))

  @functools.native_method
  def _get_modified_files_data(self) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns an `Array` of `Dictionary` items (see `create_status_file`), each containing the status data of every modified file in the project folder.
			'''




    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(51,tuple([]))
    return _ret


  @functools.native_method
  def _stage_file(self, file_path:'str'   ) -> None:
    r'''
				Stages the file present at `file_path` to the staged area.
			'''

    assert(not file_path is None)
    assert isinstance(file_path, (str, String)), 'file_path must be str or String'





    assert(isinstance(file_path, (str, String)))
    py_string_file_path = file_path if isinstance(file_path, StringName) else c_utils.py_string_to_string(file_path)

    self._ptr.call_with_return(52,tuple([py_string_file_path._ptr]))

  @functools.native_method
  def _unstage_file(self, file_path:'str'   ) -> None:
    r'''
				Unstages the file present at `file_path` from the staged area to the unstaged area.
			'''

    assert(not file_path is None)
    assert isinstance(file_path, (str, String)), 'file_path must be str or String'





    assert(isinstance(file_path, (str, String)))
    py_string_file_path = file_path if isinstance(file_path, StringName) else c_utils.py_string_to_string(file_path)

    self._ptr.call_with_return(53,tuple([py_string_file_path._ptr]))

  @functools.native_method
  def _discard_file(self, file_path:'str'   ) -> None:
    r'''
				Discards the changes made in a file present at `file_path`.
			'''

    assert(not file_path is None)
    assert isinstance(file_path, (str, String)), 'file_path must be str or String'





    assert(isinstance(file_path, (str, String)))
    py_string_file_path = file_path if isinstance(file_path, StringName) else c_utils.py_string_to_string(file_path)

    self._ptr.call_with_return(54,tuple([py_string_file_path._ptr]))

  @functools.native_method
  def _commit(self, msg:'str'   ) -> None:
    r'''
				Commits the currently staged changes and applies the commit `msg` to the resulting commit.
			'''

    assert(not msg is None)
    assert isinstance(msg, (str, String)), 'msg must be str or String'





    assert(isinstance(msg, (str, String)))
    py_string_msg = msg if isinstance(msg, StringName) else c_utils.py_string_to_string(msg)

    self._ptr.call_with_return(55,tuple([py_string_msg._ptr]))

  @functools.native_method
  def _get_diff(self, identifier:'str'   , area:'int'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns an array of `Dictionary` items (see `create_diff_file`, `create_diff_hunk`, `create_diff_line`, `add_line_diffs_into_diff_hunk` and `add_diff_hunks_into_diff_file`), each containing information about a diff. If `identifier` is a file path, returns a file diff, and if it is a commit identifier, then returns a commit diff.
			'''

    assert(not identifier is None)
    assert isinstance(identifier, (str, String)), 'identifier must be str or String'
    assert isinstance(area, (int, float)), 'area must be int or float'





    assert(isinstance(identifier, (str, String)))
    py_string_identifier = identifier if isinstance(identifier, StringName) else c_utils.py_string_to_string(identifier)


    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(56,tuple([py_string_identifier._ptr, area]))
    return _ret


  @functools.native_method
  def _shut_down(self) -> typing.Union[bool]:
    r'''
				Shuts down VCS plugin instance. Called when the user either closes the editor or shuts down the VCS plugin through the editor UI.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([]))
    return _ret


  @functools.native_method
  def _get_vcs_name(self) -> typing.Union[str]:
    r'''
				Returns the name of the underlying VCS provider.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _get_previous_commits(self, max_commits:'int'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns an `Array` of `Dictionary` items (see `create_commit`), each containing the data for a past commit.
			'''

    assert isinstance(max_commits, (int, float)), 'max_commits must be int or float'







    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(59,tuple([max_commits]))
    return _ret


  @functools.native_method
  def _get_branch_list(self) -> typing.Union['py4godot_stringtypedarray.StringTypedArray']:
    r'''
				Gets an instance of an `Array` of `String`s containing available branch names in the VCS.
			'''




    _ret = py4godot_stringtypedarray.StringTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([]))
    return _ret


  @functools.native_method
  def _get_remotes(self) -> typing.Union['py4godot_stringtypedarray.StringTypedArray']:
    r'''
				Returns an `Array` of `String`s, each containing the name of a remote configured in the VCS.
			'''




    _ret = py4godot_stringtypedarray.StringTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([]))
    return _ret


  @functools.native_method
  def _create_branch(self, branch_name:'str'   ) -> None:
    r'''
				Creates a new branch named `branch_name` in the VCS.
			'''

    assert(not branch_name is None)
    assert isinstance(branch_name, (str, String)), 'branch_name must be str or String'





    assert(isinstance(branch_name, (str, String)))
    py_string_branch_name = branch_name if isinstance(branch_name, StringName) else c_utils.py_string_to_string(branch_name)

    self._ptr.call_with_return(62,tuple([py_string_branch_name._ptr]))

  @functools.native_method
  def _remove_branch(self, branch_name:'str'   ) -> None:
    r'''
				Remove a branch from the local VCS.
			'''

    assert(not branch_name is None)
    assert isinstance(branch_name, (str, String)), 'branch_name must be str or String'





    assert(isinstance(branch_name, (str, String)))
    py_string_branch_name = branch_name if isinstance(branch_name, StringName) else c_utils.py_string_to_string(branch_name)

    self._ptr.call_with_return(63,tuple([py_string_branch_name._ptr]))

  @functools.native_method
  def _create_remote(self, remote_name:'str'   , remote_url:'str'   ) -> None:
    r'''
				Creates a new remote destination with name `remote_name` and points it to `remote_url`. This can be an HTTPS remote or an SSH remote.
			'''

    assert(not remote_name is None)
    assert isinstance(remote_name, (str, String)), 'remote_name must be str or String'
    assert(not remote_url is None)
    assert isinstance(remote_url, (str, String)), 'remote_url must be str or String'





    assert(isinstance(remote_name, (str, String)))
    py_string_remote_name = remote_name if isinstance(remote_name, StringName) else c_utils.py_string_to_string(remote_name)
    assert(isinstance(remote_url, (str, String)))
    py_string_remote_url = remote_url if isinstance(remote_url, StringName) else c_utils.py_string_to_string(remote_url)

    self._ptr.call_with_return(64,tuple([py_string_remote_name._ptr, py_string_remote_url._ptr]))

  @functools.native_method
  def _remove_remote(self, remote_name:'str'   ) -> None:
    r'''
				Remove a remote from the local VCS.
			'''

    assert(not remote_name is None)
    assert isinstance(remote_name, (str, String)), 'remote_name must be str or String'





    assert(isinstance(remote_name, (str, String)))
    py_string_remote_name = remote_name if isinstance(remote_name, StringName) else c_utils.py_string_to_string(remote_name)

    self._ptr.call_with_return(65,tuple([py_string_remote_name._ptr]))

  @functools.native_method
  def _get_current_branch_name(self) -> typing.Union[str]:
    r'''
				Gets the current branch name defined in the VCS.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(66,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _checkout_branch(self, branch_name:'str'   ) -> typing.Union[bool]:
    r'''
				Checks out a `branch_name` in the VCS.
			'''

    assert(not branch_name is None)
    assert isinstance(branch_name, (str, String)), 'branch_name must be str or String'





    assert(isinstance(branch_name, (str, String)))
    py_string_branch_name = branch_name if isinstance(branch_name, StringName) else c_utils.py_string_to_string(branch_name)

    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([py_string_branch_name._ptr]))
    return _ret


  @functools.native_method
  def _pull(self, remote:'str'   ) -> None:
    r'''
				Pulls changes from the remote. This can give rise to merge conflicts.
			'''

    assert(not remote is None)
    assert isinstance(remote, (str, String)), 'remote must be str or String'





    assert(isinstance(remote, (str, String)))
    py_string_remote = remote if isinstance(remote, StringName) else c_utils.py_string_to_string(remote)

    self._ptr.call_with_return(68,tuple([py_string_remote._ptr]))

  @functools.native_method
  def _push(self, remote:'str'   , force:'bool'   ) -> None:
    r'''
				Pushes changes to the `remote`. If `force` is `true`, a force push will override the change history already present on the remote.
			'''

    assert(not remote is None)
    assert isinstance(remote, (str, String)), 'remote must be str or String'
    assert isinstance(force, bool), 'force must be bool'





    assert(isinstance(remote, (str, String)))
    py_string_remote = remote if isinstance(remote, StringName) else c_utils.py_string_to_string(remote)


    self._ptr.call_with_return(69,tuple([py_string_remote._ptr, force]))

  @functools.native_method
  def _fetch(self, remote:'str'   ) -> None:
    r'''
				Fetches new changes from the `remote`, but doesn't write changes to the current working directory. Equivalent to `git fetch`.
			'''

    assert(not remote is None)
    assert isinstance(remote, (str, String)), 'remote must be str or String'





    assert(isinstance(remote, (str, String)))
    py_string_remote = remote if isinstance(remote, StringName) else c_utils.py_string_to_string(remote)

    self._ptr.call_with_return(70,tuple([py_string_remote._ptr]))

  @functools.native_method
  def _get_line_diff(self, file_path:'str'   , text:'str'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns an `Array` of `Dictionary` items (see `create_diff_hunk`), each containing a line diff between a file at `file_path` and the `text` which is passed in.
			'''

    assert(not file_path is None)
    assert isinstance(file_path, (str, String)), 'file_path must be str or String'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'





    assert(isinstance(file_path, (str, String)))
    py_string_file_path = file_path if isinstance(file_path, StringName) else c_utils.py_string_to_string(file_path)
    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(71,tuple([py_string_file_path._ptr, py_string_text._ptr]))
    return _ret


  @functools.native_method
  def create_diff_line(self, new_line_no:'int'   , old_line_no:'int'   , content:'str'   , status:'str'   ) -> typing.Union['Dictionary']:
    r'''
				Helper function to create a `Dictionary` for storing a line diff. `new_line_no` is the line number in the new file (can be `-1` if the line is deleted). `old_line_no` is the line number in the old file (can be `-1` if the line is added). `content` is the diff text. `status` is a single character string which stores the line origin.
			'''

    assert isinstance(new_line_no, (int, float)), 'new_line_no must be int or float'
    assert isinstance(old_line_no, (int, float)), 'old_line_no must be int or float'
    assert(not content is None)
    assert isinstance(content, (str, String)), 'content must be str or String'
    assert(not status is None)
    assert isinstance(status, (str, String)), 'status must be str or String'







    assert(isinstance(content, (str, String)))
    py_string_content = content if isinstance(content, StringName) else c_utils.py_string_to_string(content)
    assert(isinstance(status, (str, String)))
    py_string_status = status if isinstance(status, StringName) else c_utils.py_string_to_string(status)

    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(72,tuple([new_line_no, old_line_no, py_string_content._ptr, py_string_status._ptr]))
    return _ret


  @functools.native_method
  def create_diff_hunk(self, old_start:'int'   , new_start:'int'   , old_lines:'int'   , new_lines:'int'   ) -> typing.Union['Dictionary']:
    r'''
				Helper function to create a `Dictionary` for storing diff hunk data. `old_start` is the starting line number in old file. `new_start` is the starting line number in new file. `old_lines` is the number of lines in the old file. `new_lines` is the number of lines in the new file.
			'''

    assert isinstance(old_start, (int, float)), 'old_start must be int or float'
    assert isinstance(new_start, (int, float)), 'new_start must be int or float'
    assert isinstance(old_lines, (int, float)), 'old_lines must be int or float'
    assert isinstance(new_lines, (int, float)), 'new_lines must be int or float'










    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(73,tuple([old_start, new_start, old_lines, new_lines]))
    return _ret


  @functools.native_method
  def create_diff_file(self, new_file:'str'   , old_file:'str'   ) -> typing.Union['Dictionary']:
    r'''
				Helper function to create a `Dictionary` for storing old and new diff file paths.
			'''

    assert(not new_file is None)
    assert isinstance(new_file, (str, String)), 'new_file must be str or String'
    assert(not old_file is None)
    assert isinstance(old_file, (str, String)), 'old_file must be str or String'





    assert(isinstance(new_file, (str, String)))
    py_string_new_file = new_file if isinstance(new_file, StringName) else c_utils.py_string_to_string(new_file)
    assert(isinstance(old_file, (str, String)))
    py_string_old_file = old_file if isinstance(old_file, StringName) else c_utils.py_string_to_string(old_file)

    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(74,tuple([py_string_new_file._ptr, py_string_old_file._ptr]))
    return _ret


  @functools.native_method
  def create_commit(self, msg:'str'   , author:'str'   , id:'str'   , unix_timestamp:'int'   , offset_minutes:'int'   ) -> typing.Union['Dictionary']:
    r'''
				Helper function to create a commit `Dictionary` item. `msg` is the commit message of the commit. `author` is a single human-readable string containing all the author's details, e.g. the email and name configured in the VCS. `id` is the identifier of the commit, in whichever format your VCS may provide an identifier to commits. `unix_timestamp` is the UTC Unix timestamp of when the commit was created. `offset_minutes` is the timezone offset in minutes, recorded from the system timezone where the commit was created.
			'''

    assert(not msg is None)
    assert isinstance(msg, (str, String)), 'msg must be str or String'
    assert(not author is None)
    assert isinstance(author, (str, String)), 'author must be str or String'
    assert(not id is None)
    assert isinstance(id, (str, String)), 'id must be str or String'
    assert isinstance(unix_timestamp, (int, float)), 'unix_timestamp must be int or float'
    assert isinstance(offset_minutes, (int, float)), 'offset_minutes must be int or float'





    assert(isinstance(msg, (str, String)))
    py_string_msg = msg if isinstance(msg, StringName) else c_utils.py_string_to_string(msg)
    assert(isinstance(author, (str, String)))
    py_string_author = author if isinstance(author, StringName) else c_utils.py_string_to_string(author)
    assert(isinstance(id, (str, String)))
    py_string_id = id if isinstance(id, StringName) else c_utils.py_string_to_string(id)



    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(75,tuple([py_string_msg._ptr, py_string_author._ptr, py_string_id._ptr, unix_timestamp, offset_minutes]))
    return _ret


  @functools.native_method
  def create_status_file(self, file_path:'str'   , change_type:'int'  , area:'int'  ) -> typing.Union['Dictionary']:
    r'''
				Helper function to create a `Dictionary` used by editor to read the status of a file.
			'''

    assert(not file_path is None)
    assert isinstance(file_path, (str, String)), 'file_path must be str or String'
    assert isinstance(change_type, (int, float)), 'change_type must be int or float'
    assert isinstance(area, (int, float)), 'area must be int or float'





    assert(isinstance(file_path, (str, String)))
    py_string_file_path = file_path if isinstance(file_path, StringName) else c_utils.py_string_to_string(file_path)



    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(76,tuple([py_string_file_path._ptr, change_type, area]))
    return _ret


  @functools.native_method
  def add_diff_hunks_into_diff_file(self, diff_file:'Dictionary'   , diff_hunks:'py4godot_dictionarytypedarray.DictionaryTypedArray'   ) -> typing.Union['Dictionary']:
    r'''
				Helper function to add an array of `diff_hunks` into a `diff_file`.
			'''

    assert(not diff_file is None)
    assert isinstance(diff_file, Dictionary), 'diff_file must be Dictionary'
    assert isinstance(diff_hunks, Array), 'diff_hunks must be Array'








    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(77,tuple([diff_file._ptr, diff_hunks._ptr]))
    return _ret


  @functools.native_method
  def add_line_diffs_into_diff_hunk(self, diff_hunk:'Dictionary'   , line_diffs:'py4godot_dictionarytypedarray.DictionaryTypedArray'   ) -> typing.Union['Dictionary']:
    r'''
				Helper function to add an array of `line_diffs` into a `diff_hunk`.
			'''

    assert(not diff_hunk is None)
    assert isinstance(diff_hunk, Dictionary), 'diff_hunk must be Dictionary'
    assert isinstance(line_diffs, Array), 'line_diffs must be Array'








    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([diff_hunk._ptr, line_diffs._ptr]))
    return _ret


  @functools.native_method
  def popup_error(self, msg:'str'   ) -> None:
    r'''
				Pops up an error message in the editor which is shown as coming from the underlying VCS. Use this to show VCS specific error messages.
			'''

    assert(not msg is None)
    assert isinstance(msg, (str, String)), 'msg must be str or String'





    assert(isinstance(msg, (str, String)))
    py_string_msg = msg if isinstance(msg, StringName) else c_utils.py_string_to_string(msg)

    self._ptr.call_with_return(79,tuple([py_string_msg._ptr]))


register_cast_function('EditorVCSInterface', EditorVCSInterface.cast)
register_class('EditorVCSInterface', EditorVCSInterface)
