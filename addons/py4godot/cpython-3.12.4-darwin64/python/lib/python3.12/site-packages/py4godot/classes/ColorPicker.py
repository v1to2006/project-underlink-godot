# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
from py4godot.wrappers.wrappers import CPPColorPickerWrapper

class ColorModeType:
  MODE_RGB = 0
  MODE_HSV = 1
  MODE_RAW = 2
  MODE_LINEAR = 2
  MODE_OKHSL = 3
class PickerShapeType:
  SHAPE_HSV_RECTANGLE = 0
  SHAPE_HSV_WHEEL = 1
  SHAPE_VHS_CIRCLE = 2
  SHAPE_OKHSL_CIRCLE = 3
  SHAPE_NONE = 4
  SHAPE_OK_HS_RECTANGLE = 5
  SHAPE_OK_HL_RECTANGLE = 6


class ColorPicker(py4godot_vboxcontainer.VBoxContainer):
  r'''
		A widget that provides an interface for selecting or modifying a color. It can optionally provide functionalities like a color sampler (eyedropper), color modes, and presets.
		**Note:** This control is the color picker widget itself. You can use a `ColorPickerButton` instead if you need a button that brings up a `ColorPicker` in a popup.
	'''

  @staticmethod
  def constructor():
    class_ = ColorPicker.construct_without_init()
    class_._ptr = constructor(222,0, ())
    return class_
  @staticmethod
  def new():
    class_ = ColorPicker.construct_without_init()
    class_._ptr = constructor(222,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPColorPickerWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(222,0, ())


  def generate_wrapper(self):
    return CPPColorPickerWrapper()
  def init_signals(self):
    super().init_signals()
    color_changed_name = utils.py_string_to_string_name("color_changed")
    self.color_changed = signals.BuiltinSignal(self, color_changed_name)
    preset_added_name = utils.py_string_to_string_name("preset_added")
    self.preset_added = signals.BuiltinSignal(self, preset_added_name)
    preset_removed_name = utils.py_string_to_string_name("preset_removed")
    self.preset_removed = signals.BuiltinSignal(self, preset_removed_name)

  @staticmethod
  def construct_without_init():
    cls = ColorPicker.__new__(ColorPicker)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'ColorPicker'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = ColorPicker.construct_without_init()
    cls._ptr = CPPColorPickerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = ColorPicker.construct_without_init()
    cls._ptr = CPPColorPickerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_pick_color()
    return _ret
  @color.setter
  def color(self,  value:'Color'):
    self.set_pick_color(value)
  @property
  def edit_alpha(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_editing_alpha()
    return _ret
  @edit_alpha.setter
  def edit_alpha(self,  value:'bool'):
    self.set_edit_alpha(value)
  @property
  def edit_intensity(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_editing_intensity()
    return _ret
  @edit_intensity.setter
  def edit_intensity(self,  value:'bool'):
    self.set_edit_intensity(value)
  @property
  def color_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_color_mode()
    return _ret
  @color_mode.setter
  def color_mode(self,  value:'int'):
    self.set_color_mode(value)
  @property
  def deferred_mode(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_deferred_mode()
    return _ret
  @deferred_mode.setter
  def deferred_mode(self,  value:'bool'):
    self.set_deferred_mode(value)
  @property
  def picker_shape(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_picker_shape()
    return _ret
  @picker_shape.setter
  def picker_shape(self,  value:'int'):
    self.set_picker_shape(value)
  @property
  def can_add_swatches(self) -> typing.Union[bool]:
    r''''''
    _ret = self. are_swatches_enabled()
    return _ret
  @can_add_swatches.setter
  def can_add_swatches(self,  value:'bool'):
    self.set_can_add_swatches(value)
  @property
  def sampler_visible(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_sampler_visible()
    return _ret
  @sampler_visible.setter
  def sampler_visible(self,  value:'bool'):
    self.set_sampler_visible(value)
  @property
  def color_modes_visible(self) -> typing.Union[bool]:
    r''''''
    _ret = self. are_modes_visible()
    return _ret
  @color_modes_visible.setter
  def color_modes_visible(self,  value:'bool'):
    self.set_modes_visible(value)
  @property
  def sliders_visible(self) -> typing.Union[bool]:
    r''''''
    _ret = self. are_sliders_visible()
    return _ret
  @sliders_visible.setter
  def sliders_visible(self,  value:'bool'):
    self.set_sliders_visible(value)
  @property
  def hex_visible(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_hex_visible()
    return _ret
  @hex_visible.setter
  def hex_visible(self,  value:'bool'):
    self.set_hex_visible(value)
  @property
  def presets_visible(self) -> typing.Union[bool]:
    r''''''
    _ret = self. are_presets_visible()
    return _ret
  @presets_visible.setter
  def presets_visible(self,  value:'bool'):
    self.set_presets_visible(value)
  @functools.native_method
  def set_pick_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__color = color






    self._ptr.call_with_return(442,tuple([color._ptr]))

  @functools.native_method
  def get_pick_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(443,tuple([]))

    return _ret


  @functools.native_method
  def set_deferred_mode(self, mode:'bool'   ) -> None:
    r''''''

    assert isinstance(mode, bool), 'mode must be bool'


    self.py__deferred_mode = mode






    self._ptr.call_with_return(444,tuple([mode]))

  @functools.native_method
  def is_deferred_mode(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(445,tuple([]))

    return _ret


  @functools.native_method
  def set_color_mode(self, color_mode:'int'  ) -> None:
    r''''''

    assert isinstance(color_mode, (int, float)), 'color_mode must be int or float'


    self.py__color_mode = color_mode






    self._ptr.call_with_return(446,tuple([color_mode]))

  @functools.native_method
  def get_color_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(447,tuple([]))

    return _ret


  @functools.native_method
  def set_edit_alpha(self, show:'bool'   ) -> None:
    r''''''

    assert isinstance(show, bool), 'show must be bool'


    self.py__edit_alpha = show






    self._ptr.call_with_return(448,tuple([show]))

  @functools.native_method
  def is_editing_alpha(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(449,tuple([]))

    return _ret


  @functools.native_method
  def set_edit_intensity(self, show:'bool'   ) -> None:
    r''''''

    assert isinstance(show, bool), 'show must be bool'


    self.py__edit_intensity = show






    self._ptr.call_with_return(450,tuple([show]))

  @functools.native_method
  def is_editing_intensity(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(451,tuple([]))

    return _ret


  @functools.native_method
  def set_can_add_swatches(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__can_add_swatches = enabled






    self._ptr.call_with_return(452,tuple([enabled]))

  @functools.native_method
  def are_swatches_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(453,tuple([]))

    return _ret


  @functools.native_method
  def set_presets_visible(self, visible:'bool'   ) -> None:
    r''''''

    assert isinstance(visible, bool), 'visible must be bool'


    self.py__presets_visible = visible






    self._ptr.call_with_return(454,tuple([visible]))

  @functools.native_method
  def are_presets_visible(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(455,tuple([]))

    return _ret


  @functools.native_method
  def set_modes_visible(self, visible:'bool'   ) -> None:
    r''''''

    assert isinstance(visible, bool), 'visible must be bool'


    self.py__color_modes_visible = visible






    self._ptr.call_with_return(456,tuple([visible]))

  @functools.native_method
  def are_modes_visible(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(457,tuple([]))

    return _ret


  @functools.native_method
  def set_sampler_visible(self, visible:'bool'   ) -> None:
    r''''''

    assert isinstance(visible, bool), 'visible must be bool'


    self.py__sampler_visible = visible






    self._ptr.call_with_return(458,tuple([visible]))

  @functools.native_method
  def is_sampler_visible(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(459,tuple([]))

    return _ret


  @functools.native_method
  def set_sliders_visible(self, visible:'bool'   ) -> None:
    r''''''

    assert isinstance(visible, bool), 'visible must be bool'


    self.py__sliders_visible = visible






    self._ptr.call_with_return(460,tuple([visible]))

  @functools.native_method
  def are_sliders_visible(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(461,tuple([]))

    return _ret


  @functools.native_method
  def set_hex_visible(self, visible:'bool'   ) -> None:
    r''''''

    assert isinstance(visible, bool), 'visible must be bool'


    self.py__hex_visible = visible






    self._ptr.call_with_return(462,tuple([visible]))

  @functools.native_method
  def is_hex_visible(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(463,tuple([]))

    return _ret


  @functools.native_method
  def add_preset(self, color:'Color'   ) -> None:
    r'''
				Adds the given color to a list of color presets. The presets are displayed in the color picker and the user will be able to select them.
				**Note:** The presets list is only for _this_ color picker.
			'''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(464,tuple([color._ptr]))

  @functools.native_method
  def erase_preset(self, color:'Color'   ) -> None:
    r'''
				Removes the given color from the list of color presets of this color picker.
			'''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(465,tuple([color._ptr]))

  @functools.native_method
  def get_presets(self) -> typing.Union['PackedColorArray']:
    r'''
				Returns the list of colors in the presets of the color picker.
			'''




    _ret = PackedColorArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(466,tuple([]))
    return _ret


  @functools.native_method
  def add_recent_preset(self, color:'Color'   ) -> None:
    r'''
				Adds the given color to a list of color recent presets so that it can be picked later. Recent presets are the colors that were picked recently, a new preset is automatically created and added to recent presets when you pick a new color.
				**Note:** The recent presets list is only for _this_ color picker.
			'''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(467,tuple([color._ptr]))

  @functools.native_method
  def erase_recent_preset(self, color:'Color'   ) -> None:
    r'''
				Removes the given color from the list of color recent presets of this color picker.
			'''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'







    self._ptr.call_with_return(468,tuple([color._ptr]))

  @functools.native_method
  def get_recent_presets(self) -> typing.Union['PackedColorArray']:
    r'''
				Returns the list of colors in the recent presets of the color picker.
			'''




    _ret = PackedColorArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(469,tuple([]))
    return _ret


  @functools.native_method
  def set_picker_shape(self, shape:'int'  ) -> None:
    r''''''

    assert isinstance(shape, (int, float)), 'shape must be int or float'


    self.py__picker_shape = shape






    self._ptr.call_with_return(470,tuple([shape]))

  @functools.native_method
  def get_picker_shape(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(471,tuple([]))

    return _ret



register_cast_function('ColorPicker', ColorPicker.cast)
register_class('ColorPicker', ColorPicker)
