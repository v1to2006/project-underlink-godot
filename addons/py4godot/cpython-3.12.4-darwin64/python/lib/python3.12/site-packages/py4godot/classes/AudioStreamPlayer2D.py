# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.AudioStreamPolyphonic as py4godot_audiostreampolyphonic 
  import py4godot.classes.AudioServer as py4godot_audioserver 
  import py4godot.classes.AudioStreamPlaybackPolyphonic as py4godot_audiostreamplaybackpolyphonic 
  import py4godot.classes.AudioStreamPlaybackPlaylist as py4godot_audiostreamplaybackplaylist 
  import py4godot.classes.AudioStreamPlaylist as py4godot_audiostreamplaylist 
  import py4godot.classes.AudioStreamPlaybackInteractive as py4godot_audiostreamplaybackinteractive 
  import py4godot.classes.AudioStreamPlaybackResampled as py4godot_audiostreamplaybackresampled 
  import py4godot.classes.AudioStreamPlayback as py4godot_audiostreamplayback 
  import py4godot.classes.AudioStreamInteractive as py4godot_audiostreaminteractive 
  import py4godot.classes.AudioStream as py4godot_audiostream 
  import py4godot.classes.AudioStreamMicrophone as py4godot_audiostreammicrophone 
  import py4godot.classes.AudioStreamOggVorbis as py4godot_audiostreamoggvorbis 
  import py4godot.classes.AudioStreamSynchronized as py4godot_audiostreamsynchronized 
  import py4godot.classes.AudioStreamGeneratorPlayback as py4godot_audiostreamgeneratorplayback 
  import py4godot.classes.AudioStreamMP3 as py4godot_audiostreammp3 
  import py4godot.classes.AudioStreamPlaybackOggVorbis as py4godot_audiostreamplaybackoggvorbis 
  import py4godot.classes.AudioStreamWAV as py4godot_audiostreamwav 
  import py4godot.classes.AudioStreamGenerator as py4godot_audiostreamgenerator 
  import py4godot.classes.AudioStreamRandomizer as py4godot_audiostreamrandomizer 
  import py4godot.classes.AudioStreamPlaybackSynchronized as py4godot_audiostreamplaybacksynchronized 
import py4godot.classes.Node2D as py4godot_node2d 
from py4godot.wrappers.wrappers import CPPAudioStreamPlayer2DWrapper


class AudioStreamPlayer2D(py4godot_node2d.Node2D):
  r'''
		Plays audio that is attenuated with distance to the listener.
		By default, audio is heard from the screen center. This can be changed by adding an `AudioListener2D` node to the scene and enabling it by calling `AudioListener2D.make_current` on it.
		See also `AudioStreamPlayer` to play a sound non-positionally.
		**Note:** Hiding an `AudioStreamPlayer2D` node does not disable its audio output. To temporarily disable an `AudioStreamPlayer2D`'s audio output, set `volume_db` to a very low value like `-100` (which isn't audible to human hearing).
	'''

  @staticmethod
  def constructor():
    class_ = AudioStreamPlayer2D.construct_without_init()
    class_._ptr = constructor(155,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AudioStreamPlayer2D.construct_without_init()
    class_._ptr = constructor(155,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAudioStreamPlayer2DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(155,0, ())


  def generate_wrapper(self):
    return CPPAudioStreamPlayer2DWrapper()
  def init_signals(self):
    super().init_signals()
    finished_name = utils.py_string_to_string_name("finished")
    self.finished = signals.BuiltinSignal(self, finished_name)

  @staticmethod
  def construct_without_init():
    cls = AudioStreamPlayer2D.__new__(AudioStreamPlayer2D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AudioStreamPlayer2D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AudioStreamPlayer2D.construct_without_init()
    cls._ptr = CPPAudioStreamPlayer2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AudioStreamPlayer2D.construct_without_init()
    cls._ptr = CPPAudioStreamPlayer2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def stream(self) -> typing.Any:
    r''''''
    _ret = self. get_stream()
    return _ret
  @stream.setter
  def stream(self,  value:'py4godot_object.Object'):
    self.set_stream(value)
  @property
  def volume_db(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volume_db()
    return _ret
  @volume_db.setter
  def volume_db(self,  value:'float'):
    self.set_volume_db(value)
  @property
  def volume_linear(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volume_linear()
    return _ret
  @volume_linear.setter
  def volume_linear(self,  value:'float'):
    self.set_volume_linear(value)
  @property
  def pitch_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_pitch_scale()
    return _ret
  @pitch_scale.setter
  def pitch_scale(self,  value:'float'):
    self.set_pitch_scale(value)
  @property
  def playing(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_playing()
    return _ret
  @playing.setter
  def playing(self,  value:'bool'):
    self.set_playing(value)
  @property
  def autoplay(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_autoplay_enabled()
    return _ret
  @autoplay.setter
  def autoplay(self,  value:'bool'):
    self.set_autoplay(value)
  @property
  def stream_paused(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_stream_paused()
    return _ret
  @stream_paused.setter
  def stream_paused(self,  value:'bool'):
    self.set_stream_paused(value)
  @property
  def max_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_max_distance()
    return _ret
  @max_distance.setter
  def max_distance(self,  value:'float'):
    self.set_max_distance(value)
  @property
  def attenuation(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_attenuation()
    return _ret
  @attenuation.setter
  def attenuation(self,  value:'float'):
    self.set_attenuation(value)
  @property
  def max_polyphony(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_polyphony()
    return _ret
  @max_polyphony.setter
  def max_polyphony(self,  value:'int'):
    self.set_max_polyphony(value)
  @property
  def panning_strength(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_panning_strength()
    return _ret
  @panning_strength.setter
  def panning_strength(self,  value:'float'):
    self.set_panning_strength(value)
  @property
  def bus(self) -> typing.Union['StringName']:
    r''''''
    _ret = self. get_bus()
    return _ret
  @bus.setter
  def bus(self,  value:'object'):
    self.set_bus(value)
  @property
  def area_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_area_mask()
    return _ret
  @area_mask.setter
  def area_mask(self,  value:'int'):
    self.set_area_mask(value)
  @property
  def playback_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_playback_type()
    return _ret
  @playback_type.setter
  def playback_type(self,  value:'int'):
    self.set_playback_type(value)
  @functools.native_method
  def set_stream(self, stream:'py4godot_audiostream.AudioStream'   ) -> None:
    r''''''

    assert(not stream is None)
    assert isinstance(stream, get_class('AudioStream')), 'stream must be AudioStream'


    self.py__stream = stream






    self._ptr.call_with_return(303,tuple([stream._ptr]))

  @functools.native_method
  def get_stream(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioStream
    _ret._ptr = self._ptr.call_with_return(304,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_volume_db(self, volume_db:'float'   ) -> None:
    r''''''

    assert isinstance(volume_db, (int, float)), 'volume_db must be int or float'


    self.py__volume_db = volume_db






    self._ptr.call_with_return(305,tuple([volume_db]))

  @functools.native_method
  def get_volume_db(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(306,tuple([]))

    return _ret


  @functools.native_method
  def set_volume_linear(self, volume_linear:'float'   ) -> None:
    r''''''

    assert isinstance(volume_linear, (int, float)), 'volume_linear must be int or float'


    self.py__volume_linear = volume_linear






    self._ptr.call_with_return(307,tuple([volume_linear]))

  @functools.native_method
  def get_volume_linear(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(308,tuple([]))

    return _ret


  @functools.native_method
  def set_pitch_scale(self, pitch_scale:'float'   ) -> None:
    r''''''

    assert isinstance(pitch_scale, (int, float)), 'pitch_scale must be int or float'


    self.py__pitch_scale = pitch_scale






    self._ptr.call_with_return(309,tuple([pitch_scale]))

  @functools.native_method
  def get_pitch_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(310,tuple([]))

    return _ret


  @functools.native_method
  def play(self, from_position:'float' =0.0  ) -> None:
    r'''
				Queues the audio to play on the next physics frame, from the given position `from_position`, in seconds.
			'''

    assert isinstance(from_position, (int, float)), 'from_position must be int or float'







    self._ptr.call_with_return(311,tuple([from_position]))

  @functools.native_method
  def seek(self, to_position:'float'   ) -> None:
    r'''
				Sets the position from which audio will be played, in seconds.
			'''

    assert isinstance(to_position, (int, float)), 'to_position must be int or float'







    self._ptr.call_with_return(312,tuple([to_position]))

  @functools.native_method
  def stop(self) -> None:
    r'''
				Stops the audio.
			'''




    self._ptr.call_with_return(313,tuple([]))

  @functools.native_method
  def is_playing(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(314,tuple([]))

    return _ret


  @functools.native_method
  def get_playback_position(self) -> typing.Union[float]:
    r'''
				Returns the position in the `AudioStream`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(315,tuple([]))
    return _ret


  @functools.native_method
  def set_bus(self, bus:'object'   ) -> None:
    r''''''

    assert(not bus is None)
    assert isinstance(bus, (str, StringName)), 'bus must be str or StringName'


    self.py__bus = bus



    assert(isinstance(bus, (str, StringName)))
    py_stringname_bus = bus if isinstance(bus, StringName) else c_utils.py_string_to_string_name(bus)


    self._ptr.call_with_return(316,tuple([py_stringname_bus._ptr]))

  @functools.native_method
  def get_bus(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(317,tuple([]))

    return str(_ret)


  @functools.native_method
  def set_autoplay(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__autoplay = enable






    self._ptr.call_with_return(318,tuple([enable]))

  @functools.native_method
  def is_autoplay_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(319,tuple([]))

    return _ret


  @functools.native_method
  def set_playing(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__playing = enable






    self._ptr.call_with_return(320,tuple([enable]))

  @functools.native_method
  def set_max_distance(self, pixels:'float'   ) -> None:
    r''''''

    assert isinstance(pixels, (int, float)), 'pixels must be int or float'


    self.py__max_distance = pixels






    self._ptr.call_with_return(321,tuple([pixels]))

  @functools.native_method
  def get_max_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(322,tuple([]))

    return _ret


  @functools.native_method
  def set_attenuation(self, curve:'float'   ) -> None:
    r''''''

    assert isinstance(curve, (int, float)), 'curve must be int or float'


    self.py__attenuation = curve






    self._ptr.call_with_return(323,tuple([curve]))

  @functools.native_method
  def get_attenuation(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(324,tuple([]))

    return _ret


  @functools.native_method
  def set_area_mask(self, mask:'int'   ) -> None:
    r''''''

    assert isinstance(mask, (int, float)), 'mask must be int or float'


    self.py__area_mask = mask






    self._ptr.call_with_return(325,tuple([mask]))

  @functools.native_method
  def get_area_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(326,tuple([]))

    return _ret


  @functools.native_method
  def set_stream_paused(self, pause:'bool'   ) -> None:
    r''''''

    assert isinstance(pause, bool), 'pause must be bool'


    self.py__stream_paused = pause






    self._ptr.call_with_return(327,tuple([pause]))

  @functools.native_method
  def get_stream_paused(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(328,tuple([]))

    return _ret


  @functools.native_method
  def set_max_polyphony(self, max_polyphony:'int'   ) -> None:
    r''''''

    assert isinstance(max_polyphony, (int, float)), 'max_polyphony must be int or float'


    self.py__max_polyphony = max_polyphony






    self._ptr.call_with_return(329,tuple([max_polyphony]))

  @functools.native_method
  def get_max_polyphony(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(330,tuple([]))

    return _ret


  @functools.native_method
  def set_panning_strength(self, panning_strength:'float'   ) -> None:
    r''''''

    assert isinstance(panning_strength, (int, float)), 'panning_strength must be int or float'


    self.py__panning_strength = panning_strength






    self._ptr.call_with_return(331,tuple([panning_strength]))

  @functools.native_method
  def get_panning_strength(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(332,tuple([]))

    return _ret


  @functools.native_method
  def has_stream_playback(self) -> typing.Union[bool]:
    r'''
				Returns whether the `AudioStreamPlayer` can return the `AudioStreamPlayback` object or not.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(333,tuple([]))
    return _ret


  @functools.native_method
  def get_stream_playback(self) -> typing.Any:
    r'''
				Returns the `AudioStreamPlayback` object associated with this `AudioStreamPlayer2D`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioStreamPlayback
    _ret._ptr = self._ptr.call_with_return(334,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_playback_type(self, playback_type:'int'  ) -> None:
    r''''''

    assert isinstance(playback_type, (int, float)), 'playback_type must be int or float'


    self.py__playback_type = playback_type






    self._ptr.call_with_return(335,tuple([playback_type]))

  @functools.native_method
  def get_playback_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(336,tuple([]))

    return _ret



register_cast_function('AudioStreamPlayer2D', AudioStreamPlayer2D.cast)
register_class('AudioStreamPlayer2D', AudioStreamPlayer2D)
