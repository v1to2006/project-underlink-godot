# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.Object as py4godot_object 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
from py4godot.wrappers.wrappers import CPPProjectSettingsWrapper

_ProjectSettings_singleton_instance = None

class ProjectSettings(py4godot_object.Object):
  r'''
		Stores variables that can be accessed from everywhere. Use `get_setting`, `set_setting` or `has_setting` to access them. Variables stored in `project.godot` are also loaded into `ProjectSettings`, making this object very useful for reading custom game configuration options.
		When naming a Project Settings property, use the full path to the setting including the category. For example, `"application/config/name"` for the project name. Category and property names can be viewed in the Project Settings dialog.
		**Feature tags:** Project settings can be overridden for specific platforms and configurations (debug, release, ...) using `url=$DOCS_URL/tutorials/export/feature_tags.html`feature tags`/url`.
		**Overriding:** Any project setting can be overridden by creating a file named `override.cfg` in the project's root directory. This can also be used in exported projects by placing this file in the same directory as the project binary. Overriding will still take the base project settings' `url=$DOCS_URL/tutorials/export/feature_tags.html`feature tags`/url` in account. Therefore, make sure to _also_ override the setting with the desired feature tags if you want them to override base project settings on all platforms and configurations.
	'''


  def generate_wrapper(self):
    return CPPProjectSettingsWrapper()
  def init_signals(self):
    super().init_signals()
    settings_changed_name = utils.py_string_to_string_name("settings_changed")
    self.settings_changed = signals.BuiltinSignal(self, settings_changed_name)

  @staticmethod
  def construct_without_init():
    cls = ProjectSettings.__new__(ProjectSettings)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'ProjectSettings'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = ProjectSettings.construct_without_init()
    cls._ptr = CPPProjectSettingsWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = ProjectSettings.construct_without_init()
    cls._ptr = CPPProjectSettingsWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _ProjectSettings_singleton_instance
    if _ProjectSettings_singleton_instance is None:
      singleton = ProjectSettings()
      singleton._ptr = constructor(641,0, ())
      _ProjectSettings_singleton_instance = singleton
    return _ProjectSettings_singleton_instance

  @functools.native_method
  def has_setting(self, name:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if a configuration value is present.
				**Note:** In order to be be detected, custom settings have to be either defined with `set_setting`, or exist in the `project.godot` file. This is especially relevant when using `set_initial_value`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(49,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def set_setting(self, name:'str'   , value:'object'   ) -> None:
    r'''
				Sets the value of a setting.
				
				```gdscript
				ProjectSettings.set_setting("application/config/name", "Example")
				```
				
				
				This can also be used to erase custom project settings. To do this change the setting value to `null`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    self._ptr.call_with_return(50,tuple([py_string_name._ptr, value]))

  @functools.native_method
  def get_setting(self, name:'str'   , default_value:'object' =None  ) -> typing.Union[typing.Any]:
    r'''
				Returns the value of the setting identified by `name`. If the setting doesn't exist and `default_value` is specified, the value of `default_value` is returned. Otherwise, `null` is returned.
				
				```gdscript
				print(ProjectSettings.get_setting("application/config/name"))
				print(ProjectSettings.get_setting("application/config/custom_description", "No description specified."))
				```
				
				
				**Note:** This method doesn't take potential feature overrides into account automatically. Use `get_setting_with_override` to handle seamlessly.
				See also `has_setting` to check whether a setting exists.
			'''


    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    

    if not (type(default_value).__name__ in py4godot.variant_types.core_types or isinstance(default_value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'default_value': "
                f"{type(default_value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    _ret = None
    _ret = self._ptr.call_with_return(51,tuple([py_string_name._ptr, default_value]))
    return _ret


  @functools.native_method
  def get_setting_with_override(self, name:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Similar to `get_setting`, but applies feature tag overrides if any exists and is valid.
				**Example:** If the setting override `"application/config/name.windows"` exists, and the following code is executed on a _Windows_ operating system, the overridden setting is printed instead:
				
				```gdscript
				print(ProjectSettings.get_setting_with_override("application/config/name"))
				```
				
				
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = None
    _ret = self._ptr.call_with_return(52,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def get_global_class_list(self) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns an `Array` of registered global classes. Each global class is represented as a `Dictionary` that contains the following entries:
				- `base` is a name of the base class;
				- `class` is a name of the registered global class;
				- `icon` is a path to a custom icon of the global class, if it has any;
				- `language` is a name of a programming language in which the global class is written;
				- `path` is a path to a file containing the global class.
				**Note:** Both the script and the icon paths are local to the project filesystem, i.e. they start with `res://`.
			'''




    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([]))
    return _ret


  @functools.native_method
  def get_setting_with_override_and_custom_features(self, name:'object'   , features:'PackedStringArray'   ) -> typing.Union[typing.Any]:
    r'''
				Similar to `get_setting_with_override`, but applies feature tag overrides instead of current OS features.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not features is None)
    assert isinstance(features, PackedStringArray), 'features must be PackedStringArray'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    _ret = None
    _ret = self._ptr.call_with_return(54,tuple([py_stringname_name._ptr, features._ptr]))
    return _ret


  @functools.native_method
  def set_order(self, name:'str'   , position:'int'   ) -> None:
    r'''
				Sets the order of a configuration value (influences when saved to the config file).
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert isinstance(position, (int, float)), 'position must be int or float'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    self._ptr.call_with_return(55,tuple([py_string_name._ptr, position]))

  @functools.native_method
  def get_order(self, name:'str'   ) -> typing.Union[int]:
    r'''
				Returns the order of a configuration value (influences when saved to the config file).
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def set_initial_value(self, name:'str'   , value:'object'   ) -> None:
    r'''
				Sets the specified setting's initial value. This is the value the setting reverts to. The setting should already exist before calling this method. Note that project settings equal to their default value are not saved, so your code needs to account for that.
				```gdscript
				extends EditorPlugin

				const SETTING_NAME = "addons/my_setting"
				const SETTING_DEFAULT = 10.0

				func _enter_tree():
					if not ProjectSettings.has_setting(SETTING_NAME):
						ProjectSettings.set_setting(SETTING_NAME, SETTING_DEFAULT)

					ProjectSettings.set_initial_value(SETTING_NAME, SETTING_DEFAULT)
				```
				If you have a project setting defined by an `EditorPlugin`, but want to use it in a running project, you will need a similar code at runtime.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    self._ptr.call_with_return(57,tuple([py_string_name._ptr, value]))

  @functools.native_method
  def set_as_basic(self, name:'str'   , basic:'bool'   ) -> None:
    r'''
				Defines if the specified setting is considered basic or advanced. Basic settings will always be shown in the project settings. Advanced settings will only be shown if the user enables the "Advanced Settings" option.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert isinstance(basic, bool), 'basic must be bool'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    self._ptr.call_with_return(58,tuple([py_string_name._ptr, basic]))

  @functools.native_method
  def set_as_internal(self, name:'str'   , internal:'bool'   ) -> None:
    r'''
				Defines if the specified setting is considered internal. An internal setting won't show up in the Project Settings dialog. This is mostly useful for addons that need to store their own internal settings without exposing them directly to the user.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert isinstance(internal, bool), 'internal must be bool'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    self._ptr.call_with_return(59,tuple([py_string_name._ptr, internal]))

  @functools.native_method
  def add_property_info(self, hint:'Dictionary'   ) -> None:
    r'''
				Adds a custom property info to a property. The dictionary must contain:
				- `"name"`: `String` (the property's name)
				- `"type"`: `int` (see `enum Variant.Type`)
				- optionally `"hint"`: `int` (see `enum PropertyHint`) and `"hint_string"`: `String`
				
				```gdscript
				ProjectSettings.set("category/property_name", 0)

				var property_info = {
					"name": "category/property_name",
					"type": TYPE_INT,
					"hint": PROPERTY_HINT_ENUM,
					"hint_string": "one,two,three"
				}

				ProjectSettings.add_property_info(property_info)
				```
				
				
				**Note:** Setting `"usage"` for the property is not supported. Use `set_as_basic`, `set_restart_if_changed`, and `set_as_internal` to modify usage flags.
			'''

    assert(not hint is None)
    assert isinstance(hint, Dictionary), 'hint must be Dictionary'







    self._ptr.call_with_return(60,tuple([hint._ptr]))

  @functools.native_method
  def set_restart_if_changed(self, name:'str'   , restart:'bool'   ) -> None:
    r'''
				Sets whether a setting requires restarting the editor to properly take effect.
				**Note:** This is just a hint to display to the user that the editor must be restarted for changes to take effect. Enabling `set_restart_if_changed` does _not_ delay the setting being set when changed.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert isinstance(restart, bool), 'restart must be bool'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    self._ptr.call_with_return(61,tuple([py_string_name._ptr, restart]))

  @functools.native_method
  def clear(self, name:'str'   ) -> None:
    r'''
				Clears the whole configuration (not recommended, may break things).
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(62,tuple([py_string_name._ptr]))

  @functools.native_method
  def localize_path(self, path:'str'   ) -> typing.Union[str]:
    r'''
				Returns the localized path (starting with `res://`) corresponding to the absolute, native OS `path`. See also `globalize_path`.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(63,tuple([py_string_path._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def globalize_path(self, path:'str'   ) -> typing.Union[str]:
    r'''
				Returns the absolute, native OS path corresponding to the localized `path` (starting with `res://` or `user://`). The returned path will vary depending on the operating system and user preferences. See `url=$DOCS_URL/tutorials/io/data_paths.html`File paths in Godot projects`/url` to see what those paths convert to. See also `localize_path`.
				**Note:** `globalize_path` with `res://` will not work in an exported project. Instead, prepend the executable's base directory to the path when running from an exported project:
				```gdscript
				var path = ""
				if OS.has_feature("editor"):
					# Running from an editor binary.
					# `path` will contain the absolute path to `hello.txt` located in the project root.
					path = ProjectSettings.globalize_path("res://hello.txt")
				else:
					# Running from an exported project.
					# `path` will contain the absolute path to `hello.txt` next to the executable.
					# This is *not* identical to using `ProjectSettings.globalize_path()` with a `res://` path,
					# but is close enough in spirit.
					path = OS.get_executable_path().get_base_dir().path_join("hello.txt")
				```
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(64,tuple([py_string_path._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def save(self) -> typing.Union[int]:
    r'''
				Saves the configuration to the `project.godot` file.
				**Note:** This method is intended to be used by editor plugins, as modified `ProjectSettings` can't be loaded back in the running app. If you want to change project settings in exported projects, use `save_custom` to save `override.cfg` file.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(65,tuple([]))
    return _ret


  @functools.native_method
  def load_resource_pack(self, pack:'str'   , replace_files:'bool' =True  , offset:'int' =0  ) -> typing.Union[bool]:
    r'''
				Loads the contents of the .pck or .zip file specified by `pack` into the resource filesystem (`res://`). Returns `true` on success.
				**Note:** If a file from `pack` shares the same path as a file already in the resource filesystem, any attempts to load that file will use the file from `pack` unless `replace_files` is set to `false`.
				**Note:** The optional `offset` parameter can be used to specify the offset in bytes to the start of the resource pack. This is only supported for .pck files.
				**Note:** `DirAccess` will not show changes made to the contents of `res://` after calling this function.
			'''

    assert(not pack is None)
    assert isinstance(pack, (str, String)), 'pack must be str or String'
    assert isinstance(replace_files, bool), 'replace_files must be bool'
    assert isinstance(offset, (int, float)), 'offset must be int or float'





    assert(isinstance(pack, (str, String)))
    py_string_pack = pack if isinstance(pack, StringName) else c_utils.py_string_to_string(pack)



    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([py_string_pack._ptr, replace_files, offset]))
    return _ret


  @functools.native_method
  def save_custom(self, file:'str'   ) -> typing.Union[int]:
    r'''
				Saves the configuration to a custom file. The file extension must be `.godot` (to save in text-based `ConfigFile` format) or `.binary` (to save in binary format). You can also save `override.cfg` file, which is also text, but can be used in exported projects unlike other formats.
			'''

    assert(not file is None)
    assert isinstance(file, (str, String)), 'file must be str or String'





    assert(isinstance(file, (str, String)))
    py_string_file = file if isinstance(file, StringName) else c_utils.py_string_to_string(file)

    _ret:int
    _ret = self._ptr.call_with_return(67,tuple([py_string_file._ptr]))
    return _ret



register_cast_function('ProjectSettings', ProjectSettings.cast)
register_class('ProjectSettings', ProjectSettings)
