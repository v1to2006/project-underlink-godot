# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.StandardMaterial3D as py4godot_standardmaterial3d 
  import py4godot.classes.AnimatedSprite3D as py4godot_animatedsprite3d 
  import py4godot.classes.TriangleMesh as py4godot_trianglemesh 
  import py4godot.classes.BaseMaterial3D as py4godot_basematerial3d 
  import py4godot.classes.Sprite3D as py4godot_sprite3d 
  import py4godot.classes.ORMMaterial3D as py4godot_ormmaterial3d 
import py4godot.classes.GeometryInstance3D as py4godot_geometryinstance3d 
from py4godot.wrappers.wrappers import CPPSpriteBase3DWrapper

class DrawFlags:
  FLAG_TRANSPARENT = 0
  FLAG_SHADED = 1
  FLAG_DOUBLE_SIDED = 2
  FLAG_DISABLE_DEPTH_TEST = 3
  FLAG_FIXED_SIZE = 4
  FLAG_MAX = 5
class AlphaCutMode:
  ALPHA_CUT_DISABLED = 0
  ALPHA_CUT_DISCARD = 1
  ALPHA_CUT_OPAQUE_PREPASS = 2
  ALPHA_CUT_HASH = 3


class SpriteBase3D(py4godot_geometryinstance3d.GeometryInstance3D):
  r'''
		A node that displays 2D texture information in a 3D environment. See also `Sprite3D` where many other properties are defined.
	'''

  @staticmethod
  def constructor():
    class_ = SpriteBase3D.construct_without_init()
    class_._ptr = constructor(781,0, ())
    return class_
  @staticmethod
  def new():
    class_ = SpriteBase3D.construct_without_init()
    class_._ptr = constructor(781,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPSpriteBase3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(781,0, ())


  def generate_wrapper(self):
    return CPPSpriteBase3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = SpriteBase3D.__new__(SpriteBase3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'SpriteBase3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = SpriteBase3D.construct_without_init()
    cls._ptr = CPPSpriteBase3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = SpriteBase3D.construct_without_init()
    cls._ptr = CPPSpriteBase3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def centered(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_centered()
    return _ret
  @centered.setter
  def centered(self,  value:'bool'):
    self.set_centered(value)
  @property
  def offset(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_offset()
    return _ret
  @offset.setter
  def offset(self,  value:'Vector2'):
    self.set_offset(value)
  @property
  def flip_h(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_flipped_h()
    return _ret
  @flip_h.setter
  def flip_h(self,  value:'bool'):
    self.set_flip_h(value)
  @property
  def flip_v(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_flipped_v()
    return _ret
  @flip_v.setter
  def flip_v(self,  value:'bool'):
    self.set_flip_v(value)
  @property
  def modulate(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_modulate()
    return _ret
  @modulate.setter
  def modulate(self,  value:'Color'):
    self.set_modulate(value)
  @property
  def pixel_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_pixel_size()
    return _ret
  @pixel_size.setter
  def pixel_size(self,  value:'float'):
    self.set_pixel_size(value)
  @property
  def axis(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_axis()
    return _ret
  @axis.setter
  def axis(self,  value:'int'):
    self.set_axis(value)
  @property
  def billboard(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_billboard_mode()
    return _ret
  @billboard.setter
  def billboard(self,  value:'int'):
    self.set_billboard_mode(value)
  @property
  def transparent(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_draw_flag(0)
    return _ret
  @transparent.setter
  def transparent(self,  value:'bool'):
    self.set_draw_flag(0, value)
  @property
  def shaded(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_draw_flag(1)
    return _ret
  @shaded.setter
  def shaded(self,  value:'bool'):
    self.set_draw_flag(1, value)
  @property
  def double_sided(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_draw_flag(2)
    return _ret
  @double_sided.setter
  def double_sided(self,  value:'bool'):
    self.set_draw_flag(2, value)
  @property
  def no_depth_test(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_draw_flag(3)
    return _ret
  @no_depth_test.setter
  def no_depth_test(self,  value:'bool'):
    self.set_draw_flag(3, value)
  @property
  def fixed_size(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_draw_flag(4)
    return _ret
  @fixed_size.setter
  def fixed_size(self,  value:'bool'):
    self.set_draw_flag(4, value)
  @property
  def alpha_cut(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_alpha_cut_mode()
    return _ret
  @alpha_cut.setter
  def alpha_cut(self,  value:'int'):
    self.set_alpha_cut_mode(value)
  @property
  def alpha_scissor_threshold(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_alpha_scissor_threshold()
    return _ret
  @alpha_scissor_threshold.setter
  def alpha_scissor_threshold(self,  value:'float'):
    self.set_alpha_scissor_threshold(value)
  @property
  def alpha_hash_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_alpha_hash_scale()
    return _ret
  @alpha_hash_scale.setter
  def alpha_hash_scale(self,  value:'float'):
    self.set_alpha_hash_scale(value)
  @property
  def alpha_antialiasing_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_alpha_antialiasing()
    return _ret
  @alpha_antialiasing_mode.setter
  def alpha_antialiasing_mode(self,  value:'int'):
    self.set_alpha_antialiasing(value)
  @property
  def alpha_antialiasing_edge(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_alpha_antialiasing_edge()
    return _ret
  @alpha_antialiasing_edge.setter
  def alpha_antialiasing_edge(self,  value:'float'):
    self.set_alpha_antialiasing_edge(value)
  @property
  def texture_filter(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_texture_filter()
    return _ret
  @texture_filter.setter
  def texture_filter(self,  value:'int'):
    self.set_texture_filter(value)
  @property
  def render_priority(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_render_priority()
    return _ret
  @render_priority.setter
  def render_priority(self,  value:'int'):
    self.set_render_priority(value)
  @functools.native_method
  def set_centered(self, centered:'bool'   ) -> None:
    r''''''

    assert isinstance(centered, bool), 'centered must be bool'


    self.py__centered = centered






    self._ptr.call_with_return(298,tuple([centered]))

  @functools.native_method
  def is_centered(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(299,tuple([]))

    return _ret


  @functools.native_method
  def set_offset(self, offset:'Vector2'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'


    self.py__offset = offset






    self._ptr.call_with_return(300,tuple([offset._ptr]))

  @functools.native_method
  def get_offset(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(301,tuple([]))

    return _ret


  @functools.native_method
  def set_flip_h(self, flip_h:'bool'   ) -> None:
    r''''''

    assert isinstance(flip_h, bool), 'flip_h must be bool'


    self.py__flip_h = flip_h






    self._ptr.call_with_return(302,tuple([flip_h]))

  @functools.native_method
  def is_flipped_h(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(303,tuple([]))

    return _ret


  @functools.native_method
  def set_flip_v(self, flip_v:'bool'   ) -> None:
    r''''''

    assert isinstance(flip_v, bool), 'flip_v must be bool'


    self.py__flip_v = flip_v






    self._ptr.call_with_return(304,tuple([flip_v]))

  @functools.native_method
  def is_flipped_v(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(305,tuple([]))

    return _ret


  @functools.native_method
  def set_modulate(self, modulate:'Color'   ) -> None:
    r''''''

    assert(not modulate is None)
    assert isinstance(modulate, Color), 'modulate must be Color'


    self.py__modulate = modulate






    self._ptr.call_with_return(306,tuple([modulate._ptr]))

  @functools.native_method
  def get_modulate(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(307,tuple([]))

    return _ret


  @functools.native_method
  def set_render_priority(self, priority:'int'   ) -> None:
    r''''''

    assert isinstance(priority, (int, float)), 'priority must be int or float'


    self.py__render_priority = priority






    self._ptr.call_with_return(308,tuple([priority]))

  @functools.native_method
  def get_render_priority(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(309,tuple([]))

    return _ret


  @functools.native_method
  def set_pixel_size(self, pixel_size:'float'   ) -> None:
    r''''''

    assert isinstance(pixel_size, (int, float)), 'pixel_size must be int or float'


    self.py__pixel_size = pixel_size






    self._ptr.call_with_return(310,tuple([pixel_size]))

  @functools.native_method
  def get_pixel_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(311,tuple([]))

    return _ret


  @functools.native_method
  def set_axis(self, axis:'int'  ) -> None:
    r''''''

    assert isinstance(axis, (int, float)), 'axis must be int or float'


    self.py__axis = axis






    self._ptr.call_with_return(312,tuple([axis]))

  @functools.native_method
  def get_axis(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(313,tuple([]))

    return _ret


  @functools.native_method
  def set_draw_flag(self, flag:'int'  , enabled:'bool'   ) -> None:
    r'''
				If `true`, the specified flag will be enabled.
			'''

    assert isinstance(flag, (int, float)), 'flag must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__transparent = flag







    self._ptr.call_with_return(314,tuple([flag, enabled]))

  @functools.native_method
  def get_draw_flag(self, flag:'int'  ) -> typing.Union[bool]:
    r'''
				Returns the value of the specified flag.
			'''

    assert isinstance(flag, (int, float)), 'flag must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(315,tuple([flag]))

    return _ret


  @functools.native_method
  def set_alpha_cut_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__alpha_cut = mode






    self._ptr.call_with_return(316,tuple([mode]))

  @functools.native_method
  def get_alpha_cut_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(317,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_scissor_threshold(self, threshold:'float'   ) -> None:
    r''''''

    assert isinstance(threshold, (int, float)), 'threshold must be int or float'


    self.py__alpha_scissor_threshold = threshold






    self._ptr.call_with_return(318,tuple([threshold]))

  @functools.native_method
  def get_alpha_scissor_threshold(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(319,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_hash_scale(self, threshold:'float'   ) -> None:
    r''''''

    assert isinstance(threshold, (int, float)), 'threshold must be int or float'


    self.py__alpha_hash_scale = threshold






    self._ptr.call_with_return(320,tuple([threshold]))

  @functools.native_method
  def get_alpha_hash_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(321,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_antialiasing(self, alpha_aa:'int'  ) -> None:
    r''''''

    assert isinstance(alpha_aa, (int, float)), 'alpha_aa must be int or float'


    self.py__alpha_antialiasing_mode = alpha_aa






    self._ptr.call_with_return(322,tuple([alpha_aa]))

  @functools.native_method
  def get_alpha_antialiasing(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(323,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_antialiasing_edge(self, edge:'float'   ) -> None:
    r''''''

    assert isinstance(edge, (int, float)), 'edge must be int or float'


    self.py__alpha_antialiasing_edge = edge






    self._ptr.call_with_return(324,tuple([edge]))

  @functools.native_method
  def get_alpha_antialiasing_edge(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(325,tuple([]))

    return _ret


  @functools.native_method
  def set_billboard_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__billboard = mode






    self._ptr.call_with_return(326,tuple([mode]))

  @functools.native_method
  def get_billboard_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(327,tuple([]))

    return _ret


  @functools.native_method
  def set_texture_filter(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__texture_filter = mode






    self._ptr.call_with_return(328,tuple([mode]))

  @functools.native_method
  def get_texture_filter(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(329,tuple([]))

    return _ret


  @functools.native_method
  def get_item_rect(self) -> typing.Union['Rect2']:
    r'''
				Returns the rectangle representing this sprite.
			'''




    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(330,tuple([]))
    return _ret


  @functools.native_method
  def generate_triangle_mesh(self) -> typing.Union['py4godot_trianglemesh.TriangleMesh']:
    r'''
				Returns a `TriangleMesh` with the sprite's vertices following its current configuration (such as its `axis` and `pixel_size`).
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TriangleMesh
    _ret._ptr = self._ptr.call_with_return(331,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('SpriteBase3D', SpriteBase3D.cast)
register_class('SpriteBase3D', SpriteBase3D)
