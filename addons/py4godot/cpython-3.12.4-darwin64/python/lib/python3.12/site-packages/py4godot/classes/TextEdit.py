# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.Tree as py4godot_tree 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.GDScriptSyntaxHighlighter as py4godot_gdscriptsyntaxhighlighter 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.GraphElement as py4godot_graphelement 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.RichTextLabel as py4godot_richtextlabel 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.TabBar as py4godot_tabbar 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.GraphNode as py4godot_graphnode 
  import py4godot.classes.TextServerExtension as py4godot_textserverextension 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.TextServer as py4godot_textserver 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.Container as py4godot_container 
  import py4godot.classes.Vector2iTypedArray as py4godot_vector2itypedarray 
  import py4godot.classes.SyntaxHighlighter as py4godot_syntaxhighlighter 
  import py4godot.classes.TextServerAdvanced as py4godot_textserveradvanced 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.TextServerDummy as py4godot_textserverdummy 
  import py4godot.classes.EditorSyntaxHighlighter as py4godot_editorsyntaxhighlighter 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.PopupMenu as py4godot_popupmenu 
  import py4godot.classes.FoldableContainer as py4godot_foldablecontainer 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.CodeHighlighter as py4godot_codehighlighter 
  import py4godot.classes.TabContainer as py4godot_tabcontainer 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
import py4godot.classes.Vector2iTypedArray as py4godot_vector2itypedarray 
import py4godot.classes.Control as py4godot_control 
from py4godot.wrappers.wrappers import CPPTextEditWrapper

class MenuItems:
  MENU_CUT = 0
  MENU_COPY = 1
  MENU_PASTE = 2
  MENU_CLEAR = 3
  MENU_SELECT_ALL = 4
  MENU_UNDO = 5
  MENU_REDO = 6
  MENU_SUBMENU_TEXT_DIR = 7
  MENU_DIR_INHERITED = 8
  MENU_DIR_AUTO = 9
  MENU_DIR_LTR = 10
  MENU_DIR_RTL = 11
  MENU_DISPLAY_UCC = 12
  MENU_SUBMENU_INSERT_UCC = 13
  MENU_INSERT_LRM = 14
  MENU_INSERT_RLM = 15
  MENU_INSERT_LRE = 16
  MENU_INSERT_RLE = 17
  MENU_INSERT_LRO = 18
  MENU_INSERT_RLO = 19
  MENU_INSERT_PDF = 20
  MENU_INSERT_ALM = 21
  MENU_INSERT_LRI = 22
  MENU_INSERT_RLI = 23
  MENU_INSERT_FSI = 24
  MENU_INSERT_PDI = 25
  MENU_INSERT_ZWJ = 26
  MENU_INSERT_ZWNJ = 27
  MENU_INSERT_WJ = 28
  MENU_INSERT_SHY = 29
  MENU_EMOJI_AND_SYMBOL = 30
  MENU_MAX = 31
class EditAction:
  ACTION_NONE = 0
  ACTION_TYPING = 1
  ACTION_BACKSPACE = 2
  ACTION_DELETE = 3
class SearchFlags:
  SEARCH_MATCH_CASE = 1
  SEARCH_WHOLE_WORDS = 2
  SEARCH_BACKWARDS = 4
class CaretType:
  CARET_TYPE_LINE = 0
  CARET_TYPE_BLOCK = 1
class SelectionMode:
  SELECTION_MODE_NONE = 0
  SELECTION_MODE_SHIFT = 1
  SELECTION_MODE_POINTER = 2
  SELECTION_MODE_WORD = 3
  SELECTION_MODE_LINE = 4
class LineWrappingMode:
  LINE_WRAPPING_NONE = 0
  LINE_WRAPPING_BOUNDARY = 1
class GutterType:
  GUTTER_TYPE_STRING = 0
  GUTTER_TYPE_ICON = 1
  GUTTER_TYPE_CUSTOM = 2


class TextEdit(py4godot_control.Control):
  r'''
		A multiline text editor. It also has limited facilities for editing code, such as syntax highlighting support. For more advanced facilities for editing code, see `CodeEdit`.
		While entering text, it is possible to insert special characters using Unicode, OEM or Windows alt codes:
		- To enter Unicode codepoints, hold `kbd`Alt`/kbd` and type the codepoint on the numpad. For example, to enter the character `รก` (U+00E1), hold `kbd`Alt`/kbd` and type `kbd`+E1`/kbd` on the numpad (the leading zeroes can be omitted).
		- To enter OEM codepoints, hold `kbd`Alt`/kbd` and type the code on the numpad. For example, to enter the character `รก` (OEM 160), hold `kbd`Alt`/kbd` and type `160` on the numpad.
		- To enter Windows codepoints, hold `kbd`Alt`/kbd` and type the code on the numpad. For example, to enter the character `รก` (Windows 0225), hold `kbd`Alt`/kbd` and type `kbd`0`/kbd`, `kbd`2`/kbd`, `kbd`2`/kbd`, `kbd`5`/kbd` on the numpad. The leading zero here must **not** be omitted, as this is how Windows codepoints are distinguished from OEM codepoints.
		**Note:** Most viewport, caret, and edit methods contain a `caret_index` argument for `caret_multiple` support. The argument should be one of the following: `-1` for all carets, `0` for the main caret, or greater than `0` for secondary carets in the order they were created.
		**Note:** When holding down `kbd`Alt`/kbd`, the vertical scroll wheel will scroll 5 times as fast as it would normally do. This also works in the Godot script editor.
	'''

  @staticmethod
  def constructor():
    class_ = TextEdit.construct_without_init()
    class_._ptr = constructor(808,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TextEdit.construct_without_init()
    class_._ptr = constructor(808,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTextEditWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(808,0, ())


  def generate_wrapper(self):
    return CPPTextEditWrapper()
  def init_signals(self):
    super().init_signals()
    text_set_name = utils.py_string_to_string_name("text_set")
    self.text_set = signals.BuiltinSignal(self, text_set_name)
    text_changed_name = utils.py_string_to_string_name("text_changed")
    self.text_changed = signals.BuiltinSignal(self, text_changed_name)
    lines_edited_from_name = utils.py_string_to_string_name("lines_edited_from")
    self.lines_edited_from = signals.BuiltinSignal(self, lines_edited_from_name)
    caret_changed_name = utils.py_string_to_string_name("caret_changed")
    self.caret_changed = signals.BuiltinSignal(self, caret_changed_name)
    gutter_clicked_name = utils.py_string_to_string_name("gutter_clicked")
    self.gutter_clicked = signals.BuiltinSignal(self, gutter_clicked_name)
    gutter_added_name = utils.py_string_to_string_name("gutter_added")
    self.gutter_added = signals.BuiltinSignal(self, gutter_added_name)
    gutter_removed_name = utils.py_string_to_string_name("gutter_removed")
    self.gutter_removed = signals.BuiltinSignal(self, gutter_removed_name)

  @staticmethod
  def construct_without_init():
    cls = TextEdit.__new__(TextEdit)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TextEdit'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TextEdit.construct_without_init()
    cls._ptr = CPPTextEditWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TextEdit.construct_without_init()
    cls._ptr = CPPTextEditWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def text(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_text()
    return _ret
  @text.setter
  def text(self,  value:'str'):
    self.set_text(value)
  @property
  def placeholder_text(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_placeholder()
    return _ret
  @placeholder_text.setter
  def placeholder_text(self,  value:'str'):
    self.set_placeholder(value)
  @property
  def editable(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_editable()
    return _ret
  @editable.setter
  def editable(self,  value:'bool'):
    self.set_editable(value)
  @property
  def context_menu_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_context_menu_enabled()
    return _ret
  @context_menu_enabled.setter
  def context_menu_enabled(self,  value:'bool'):
    self.set_context_menu_enabled(value)
  @property
  def emoji_menu_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_emoji_menu_enabled()
    return _ret
  @emoji_menu_enabled.setter
  def emoji_menu_enabled(self,  value:'bool'):
    self.set_emoji_menu_enabled(value)
  @property
  def backspace_deletes_composite_character_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_backspace_deletes_composite_character_enabled()
    return _ret
  @backspace_deletes_composite_character_enabled.setter
  def backspace_deletes_composite_character_enabled(self,  value:'bool'):
    self.set_backspace_deletes_composite_character_enabled(value)
  @property
  def shortcut_keys_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_shortcut_keys_enabled()
    return _ret
  @shortcut_keys_enabled.setter
  def shortcut_keys_enabled(self,  value:'bool'):
    self.set_shortcut_keys_enabled(value)
  @property
  def selecting_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_selecting_enabled()
    return _ret
  @selecting_enabled.setter
  def selecting_enabled(self,  value:'bool'):
    self.set_selecting_enabled(value)
  @property
  def deselect_on_focus_loss_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_deselect_on_focus_loss_enabled()
    return _ret
  @deselect_on_focus_loss_enabled.setter
  def deselect_on_focus_loss_enabled(self,  value:'bool'):
    self.set_deselect_on_focus_loss_enabled(value)
  @property
  def drag_and_drop_selection_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_drag_and_drop_selection_enabled()
    return _ret
  @drag_and_drop_selection_enabled.setter
  def drag_and_drop_selection_enabled(self,  value:'bool'):
    self.set_drag_and_drop_selection_enabled(value)
  @property
  def virtual_keyboard_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_virtual_keyboard_enabled()
    return _ret
  @virtual_keyboard_enabled.setter
  def virtual_keyboard_enabled(self,  value:'bool'):
    self.set_virtual_keyboard_enabled(value)
  @property
  def virtual_keyboard_show_on_focus(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_virtual_keyboard_show_on_focus()
    return _ret
  @virtual_keyboard_show_on_focus.setter
  def virtual_keyboard_show_on_focus(self,  value:'bool'):
    self.set_virtual_keyboard_show_on_focus(value)
  @property
  def middle_mouse_paste_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_middle_mouse_paste_enabled()
    return _ret
  @middle_mouse_paste_enabled.setter
  def middle_mouse_paste_enabled(self,  value:'bool'):
    self.set_middle_mouse_paste_enabled(value)
  @property
  def empty_selection_clipboard_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_empty_selection_clipboard_enabled()
    return _ret
  @empty_selection_clipboard_enabled.setter
  def empty_selection_clipboard_enabled(self,  value:'bool'):
    self.set_empty_selection_clipboard_enabled(value)
  @property
  def wrap_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_line_wrapping_mode()
    return _ret
  @wrap_mode.setter
  def wrap_mode(self,  value:'int'):
    self.set_line_wrapping_mode(value)
  @property
  def autowrap_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_autowrap_mode()
    return _ret
  @autowrap_mode.setter
  def autowrap_mode(self,  value:'int'):
    self.set_autowrap_mode(value)
  @property
  def indent_wrapped_lines(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_indent_wrapped_lines()
    return _ret
  @indent_wrapped_lines.setter
  def indent_wrapped_lines(self,  value:'bool'):
    self.set_indent_wrapped_lines(value)
  @property
  def tab_input_mode(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_tab_input_mode()
    return _ret
  @tab_input_mode.setter
  def tab_input_mode(self,  value:'bool'):
    self.set_tab_input_mode(value)
  @property
  def scroll_smooth(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_smooth_scroll_enabled()
    return _ret
  @scroll_smooth.setter
  def scroll_smooth(self,  value:'bool'):
    self.set_smooth_scroll_enabled(value)
  @property
  def scroll_v_scroll_speed(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_v_scroll_speed()
    return _ret
  @scroll_v_scroll_speed.setter
  def scroll_v_scroll_speed(self,  value:'float'):
    self.set_v_scroll_speed(value)
  @property
  def scroll_past_end_of_file(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_scroll_past_end_of_file_enabled()
    return _ret
  @scroll_past_end_of_file.setter
  def scroll_past_end_of_file(self,  value:'bool'):
    self.set_scroll_past_end_of_file_enabled(value)
  @property
  def scroll_vertical(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_v_scroll()
    return _ret
  @scroll_vertical.setter
  def scroll_vertical(self,  value:'float'):
    self.set_v_scroll(value)
  @property
  def scroll_horizontal(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_h_scroll()
    return _ret
  @scroll_horizontal.setter
  def scroll_horizontal(self,  value:'int'):
    self.set_h_scroll(value)
  @property
  def scroll_fit_content_height(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_fit_content_height_enabled()
    return _ret
  @scroll_fit_content_height.setter
  def scroll_fit_content_height(self,  value:'bool'):
    self.set_fit_content_height_enabled(value)
  @property
  def scroll_fit_content_width(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_fit_content_width_enabled()
    return _ret
  @scroll_fit_content_width.setter
  def scroll_fit_content_width(self,  value:'bool'):
    self.set_fit_content_width_enabled(value)
  @property
  def minimap_draw(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_drawing_minimap()
    return _ret
  @minimap_draw.setter
  def minimap_draw(self,  value:'bool'):
    self.set_draw_minimap(value)
  @property
  def minimap_width(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_minimap_width()
    return _ret
  @minimap_width.setter
  def minimap_width(self,  value:'int'):
    self.set_minimap_width(value)
  @property
  def caret_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_caret_type()
    return _ret
  @caret_type.setter
  def caret_type(self,  value:'int'):
    self.set_caret_type(value)
  @property
  def caret_blink(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_caret_blink_enabled()
    return _ret
  @caret_blink.setter
  def caret_blink(self,  value:'bool'):
    self.set_caret_blink_enabled(value)
  @property
  def caret_blink_interval(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_caret_blink_interval()
    return _ret
  @caret_blink_interval.setter
  def caret_blink_interval(self,  value:'float'):
    self.set_caret_blink_interval(value)
  @property
  def caret_draw_when_editable_disabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_drawing_caret_when_editable_disabled()
    return _ret
  @caret_draw_when_editable_disabled.setter
  def caret_draw_when_editable_disabled(self,  value:'bool'):
    self.set_draw_caret_when_editable_disabled(value)
  @property
  def caret_move_on_right_click(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_move_caret_on_right_click_enabled()
    return _ret
  @caret_move_on_right_click.setter
  def caret_move_on_right_click(self,  value:'bool'):
    self.set_move_caret_on_right_click_enabled(value)
  @property
  def caret_mid_grapheme(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_caret_mid_grapheme_enabled()
    return _ret
  @caret_mid_grapheme.setter
  def caret_mid_grapheme(self,  value:'bool'):
    self.set_caret_mid_grapheme_enabled(value)
  @property
  def caret_multiple(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_multiple_carets_enabled()
    return _ret
  @caret_multiple.setter
  def caret_multiple(self,  value:'bool'):
    self.set_multiple_carets_enabled(value)
  @property
  def use_default_word_separators(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_default_word_separators_enabled()
    return _ret
  @use_default_word_separators.setter
  def use_default_word_separators(self,  value:'bool'):
    self.set_use_default_word_separators(value)
  @property
  def use_custom_word_separators(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_custom_word_separators_enabled()
    return _ret
  @use_custom_word_separators.setter
  def use_custom_word_separators(self,  value:'bool'):
    self.set_use_custom_word_separators(value)
  @property
  def custom_word_separators(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_custom_word_separators()
    return _ret
  @custom_word_separators.setter
  def custom_word_separators(self,  value:'str'):
    self.set_custom_word_separators(value)
  @property
  def syntax_highlighter(self) -> typing.Any:
    r''''''
    _ret = self. get_syntax_highlighter()
    return _ret
  @syntax_highlighter.setter
  def syntax_highlighter(self,  value:'py4godot_object.Object'):
    self.set_syntax_highlighter(value)
  @property
  def highlight_all_occurrences(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_highlight_all_occurrences_enabled()
    return _ret
  @highlight_all_occurrences.setter
  def highlight_all_occurrences(self,  value:'bool'):
    self.set_highlight_all_occurrences(value)
  @property
  def highlight_current_line(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_highlight_current_line_enabled()
    return _ret
  @highlight_current_line.setter
  def highlight_current_line(self,  value:'bool'):
    self.set_highlight_current_line(value)
  @property
  def draw_control_chars(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_draw_control_chars()
    return _ret
  @draw_control_chars.setter
  def draw_control_chars(self,  value:'bool'):
    self.set_draw_control_chars(value)
  @property
  def draw_tabs(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_drawing_tabs()
    return _ret
  @draw_tabs.setter
  def draw_tabs(self,  value:'bool'):
    self.set_draw_tabs(value)
  @property
  def draw_spaces(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_drawing_spaces()
    return _ret
  @draw_spaces.setter
  def draw_spaces(self,  value:'bool'):
    self.set_draw_spaces(value)
  @property
  def text_direction(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_text_direction()
    return _ret
  @text_direction.setter
  def text_direction(self,  value:'int'):
    self.set_text_direction(value)
  @property
  def language(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_language()
    return _ret
  @language.setter
  def language(self,  value:'str'):
    self.set_language(value)
  @property
  def structured_text_bidi_override(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_structured_text_bidi_override()
    return _ret
  @structured_text_bidi_override.setter
  def structured_text_bidi_override(self,  value:'int'):
    self.set_structured_text_bidi_override(value)
  @property
  def structured_text_bidi_override_options(self) -> typing.Union['Array']:
    r''''''
    _ret = self. get_structured_text_bidi_override_options()
    return _ret
  @structured_text_bidi_override_options.setter
  def structured_text_bidi_override_options(self,  value:'Array'):
    self.set_structured_text_bidi_override_options(value)
  @functools.native_method
  def _handle_unicode_input(self, unicode_char:'int'   , caret_index:'int'   ) -> None:
    r'''
				Override this method to define what happens when the user types in the provided key `unicode_char`.
			'''

    assert isinstance(unicode_char, (int, float)), 'unicode_char must be int or float'
    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'








    self._ptr.call_with_return(433,tuple([unicode_char, caret_index]))

  @functools.native_method
  def _backspace(self, caret_index:'int'   ) -> None:
    r'''
				Override this method to define what happens when the user presses the backspace key.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(434,tuple([caret_index]))

  @functools.native_method
  def _cut(self, caret_index:'int'   ) -> None:
    r'''
				Override this method to define what happens when the user performs a cut operation.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(435,tuple([caret_index]))

  @functools.native_method
  def _copy(self, caret_index:'int'   ) -> None:
    r'''
				Override this method to define what happens when the user performs a copy operation.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(436,tuple([caret_index]))

  @functools.native_method
  def _paste(self, caret_index:'int'   ) -> None:
    r'''
				Override this method to define what happens when the user performs a paste operation.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(437,tuple([caret_index]))

  @functools.native_method
  def _paste_primary_clipboard(self, caret_index:'int'   ) -> None:
    r'''
				Override this method to define what happens when the user performs a paste operation with middle mouse button.
				**Note:** This method is only implemented on Linux.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(438,tuple([caret_index]))

  @functools.native_method
  def has_ime_text(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the user has text in the `url=https://en.wikipedia.org/wiki/Input_method`Input Method Editor`/url` (IME).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(439,tuple([]))
    return _ret


  @functools.native_method
  def cancel_ime(self) -> None:
    r'''
				Closes the `url=https://en.wikipedia.org/wiki/Input_method`Input Method Editor`/url` (IME) if it is open. Any text in the IME will be lost.
			'''




    self._ptr.call_with_return(440,tuple([]))

  @functools.native_method
  def apply_ime(self) -> None:
    r'''
				Applies text from the `url=https://en.wikipedia.org/wiki/Input_method`Input Method Editor`/url` (IME) to each caret and closes the IME if it is open.
			'''




    self._ptr.call_with_return(441,tuple([]))

  @functools.native_method
  def set_editable(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__editable = enabled






    self._ptr.call_with_return(442,tuple([enabled]))

  @functools.native_method
  def is_editable(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(443,tuple([]))

    return _ret


  @functools.native_method
  def set_text_direction(self, direction:'int'  ) -> None:
    r''''''

    assert isinstance(direction, (int, float)), 'direction must be int or float'


    self.py__text_direction = direction






    self._ptr.call_with_return(444,tuple([direction]))

  @functools.native_method
  def get_text_direction(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(445,tuple([]))

    return _ret


  @functools.native_method
  def set_language(self, language:'str'   ) -> None:
    r''''''

    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'


    self.py__language = language



    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    py__string_language = utils.py_string_to_string(language)
    py__string_language.shouldBeDeleted = False


    self._ptr.call_with_return(446,tuple([py__string_language._ptr]))

  @functools.native_method
  def get_language(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(447,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_structured_text_bidi_override(self, parser:'int'  ) -> None:
    r''''''

    assert isinstance(parser, (int, float)), 'parser must be int or float'


    self.py__structured_text_bidi_override = parser






    self._ptr.call_with_return(448,tuple([parser]))

  @functools.native_method
  def get_structured_text_bidi_override(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(449,tuple([]))

    return _ret


  @functools.native_method
  def set_structured_text_bidi_override_options(self, args:'Array'   ) -> None:
    r''''''

    assert(not args is None)
    assert isinstance(args, Array), 'args must be Array'


    self.py__structured_text_bidi_override_options = args






    self._ptr.call_with_return(450,tuple([args._ptr]))

  @functools.native_method
  def get_structured_text_bidi_override_options(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(451,tuple([]))

    return _ret


  @functools.native_method
  def set_tab_size(self, size:'int'   ) -> None:
    r'''
				Sets the tab size for the `TextEdit` to use.
			'''

    assert isinstance(size, (int, float)), 'size must be int or float'







    self._ptr.call_with_return(452,tuple([size]))

  @functools.native_method
  def get_tab_size(self) -> typing.Union[int]:
    r'''
				Returns the `TextEdit`'s' tab size.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(453,tuple([]))
    return _ret


  @functools.native_method
  def set_indent_wrapped_lines(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__indent_wrapped_lines = enabled






    self._ptr.call_with_return(454,tuple([enabled]))

  @functools.native_method
  def is_indent_wrapped_lines(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(455,tuple([]))

    return _ret


  @functools.native_method
  def set_tab_input_mode(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__tab_input_mode = enabled






    self._ptr.call_with_return(456,tuple([enabled]))

  @functools.native_method
  def get_tab_input_mode(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(457,tuple([]))

    return _ret


  @functools.native_method
  def set_overtype_mode_enabled(self, enabled:'bool'   ) -> None:
    r'''
				If `true`, enables overtype mode. In this mode, typing overrides existing text instead of inserting text. The `ProjectSettings.input/ui_text_toggle_insert_mode` action toggles overtype mode. See `is_overtype_mode_enabled`.
			'''

    assert isinstance(enabled, bool), 'enabled must be bool'







    self._ptr.call_with_return(458,tuple([enabled]))

  @functools.native_method
  def is_overtype_mode_enabled(self) -> typing.Union[bool]:
    r'''
				Returns `true` if overtype mode is enabled. See `set_overtype_mode_enabled`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(459,tuple([]))
    return _ret


  @functools.native_method
  def set_context_menu_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__context_menu_enabled = enabled






    self._ptr.call_with_return(460,tuple([enabled]))

  @functools.native_method
  def is_context_menu_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(461,tuple([]))

    return _ret


  @functools.native_method
  def set_emoji_menu_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__emoji_menu_enabled = enable






    self._ptr.call_with_return(462,tuple([enable]))

  @functools.native_method
  def is_emoji_menu_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(463,tuple([]))

    return _ret


  @functools.native_method
  def set_backspace_deletes_composite_character_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__backspace_deletes_composite_character_enabled = enable






    self._ptr.call_with_return(464,tuple([enable]))

  @functools.native_method
  def is_backspace_deletes_composite_character_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(465,tuple([]))

    return _ret


  @functools.native_method
  def set_shortcut_keys_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__shortcut_keys_enabled = enabled






    self._ptr.call_with_return(466,tuple([enabled]))

  @functools.native_method
  def is_shortcut_keys_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(467,tuple([]))

    return _ret


  @functools.native_method
  def set_virtual_keyboard_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__virtual_keyboard_enabled = enabled






    self._ptr.call_with_return(468,tuple([enabled]))

  @functools.native_method
  def is_virtual_keyboard_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(469,tuple([]))

    return _ret


  @functools.native_method
  def set_virtual_keyboard_show_on_focus(self, show_on_focus:'bool'   ) -> None:
    r''''''

    assert isinstance(show_on_focus, bool), 'show_on_focus must be bool'


    self.py__virtual_keyboard_show_on_focus = show_on_focus






    self._ptr.call_with_return(470,tuple([show_on_focus]))

  @functools.native_method
  def get_virtual_keyboard_show_on_focus(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(471,tuple([]))

    return _ret


  @functools.native_method
  def set_middle_mouse_paste_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__middle_mouse_paste_enabled = enabled






    self._ptr.call_with_return(472,tuple([enabled]))

  @functools.native_method
  def is_middle_mouse_paste_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(473,tuple([]))

    return _ret


  @functools.native_method
  def set_empty_selection_clipboard_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__empty_selection_clipboard_enabled = enabled






    self._ptr.call_with_return(474,tuple([enabled]))

  @functools.native_method
  def is_empty_selection_clipboard_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(475,tuple([]))

    return _ret


  @functools.native_method
  def clear(self) -> None:
    r'''
				Performs a full reset of `TextEdit`, including undo history.
			'''




    self._ptr.call_with_return(476,tuple([]))

  @functools.native_method
  def set_text(self, text:'str'   ) -> None:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'


    self.py__text = text



    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    py__string_text = utils.py_string_to_string(text)
    py__string_text.shouldBeDeleted = False


    self._ptr.call_with_return(477,tuple([py__string_text._ptr]))

  @functools.native_method
  def get_text(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(478,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_line_count(self) -> typing.Union[int]:
    r'''
				Returns the number of lines in the text.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(479,tuple([]))
    return _ret


  @functools.native_method
  def set_placeholder(self, text:'str'   ) -> None:
    r''''''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'


    self.py__placeholder_text = text



    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    py__string_text = utils.py_string_to_string(text)
    py__string_text.shouldBeDeleted = False


    self._ptr.call_with_return(480,tuple([py__string_text._ptr]))

  @functools.native_method
  def get_placeholder(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(481,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_line(self, line:'int'   , new_text:'str'   ) -> None:
    r'''
				Sets the text for a specific `line`.
				Carets on the line will attempt to keep their visual x position.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert(not new_text is None)
    assert isinstance(new_text, (str, String)), 'new_text must be str or String'






    assert(isinstance(new_text, (str, String)))
    py_string_new_text = new_text if isinstance(new_text, StringName) else c_utils.py_string_to_string(new_text)

    self._ptr.call_with_return(482,tuple([line, py_string_new_text._ptr]))

  @functools.native_method
  def get_line(self, line:'int'   ) -> typing.Union[str]:
    r'''
				Returns the text of a specific line.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(483,tuple([line]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_line_with_ime(self, line:'int'   ) -> typing.Union[str]:
    r'''
				Returns line text as it is currently displayed, including IME composition string.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(484,tuple([line]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_line_width(self, line:'int'   , wrap_index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Returns the width in pixels of the `wrap_index` on `line`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(wrap_index, (int, float)), 'wrap_index must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(485,tuple([line, wrap_index]))
    return _ret


  @functools.native_method
  def get_line_height(self) -> typing.Union[int]:
    r'''
				Returns the maximum value of the line height among all lines.
				**Note:** The return value is influenced by `theme_item line_spacing` and `theme_item font_size`. And it will not be less than `1`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(486,tuple([]))
    return _ret


  @functools.native_method
  def get_indent_level(self, line:'int'   ) -> typing.Union[int]:
    r'''
				Returns the indent level of the given line. This is the number of spaces and tabs at the beginning of the line, with the tabs taking the tab size into account (see `get_tab_size`).
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(487,tuple([line]))
    return _ret


  @functools.native_method
  def get_first_non_whitespace_column(self, line:'int'   ) -> typing.Union[int]:
    r'''
				Returns the first column containing a non-whitespace character on the given line. If there is only whitespace, returns the number of characters.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(488,tuple([line]))
    return _ret


  @functools.native_method
  def swap_lines(self, from_line:'int'   , to_line:'int'   ) -> None:
    r'''
				Swaps the two lines. Carets will be swapped with the lines.
			'''

    assert isinstance(from_line, (int, float)), 'from_line must be int or float'
    assert isinstance(to_line, (int, float)), 'to_line must be int or float'








    self._ptr.call_with_return(489,tuple([from_line, to_line]))

  @functools.native_method
  def insert_line_at(self, line:'int'   , text:'str'   ) -> None:
    r'''
				Inserts a new line with `text` at `line`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'






    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    self._ptr.call_with_return(490,tuple([line, py_string_text._ptr]))

  @functools.native_method
  def remove_line_at(self, line:'int'   , move_carets_down:'bool' =True  ) -> None:
    r'''
				Removes the line of text at `line`. Carets on this line will attempt to match their previous visual x position.
				If `move_carets_down` is `true` carets will move to the next line down, otherwise carets will move up.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(move_carets_down, bool), 'move_carets_down must be bool'








    self._ptr.call_with_return(491,tuple([line, move_carets_down]))

  @functools.native_method
  def insert_text_at_caret(self, text:'str'   , caret_index:'int' =-1  ) -> None:
    r'''
				Insert the specified text at the caret position.
			'''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)


    self._ptr.call_with_return(492,tuple([py_string_text._ptr, caret_index]))

  @functools.native_method
  def insert_text(self, text:'str'   , line:'int'   , column:'int'   , before_selection_begin:'bool' =True  , before_selection_end:'bool' =False  ) -> None:
    r'''
				Inserts the `text` at `line` and `column`.
				If `before_selection_begin` is `true`, carets and selections that begin at `line` and `column` will moved to the end of the inserted text, along with all carets after it.
				If `before_selection_end` is `true`, selections that end at `line` and `column` will be extended to the end of the inserted text. These parameters can be used to insert text inside of or outside of selections.
			'''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(before_selection_begin, bool), 'before_selection_begin must be bool'
    assert isinstance(before_selection_end, bool), 'before_selection_end must be bool'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)





    self._ptr.call_with_return(493,tuple([py_string_text._ptr, line, column, before_selection_begin, before_selection_end]))

  @functools.native_method
  def remove_text(self, from_line:'int'   , from_column:'int'   , to_line:'int'   , to_column:'int'   ) -> None:
    r'''
				Removes text between the given positions.
			'''

    assert isinstance(from_line, (int, float)), 'from_line must be int or float'
    assert isinstance(from_column, (int, float)), 'from_column must be int or float'
    assert isinstance(to_line, (int, float)), 'to_line must be int or float'
    assert isinstance(to_column, (int, float)), 'to_column must be int or float'










    self._ptr.call_with_return(494,tuple([from_line, from_column, to_line, to_column]))

  @functools.native_method
  def get_last_unhidden_line(self) -> typing.Union[int]:
    r'''
				Returns the last unhidden line in the entire `TextEdit`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(495,tuple([]))
    return _ret


  @functools.native_method
  def get_next_visible_line_offset_from(self, line:'int'   , visible_amount:'int'   ) -> typing.Union[int]:
    r'''
				Returns the count to the next visible line from `line` to `line + visible_amount`. Can also count backwards. For example if a `TextEdit` has 5 lines with lines 2 and 3 hidden, calling this with `line = 1, visible_amount = 1` would return 3.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(visible_amount, (int, float)), 'visible_amount must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(496,tuple([line, visible_amount]))
    return _ret


  @functools.native_method
  def get_next_visible_line_index_offset_from(self, line:'int'   , wrap_index:'int'   , visible_amount:'int'   ) -> typing.Union['Vector2i']:
    r'''
				Similar to `get_next_visible_line_offset_from`, but takes into account the line wrap indexes. In the returned vector, `x` is the line, `y` is the wrap index.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(wrap_index, (int, float)), 'wrap_index must be int or float'
    assert isinstance(visible_amount, (int, float)), 'visible_amount must be int or float'









    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(497,tuple([line, wrap_index, visible_amount]))
    return _ret


  @functools.native_method
  def backspace(self, caret_index:'int' =-1  ) -> None:
    r'''
				Called when the user presses the backspace key. Can be overridden with `_backspace`.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(498,tuple([caret_index]))

  @functools.native_method
  def cut(self, caret_index:'int' =-1  ) -> None:
    r'''
				Cut's the current selection. Can be overridden with `_cut`.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(499,tuple([caret_index]))

  @functools.native_method
  def copy(self, caret_index:'int' =-1  ) -> None:
    r'''
				Copies the current text selection. Can be overridden with `_copy`.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(500,tuple([caret_index]))

  @functools.native_method
  def paste(self, caret_index:'int' =-1  ) -> None:
    r'''
				Paste at the current location. Can be overridden with `_paste`.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(501,tuple([caret_index]))

  @functools.native_method
  def paste_primary_clipboard(self, caret_index:'int' =-1  ) -> None:
    r'''
				Pastes the primary clipboard.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(502,tuple([caret_index]))

  @functools.native_method
  def start_action(self, action:'int'  ) -> None:
    r'''
				Starts an action, will end the current action if `action` is different.
				An action will also end after a call to `end_action`, after `ProjectSettings.gui/timers/text_edit_idle_detect_sec` is triggered or a new undoable step outside the `start_action` and `end_action` calls.
			'''

    assert isinstance(action, (int, float)), 'action must be int or float'







    self._ptr.call_with_return(503,tuple([action]))

  @functools.native_method
  def end_action(self) -> None:
    r'''
				Marks the end of steps in the current action started with `start_action`.
			'''




    self._ptr.call_with_return(504,tuple([]))

  @functools.native_method
  def begin_complex_operation(self) -> None:
    r'''
				Starts a multipart edit. All edits will be treated as one action until `end_complex_operation` is called.
			'''




    self._ptr.call_with_return(505,tuple([]))

  @functools.native_method
  def end_complex_operation(self) -> None:
    r'''
				Ends a multipart edit, started with `begin_complex_operation`. If called outside a complex operation, the current operation is pushed onto the undo/redo stack.
			'''




    self._ptr.call_with_return(506,tuple([]))

  @functools.native_method
  def has_undo(self) -> typing.Union[bool]:
    r'''
				Returns `true` if an "undo" action is available.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(507,tuple([]))
    return _ret


  @functools.native_method
  def has_redo(self) -> typing.Union[bool]:
    r'''
				Returns `true` if a "redo" action is available.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(508,tuple([]))
    return _ret


  @functools.native_method
  def undo(self) -> None:
    r'''
				Perform undo operation.
			'''




    self._ptr.call_with_return(509,tuple([]))

  @functools.native_method
  def redo(self) -> None:
    r'''
				Perform redo operation.
			'''




    self._ptr.call_with_return(510,tuple([]))

  @functools.native_method
  def clear_undo_history(self) -> None:
    r'''
				Clears the undo history.
			'''




    self._ptr.call_with_return(511,tuple([]))

  @functools.native_method
  def tag_saved_version(self) -> None:
    r'''
				Tag the current version as saved.
			'''




    self._ptr.call_with_return(512,tuple([]))

  @functools.native_method
  def get_version(self) -> typing.Union[int]:
    r'''
				Returns the current version of the `TextEdit`. The version is a count of recorded operations by the undo/redo history.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(513,tuple([]))
    return _ret


  @functools.native_method
  def get_saved_version(self) -> typing.Union[int]:
    r'''
				Returns the last tagged saved version from `tag_saved_version`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(514,tuple([]))
    return _ret


  @functools.native_method
  def set_search_text(self, search_text:'str'   ) -> None:
    r'''
				Sets the search text. See `set_search_flags`.
			'''

    assert(not search_text is None)
    assert isinstance(search_text, (str, String)), 'search_text must be str or String'





    assert(isinstance(search_text, (str, String)))
    py_string_search_text = search_text if isinstance(search_text, StringName) else c_utils.py_string_to_string(search_text)

    self._ptr.call_with_return(515,tuple([py_string_search_text._ptr]))

  @functools.native_method
  def set_search_flags(self, flags:'int'   ) -> None:
    r'''
				Sets the search `flags`. This is used with `set_search_text` to highlight occurrences of the searched text. Search flags can be specified from the `enum SearchFlags` enum.
			'''

    assert isinstance(flags, (int, float)), 'flags must be int or float'







    self._ptr.call_with_return(516,tuple([flags]))

  @functools.native_method
  def search(self, text:'str'   , flags:'int'   , from_line:'int'   , from_column:'int'   ) -> typing.Union['Vector2i']:
    r'''
				Perform a search inside the text. Search flags can be specified in the `enum SearchFlags` enum.
				In the returned vector, `x` is the column, `y` is the line. If no results are found, both are equal to `-1`.
				
				```gdscript
				var result = search("print", SEARCH_WHOLE_WORDS, 0, 0)
				if result.x != -1:
					# Result found.
					var line_number = result.y
					var column_number = result.x
				```
				
				
			'''

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(flags, (int, float)), 'flags must be int or float'
    assert isinstance(from_line, (int, float)), 'from_line must be int or float'
    assert isinstance(from_column, (int, float)), 'from_column must be int or float'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(517,tuple([py_string_text._ptr, flags, from_line, from_column]))
    return _ret


  @functools.native_method
  def set_tooltip_request_func(self, callback:'Callable'   ) -> None:
    r'''
				Provide custom tooltip text. The callback method must take the following args: `hovered_word: String`.
			'''

    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'







    self._ptr.call_with_return(518,tuple([callback._ptr]))

  @functools.native_method
  def get_local_mouse_pos(self) -> typing.Union['Vector2']:
    r'''
				Returns the local mouse position adjusted for the text direction.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(519,tuple([]))
    return _ret


  @functools.native_method
  def get_word_at_pos(self, position:'Vector2'   ) -> typing.Union[str]:
    r'''
				Returns the word at `position`.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(520,tuple([position._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_line_column_at_pos(self, position:'Vector2i'   , clamp_line:'bool' =True  , clamp_column:'bool' =True  ) -> typing.Union['Vector2i']:
    r'''
				Returns the line and column at the given position. In the returned vector, `x` is the column and `y` is the line.
				If `clamp_line` is `false` and `position` is below the last line, `Vector2i(-1, -1)` is returned.
				If `clamp_column` is `false` and `position` is outside the column range of the line, `Vector2i(-1, -1)` is returned.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'
    assert isinstance(clamp_line, bool), 'clamp_line must be bool'
    assert isinstance(clamp_column, bool), 'clamp_column must be bool'









    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(521,tuple([position._ptr, clamp_line, clamp_column]))
    return _ret


  @functools.native_method
  def get_pos_at_line_column(self, line:'int'   , column:'int'   ) -> typing.Union['Vector2i']:
    r'''
				Returns the local position for the given `line` and `column`. If `x` or `y` of the returned vector equal `-1`, the position is outside of the viewable area of the control.
				**Note:** The Y position corresponds to the bottom side of the line. Use `get_rect_at_line_column` to get the top side position.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(column, (int, float)), 'column must be int or float'








    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(522,tuple([line, column]))
    return _ret


  @functools.native_method
  def get_rect_at_line_column(self, line:'int'   , column:'int'   ) -> typing.Union['Rect2i']:
    r'''
				Returns the local position and size for the grapheme at the given `line` and `column`. If `x` or `y` position of the returned rect equal `-1`, the position is outside of the viewable area of the control.
				**Note:** The Y position of the returned rect corresponds to the top side of the line, unlike `get_pos_at_line_column` which returns the bottom side.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(column, (int, float)), 'column must be int or float'








    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(523,tuple([line, column]))
    return _ret


  @functools.native_method
  def get_minimap_line_at_pos(self, position:'Vector2i'   ) -> typing.Union[int]:
    r'''
				Returns the equivalent minimap line at `position`.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(524,tuple([position._ptr]))
    return _ret


  @functools.native_method
  def is_dragging_cursor(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the user is dragging their mouse for scrolling, selecting, or text dragging.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(525,tuple([]))
    return _ret


  @functools.native_method
  def is_mouse_over_selection(self, edges:'bool'   , caret_index:'int' =-1  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the mouse is over a selection. If `edges` is `true`, the edges are considered part of the selection.
			'''

    assert isinstance(edges, bool), 'edges must be bool'
    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(526,tuple([edges, caret_index]))
    return _ret


  @functools.native_method
  def set_caret_type(self, type:'int'  ) -> None:
    r''''''

    assert isinstance(type, (int, float)), 'type must be int or float'


    self.py__caret_type = type






    self._ptr.call_with_return(527,tuple([type]))

  @functools.native_method
  def get_caret_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(528,tuple([]))

    return _ret


  @functools.native_method
  def set_caret_blink_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__caret_blink = enable






    self._ptr.call_with_return(529,tuple([enable]))

  @functools.native_method
  def is_caret_blink_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(530,tuple([]))

    return _ret


  @functools.native_method
  def set_caret_blink_interval(self, interval:'float'   ) -> None:
    r''''''

    assert isinstance(interval, (int, float)), 'interval must be int or float'


    self.py__caret_blink_interval = interval






    self._ptr.call_with_return(531,tuple([interval]))

  @functools.native_method
  def get_caret_blink_interval(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(532,tuple([]))

    return _ret


  @functools.native_method
  def set_draw_caret_when_editable_disabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__caret_draw_when_editable_disabled = enable






    self._ptr.call_with_return(533,tuple([enable]))

  @functools.native_method
  def is_drawing_caret_when_editable_disabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(534,tuple([]))

    return _ret


  @functools.native_method
  def set_move_caret_on_right_click_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__caret_move_on_right_click = enable






    self._ptr.call_with_return(535,tuple([enable]))

  @functools.native_method
  def is_move_caret_on_right_click_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(536,tuple([]))

    return _ret


  @functools.native_method
  def set_caret_mid_grapheme_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__caret_mid_grapheme = enabled






    self._ptr.call_with_return(537,tuple([enabled]))

  @functools.native_method
  def is_caret_mid_grapheme_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(538,tuple([]))

    return _ret


  @functools.native_method
  def set_multiple_carets_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__caret_multiple = enabled






    self._ptr.call_with_return(539,tuple([enabled]))

  @functools.native_method
  def is_multiple_carets_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(540,tuple([]))

    return _ret


  @functools.native_method
  def add_caret(self, line:'int'   , column:'int'   ) -> typing.Union[int]:
    r'''
				Adds a new caret at the given location. Returns the index of the new caret, or `-1` if the location is invalid.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(column, (int, float)), 'column must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(541,tuple([line, column]))
    return _ret


  @functools.native_method
  def remove_caret(self, caret:'int'   ) -> None:
    r'''
				Removes the given caret index.
				**Note:** This can result in adjustment of all other caret indices.
			'''

    assert isinstance(caret, (int, float)), 'caret must be int or float'







    self._ptr.call_with_return(542,tuple([caret]))

  @functools.native_method
  def remove_secondary_carets(self) -> None:
    r'''
				Removes all additional carets.
			'''




    self._ptr.call_with_return(543,tuple([]))

  @functools.native_method
  def get_caret_count(self) -> typing.Union[int]:
    r'''
				Returns the number of carets in this `TextEdit`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(544,tuple([]))
    return _ret


  @functools.native_method
  def add_caret_at_carets(self, below:'bool'   ) -> None:
    r'''
				Adds an additional caret above or below every caret. If `below` is `true` the new caret will be added below and above otherwise.
			'''

    assert isinstance(below, bool), 'below must be bool'







    self._ptr.call_with_return(545,tuple([below]))

  @functools.native_method
  def get_sorted_carets(self, include_ignored_carets:'bool' =False  ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns the carets sorted by selection beginning from lowest line and column to highest (from top to bottom of text).
				If `include_ignored_carets` is `false`, carets from `multicaret_edit_ignore_caret` will be ignored.
			'''

    assert isinstance(include_ignored_carets, bool), 'include_ignored_carets must be bool'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(546,tuple([include_ignored_carets]))
    return _ret


  @functools.native_method
  def collapse_carets(self, from_line:'int'   , from_column:'int'   , to_line:'int'   , to_column:'int'   , inclusive:'bool' =False  ) -> None:
    r'''
				Collapse all carets in the given range to the `from_line` and `from_column` position.
				`inclusive` applies to both ends.
				If `is_in_mulitcaret_edit` is `true`, carets that are collapsed will be `true` for `multicaret_edit_ignore_caret`.
				`merge_overlapping_carets` will be called if any carets were collapsed.
			'''

    assert isinstance(from_line, (int, float)), 'from_line must be int or float'
    assert isinstance(from_column, (int, float)), 'from_column must be int or float'
    assert isinstance(to_line, (int, float)), 'to_line must be int or float'
    assert isinstance(to_column, (int, float)), 'to_column must be int or float'
    assert isinstance(inclusive, bool), 'inclusive must be bool'











    self._ptr.call_with_return(547,tuple([from_line, from_column, to_line, to_column, inclusive]))

  @functools.native_method
  def merge_overlapping_carets(self) -> None:
    r'''
				Merges any overlapping carets. Will favor the newest caret, or the caret with a selection.
				If `is_in_mulitcaret_edit` is `true`, the merge will be queued to happen at the end of the multicaret edit. See `begin_multicaret_edit` and `end_multicaret_edit`.
				**Note:** This is not called when a caret changes position but after certain actions, so it is possible to get into a state where carets overlap.
			'''




    self._ptr.call_with_return(548,tuple([]))

  @functools.native_method
  def begin_multicaret_edit(self) -> None:
    r'''
				Starts an edit for multiple carets. The edit must be ended with `end_multicaret_edit`. Multicaret edits can be used to edit text at multiple carets and delay merging the carets until the end, so the caret indexes aren't affected immediately. `begin_multicaret_edit` and `end_multicaret_edit` can be nested, and the merge will happen at the last `end_multicaret_edit`.
				```gdscript
				begin_complex_operation()
				begin_multicaret_edit()
				for i in range(get_caret_count()):
					if multicaret_edit_ignore_caret(i):
						continue
					# Logic here.
				end_multicaret_edit()
				end_complex_operation()
				```
			'''




    self._ptr.call_with_return(549,tuple([]))

  @functools.native_method
  def end_multicaret_edit(self) -> None:
    r'''
				Ends an edit for multiple carets, that was started with `begin_multicaret_edit`. If this was the last `end_multicaret_edit` and `merge_overlapping_carets` was called, carets will be merged.
			'''




    self._ptr.call_with_return(550,tuple([]))

  @functools.native_method
  def is_in_mulitcaret_edit(self) -> typing.Union[bool]:
    r'''
				Returns `true` if a `begin_multicaret_edit` has been called and `end_multicaret_edit` has not yet been called.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(551,tuple([]))
    return _ret


  @functools.native_method
  def multicaret_edit_ignore_caret(self, caret_index:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given `caret_index` should be ignored as part of a multicaret edit. See `begin_multicaret_edit` and `end_multicaret_edit`. Carets that should be ignored are ones that were part of removed text and will likely be merged at the end of the edit, or carets that were added during the edit.
				It is recommended to `continue` within a loop iterating on multiple carets if a caret should be ignored.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(552,tuple([caret_index]))
    return _ret


  @functools.native_method
  def is_caret_visible(self, caret_index:'int' =0  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the caret is visible, `false` otherwise. A caret will be considered hidden if it is outside the scrollable area when scrolling is enabled.
				**Note:** `is_caret_visible` does not account for a caret being off-screen if it is still within the scrollable area. It will return `true` even if the caret is off-screen as long as it meets `TextEdit`'s own conditions for being visible. This includes uses of `scroll_fit_content_width` and `scroll_fit_content_height` that cause the `TextEdit` to expand beyond the viewport's bounds.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(553,tuple([caret_index]))
    return _ret


  @functools.native_method
  def get_caret_draw_pos(self, caret_index:'int' =0  ) -> typing.Union['Vector2']:
    r'''
				Returns the caret pixel draw position.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(554,tuple([caret_index]))
    return _ret


  @functools.native_method
  def set_caret_line(self, line:'int'   , adjust_viewport:'bool' =True  , can_be_hidden:'bool' =True  , wrap_index:'int' =0  , caret_index:'int' =0  ) -> None:
    r'''
				Moves the caret to the specified `line` index. The caret column will be moved to the same visual position it was at the last time `set_caret_column` was called, or clamped to the end of the line.
				If `adjust_viewport` is `true`, the viewport will center at the caret position after the move occurs.
				If `can_be_hidden` is `true`, the specified `line` can be hidden.
				If `wrap_index` is `-1`, the caret column will be clamped to the `line`'s length. If `wrap_index` is greater than `-1`, the column will be moved to attempt to match the visual x position on the line's `wrap_index` to the position from the last time `set_caret_column` was called.
				**Note:** If supporting multiple carets this will not check for any overlap. See `merge_overlapping_carets`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(adjust_viewport, bool), 'adjust_viewport must be bool'
    assert isinstance(can_be_hidden, bool), 'can_be_hidden must be bool'
    assert isinstance(wrap_index, (int, float)), 'wrap_index must be int or float'
    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'











    self._ptr.call_with_return(555,tuple([line, adjust_viewport, can_be_hidden, wrap_index, caret_index]))

  @functools.native_method
  def get_caret_line(self, caret_index:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the line the editing caret is on.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(556,tuple([caret_index]))
    return _ret


  @functools.native_method
  def set_caret_column(self, column:'int'   , adjust_viewport:'bool' =True  , caret_index:'int' =0  ) -> None:
    r'''
				Moves the caret to the specified `column` index.
				If `adjust_viewport` is `true`, the viewport will center at the caret position after the move occurs.
				**Note:** If supporting multiple carets this will not check for any overlap. See `merge_overlapping_carets`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(adjust_viewport, bool), 'adjust_viewport must be bool'
    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'









    self._ptr.call_with_return(557,tuple([column, adjust_viewport, caret_index]))

  @functools.native_method
  def get_caret_column(self, caret_index:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the column the editing caret is at.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(558,tuple([caret_index]))
    return _ret


  @functools.native_method
  def get_next_composite_character_column(self, line:'int'   , column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the correct column at the end of a composite character like โค๏ธโ๐ฉน (mending heart; Unicode: `U+2764 U+FE0F U+200D U+1FA79`) which is comprised of more than one Unicode code point, if the caret is at the start of the composite character. Also returns the correct column with the caret at mid grapheme and for non-composite characters.
				**Note:** To check at caret location use `get_next_composite_character_column(get_caret_line(), get_caret_column())`
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(column, (int, float)), 'column must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(559,tuple([line, column]))
    return _ret


  @functools.native_method
  def get_previous_composite_character_column(self, line:'int'   , column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the correct column at the start of a composite character like โค๏ธโ๐ฉน (mending heart; Unicode: `U+2764 U+FE0F U+200D U+1FA79`) which is comprised of more than one Unicode code point, if the caret is at the end of the composite character. Also returns the correct column with the caret at mid grapheme and for non-composite characters.
				**Note:** To check at caret location use `get_previous_composite_character_column(get_caret_line(), get_caret_column())`
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(column, (int, float)), 'column must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(560,tuple([line, column]))
    return _ret


  @functools.native_method
  def get_caret_wrap_index(self, caret_index:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the wrap index the editing caret is on.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(561,tuple([caret_index]))
    return _ret


  @functools.native_method
  def get_word_under_caret(self, caret_index:'int' =-1  ) -> typing.Union[str]:
    r'''
				Returns a `String` text with the word under the caret's location.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(562,tuple([caret_index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_use_default_word_separators(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__use_default_word_separators = enabled






    self._ptr.call_with_return(563,tuple([enabled]))

  @functools.native_method
  def is_default_word_separators_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(564,tuple([]))

    return _ret


  @functools.native_method
  def set_use_custom_word_separators(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__use_custom_word_separators = enabled






    self._ptr.call_with_return(565,tuple([enabled]))

  @functools.native_method
  def is_custom_word_separators_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(566,tuple([]))

    return _ret


  @functools.native_method
  def set_custom_word_separators(self, custom_word_separators:'str'   ) -> None:
    r''''''

    assert(not custom_word_separators is None)
    assert isinstance(custom_word_separators, (str, String)), 'custom_word_separators must be str or String'


    self.py__custom_word_separators = custom_word_separators



    assert(isinstance(custom_word_separators, (str, String)))
    py_string_custom_word_separators = custom_word_separators if isinstance(custom_word_separators, StringName) else c_utils.py_string_to_string(custom_word_separators)

    py__string_custom_word_separators = utils.py_string_to_string(custom_word_separators)
    py__string_custom_word_separators.shouldBeDeleted = False


    self._ptr.call_with_return(567,tuple([py__string_custom_word_separators._ptr]))

  @functools.native_method
  def get_custom_word_separators(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(568,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_selecting_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__selecting_enabled = enable






    self._ptr.call_with_return(569,tuple([enable]))

  @functools.native_method
  def is_selecting_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(570,tuple([]))

    return _ret


  @functools.native_method
  def set_deselect_on_focus_loss_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__deselect_on_focus_loss_enabled = enable






    self._ptr.call_with_return(571,tuple([enable]))

  @functools.native_method
  def is_deselect_on_focus_loss_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(572,tuple([]))

    return _ret


  @functools.native_method
  def set_drag_and_drop_selection_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__drag_and_drop_selection_enabled = enable






    self._ptr.call_with_return(573,tuple([enable]))

  @functools.native_method
  def is_drag_and_drop_selection_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(574,tuple([]))

    return _ret


  @functools.native_method
  def set_selection_mode(self, mode:'int'  ) -> None:
    r'''
				Sets the current selection mode.
			'''

    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(575,tuple([mode]))

  @functools.native_method
  def get_selection_mode(self) -> typing.Union[int]:
    r'''
				Returns the current selection mode.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(576,tuple([]))
    return _ret


  @functools.native_method
  def select_all(self) -> None:
    r'''
				Select all the text.
				If `selecting_enabled` is `false`, no selection will occur.
			'''




    self._ptr.call_with_return(577,tuple([]))

  @functools.native_method
  def select_word_under_caret(self, caret_index:'int' =-1  ) -> None:
    r'''
				Selects the word under the caret.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(578,tuple([caret_index]))

  @functools.native_method
  def add_selection_for_next_occurrence(self) -> None:
    r'''
				Adds a selection and a caret for the next occurrence of the current selection. If there is no active selection, selects word under caret.
			'''




    self._ptr.call_with_return(579,tuple([]))

  @functools.native_method
  def skip_selection_for_next_occurrence(self) -> None:
    r'''
				Moves a selection and a caret for the next occurrence of the current selection. If there is no active selection, moves to the next occurrence of the word under caret.
			'''




    self._ptr.call_with_return(580,tuple([]))

  @functools.native_method
  def select(self, origin_line:'int'   , origin_column:'int'   , caret_line:'int'   , caret_column:'int'   , caret_index:'int' =0  ) -> None:
    r'''
				Selects text from `origin_line` and `origin_column` to `caret_line` and `caret_column` for the given `caret_index`. This moves the selection origin and the caret. If the positions are the same, the selection will be deselected.
				If `selecting_enabled` is `false`, no selection will occur.
				**Note:** If supporting multiple carets this will not check for any overlap. See `merge_overlapping_carets`.
			'''

    assert isinstance(origin_line, (int, float)), 'origin_line must be int or float'
    assert isinstance(origin_column, (int, float)), 'origin_column must be int or float'
    assert isinstance(caret_line, (int, float)), 'caret_line must be int or float'
    assert isinstance(caret_column, (int, float)), 'caret_column must be int or float'
    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'











    self._ptr.call_with_return(581,tuple([origin_line, origin_column, caret_line, caret_column, caret_index]))

  @functools.native_method
  def has_selection(self, caret_index:'int' =-1  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the user has selected text.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(582,tuple([caret_index]))
    return _ret


  @functools.native_method
  def get_selected_text(self, caret_index:'int' =-1  ) -> typing.Union[str]:
    r'''
				Returns the text inside the selection of a caret, or all the carets if `caret_index` is its default value `-1`.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(583,tuple([caret_index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_selection_at_line_column(self, line:'int'   , column:'int'   , include_edges:'bool' =True  , only_selections:'bool' =True  ) -> typing.Union[int]:
    r'''
				Returns the caret index of the selection at the given `line` and `column`, or `-1` if there is none.
				If `include_edges` is `false`, the position must be inside the selection and not at either end. If `only_selections` is `false`, carets without a selection will also be considered.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(include_edges, bool), 'include_edges must be bool'
    assert isinstance(only_selections, bool), 'only_selections must be bool'










    _ret = 0
    _ret = self._ptr.call_with_return(584,tuple([line, column, include_edges, only_selections]))
    return _ret


  @functools.native_method
  def get_line_ranges_from_carets(self, only_selections:'bool' =False  , merge_adjacent:'bool' =True  ) -> typing.Union['py4godot_vector2itypedarray.Vector2iTypedArray']:
    r'''
				Returns an `Array` of line ranges where `x` is the first line and `y` is the last line. All lines within these ranges will have a caret on them or be part of a selection. Each line will only be part of one line range, even if it has multiple carets on it.
				If a selection's end column (`get_selection_to_column`) is at column `0`, that line will not be included. If a selection begins on the line after another selection ends and `merge_adjacent` is `true`, or they begin and end on the same line, one line range will include both selections.
			'''

    assert isinstance(only_selections, bool), 'only_selections must be bool'
    assert isinstance(merge_adjacent, bool), 'merge_adjacent must be bool'








    _ret = py4godot_vector2itypedarray.Vector2iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(585,tuple([only_selections, merge_adjacent]))
    return _ret


  @functools.native_method
  def get_selection_origin_line(self, caret_index:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the origin line of the selection. This is the opposite end from the caret.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(586,tuple([caret_index]))
    return _ret


  @functools.native_method
  def get_selection_origin_column(self, caret_index:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the origin column of the selection. This is the opposite end from the caret.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(587,tuple([caret_index]))
    return _ret


  @functools.native_method
  def set_selection_origin_line(self, line:'int'   , can_be_hidden:'bool' =True  , wrap_index:'int' =-1  , caret_index:'int' =0  ) -> None:
    r'''
				Sets the selection origin line to the `line` for the given `caret_index`. If the selection origin is moved to the caret position, the selection will deselect.
				If `can_be_hidden` is `false`, The line will be set to the nearest unhidden line below or above.
				If `wrap_index` is `-1`, the selection origin column will be clamped to the `line`'s length. If `wrap_index` is greater than `-1`, the column will be moved to attempt to match the visual x position on the line's `wrap_index` to the position from the last time `set_selection_origin_column` or `select` was called.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(can_be_hidden, bool), 'can_be_hidden must be bool'
    assert isinstance(wrap_index, (int, float)), 'wrap_index must be int or float'
    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'










    self._ptr.call_with_return(588,tuple([line, can_be_hidden, wrap_index, caret_index]))

  @functools.native_method
  def set_selection_origin_column(self, column:'int'   , caret_index:'int' =0  ) -> None:
    r'''
				Sets the selection origin column to the `column` for the given `caret_index`. If the selection origin is moved to the caret position, the selection will deselect.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'








    self._ptr.call_with_return(589,tuple([column, caret_index]))

  @functools.native_method
  def get_selection_from_line(self, caret_index:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the selection begin line. Returns the caret line if there is no selection.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(590,tuple([caret_index]))
    return _ret


  @functools.native_method
  def get_selection_from_column(self, caret_index:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the selection begin column. Returns the caret column if there is no selection.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(591,tuple([caret_index]))
    return _ret


  @functools.native_method
  def get_selection_to_line(self, caret_index:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the selection end line. Returns the caret line if there is no selection.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(592,tuple([caret_index]))
    return _ret


  @functools.native_method
  def get_selection_to_column(self, caret_index:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the selection end column. Returns the caret column if there is no selection.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(593,tuple([caret_index]))
    return _ret


  @functools.native_method
  def is_caret_after_selection_origin(self, caret_index:'int' =0  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the caret of the selection is after the selection origin. This can be used to determine the direction of the selection.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(594,tuple([caret_index]))
    return _ret


  @functools.native_method
  def deselect(self, caret_index:'int' =-1  ) -> None:
    r'''
				Deselects the current selection.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(595,tuple([caret_index]))

  @functools.native_method
  def delete_selection(self, caret_index:'int' =-1  ) -> None:
    r'''
				Deletes the selected text.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(596,tuple([caret_index]))

  @functools.native_method
  def set_line_wrapping_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__wrap_mode = mode






    self._ptr.call_with_return(597,tuple([mode]))

  @functools.native_method
  def get_line_wrapping_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(598,tuple([]))

    return _ret


  @functools.native_method
  def set_autowrap_mode(self, autowrap_mode:'int'  ) -> None:
    r''''''

    assert isinstance(autowrap_mode, (int, float)), 'autowrap_mode must be int or float'


    self.py__autowrap_mode = autowrap_mode






    self._ptr.call_with_return(599,tuple([autowrap_mode]))

  @functools.native_method
  def get_autowrap_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(600,tuple([]))

    return _ret


  @functools.native_method
  def is_line_wrapped(self, line:'int'   ) -> typing.Union[bool]:
    r'''
				Returns if the given line is wrapped.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(601,tuple([line]))
    return _ret


  @functools.native_method
  def get_line_wrap_count(self, line:'int'   ) -> typing.Union[int]:
    r'''
				Returns the number of times the given line is wrapped.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(602,tuple([line]))
    return _ret


  @functools.native_method
  def get_line_wrap_index_at_column(self, line:'int'   , column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the wrap index of the given column on the given line. This ranges from `0` to `get_line_wrap_count`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(column, (int, float)), 'column must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(603,tuple([line, column]))
    return _ret


  @functools.native_method
  def get_line_wrapped_text(self, line:'int'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns an array of `String`s representing each wrapped index.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(604,tuple([line]))
    return _ret


  @functools.native_method
  def set_smooth_scroll_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__scroll_smooth = enable






    self._ptr.call_with_return(605,tuple([enable]))

  @functools.native_method
  def is_smooth_scroll_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(606,tuple([]))

    return _ret


  @functools.native_method
  def get_v_scroll_bar(self) -> typing.Union['py4godot_vscrollbar.VScrollBar']:
    r'''
				Returns the `VScrollBar` of the `TextEdit`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: VScrollBar
    _ret._ptr = self._ptr.call_with_return(607,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_h_scroll_bar(self) -> typing.Union['py4godot_hscrollbar.HScrollBar']:
    r'''
				Returns the `HScrollBar` used by `TextEdit`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: HScrollBar
    _ret._ptr = self._ptr.call_with_return(608,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_v_scroll(self, value:'float'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'


    self.py__scroll_vertical = value






    self._ptr.call_with_return(609,tuple([value]))

  @functools.native_method
  def get_v_scroll(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(610,tuple([]))

    return _ret


  @functools.native_method
  def set_h_scroll(self, value:'int'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'


    self.py__scroll_horizontal = value






    self._ptr.call_with_return(611,tuple([value]))

  @functools.native_method
  def get_h_scroll(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(612,tuple([]))

    return _ret


  @functools.native_method
  def set_scroll_past_end_of_file_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__scroll_past_end_of_file = enable






    self._ptr.call_with_return(613,tuple([enable]))

  @functools.native_method
  def is_scroll_past_end_of_file_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(614,tuple([]))

    return _ret


  @functools.native_method
  def set_v_scroll_speed(self, speed:'float'   ) -> None:
    r''''''

    assert isinstance(speed, (int, float)), 'speed must be int or float'


    self.py__scroll_v_scroll_speed = speed






    self._ptr.call_with_return(615,tuple([speed]))

  @functools.native_method
  def get_v_scroll_speed(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(616,tuple([]))

    return _ret


  @functools.native_method
  def set_fit_content_height_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__scroll_fit_content_height = enabled






    self._ptr.call_with_return(617,tuple([enabled]))

  @functools.native_method
  def is_fit_content_height_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(618,tuple([]))

    return _ret


  @functools.native_method
  def set_fit_content_width_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__scroll_fit_content_width = enabled






    self._ptr.call_with_return(619,tuple([enabled]))

  @functools.native_method
  def is_fit_content_width_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(620,tuple([]))

    return _ret


  @functools.native_method
  def get_scroll_pos_for_line(self, line:'int'   , wrap_index:'int' =0  ) -> typing.Union[float]:
    r'''
				Returns the scroll position for `wrap_index` of `line`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(wrap_index, (int, float)), 'wrap_index must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(621,tuple([line, wrap_index]))
    return _ret


  @functools.native_method
  def set_line_as_first_visible(self, line:'int'   , wrap_index:'int' =0  ) -> None:
    r'''
				Positions the `wrap_index` of `line` at the top of the viewport.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(wrap_index, (int, float)), 'wrap_index must be int or float'








    self._ptr.call_with_return(622,tuple([line, wrap_index]))

  @functools.native_method
  def get_first_visible_line(self) -> typing.Union[int]:
    r'''
				Returns the first visible line.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(623,tuple([]))
    return _ret


  @functools.native_method
  def set_line_as_center_visible(self, line:'int'   , wrap_index:'int' =0  ) -> None:
    r'''
				Positions the `wrap_index` of `line` at the center of the viewport.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(wrap_index, (int, float)), 'wrap_index must be int or float'








    self._ptr.call_with_return(624,tuple([line, wrap_index]))

  @functools.native_method
  def set_line_as_last_visible(self, line:'int'   , wrap_index:'int' =0  ) -> None:
    r'''
				Positions the `wrap_index` of `line` at the bottom of the viewport.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(wrap_index, (int, float)), 'wrap_index must be int or float'








    self._ptr.call_with_return(625,tuple([line, wrap_index]))

  @functools.native_method
  def get_last_full_visible_line(self) -> typing.Union[int]:
    r'''
				Returns the last visible line. Use `get_last_full_visible_line_wrap_index` for the wrap index.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(626,tuple([]))
    return _ret


  @functools.native_method
  def get_last_full_visible_line_wrap_index(self) -> typing.Union[int]:
    r'''
				Returns the last visible wrap index of the last visible line.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(627,tuple([]))
    return _ret


  @functools.native_method
  def get_visible_line_count(self) -> typing.Union[int]:
    r'''
				Returns the number of lines that can visually fit, rounded down, based on this control's height.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(628,tuple([]))
    return _ret


  @functools.native_method
  def get_visible_line_count_in_range(self, from_line:'int'   , to_line:'int'   ) -> typing.Union[int]:
    r'''
				Returns the total number of lines between `from_line` and `to_line` (inclusive) in the text. This includes wrapped lines and excludes folded lines. If the range covers all lines it is equivalent to `get_total_visible_line_count`.
			'''

    assert isinstance(from_line, (int, float)), 'from_line must be int or float'
    assert isinstance(to_line, (int, float)), 'to_line must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(629,tuple([from_line, to_line]))
    return _ret


  @functools.native_method
  def get_total_visible_line_count(self) -> typing.Union[int]:
    r'''
				Returns the total number of lines in the text. This includes wrapped lines and excludes folded lines. If `wrap_mode` is set to `constant LINE_WRAPPING_NONE` and no lines are folded (see `CodeEdit.is_line_folded`) then this is equivalent to `get_line_count`. See `get_visible_line_count_in_range` for a limited range of lines.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(630,tuple([]))
    return _ret


  @functools.native_method
  def adjust_viewport_to_caret(self, caret_index:'int' =0  ) -> None:
    r'''
				Adjust the viewport so the caret is visible.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(631,tuple([caret_index]))

  @functools.native_method
  def center_viewport_to_caret(self, caret_index:'int' =0  ) -> None:
    r'''
				Centers the viewport on the line the editing caret is at. This also resets the `scroll_horizontal` value to `0`.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    self._ptr.call_with_return(632,tuple([caret_index]))

  @functools.native_method
  def set_draw_minimap(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__minimap_draw = enabled






    self._ptr.call_with_return(633,tuple([enabled]))

  @functools.native_method
  def is_drawing_minimap(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(634,tuple([]))

    return _ret


  @functools.native_method
  def set_minimap_width(self, width:'int'   ) -> None:
    r''''''

    assert isinstance(width, (int, float)), 'width must be int or float'


    self.py__minimap_width = width






    self._ptr.call_with_return(635,tuple([width]))

  @functools.native_method
  def get_minimap_width(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(636,tuple([]))

    return _ret


  @functools.native_method
  def get_minimap_visible_lines(self) -> typing.Union[int]:
    r'''
				Returns the number of lines that may be drawn on the minimap.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(637,tuple([]))
    return _ret


  @functools.native_method
  def add_gutter(self, at:'int' =-1  ) -> None:
    r'''
				Register a new gutter to this `TextEdit`. Use `at` to have a specific gutter order. A value of `-1` appends the gutter to the right.
			'''

    assert isinstance(at, (int, float)), 'at must be int or float'







    self._ptr.call_with_return(638,tuple([at]))

  @functools.native_method
  def remove_gutter(self, gutter:'int'   ) -> None:
    r'''
				Removes the gutter at the given index.
			'''

    assert isinstance(gutter, (int, float)), 'gutter must be int or float'







    self._ptr.call_with_return(639,tuple([gutter]))

  @functools.native_method
  def get_gutter_count(self) -> typing.Union[int]:
    r'''
				Returns the number of gutters registered.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(640,tuple([]))
    return _ret


  @functools.native_method
  def set_gutter_name(self, gutter:'int'   , name:'str'   ) -> None:
    r'''
				Sets the name of the gutter at the given index.
			'''

    assert isinstance(gutter, (int, float)), 'gutter must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(641,tuple([gutter, py_string_name._ptr]))

  @functools.native_method
  def get_gutter_name(self, gutter:'int'   ) -> typing.Union[str]:
    r'''
				Returns the name of the gutter at the given index.
			'''

    assert isinstance(gutter, (int, float)), 'gutter must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(642,tuple([gutter]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_gutter_type(self, gutter:'int'   , type:'int'  ) -> None:
    r'''
				Sets the type of gutter at the given index. Gutters can contain icons, text, or custom visuals.
			'''

    assert isinstance(gutter, (int, float)), 'gutter must be int or float'
    assert isinstance(type, (int, float)), 'type must be int or float'








    self._ptr.call_with_return(643,tuple([gutter, type]))

  @functools.native_method
  def get_gutter_type(self, gutter:'int'   ) -> typing.Union[int]:
    r'''
				Returns the type of the gutter at the given index. Gutters can contain icons, text, or custom visuals.
			'''

    assert isinstance(gutter, (int, float)), 'gutter must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(644,tuple([gutter]))
    return _ret


  @functools.native_method
  def set_gutter_width(self, gutter:'int'   , width:'int'   ) -> None:
    r'''
				Set the width of the gutter at the given index.
			'''

    assert isinstance(gutter, (int, float)), 'gutter must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'








    self._ptr.call_with_return(645,tuple([gutter, width]))

  @functools.native_method
  def get_gutter_width(self, gutter:'int'   ) -> typing.Union[int]:
    r'''
				Returns the width of the gutter at the given index.
			'''

    assert isinstance(gutter, (int, float)), 'gutter must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(646,tuple([gutter]))
    return _ret


  @functools.native_method
  def set_gutter_draw(self, gutter:'int'   , draw:'bool'   ) -> None:
    r'''
				If `true`, the gutter at the given index is drawn. The gutter type (`set_gutter_type`) determines how it is drawn. See `is_gutter_drawn`.
			'''

    assert isinstance(gutter, (int, float)), 'gutter must be int or float'
    assert isinstance(draw, bool), 'draw must be bool'








    self._ptr.call_with_return(647,tuple([gutter, draw]))

  @functools.native_method
  def is_gutter_drawn(self, gutter:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the gutter at the given index is currently drawn. See `set_gutter_draw`.
			'''

    assert isinstance(gutter, (int, float)), 'gutter must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(648,tuple([gutter]))
    return _ret


  @functools.native_method
  def set_gutter_clickable(self, gutter:'int'   , clickable:'bool'   ) -> None:
    r'''
				If `true`, the mouse cursor will change to a pointing hand (`constant Control.CURSOR_POINTING_HAND`) when hovering over the gutter at the given index. See `is_gutter_clickable` and `set_line_gutter_clickable`.
			'''

    assert isinstance(gutter, (int, float)), 'gutter must be int or float'
    assert isinstance(clickable, bool), 'clickable must be bool'








    self._ptr.call_with_return(649,tuple([gutter, clickable]))

  @functools.native_method
  def is_gutter_clickable(self, gutter:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the gutter at the given index is clickable. See `set_gutter_clickable`.
			'''

    assert isinstance(gutter, (int, float)), 'gutter must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(650,tuple([gutter]))
    return _ret


  @functools.native_method
  def set_gutter_overwritable(self, gutter:'int'   , overwritable:'bool'   ) -> None:
    r'''
				If `true`, the line data of the gutter at the given index can be overridden when using `merge_gutters`. See `is_gutter_overwritable`.
			'''

    assert isinstance(gutter, (int, float)), 'gutter must be int or float'
    assert isinstance(overwritable, bool), 'overwritable must be bool'








    self._ptr.call_with_return(651,tuple([gutter, overwritable]))

  @functools.native_method
  def is_gutter_overwritable(self, gutter:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the gutter at the given index is overwritable. See `set_gutter_overwritable`.
			'''

    assert isinstance(gutter, (int, float)), 'gutter must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(652,tuple([gutter]))
    return _ret


  @functools.native_method
  def merge_gutters(self, from_line:'int'   , to_line:'int'   ) -> None:
    r'''
				Merge the gutters from `from_line` into `to_line`. Only overwritable gutters will be copied. See `set_gutter_overwritable`.
			'''

    assert isinstance(from_line, (int, float)), 'from_line must be int or float'
    assert isinstance(to_line, (int, float)), 'to_line must be int or float'








    self._ptr.call_with_return(653,tuple([from_line, to_line]))

  @functools.native_method
  def set_gutter_custom_draw(self, column:'int'   , draw_callback:'Callable'   ) -> None:
    r'''
				Set a custom draw callback for the gutter at the given index. `draw_callback` must take the following arguments: A line index `int`, a gutter index `int`, and an area `Rect2`. This callback only works when the gutter type is `constant GUTTER_TYPE_CUSTOM` (see `set_gutter_type`).
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not draw_callback is None)
    assert isinstance(draw_callback, Callable), 'draw_callback must be Callable'








    self._ptr.call_with_return(654,tuple([column, draw_callback._ptr]))

  @functools.native_method
  def get_total_gutter_width(self) -> typing.Union[int]:
    r'''
				Returns the total width of all gutters and internal padding.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(655,tuple([]))
    return _ret


  @functools.native_method
  def set_line_gutter_metadata(self, line:'int'   , gutter:'int'   , metadata:'object'   ) -> None:
    r'''
				Sets the metadata for `gutter` on `line` to `metadata`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(gutter, (int, float)), 'gutter must be int or float'
    

    if not (type(metadata).__name__ in py4godot.variant_types.core_types or isinstance(metadata, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'metadata': "
                f"{type(metadata).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    self._ptr.call_with_return(656,tuple([line, gutter, metadata]))

  @functools.native_method
  def get_line_gutter_metadata(self, line:'int'   , gutter:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the metadata currently in `gutter` at `line`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(gutter, (int, float)), 'gutter must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(657,tuple([line, gutter]))
    return _ret


  @functools.native_method
  def set_line_gutter_text(self, line:'int'   , gutter:'int'   , text:'str'   ) -> None:
    r'''
				Sets the text for `gutter` on `line` to `text`. This only works when the gutter type is `constant GUTTER_TYPE_STRING` (see `set_gutter_type`).
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(gutter, (int, float)), 'gutter must be int or float'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'







    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    self._ptr.call_with_return(658,tuple([line, gutter, py_string_text._ptr]))

  @functools.native_method
  def get_line_gutter_text(self, line:'int'   , gutter:'int'   ) -> typing.Union[str]:
    r'''
				Returns the text currently in `gutter` at `line`. This only works when the gutter type is `constant GUTTER_TYPE_STRING` (see `set_gutter_type`).
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(gutter, (int, float)), 'gutter must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(659,tuple([line, gutter]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_line_gutter_icon(self, line:'int'   , gutter:'int'   , icon:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets the icon for `gutter` on `line` to `icon`. This only works when the gutter type is `constant GUTTER_TYPE_ICON` (see `set_gutter_type`).
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(gutter, (int, float)), 'gutter must be int or float'
    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'









    self._ptr.call_with_return(660,tuple([line, gutter, icon._ptr]))

  @functools.native_method
  def get_line_gutter_icon(self, line:'int'   , gutter:'int'   ) -> typing.Any:
    r'''
				Returns the icon currently in `gutter` at `line`. This only works when the gutter type is `constant GUTTER_TYPE_ICON` (see `set_gutter_type`).
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(gutter, (int, float)), 'gutter must be int or float'








    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(661,tuple([line, gutter]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_line_gutter_item_color(self, line:'int'   , gutter:'int'   , color:'Color'   ) -> None:
    r'''
				Sets the color for `gutter` on `line` to `color`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(gutter, (int, float)), 'gutter must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'









    self._ptr.call_with_return(662,tuple([line, gutter, color._ptr]))

  @functools.native_method
  def get_line_gutter_item_color(self, line:'int'   , gutter:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the color currently in `gutter` at `line`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(gutter, (int, float)), 'gutter must be int or float'








    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(663,tuple([line, gutter]))
    return _ret


  @functools.native_method
  def set_line_gutter_clickable(self, line:'int'   , gutter:'int'   , clickable:'bool'   ) -> None:
    r'''
				If `clickable` is `true`, makes the `gutter` on the given `line` clickable. This is like `set_gutter_clickable`, but for a single line. If `is_gutter_clickable` is `true`, this will not have any effect. See `is_line_gutter_clickable` and `signal gutter_clicked`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(gutter, (int, float)), 'gutter must be int or float'
    assert isinstance(clickable, bool), 'clickable must be bool'









    self._ptr.call_with_return(664,tuple([line, gutter, clickable]))

  @functools.native_method
  def is_line_gutter_clickable(self, line:'int'   , gutter:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the gutter at the given index on the given line is clickable. See `set_line_gutter_clickable`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(gutter, (int, float)), 'gutter must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(665,tuple([line, gutter]))
    return _ret


  @functools.native_method
  def set_line_background_color(self, line:'int'   , color:'Color'   ) -> None:
    r'''
				Sets the custom background color of the given line. If transparent, this color is applied on top of the default background color (See `theme_item background_color`). If set to `Color(0, 0, 0, 0)`, no additional color is applied.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'








    self._ptr.call_with_return(666,tuple([line, color._ptr]))

  @functools.native_method
  def get_line_background_color(self, line:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the custom background color of the given line. If no color is set, returns `Color(0, 0, 0, 0)`.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(667,tuple([line]))
    return _ret


  @functools.native_method
  def set_syntax_highlighter(self, syntax_highlighter:'py4godot_syntaxhighlighter.SyntaxHighlighter'   ) -> None:
    r''''''

    assert(not syntax_highlighter is None)
    assert isinstance(syntax_highlighter, get_class('SyntaxHighlighter')), 'syntax_highlighter must be SyntaxHighlighter'


    self.py__syntax_highlighter = syntax_highlighter






    self._ptr.call_with_return(668,tuple([syntax_highlighter._ptr]))

  @functools.native_method
  def get_syntax_highlighter(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: SyntaxHighlighter
    _ret._ptr = self._ptr.call_with_return(669,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_highlight_current_line(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__highlight_current_line = enabled






    self._ptr.call_with_return(670,tuple([enabled]))

  @functools.native_method
  def is_highlight_current_line_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(671,tuple([]))

    return _ret


  @functools.native_method
  def set_highlight_all_occurrences(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__highlight_all_occurrences = enabled






    self._ptr.call_with_return(672,tuple([enabled]))

  @functools.native_method
  def is_highlight_all_occurrences_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(673,tuple([]))

    return _ret


  @functools.native_method
  def get_draw_control_chars(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(674,tuple([]))

    return _ret


  @functools.native_method
  def set_draw_control_chars(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__draw_control_chars = enabled






    self._ptr.call_with_return(675,tuple([enabled]))

  @functools.native_method
  def set_draw_tabs(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__draw_tabs = enabled






    self._ptr.call_with_return(676,tuple([enabled]))

  @functools.native_method
  def is_drawing_tabs(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(677,tuple([]))

    return _ret


  @functools.native_method
  def set_draw_spaces(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__draw_spaces = enabled






    self._ptr.call_with_return(678,tuple([enabled]))

  @functools.native_method
  def is_drawing_spaces(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(679,tuple([]))

    return _ret


  @functools.native_method
  def get_menu(self) -> typing.Union['py4godot_popupmenu.PopupMenu']:
    r'''
				Returns the `PopupMenu` of this `TextEdit`. By default, this menu is displayed when right-clicking on the `TextEdit`.
				You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see `enum MenuItems`). For example:
				
				```gdscript
				func _ready():
					var menu = get_menu()
					# Remove all items after "Redo".
					menu.item_count = menu.get_item_index(MENU_REDO) + 1
					# Add custom items.
					menu.add_separator()
					menu.add_item("Insert Date", MENU_MAX + 1)
					# Connect callback.
					menu.id_pressed.connect(_on_item_pressed)

				func _on_item_pressed(id):
					if id == MENU_MAX + 1:
						insert_text_at_caret(Time.get_date_string_from_system())
				```
				
				
				**Warning:** This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their `Window.visible` property.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: PopupMenu
    _ret._ptr = self._ptr.call_with_return(680,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def is_menu_visible(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the menu is visible. Use this instead of `get_menu().visible` to improve performance (so the creation of the menu is avoided). See `get_menu`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(681,tuple([]))
    return _ret


  @functools.native_method
  def menu_option(self, option:'int'   ) -> None:
    r'''
				Executes a given action as defined in the `enum MenuItems` enum.
			'''

    assert isinstance(option, (int, float)), 'option must be int or float'







    self._ptr.call_with_return(682,tuple([option]))

  @functools.native_method
  def adjust_carets_after_edit(self, caret:'int'   , from_line:'int'   , from_col:'int'   , to_line:'int'   , to_col:'int'   ) -> None:
    r'''
				This method does nothing.
			'''

    assert isinstance(caret, (int, float)), 'caret must be int or float'
    assert isinstance(from_line, (int, float)), 'from_line must be int or float'
    assert isinstance(from_col, (int, float)), 'from_col must be int or float'
    assert isinstance(to_line, (int, float)), 'to_line must be int or float'
    assert isinstance(to_col, (int, float)), 'to_col must be int or float'











    self._ptr.call_with_return(683,tuple([caret, from_line, from_col, to_line, to_col]))

  @functools.native_method
  def get_caret_index_edit_order(self) -> typing.Union['PackedInt32Array']:
    r'''
				Returns a list of caret indexes in their edit order, this done from bottom to top. Edit order refers to the way actions such as `insert_text_at_caret` are applied.
			'''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(684,tuple([]))
    return _ret


  @functools.native_method
  def get_selection_line(self, caret_index:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the original start line of the selection.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(685,tuple([caret_index]))
    return _ret


  @functools.native_method
  def get_selection_column(self, caret_index:'int' =0  ) -> typing.Union[int]:
    r'''
				Returns the original start column of the selection.
			'''

    assert isinstance(caret_index, (int, float)), 'caret_index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(686,tuple([caret_index]))
    return _ret



register_cast_function('TextEdit', TextEdit.cast)
register_class('TextEdit', TextEdit)
