# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PlaneTypedArray as py4godot_planetypedarray 
import py4godot.classes.PlaneTypedArray as py4godot_planetypedarray 
import py4godot.classes.Object as py4godot_object 
from py4godot.wrappers.wrappers import CPPGeometry3DWrapper

_Geometry3D_singleton_instance = None

class Geometry3D(py4godot_object.Object):
  r'''
		Provides a set of helper functions to create geometric shapes, compute intersections between shapes, and process various other geometric operations in 3D.
	'''


  def generate_wrapper(self):
    return CPPGeometry3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Geometry3D.__new__(Geometry3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Geometry3D'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Geometry3D.construct_without_init()
    cls._ptr = CPPGeometry3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Geometry3D.construct_without_init()
    cls._ptr = CPPGeometry3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _Geometry3D_singleton_instance
    if _Geometry3D_singleton_instance is None:
      singleton = Geometry3D()
      singleton._ptr = constructor(377,0, ())
      _Geometry3D_singleton_instance = singleton
    return _Geometry3D_singleton_instance

  @functools.native_method
  def compute_convex_mesh_points(self, planes:'py4godot_planetypedarray.PlaneTypedArray'   ) -> typing.Union['PackedVector3Array']:
    r'''
				Calculates and returns all the vertex points of a convex shape defined by an array of `planes`.
			'''

    assert isinstance(planes, Array), 'planes must be Array'







    _ret = PackedVector3Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(49,tuple([planes._ptr]))
    return _ret


  @functools.native_method
  def build_box_planes(self, extents:'Vector3'   ) -> typing.Union['py4godot_planetypedarray.PlaneTypedArray']:
    r'''
				Returns an array with 6 `Plane`s that describe the sides of a box centered at the origin. The box size is defined by `extents`, which represents one (positive) corner of the box (i.e. half its actual size).
			'''

    assert(not extents is None)
    assert isinstance(extents, Vector3), 'extents must be Vector3'







    _ret = py4godot_planetypedarray.PlaneTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(50,tuple([extents._ptr]))
    return _ret


  @functools.native_method
  def build_cylinder_planes(self, radius:'float'   , height:'float'   , sides:'int'   , axis:'int'  =2) -> typing.Union['py4godot_planetypedarray.PlaneTypedArray']:
    r'''
				Returns an array of `Plane`s closely bounding a faceted cylinder centered at the origin with radius `radius` and height `height`. The parameter `sides` defines how many planes will be generated for the round part of the cylinder. The parameter `axis` describes the axis along which the cylinder is oriented (0 for X, 1 for Y, 2 for Z).
			'''


    assert isinstance(radius, (int, float)), 'radius must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(sides, (int, float)), 'sides must be int or float'
    assert isinstance(axis, (int, float)), 'axis must be int or float'










    _ret = py4godot_planetypedarray.PlaneTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(51,tuple([radius, height, sides, axis]))
    return _ret


  @functools.native_method
  def build_capsule_planes(self, radius:'float'   , height:'float'   , sides:'int'   , lats:'int'   , axis:'int'  =2) -> typing.Union['py4godot_planetypedarray.PlaneTypedArray']:
    r'''
				Returns an array of `Plane`s closely bounding a faceted capsule centered at the origin with radius `radius` and height `height`. The parameter `sides` defines how many planes will be generated for the side part of the capsule, whereas `lats` gives the number of latitudinal steps at the bottom and top of the capsule. The parameter `axis` describes the axis along which the capsule is oriented (0 for X, 1 for Y, 2 for Z).
			'''


    assert isinstance(radius, (int, float)), 'radius must be int or float'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(sides, (int, float)), 'sides must be int or float'
    assert isinstance(lats, (int, float)), 'lats must be int or float'
    assert isinstance(axis, (int, float)), 'axis must be int or float'











    _ret = py4godot_planetypedarray.PlaneTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(52,tuple([radius, height, sides, lats, axis]))
    return _ret


  @functools.native_method
  def get_closest_points_between_segments(self, p1:'Vector3'   , p2:'Vector3'   , q1:'Vector3'   , q2:'Vector3'   ) -> typing.Union['PackedVector3Array']:
    r'''
				Given the two 3D segments (`p1`, `p2`) and (`q1`, `q2`), finds those two points on the two segments that are closest to each other. Returns a `PackedVector3Array` that contains this point on (`p1`, `p2`) as well the accompanying point on (`q1`, `q2`).
			'''

    assert(not p1 is None)
    assert isinstance(p1, Vector3), 'p1 must be Vector3'
    assert(not p2 is None)
    assert isinstance(p2, Vector3), 'p2 must be Vector3'
    assert(not q1 is None)
    assert isinstance(q1, Vector3), 'q1 must be Vector3'
    assert(not q2 is None)
    assert isinstance(q2, Vector3), 'q2 must be Vector3'










    _ret = PackedVector3Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([p1._ptr, p2._ptr, q1._ptr, q2._ptr]))
    return _ret


  @functools.native_method
  def get_closest_point_to_segment(self, point:'Vector3'   , s1:'Vector3'   , s2:'Vector3'   ) -> typing.Union['Vector3']:
    r'''
				Returns the 3D point on the 3D segment (`s1`, `s2`) that is closest to `point`. The returned point will always be inside the specified segment.
			'''

    assert(not point is None)
    assert isinstance(point, Vector3), 'point must be Vector3'
    assert(not s1 is None)
    assert isinstance(s1, Vector3), 's1 must be Vector3'
    assert(not s2 is None)
    assert isinstance(s2, Vector3), 's2 must be Vector3'









    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([point._ptr, s1._ptr, s2._ptr]))
    return _ret


  @functools.native_method
  def get_closest_point_to_segment_uncapped(self, point:'Vector3'   , s1:'Vector3'   , s2:'Vector3'   ) -> typing.Union['Vector3']:
    r'''
				Returns the 3D point on the 3D line defined by (`s1`, `s2`) that is closest to `point`. The returned point can be inside the segment (`s1`, `s2`) or outside of it, i.e. somewhere on the line extending from the segment.
			'''

    assert(not point is None)
    assert isinstance(point, Vector3), 'point must be Vector3'
    assert(not s1 is None)
    assert isinstance(s1, Vector3), 's1 must be Vector3'
    assert(not s2 is None)
    assert isinstance(s2, Vector3), 's2 must be Vector3'









    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(55,tuple([point._ptr, s1._ptr, s2._ptr]))
    return _ret


  @functools.native_method
  def get_triangle_barycentric_coords(self, point:'Vector3'   , a:'Vector3'   , b:'Vector3'   , c:'Vector3'   ) -> typing.Union['Vector3']:
    r'''
				Returns a `Vector3` containing weights based on how close a 3D position (`point`) is to a triangle's different vertices (`a`, `b` and `c`). This is useful for interpolating between the data of different vertices in a triangle. One example use case is using this to smoothly rotate over a mesh instead of relying solely on face normals.
				`url=https://en.wikipedia.org/wiki/Barycentric_coordinate_system`Here is a more detailed explanation of barycentric coordinates.`/url`
			'''

    assert(not point is None)
    assert isinstance(point, Vector3), 'point must be Vector3'
    assert(not a is None)
    assert isinstance(a, Vector3), 'a must be Vector3'
    assert(not b is None)
    assert isinstance(b, Vector3), 'b must be Vector3'
    assert(not c is None)
    assert isinstance(c, Vector3), 'c must be Vector3'










    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(56,tuple([point._ptr, a._ptr, b._ptr, c._ptr]))
    return _ret


  @functools.native_method
  def ray_intersects_triangle(self, from_:'Vector3'   , dir:'Vector3'   , a:'Vector3'   , b:'Vector3'   , c:'Vector3'   ) -> typing.Union[typing.Any]:
    r'''
				Tests if the 3D ray starting at `from` with the direction of `dir` intersects the triangle specified by `a`, `b` and `c`. If yes, returns the point of intersection as `Vector3`. If no intersection takes place, returns `null`.
			'''

    assert(not from_ is None)
    assert isinstance(from_, Vector3), 'from_ must be Vector3'
    assert(not dir is None)
    assert isinstance(dir, Vector3), 'dir must be Vector3'
    assert(not a is None)
    assert isinstance(a, Vector3), 'a must be Vector3'
    assert(not b is None)
    assert isinstance(b, Vector3), 'b must be Vector3'
    assert(not c is None)
    assert isinstance(c, Vector3), 'c must be Vector3'











    _ret = None
    _ret = self._ptr.call_with_return(57,tuple([from_._ptr, dir._ptr, a._ptr, b._ptr, c._ptr]))
    return _ret


  @functools.native_method
  def segment_intersects_triangle(self, from_:'Vector3'   , to:'Vector3'   , a:'Vector3'   , b:'Vector3'   , c:'Vector3'   ) -> typing.Union[typing.Any]:
    r'''
				Tests if the segment (`from`, `to`) intersects the triangle `a`, `b`, `c`. If yes, returns the point of intersection as `Vector3`. If no intersection takes place, returns `null`.
			'''

    assert(not from_ is None)
    assert isinstance(from_, Vector3), 'from_ must be Vector3'
    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'
    assert(not a is None)
    assert isinstance(a, Vector3), 'a must be Vector3'
    assert(not b is None)
    assert isinstance(b, Vector3), 'b must be Vector3'
    assert(not c is None)
    assert isinstance(c, Vector3), 'c must be Vector3'











    _ret = None
    _ret = self._ptr.call_with_return(58,tuple([from_._ptr, to._ptr, a._ptr, b._ptr, c._ptr]))
    return _ret


  @functools.native_method
  def segment_intersects_sphere(self, from_:'Vector3'   , to:'Vector3'   , sphere_position:'Vector3'   , sphere_radius:'float'   ) -> typing.Union['PackedVector3Array']:
    r'''
				Checks if the segment (`from`, `to`) intersects the sphere that is located at `sphere_position` and has radius `sphere_radius`. If no, returns an empty `PackedVector3Array`. If yes, returns a `PackedVector3Array` containing the point of intersection and the sphere's normal at the point of intersection.
			'''

    assert(not from_ is None)
    assert isinstance(from_, Vector3), 'from_ must be Vector3'
    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'
    assert(not sphere_position is None)
    assert isinstance(sphere_position, Vector3), 'sphere_position must be Vector3'
    assert isinstance(sphere_radius, (int, float)), 'sphere_radius must be int or float'










    _ret = PackedVector3Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(59,tuple([from_._ptr, to._ptr, sphere_position._ptr, sphere_radius]))
    return _ret


  @functools.native_method
  def segment_intersects_cylinder(self, from_:'Vector3'   , to:'Vector3'   , height:'float'   , radius:'float'   ) -> typing.Union['PackedVector3Array']:
    r'''
				Checks if the segment (`from`, `to`) intersects the cylinder with height `height` that is centered at the origin and has radius `radius`. If no, returns an empty `PackedVector3Array`. If an intersection takes place, the returned array contains the point of intersection and the cylinder's normal at the point of intersection.
			'''

    assert(not from_ is None)
    assert isinstance(from_, Vector3), 'from_ must be Vector3'
    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'
    assert isinstance(height, (int, float)), 'height must be int or float'
    assert isinstance(radius, (int, float)), 'radius must be int or float'










    _ret = PackedVector3Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([from_._ptr, to._ptr, height, radius]))
    return _ret


  @functools.native_method
  def segment_intersects_convex(self, from_:'Vector3'   , to:'Vector3'   , planes:'py4godot_planetypedarray.PlaneTypedArray'   ) -> typing.Union['PackedVector3Array']:
    r'''
				Given a convex hull defined though the `Plane`s in the array `planes`, tests if the segment (`from`, `to`) intersects with that hull. If an intersection is found, returns a `PackedVector3Array` containing the point the intersection and the hull's normal. Otherwise, returns an empty array.
			'''

    assert(not from_ is None)
    assert isinstance(from_, Vector3), 'from_ must be Vector3'
    assert(not to is None)
    assert isinstance(to, Vector3), 'to must be Vector3'
    assert isinstance(planes, Array), 'planes must be Array'









    _ret = PackedVector3Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([from_._ptr, to._ptr, planes._ptr]))
    return _ret


  @functools.native_method
  def clip_polygon(self, points:'PackedVector3Array'   , plane:'Plane'   ) -> typing.Union['PackedVector3Array']:
    r'''
				Clips the polygon defined by the points in `points` against the `plane` and returns the points of the clipped polygon.
			'''

    assert(not points is None)
    assert isinstance(points, PackedVector3Array), 'points must be PackedVector3Array'
    assert(not plane is None)
    assert isinstance(plane, Plane), 'plane must be Plane'








    _ret = PackedVector3Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([points._ptr, plane._ptr]))
    return _ret


  @functools.native_method
  def tetrahedralize_delaunay(self, points:'PackedVector3Array'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Tetrahedralizes the volume specified by a discrete set of `points` in 3D space, ensuring that no point lies within the circumsphere of any resulting tetrahedron. The method returns a `PackedInt32Array` where each tetrahedron consists of four consecutive point indices into the `points` array (resulting in an array with `n * 4` elements, where `n` is the number of tetrahedra found). If the tetrahedralization is unsuccessful, an empty `PackedInt32Array` is returned.
			'''

    assert(not points is None)
    assert isinstance(points, PackedVector3Array), 'points must be PackedVector3Array'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(63,tuple([points._ptr]))
    return _ret



register_cast_function('Geometry3D', Geometry3D.cast)
register_class('Geometry3D', Geometry3D)
