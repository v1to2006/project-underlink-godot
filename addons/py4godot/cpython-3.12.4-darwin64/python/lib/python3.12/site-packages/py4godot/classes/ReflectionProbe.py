# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.VisualInstance3D as py4godot_visualinstance3d 
from py4godot.wrappers.wrappers import CPPReflectionProbeWrapper

class UpdateMode:
  UPDATE_ONCE = 0
  UPDATE_ALWAYS = 1
class AmbientMode:
  AMBIENT_DISABLED = 0
  AMBIENT_ENVIRONMENT = 1
  AMBIENT_COLOR = 2


class ReflectionProbe(py4godot_visualinstance3d.VisualInstance3D):
  r'''
		Captures its surroundings as a cubemap, and stores versions of it with increasing levels of blur to simulate different material roughnesses.
		The `ReflectionProbe` is used to create high-quality reflections at a low performance cost (when `update_mode` is `constant UPDATE_ONCE`). `ReflectionProbe`s can be blended together and with the rest of the scene smoothly. `ReflectionProbe`s can also be combined with `VoxelGI`, SDFGI (`Environment.sdfgi_enabled`) and screen-space reflections (`Environment.ssr_enabled`) to get more accurate reflections in specific areas. `ReflectionProbe`s render all objects within their `cull_mask`, so updating them can be quite expensive. It is best to update them once with the important static objects and then leave them as-is.
		**Note:** Unlike `VoxelGI` and SDFGI, `ReflectionProbe`s only source their environment from a `WorldEnvironment` node. If you specify an `Environment` resource within a `Camera3D` node, it will be ignored by the `ReflectionProbe`. This can lead to incorrect lighting within the `ReflectionProbe`.
		**Note:** When using the Mobile rendering method, only `8` reflection probes can be displayed on each mesh resource, while the Compatibility rendering method only supports up to `2` reflection probes on each mesh. Attempting to display more than `8` reflection probes on a single mesh resource using the Mobile renderer will result in reflection probes flickering in and out as the camera moves, while the Compatibility renderer will not render any additional probes if more than `2` reflection probes are being used.
		**Note:** When using the Mobile rendering method, reflection probes will only correctly affect meshes whose visibility AABB intersects with the reflection probe's AABB. If using a shader to deform the mesh in a way that makes it go outside its AABB, `GeometryInstance3D.extra_cull_margin` must be increased on the mesh. Otherwise, the reflection probe may not be visible on the mesh.
	'''

  @staticmethod
  def constructor():
    class_ = ReflectionProbe.construct_without_init()
    class_._ptr = constructor(668,0, ())
    return class_
  @staticmethod
  def new():
    class_ = ReflectionProbe.construct_without_init()
    class_._ptr = constructor(668,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPReflectionProbeWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(668,0, ())


  def generate_wrapper(self):
    return CPPReflectionProbeWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = ReflectionProbe.__new__(ReflectionProbe)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'ReflectionProbe'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = ReflectionProbe.construct_without_init()
    cls._ptr = CPPReflectionProbeWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = ReflectionProbe.construct_without_init()
    cls._ptr = CPPReflectionProbeWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def update_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_update_mode()
    return _ret
  @update_mode.setter
  def update_mode(self,  value:'int'):
    self.set_update_mode(value)
  @property
  def intensity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_intensity()
    return _ret
  @intensity.setter
  def intensity(self,  value:'float'):
    self.set_intensity(value)
  @property
  def blend_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_blend_distance()
    return _ret
  @blend_distance.setter
  def blend_distance(self,  value:'float'):
    self.set_blend_distance(value)
  @property
  def max_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_max_distance()
    return _ret
  @max_distance.setter
  def max_distance(self,  value:'float'):
    self.set_max_distance(value)
  @property
  def size(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_size()
    return _ret
  @size.setter
  def size(self,  value:'Vector3'):
    self.set_size(value)
  @property
  def origin_offset(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_origin_offset()
    return _ret
  @origin_offset.setter
  def origin_offset(self,  value:'Vector3'):
    self.set_origin_offset(value)
  @property
  def box_projection(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_box_projection_enabled()
    return _ret
  @box_projection.setter
  def box_projection(self,  value:'bool'):
    self.set_enable_box_projection(value)
  @property
  def interior(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_set_as_interior()
    return _ret
  @interior.setter
  def interior(self,  value:'bool'):
    self.set_as_interior(value)
  @property
  def enable_shadows(self) -> typing.Union[bool]:
    r''''''
    _ret = self. are_shadows_enabled()
    return _ret
  @enable_shadows.setter
  def enable_shadows(self,  value:'bool'):
    self.set_enable_shadows(value)
  @property
  def cull_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_cull_mask()
    return _ret
  @cull_mask.setter
  def cull_mask(self,  value:'int'):
    self.set_cull_mask(value)
  @property
  def reflection_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_reflection_mask()
    return _ret
  @reflection_mask.setter
  def reflection_mask(self,  value:'int'):
    self.set_reflection_mask(value)
  @property
  def mesh_lod_threshold(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_mesh_lod_threshold()
    return _ret
  @mesh_lod_threshold.setter
  def mesh_lod_threshold(self,  value:'float'):
    self.set_mesh_lod_threshold(value)
  @property
  def ambient_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_ambient_mode()
    return _ret
  @ambient_mode.setter
  def ambient_mode(self,  value:'int'):
    self.set_ambient_mode(value)
  @property
  def ambient_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_ambient_color()
    return _ret
  @ambient_color.setter
  def ambient_color(self,  value:'Color'):
    self.set_ambient_color(value)
  @property
  def ambient_color_energy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_ambient_color_energy()
    return _ret
  @ambient_color_energy.setter
  def ambient_color_energy(self,  value:'float'):
    self.set_ambient_color_energy(value)
  @functools.native_method
  def set_intensity(self, intensity:'float'   ) -> None:
    r''''''

    assert isinstance(intensity, (int, float)), 'intensity must be int or float'


    self.py__intensity = intensity






    self._ptr.call_with_return(264,tuple([intensity]))

  @functools.native_method
  def get_intensity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(265,tuple([]))

    return _ret


  @functools.native_method
  def set_blend_distance(self, blend_distance:'float'   ) -> None:
    r''''''

    assert isinstance(blend_distance, (int, float)), 'blend_distance must be int or float'


    self.py__blend_distance = blend_distance






    self._ptr.call_with_return(266,tuple([blend_distance]))

  @functools.native_method
  def get_blend_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(267,tuple([]))

    return _ret


  @functools.native_method
  def set_ambient_mode(self, ambient:'int'  ) -> None:
    r''''''

    assert isinstance(ambient, (int, float)), 'ambient must be int or float'


    self.py__ambient_mode = ambient






    self._ptr.call_with_return(268,tuple([ambient]))

  @functools.native_method
  def get_ambient_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(269,tuple([]))

    return _ret


  @functools.native_method
  def set_ambient_color(self, ambient:'Color'   ) -> None:
    r''''''

    assert(not ambient is None)
    assert isinstance(ambient, Color), 'ambient must be Color'


    self.py__ambient_color = ambient






    self._ptr.call_with_return(270,tuple([ambient._ptr]))

  @functools.native_method
  def get_ambient_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(271,tuple([]))

    return _ret


  @functools.native_method
  def set_ambient_color_energy(self, ambient_energy:'float'   ) -> None:
    r''''''

    assert isinstance(ambient_energy, (int, float)), 'ambient_energy must be int or float'


    self.py__ambient_color_energy = ambient_energy






    self._ptr.call_with_return(272,tuple([ambient_energy]))

  @functools.native_method
  def get_ambient_color_energy(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(273,tuple([]))

    return _ret


  @functools.native_method
  def set_max_distance(self, max_distance:'float'   ) -> None:
    r''''''

    assert isinstance(max_distance, (int, float)), 'max_distance must be int or float'


    self.py__max_distance = max_distance






    self._ptr.call_with_return(274,tuple([max_distance]))

  @functools.native_method
  def get_max_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(275,tuple([]))

    return _ret


  @functools.native_method
  def set_mesh_lod_threshold(self, ratio:'float'   ) -> None:
    r''''''

    assert isinstance(ratio, (int, float)), 'ratio must be int or float'


    self.py__mesh_lod_threshold = ratio






    self._ptr.call_with_return(276,tuple([ratio]))

  @functools.native_method
  def get_mesh_lod_threshold(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(277,tuple([]))

    return _ret


  @functools.native_method
  def set_size(self, size:'Vector3'   ) -> None:
    r''''''

    assert(not size is None)
    assert isinstance(size, Vector3), 'size must be Vector3'


    self.py__size = size






    self._ptr.call_with_return(278,tuple([size._ptr]))

  @functools.native_method
  def get_size(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(279,tuple([]))

    return _ret


  @functools.native_method
  def set_origin_offset(self, origin_offset:'Vector3'   ) -> None:
    r''''''

    assert(not origin_offset is None)
    assert isinstance(origin_offset, Vector3), 'origin_offset must be Vector3'


    self.py__origin_offset = origin_offset






    self._ptr.call_with_return(280,tuple([origin_offset._ptr]))

  @functools.native_method
  def get_origin_offset(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(281,tuple([]))

    return _ret


  @functools.native_method
  def set_as_interior(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__interior = enable






    self._ptr.call_with_return(282,tuple([enable]))

  @functools.native_method
  def is_set_as_interior(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(283,tuple([]))

    return _ret


  @functools.native_method
  def set_enable_box_projection(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__box_projection = enable






    self._ptr.call_with_return(284,tuple([enable]))

  @functools.native_method
  def is_box_projection_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(285,tuple([]))

    return _ret


  @functools.native_method
  def set_enable_shadows(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__enable_shadows = enable






    self._ptr.call_with_return(286,tuple([enable]))

  @functools.native_method
  def are_shadows_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(287,tuple([]))

    return _ret


  @functools.native_method
  def set_cull_mask(self, layers:'int'   ) -> None:
    r''''''

    assert isinstance(layers, (int, float)), 'layers must be int or float'


    self.py__cull_mask = layers






    self._ptr.call_with_return(288,tuple([layers]))

  @functools.native_method
  def get_cull_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(289,tuple([]))

    return _ret


  @functools.native_method
  def set_reflection_mask(self, layers:'int'   ) -> None:
    r''''''

    assert isinstance(layers, (int, float)), 'layers must be int or float'


    self.py__reflection_mask = layers






    self._ptr.call_with_return(290,tuple([layers]))

  @functools.native_method
  def get_reflection_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(291,tuple([]))

    return _ret


  @functools.native_method
  def set_update_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__update_mode = mode






    self._ptr.call_with_return(292,tuple([mode]))

  @functools.native_method
  def get_update_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(293,tuple([]))

    return _ret



register_cast_function('ReflectionProbe', ReflectionProbe.cast)
register_class('ReflectionProbe', ReflectionProbe)
