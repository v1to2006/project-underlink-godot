# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPThreadWrapper

class Priority:
  PRIORITY_LOW = 0
  PRIORITY_NORMAL = 1
  PRIORITY_HIGH = 2


class Thread(py4godot_refcounted.RefCounted):
  r'''
		A unit of execution in a process. Can run methods on `Object`s simultaneously. The use of synchronization via `Mutex` or `Semaphore` is advised if working with shared objects.
		**Warning:** To ensure proper cleanup without crashes or deadlocks, when a `Thread`'s reference count reaches zero and it is therefore destroyed, the following conditions must be met:
		- It must not have any `Mutex` objects locked.
		- It must not be waiting on any `Semaphore` objects.
		- `wait_to_finish` should have been called on it.
	'''

  @staticmethod
  def constructor():
    class_ = Thread.construct_without_init()
    class_._ptr = constructor(833,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Thread.construct_without_init()
    class_._ptr = constructor(833,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPThreadWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(833,0, ())


  def generate_wrapper(self):
    return CPPThreadWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Thread.__new__(Thread)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Thread'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(58, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Thread.construct_without_init()
    cls._ptr = CPPThreadWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Thread.construct_without_init()
    cls._ptr = CPPThreadWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def start(self, callable:'Callable'   , priority:'int'  =1) -> typing.Union[int]:
    r'''
				Starts a new `Thread` that calls `callable`.
				If the method takes some arguments, you can pass them using `Callable.bind`.
				The `priority` of the `Thread` can be changed by passing a value from the `enum Priority` enum.
				Returns `constant OK` on success, or `constant ERR_CANT_CREATE` on failure.
			'''


    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'
    assert isinstance(priority, (int, float)), 'priority must be int or float'








    _ret:int
    _ret = self._ptr.call_with_return(53,tuple([callable._ptr, priority]))
    return _ret


  @functools.native_method
  def get_id(self) -> typing.Union[str]:
    r'''
				Returns the current `Thread`'s ID, uniquely identifying it among all threads. If the `Thread` has not started running or if `wait_to_finish` has been called, this returns an empty string.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def is_started(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this `Thread` has been started. Once started, this will return `true` until it is joined using `wait_to_finish`. For checking if a `Thread` is still executing its task, use `is_alive`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(55,tuple([]))
    return _ret


  @functools.native_method
  def is_alive(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this `Thread` is currently running the provided function. This is useful for determining if `wait_to_finish` can be called without blocking the calling thread.
				To check if a `Thread` is joinable, use `is_started`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([]))
    return _ret


  @functools.native_method
  def wait_to_finish(self) -> typing.Union[typing.Any]:
    r'''
				Joins the `Thread` and waits for it to finish. Returns the output of the `Callable` passed to `start`.
				Should either be used when you want to retrieve the value returned from the method called by the `Thread` or before freeing the instance that contains the `Thread`.
				To determine if this can be called without blocking the calling thread, check if `is_alive` is `false`.
			'''




    _ret = None
    _ret = self._ptr.call_with_return(57,tuple([]))
    return _ret


  @staticmethod
  def set_thread_safety_checks_enabled(enabled:'bool'   ) -> None:
    r'''
				Sets whether the thread safety checks the engine normally performs in methods of certain classes (e.g., `Node`) should happen **on the current thread**.
				The default, for every thread, is that they are enabled (as if called with `enabled` being `true`).
				Those checks are conservative. That means that they will only succeed in considering a call thread-safe (and therefore allow it to happen) if the engine can guarantee such safety.
				Because of that, there may be cases where the user may want to disable them (`enabled` being `false`) to make certain operations allowed again. By doing so, it becomes the user's responsibility to ensure thread safety (e.g., by using `Mutex`) for those objects that are otherwise protected by the engine.
				**Note:** This is an advanced usage of the engine. You are advised to use it only if you know what you are doing and there is no safer way.
				**Note:** This is useful for scripts running on either arbitrary `Thread` objects or tasks submitted to the `WorkerThreadPool`. It doesn't apply to code running during `Node` group processing, where the checks will be always performed.
				**Note:** Even in the case of having disabled the checks in a `WorkerThreadPool` task, there's no need to re-enable them at the end. The engine will do so.
			'''

    assert isinstance(enabled, bool), 'enabled must be bool'







    static_method(833,0,tuple([enabled]))


register_cast_function('Thread', Thread.cast)
register_class('Thread', Thread)
