# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.OmniLight3D as py4godot_omnilight3d 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.DirectionalLight3D as py4godot_directionallight3d 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.SpotLight3D as py4godot_spotlight3d 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
import py4godot.classes.VisualInstance3D as py4godot_visualinstance3d 
from py4godot.wrappers.wrappers import CPPLight3DWrapper

class Param:
  PARAM_ENERGY = 0
  PARAM_INDIRECT_ENERGY = 1
  PARAM_VOLUMETRIC_FOG_ENERGY = 2
  PARAM_SPECULAR = 3
  PARAM_RANGE = 4
  PARAM_SIZE = 5
  PARAM_ATTENUATION = 6
  PARAM_SPOT_ANGLE = 7
  PARAM_SPOT_ATTENUATION = 8
  PARAM_SHADOW_MAX_DISTANCE = 9
  PARAM_SHADOW_SPLIT_1_OFFSET = 10
  PARAM_SHADOW_SPLIT_2_OFFSET = 11
  PARAM_SHADOW_SPLIT_3_OFFSET = 12
  PARAM_SHADOW_FADE_START = 13
  PARAM_SHADOW_NORMAL_BIAS = 14
  PARAM_SHADOW_BIAS = 15
  PARAM_SHADOW_PANCAKE_SIZE = 16
  PARAM_SHADOW_OPACITY = 17
  PARAM_SHADOW_BLUR = 18
  PARAM_TRANSMITTANCE_BIAS = 19
  PARAM_INTENSITY = 20
  PARAM_MAX = 21
class BakeMode:
  BAKE_DISABLED = 0
  BAKE_STATIC = 1
  BAKE_DYNAMIC = 2


class Light3D(py4godot_visualinstance3d.VisualInstance3D):
  r'''
		Light3D is the _abstract_ base class for light nodes. As it can't be instantiated, it shouldn't be used directly. Other types of light nodes inherit from it. Light3D contains the common variables and parameters used for lighting.
	'''

  @staticmethod
  def constructor():
    class_ = Light3D.construct_without_init()
    class_._ptr = constructor(450,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Light3D.construct_without_init()
    class_._ptr = constructor(450,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPLight3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(450,0, ())


  def generate_wrapper(self):
    return CPPLight3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Light3D.__new__(Light3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Light3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Light3D.construct_without_init()
    cls._ptr = CPPLight3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Light3D.construct_without_init()
    cls._ptr = CPPLight3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def light_intensity_lumens(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param(20)
    return _ret
  @light_intensity_lumens.setter
  def light_intensity_lumens(self,  value:'float'):
    self.set_param(20, value)
  @property
  def light_intensity_lux(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param(20)
    return _ret
  @light_intensity_lux.setter
  def light_intensity_lux(self,  value:'float'):
    self.set_param(20, value)
  @property
  def light_temperature(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_temperature()
    return _ret
  @light_temperature.setter
  def light_temperature(self,  value:'float'):
    self.set_temperature(value)
  @property
  def light_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_color()
    return _ret
  @light_color.setter
  def light_color(self,  value:'Color'):
    self.set_color(value)
  @property
  def light_energy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param(0)
    return _ret
  @light_energy.setter
  def light_energy(self,  value:'float'):
    self.set_param(0, value)
  @property
  def light_indirect_energy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param(1)
    return _ret
  @light_indirect_energy.setter
  def light_indirect_energy(self,  value:'float'):
    self.set_param(1, value)
  @property
  def light_volumetric_fog_energy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param(2)
    return _ret
  @light_volumetric_fog_energy.setter
  def light_volumetric_fog_energy(self,  value:'float'):
    self.set_param(2, value)
  @property
  def light_projector(self) -> typing.Any:
    r''''''
    _ret = self. get_projector()
    return _ret
  @light_projector.setter
  def light_projector(self,  value:'py4godot_object.Object'):
    self.set_projector(value)
  @property
  def light_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param(5)
    return _ret
  @light_size.setter
  def light_size(self,  value:'float'):
    self.set_param(5, value)
  @property
  def light_angular_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param(5)
    return _ret
  @light_angular_distance.setter
  def light_angular_distance(self,  value:'float'):
    self.set_param(5, value)
  @property
  def light_negative(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_negative()
    return _ret
  @light_negative.setter
  def light_negative(self,  value:'bool'):
    self.set_negative(value)
  @property
  def light_specular(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param(3)
    return _ret
  @light_specular.setter
  def light_specular(self,  value:'float'):
    self.set_param(3, value)
  @property
  def light_bake_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_bake_mode()
    return _ret
  @light_bake_mode.setter
  def light_bake_mode(self,  value:'int'):
    self.set_bake_mode(value)
  @property
  def light_cull_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_cull_mask()
    return _ret
  @light_cull_mask.setter
  def light_cull_mask(self,  value:'int'):
    self.set_cull_mask(value)
  @property
  def shadow_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. has_shadow()
    return _ret
  @shadow_enabled.setter
  def shadow_enabled(self,  value:'bool'):
    self.set_shadow(value)
  @property
  def shadow_bias(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param(15)
    return _ret
  @shadow_bias.setter
  def shadow_bias(self,  value:'float'):
    self.set_param(15, value)
  @property
  def shadow_normal_bias(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param(14)
    return _ret
  @shadow_normal_bias.setter
  def shadow_normal_bias(self,  value:'float'):
    self.set_param(14, value)
  @property
  def shadow_reverse_cull_face(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_shadow_reverse_cull_face()
    return _ret
  @shadow_reverse_cull_face.setter
  def shadow_reverse_cull_face(self,  value:'bool'):
    self.set_shadow_reverse_cull_face(value)
  @property
  def shadow_transmittance_bias(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param(19)
    return _ret
  @shadow_transmittance_bias.setter
  def shadow_transmittance_bias(self,  value:'float'):
    self.set_param(19, value)
  @property
  def shadow_opacity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param(17)
    return _ret
  @shadow_opacity.setter
  def shadow_opacity(self,  value:'float'):
    self.set_param(17, value)
  @property
  def shadow_blur(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param(18)
    return _ret
  @shadow_blur.setter
  def shadow_blur(self,  value:'float'):
    self.set_param(18, value)
  @property
  def shadow_caster_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_shadow_caster_mask()
    return _ret
  @shadow_caster_mask.setter
  def shadow_caster_mask(self,  value:'int'):
    self.set_shadow_caster_mask(value)
  @property
  def distance_fade_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_distance_fade_enabled()
    return _ret
  @distance_fade_enabled.setter
  def distance_fade_enabled(self,  value:'bool'):
    self.set_enable_distance_fade(value)
  @property
  def distance_fade_begin(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_distance_fade_begin()
    return _ret
  @distance_fade_begin.setter
  def distance_fade_begin(self,  value:'float'):
    self.set_distance_fade_begin(value)
  @property
  def distance_fade_shadow(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_distance_fade_shadow()
    return _ret
  @distance_fade_shadow.setter
  def distance_fade_shadow(self,  value:'float'):
    self.set_distance_fade_shadow(value)
  @property
  def distance_fade_length(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_distance_fade_length()
    return _ret
  @distance_fade_length.setter
  def distance_fade_length(self,  value:'float'):
    self.set_distance_fade_length(value)
  @property
  def editor_only(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_editor_only()
    return _ret
  @editor_only.setter
  def editor_only(self,  value:'bool'):
    self.set_editor_only(value)
  @functools.native_method
  def set_editor_only(self, editor_only:'bool'   ) -> None:
    r''''''

    assert isinstance(editor_only, bool), 'editor_only must be bool'


    self.py__editor_only = editor_only






    self._ptr.call_with_return(264,tuple([editor_only]))

  @functools.native_method
  def is_editor_only(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(265,tuple([]))

    return _ret


  @functools.native_method
  def set_param(self, param:'int'  , value:'float'   ) -> None:
    r'''
				Sets the value of the specified `enum Light3D.Param` parameter.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'


    self.py__light_intensity_lumens = param







    self._ptr.call_with_return(266,tuple([param, value]))

  @functools.native_method
  def get_param(self, param:'int'  ) -> typing.Union[float]:
    r'''
				Returns the value of the specified `enum Light3D.Param` parameter.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(267,tuple([param]))

    return _ret


  @functools.native_method
  def set_shadow(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__shadow_enabled = enabled






    self._ptr.call_with_return(268,tuple([enabled]))

  @functools.native_method
  def has_shadow(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(269,tuple([]))

    return _ret


  @functools.native_method
  def set_negative(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__light_negative = enabled






    self._ptr.call_with_return(270,tuple([enabled]))

  @functools.native_method
  def is_negative(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(271,tuple([]))

    return _ret


  @functools.native_method
  def set_cull_mask(self, cull_mask:'int'   ) -> None:
    r''''''

    assert isinstance(cull_mask, (int, float)), 'cull_mask must be int or float'


    self.py__light_cull_mask = cull_mask






    self._ptr.call_with_return(272,tuple([cull_mask]))

  @functools.native_method
  def get_cull_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(273,tuple([]))

    return _ret


  @functools.native_method
  def set_enable_distance_fade(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__distance_fade_enabled = enable






    self._ptr.call_with_return(274,tuple([enable]))

  @functools.native_method
  def is_distance_fade_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(275,tuple([]))

    return _ret


  @functools.native_method
  def set_distance_fade_begin(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__distance_fade_begin = distance






    self._ptr.call_with_return(276,tuple([distance]))

  @functools.native_method
  def get_distance_fade_begin(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(277,tuple([]))

    return _ret


  @functools.native_method
  def set_distance_fade_shadow(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__distance_fade_shadow = distance






    self._ptr.call_with_return(278,tuple([distance]))

  @functools.native_method
  def get_distance_fade_shadow(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(279,tuple([]))

    return _ret


  @functools.native_method
  def set_distance_fade_length(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__distance_fade_length = distance






    self._ptr.call_with_return(280,tuple([distance]))

  @functools.native_method
  def get_distance_fade_length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(281,tuple([]))

    return _ret


  @functools.native_method
  def set_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__light_color = color






    self._ptr.call_with_return(282,tuple([color._ptr]))

  @functools.native_method
  def get_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(283,tuple([]))

    return _ret


  @functools.native_method
  def set_shadow_reverse_cull_face(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__shadow_reverse_cull_face = enable






    self._ptr.call_with_return(284,tuple([enable]))

  @functools.native_method
  def get_shadow_reverse_cull_face(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(285,tuple([]))

    return _ret


  @functools.native_method
  def set_shadow_caster_mask(self, caster_mask:'int'   ) -> None:
    r''''''

    assert isinstance(caster_mask, (int, float)), 'caster_mask must be int or float'


    self.py__shadow_caster_mask = caster_mask






    self._ptr.call_with_return(286,tuple([caster_mask]))

  @functools.native_method
  def get_shadow_caster_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(287,tuple([]))

    return _ret


  @functools.native_method
  def set_bake_mode(self, bake_mode:'int'  ) -> None:
    r''''''

    assert isinstance(bake_mode, (int, float)), 'bake_mode must be int or float'


    self.py__light_bake_mode = bake_mode






    self._ptr.call_with_return(288,tuple([bake_mode]))

  @functools.native_method
  def get_bake_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(289,tuple([]))

    return _ret


  @functools.native_method
  def set_projector(self, projector:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not projector is None)
    assert isinstance(projector, get_class('Texture2D')), 'projector must be Texture2D'


    self.py__light_projector = projector






    self._ptr.call_with_return(290,tuple([projector._ptr]))

  @functools.native_method
  def get_projector(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(291,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_temperature(self, temperature:'float'   ) -> None:
    r''''''

    assert isinstance(temperature, (int, float)), 'temperature must be int or float'


    self.py__light_temperature = temperature






    self._ptr.call_with_return(292,tuple([temperature]))

  @functools.native_method
  def get_temperature(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(293,tuple([]))

    return _ret


  @functools.native_method
  def get_correlated_color(self) -> typing.Union['Color']:
    r'''
				Returns the `Color` of an idealized blackbody at the given `light_temperature`. This value is calculated internally based on the `light_temperature`. This `Color` is multiplied by `light_color` before being sent to the `RenderingServer`.
			'''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(294,tuple([]))
    return _ret



register_cast_function('Light3D', Light3D.cast)
register_class('Light3D', Light3D)
