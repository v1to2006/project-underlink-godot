# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.VisualShaderNodeSmoothStep as py4godot_visualshadernodesmoothstep 
  import py4godot.classes.VisualShaderNodeUIntParameter as py4godot_visualshadernodeuintparameter 
  import py4godot.classes.VisualShaderNodeSwitch as py4godot_visualshadernodeswitch 
  import py4godot.classes.VisualShaderNodeParticleSphereEmitter as py4godot_visualshadernodeparticlesphereemitter 
  import py4godot.classes.VisualShaderNodeIntParameter as py4godot_visualshadernodeintparameter 
  import py4godot.classes.VisualShaderNodeParameterRef as py4godot_visualshadernodeparameterref 
  import py4godot.classes.VisualShaderNodeFloatFunc as py4godot_visualshadernodefloatfunc 
  import py4godot.classes.VisualShaderNodeInput as py4godot_visualshadernodeinput 
  import py4godot.classes.VisualShaderNodeParticleOutput as py4godot_visualshadernodeparticleoutput 
  import py4godot.classes.VisualShaderNodeFaceForward as py4godot_visualshadernodefaceforward 
  import py4godot.classes.VisualShaderNodeTexture as py4godot_visualshadernodetexture 
  import py4godot.classes.VisualShaderNodeVec2Constant as py4godot_visualshadernodevec2constant 
  import py4godot.classes.VisualShaderNodeWorldPositionFromDepth as py4godot_visualshadernodeworldpositionfromdepth 
  import py4godot.classes.VisualShaderNodeReroute as py4godot_visualshadernodereroute 
  import py4godot.classes.VisualShaderNodeSDFRaymarch as py4godot_visualshadernodesdfraymarch 
  import py4godot.classes.VisualShaderNodeVarying as py4godot_visualshadernodevarying 
  import py4godot.classes.VisualShaderNodeRandomRange as py4godot_visualshadernoderandomrange 
  import py4godot.classes.VisualShaderNodeVaryingGetter as py4godot_visualshadernodevaryinggetter 
  import py4godot.classes.VisualShaderNodeScreenUVToSDF as py4godot_visualshadernodescreenuvtosdf 
  import py4godot.classes.VisualShaderNodeGlobalExpression as py4godot_visualshadernodeglobalexpression 
  import py4godot.classes.VisualShaderNodeColorConstant as py4godot_visualshadernodecolorconstant 
  import py4godot.classes.VisualShaderNodeProximityFade as py4godot_visualshadernodeproximityfade 
  import py4godot.classes.VisualShaderNodeVectorFunc as py4godot_visualshadernodevectorfunc 
  import py4godot.classes.VisualShaderNodeTexture2DParameter as py4godot_visualshadernodetexture2dparameter 
  import py4godot.classes.VisualShaderNodeIs as py4godot_visualshadernodeis 
  import py4godot.classes.VisualShaderNodeResizableBase as py4godot_visualshadernoderesizablebase 
  import py4godot.classes.VisualShaderNodeUVFunc as py4godot_visualshadernodeuvfunc 
  import py4godot.classes.VisualShaderNodeFrame as py4godot_visualshadernodeframe 
  import py4godot.classes.VisualShaderNodeVectorOp as py4godot_visualshadernodevectorop 
  import py4godot.classes.VisualShaderNodeFloatConstant as py4godot_visualshadernodefloatconstant 
  import py4godot.classes.VisualShaderNodeConstant as py4godot_visualshadernodeconstant 
  import py4godot.classes.VisualShaderNodeParticleEmitter as py4godot_visualshadernodeparticleemitter 
  import py4godot.classes.VisualShaderNodeParticleAccelerator as py4godot_visualshadernodeparticleaccelerator 
  import py4godot.classes.VisualShaderNodeStep as py4godot_visualshadernodestep 
  import py4godot.classes.VisualShaderNodeCompare as py4godot_visualshadernodecompare 
  import py4godot.classes.VisualShaderNodeVec4Constant as py4godot_visualshadernodevec4constant 
  import py4godot.classes.VisualShaderNodeComment as py4godot_visualshadernodecomment 
  import py4godot.classes.VisualShaderNodeVectorDistance as py4godot_visualshadernodevectordistance 
  import py4godot.classes.VisualShaderNodeMix as py4godot_visualshadernodemix 
  import py4godot.classes.VisualShaderNodeFloatOp as py4godot_visualshadernodefloatop 
  import py4godot.classes.VisualShaderNodeVec3Constant as py4godot_visualshadernodevec3constant 
  import py4godot.classes.VisualShaderNodeVectorCompose as py4godot_visualshadernodevectorcompose 
  import py4godot.classes.VisualShaderNodeScreenNormalWorldSpace as py4godot_visualshadernodescreennormalworldspace 
  import py4godot.classes.VisualShaderNodeVaryingSetter as py4godot_visualshadernodevaryingsetter 
  import py4godot.classes.VisualShaderNodeUIntConstant as py4godot_visualshadernodeuintconstant 
  import py4godot.classes.VisualShaderNodeCubemap as py4godot_visualshadernodecubemap 
  import py4godot.classes.VisualShaderNodeTextureSDF as py4godot_visualshadernodetexturesdf 
  import py4godot.classes.VisualShaderNodeColorFunc as py4godot_visualshadernodecolorfunc 
  import py4godot.classes.VisualShaderNodeVectorDecompose as py4godot_visualshadernodevectordecompose 
  import py4godot.classes.VisualShaderNodeParticleEmit as py4godot_visualshadernodeparticleemit 
  import py4godot.classes.VisualShaderNodeParticleConeVelocity as py4godot_visualshadernodeparticleconevelocity 
  import py4godot.classes.VisualShaderNodeDeterminant as py4godot_visualshadernodedeterminant 
  import py4godot.classes.VisualShaderNodeTexture2DArray as py4godot_visualshadernodetexture2darray 
  import py4godot.classes.VisualShaderNodeIntOp as py4godot_visualshadernodeintop 
  import py4godot.classes.VisualShaderNodeUIntFunc as py4godot_visualshadernodeuintfunc 
  import py4godot.classes.VisualShaderNodeVectorBase as py4godot_visualshadernodevectorbase 
  import py4godot.classes.VisualShaderNodeCurveXYZTexture as py4godot_visualshadernodecurvexyztexture 
  import py4godot.classes.VisualShaderNodeDotProduct as py4godot_visualshadernodedotproduct 
  import py4godot.classes.VisualShaderNode as py4godot_visualshadernode 
  import py4godot.classes.VisualShaderNodeRemap as py4godot_visualshadernoderemap 
  import py4godot.classes.VisualShaderNodeExpression as py4godot_visualshadernodeexpression 
  import py4godot.classes.VisualShaderNodeFresnel as py4godot_visualshadernodefresnel 
  import py4godot.classes.VisualShaderNodeTransformParameter as py4godot_visualshadernodetransformparameter 
  import py4godot.classes.VisualShaderNodeIntFunc as py4godot_visualshadernodeintfunc 
  import py4godot.classes.VisualShaderNodeTransformConstant as py4godot_visualshadernodetransformconstant 
  import py4godot.classes.VisualShaderNodeParticleMeshEmitter as py4godot_visualshadernodeparticlemeshemitter 
  import py4godot.classes.VisualShaderNodeCustom as py4godot_visualshadernodecustom 
  import py4godot.classes.VisualShaderNodeParticleRandomness as py4godot_visualshadernodeparticlerandomness 
  import py4godot.classes.VisualShaderNodeTransformDecompose as py4godot_visualshadernodetransformdecompose 
  import py4godot.classes.VisualShaderNodeTextureParameter as py4godot_visualshadernodetextureparameter 
  import py4godot.classes.VisualShaderNodeIntConstant as py4godot_visualshadernodeintconstant 
  import py4godot.classes.VisualShaderNodeTransformOp as py4godot_visualshadernodetransformop 
  import py4godot.classes.VisualShaderNodeBillboard as py4godot_visualshadernodebillboard 
  import py4godot.classes.VisualShaderNodeIf as py4godot_visualshadernodeif 
  import py4godot.classes.VisualShaderNodeTextureParameterTriplanar as py4godot_visualshadernodetextureparametertriplanar 
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
  import py4godot.classes.VisualShaderNodeSDFToScreenUV as py4godot_visualshadernodesdftoscreenuv 
  import py4godot.classes.VisualShaderNodeTexture2DArrayParameter as py4godot_visualshadernodetexture2darrayparameter 
  import py4godot.classes.VisualShaderNodeFloatParameter as py4godot_visualshadernodefloatparameter 
  import py4godot.classes.VisualShaderNodeColorOp as py4godot_visualshadernodecolorop 
  import py4godot.classes.VisualShaderNodeOuterProduct as py4godot_visualshadernodeouterproduct 
  import py4godot.classes.VisualShaderNodeParameter as py4godot_visualshadernodeparameter 
  import py4godot.classes.VisualShaderNodeVec2Parameter as py4godot_visualshadernodevec2parameter 
  import py4godot.classes.VisualShaderNodeGroupBase as py4godot_visualshadernodegroupbase 
  import py4godot.classes.VisualShaderNodeRotationByAxis as py4godot_visualshadernoderotationbyaxis 
  import py4godot.classes.VisualShaderNodeTransformFunc as py4godot_visualshadernodetransformfunc 
  import py4godot.classes.VisualShaderNodeVectorLen as py4godot_visualshadernodevectorlen 
  import py4godot.classes.VisualShaderNodeTransformVecMult as py4godot_visualshadernodetransformvecmult 
  import py4godot.classes.VisualShaderNodeCubemapParameter as py4godot_visualshadernodecubemapparameter 
  import py4godot.classes.VisualShaderNodeDistanceFade as py4godot_visualshadernodedistancefade 
  import py4godot.classes.VisualShaderNodeMultiplyAdd as py4godot_visualshadernodemultiplyadd 
  import py4godot.classes.VisualShaderNodeCurveTexture as py4godot_visualshadernodecurvetexture 
  import py4godot.classes.VisualShaderNodeSample3D as py4godot_visualshadernodesample3d 
  import py4godot.classes.VisualShaderNodeLinearSceneDepth as py4godot_visualshadernodelinearscenedepth 
  import py4godot.classes.VisualShaderNodeOutput as py4godot_visualshadernodeoutput 
  import py4godot.classes.VisualShaderNodeTexture3DParameter as py4godot_visualshadernodetexture3dparameter 
  import py4godot.classes.VisualShaderNodeColorParameter as py4godot_visualshadernodecolorparameter 
  import py4godot.classes.VisualShaderNodeVectorRefract as py4godot_visualshadernodevectorrefract 
  import py4godot.classes.VisualShaderNodeUVPolarCoord as py4godot_visualshadernodeuvpolarcoord 
  import py4godot.classes.VisualShaderNodeParticleBoxEmitter as py4godot_visualshadernodeparticleboxemitter 
  import py4godot.classes.VisualShaderNodeParticleRingEmitter as py4godot_visualshadernodeparticleringemitter 
  import py4godot.classes.VisualShaderNodeClamp as py4godot_visualshadernodeclamp 
  import py4godot.classes.VisualShaderNodeBooleanParameter as py4godot_visualshadernodebooleanparameter 
  import py4godot.classes.VisualShaderNodeBooleanConstant as py4godot_visualshadernodebooleanconstant 
  import py4godot.classes.VisualShaderNodeTextureSDFNormal as py4godot_visualshadernodetexturesdfnormal 
  import py4godot.classes.VisualShaderNodeDerivativeFunc as py4godot_visualshadernodederivativefunc 
  import py4godot.classes.VisualShaderNodeParticleMultiplyByAxisAngle as py4godot_visualshadernodeparticlemultiplybyaxisangle 
  import py4godot.classes.VisualShaderNodeTransformCompose as py4godot_visualshadernodetransformcompose 
  import py4godot.classes.VisualShaderNodeVec3Parameter as py4godot_visualshadernodevec3parameter 
  import py4godot.classes.VisualShaderNodeUIntOp as py4godot_visualshadernodeuintop 
  import py4godot.classes.VisualShaderNodeTexture3D as py4godot_visualshadernodetexture3d 
  import py4godot.classes.VisualShaderNodeVec4Parameter as py4godot_visualshadernodevec4parameter 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.Shader as py4godot_shader 
from py4godot.wrappers.wrappers import CPPVisualShaderWrapper

class Type:
  TYPE_VERTEX = 0
  TYPE_FRAGMENT = 1
  TYPE_LIGHT = 2
  TYPE_START = 3
  TYPE_PROCESS = 4
  TYPE_COLLIDE = 5
  TYPE_START_CUSTOM = 6
  TYPE_PROCESS_CUSTOM = 7
  TYPE_SKY = 8
  TYPE_FOG = 9
  TYPE_MAX = 10
class VaryingMode:
  VARYING_MODE_VERTEX_TO_FRAG_LIGHT = 0
  VARYING_MODE_FRAG_TO_LIGHT = 1
  VARYING_MODE_MAX = 2
class VaryingType:
  VARYING_TYPE_FLOAT = 0
  VARYING_TYPE_INT = 1
  VARYING_TYPE_UINT = 2
  VARYING_TYPE_VECTOR_2D = 3
  VARYING_TYPE_VECTOR_3D = 4
  VARYING_TYPE_VECTOR_4D = 5
  VARYING_TYPE_BOOLEAN = 6
  VARYING_TYPE_TRANSFORM = 7
  VARYING_TYPE_MAX = 8


class VisualShader(py4godot_shader.Shader):
  r'''
		This class provides a graph-like visual editor for creating a `Shader`. Although `VisualShader`s do not require coding, they share the same logic with script shaders. They use `VisualShaderNode`s that can be connected to each other to control the flow of the shader. The visual shader graph is converted to a script shader behind the scenes.
	'''
  NODE_ID_INVALID:typing.ClassVar[int]

  NODE_ID_OUTPUT:typing.ClassVar[int]

  @staticmethod
  def constructor():
    class_ = VisualShader.construct_without_init()
    class_._ptr = constructor(879,0, ())
    return class_
  @staticmethod
  def new():
    class_ = VisualShader.construct_without_init()
    class_._ptr = constructor(879,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPVisualShaderWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(879,0, ())


  def generate_wrapper(self):
    return CPPVisualShaderWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = VisualShader.__new__(VisualShader)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'VisualShader'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(106, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = VisualShader.construct_without_init()
    cls._ptr = CPPVisualShaderWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = VisualShader.construct_without_init()
    cls._ptr = CPPVisualShaderWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def graph_offset(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_graph_offset()
    return _ret
  @graph_offset.setter
  def graph_offset(self,  value:'Vector2'):
    self.set_graph_offset(value)
  @functools.native_method
  def set_mode(self, mode:'int'  ) -> None:
    r'''
				Sets the mode of this shader.
			'''

    assert isinstance(mode, (int, float)), 'mode must be int or float'







    self._ptr.call_with_return(84,tuple([mode]))

  @functools.native_method
  def add_node(self, type:'int'  , node:'py4godot_visualshadernode.VisualShaderNode'   , position:'Vector2'   , id:'int'   ) -> None:
    r'''
				Adds the specified `node` to the shader.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert(not node is None)
    assert isinstance(node, get_class('VisualShaderNode')), 'node must be VisualShaderNode'
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'
    assert isinstance(id, (int, float)), 'id must be int or float'










    self._ptr.call_with_return(85,tuple([type, node._ptr, position._ptr, id]))

  @functools.native_method
  def get_node(self, type:'int'  , id:'int'   ) -> typing.Any:
    r'''
				Returns the shader node instance with specified `type` and `id`.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(id, (int, float)), 'id must be int or float'








    _ret = classes.Object.Object.construct_without_init() #Smart casted to: VisualShaderNode
    _ret._ptr = self._ptr.call_with_return(86,tuple([type, id]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_node_position(self, type:'int'  , id:'int'   , position:'Vector2'   ) -> None:
    r'''
				Sets the position of the specified node.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'









    self._ptr.call_with_return(87,tuple([type, id, position._ptr]))

  @functools.native_method
  def get_node_position(self, type:'int'  , id:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the position of the specified node within the shader graph.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(id, (int, float)), 'id must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([type, id]))
    return _ret


  @functools.native_method
  def get_node_list(self, type:'int'  ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns the list of all nodes in the shader with the specified type.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(89,tuple([type]))
    return _ret


  @functools.native_method
  def get_valid_node_id(self, type:'int'  ) -> typing.Union[int]:
    r'''
				Returns next valid node ID that can be added to the shader graph.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([type]))
    return _ret


  @functools.native_method
  def remove_node(self, type:'int'  , id:'int'   ) -> None:
    r'''
				Removes the specified node from the shader.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(id, (int, float)), 'id must be int or float'








    self._ptr.call_with_return(91,tuple([type, id]))

  @functools.native_method
  def replace_node(self, type:'int'  , id:'int'   , new_class:'object'   ) -> None:
    r'''
				Replaces the specified node with a node of new class type.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(id, (int, float)), 'id must be int or float'
    assert(not new_class is None)
    assert isinstance(new_class, (str, StringName)), 'new_class must be str or StringName'







    assert(isinstance(new_class, (str, StringName)))
    py_stringname_new_class = new_class if isinstance(new_class, StringName) else c_utils.py_string_to_string_name(new_class)

    self._ptr.call_with_return(92,tuple([type, id, py_stringname_new_class._ptr]))

  @functools.native_method
  def is_node_connection(self, type:'int'  , from_node:'int'   , from_port:'int'   , to_node:'int'   , to_port:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified node and port connection exist.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(from_node, (int, float)), 'from_node must be int or float'
    assert isinstance(from_port, (int, float)), 'from_port must be int or float'
    assert isinstance(to_node, (int, float)), 'to_node must be int or float'
    assert isinstance(to_port, (int, float)), 'to_port must be int or float'











    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([type, from_node, from_port, to_node, to_port]))
    return _ret


  @functools.native_method
  def can_connect_nodes(self, type:'int'  , from_node:'int'   , from_port:'int'   , to_node:'int'   , to_port:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified nodes and ports can be connected together.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(from_node, (int, float)), 'from_node must be int or float'
    assert isinstance(from_port, (int, float)), 'from_port must be int or float'
    assert isinstance(to_node, (int, float)), 'to_node must be int or float'
    assert isinstance(to_port, (int, float)), 'to_port must be int or float'











    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([type, from_node, from_port, to_node, to_port]))
    return _ret


  @functools.native_method
  def connect_nodes(self, type:'int'  , from_node:'int'   , from_port:'int'   , to_node:'int'   , to_port:'int'   ) -> typing.Union[int]:
    r'''
				Connects the specified nodes and ports.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(from_node, (int, float)), 'from_node must be int or float'
    assert isinstance(from_port, (int, float)), 'from_port must be int or float'
    assert isinstance(to_node, (int, float)), 'to_node must be int or float'
    assert isinstance(to_port, (int, float)), 'to_port must be int or float'











    _ret:int
    _ret = self._ptr.call_with_return(95,tuple([type, from_node, from_port, to_node, to_port]))
    return _ret


  @functools.native_method
  def disconnect_nodes(self, type:'int'  , from_node:'int'   , from_port:'int'   , to_node:'int'   , to_port:'int'   ) -> None:
    r'''
				Connects the specified nodes and ports.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(from_node, (int, float)), 'from_node must be int or float'
    assert isinstance(from_port, (int, float)), 'from_port must be int or float'
    assert isinstance(to_node, (int, float)), 'to_node must be int or float'
    assert isinstance(to_port, (int, float)), 'to_port must be int or float'











    self._ptr.call_with_return(96,tuple([type, from_node, from_port, to_node, to_port]))

  @functools.native_method
  def connect_nodes_forced(self, type:'int'  , from_node:'int'   , from_port:'int'   , to_node:'int'   , to_port:'int'   ) -> None:
    r'''
				Connects the specified nodes and ports, even if they can't be connected. Such connection is invalid and will not function properly.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(from_node, (int, float)), 'from_node must be int or float'
    assert isinstance(from_port, (int, float)), 'from_port must be int or float'
    assert isinstance(to_node, (int, float)), 'to_node must be int or float'
    assert isinstance(to_port, (int, float)), 'to_port must be int or float'











    self._ptr.call_with_return(97,tuple([type, from_node, from_port, to_node, to_port]))

  @functools.native_method
  def get_node_connections(self, type:'int'  ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns the list of connected nodes with the specified type.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'







    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(98,tuple([type]))
    return _ret


  @functools.native_method
  def attach_node_to_frame(self, type:'int'  , id:'int'   , frame:'int'   ) -> None:
    r'''
				Attaches the given node to the given frame.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(id, (int, float)), 'id must be int or float'
    assert isinstance(frame, (int, float)), 'frame must be int or float'









    self._ptr.call_with_return(99,tuple([type, id, frame]))

  @functools.native_method
  def detach_node_from_frame(self, type:'int'  , id:'int'   ) -> None:
    r'''
				Detaches the given node from the frame it is attached to.
			'''

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert isinstance(id, (int, float)), 'id must be int or float'








    self._ptr.call_with_return(100,tuple([type, id]))

  @functools.native_method
  def add_varying(self, name:'str'   , mode:'int'  , type:'int'  ) -> None:
    r'''
				Adds a new varying value node to the shader.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert isinstance(mode, (int, float)), 'mode must be int or float'
    assert isinstance(type, (int, float)), 'type must be int or float'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)



    self._ptr.call_with_return(101,tuple([py_string_name._ptr, mode, type]))

  @functools.native_method
  def remove_varying(self, name:'str'   ) -> None:
    r'''
				Removes a varying value node with the given `name`. Prints an error if a node with this name is not found.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(102,tuple([py_string_name._ptr]))

  @functools.native_method
  def has_varying(self, name:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the shader has a varying with the given `name`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def set_graph_offset(self, offset:'Vector2'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'


    self.py__graph_offset = offset






    self._ptr.call_with_return(104,tuple([offset._ptr]))

  @functools.native_method
  def get_graph_offset(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(105,tuple([]))

    return _ret



register_cast_function('VisualShader', VisualShader.cast)
register_class('VisualShader', VisualShader)
