# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.TileData as py4godot_tiledata 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
import py4godot.classes.TileSetSource as py4godot_tilesetsource 
from py4godot.wrappers.wrappers import CPPTileSetAtlasSourceWrapper

class TileAnimationMode:
  TILE_ANIMATION_MODE_DEFAULT = 0
  TILE_ANIMATION_MODE_RANDOM_START_TIMES = 1
  TILE_ANIMATION_MODE_MAX = 2


class TileSetAtlasSource(py4godot_tilesetsource.TileSetSource):
  r'''
		An atlas is a grid of tiles laid out on a texture. Each tile in the grid must be exposed using `create_tile`. Those tiles are then indexed using their coordinates in the grid.
		Each tile can also have a size in the grid coordinates, making it more or less cells in the atlas.
		Alternatives version of a tile can be created using `create_alternative_tile`, which are then indexed using an alternative ID. The main tile (the one in the grid), is accessed with an alternative ID equal to 0.
		Each tile alternate has a set of properties that is defined by the source's `TileSet` layers. Those properties are stored in a TileData object that can be accessed and modified using `get_tile_data`.
		As TileData properties are stored directly in the TileSetAtlasSource resource, their properties might also be set using `TileSetAtlasSource.set("<coords_x>:<coords_y>/<alternative_id>/<tile_data_property>")`.
	'''
  TRANSFORM_FLIP_H:typing.ClassVar[int]

  TRANSFORM_FLIP_V:typing.ClassVar[int]

  TRANSFORM_TRANSPOSE:typing.ClassVar[int]

  @staticmethod
  def constructor():
    class_ = TileSetAtlasSource.construct_without_init()
    class_._ptr = constructor(839,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TileSetAtlasSource.construct_without_init()
    class_._ptr = constructor(839,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTileSetAtlasSourceWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(839,0, ())


  def generate_wrapper(self):
    return CPPTileSetAtlasSourceWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = TileSetAtlasSource.__new__(TileSetAtlasSource)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TileSetAtlasSource'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(124, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TileSetAtlasSource.construct_without_init()
    cls._ptr = CPPTileSetAtlasSourceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TileSetAtlasSource.construct_without_init()
    cls._ptr = CPPTileSetAtlasSourceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def texture(self) -> typing.Any:
    r''''''
    _ret = self. get_texture()
    return _ret
  @texture.setter
  def texture(self,  value:'py4godot_object.Object'):
    self.set_texture(value)
  @property
  def margins(self) -> typing.Union['Vector2i']:
    r''''''
    _ret = self. get_margins()
    return _ret
  @margins.setter
  def margins(self,  value:'Vector2i'):
    self.set_margins(value)
  @property
  def separation(self) -> typing.Union['Vector2i']:
    r''''''
    _ret = self. get_separation()
    return _ret
  @separation.setter
  def separation(self,  value:'Vector2i'):
    self.set_separation(value)
  @property
  def texture_region_size(self) -> typing.Union['Vector2i']:
    r''''''
    _ret = self. get_texture_region_size()
    return _ret
  @texture_region_size.setter
  def texture_region_size(self,  value:'Vector2i'):
    self.set_texture_region_size(value)
  @property
  def use_texture_padding(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_use_texture_padding()
    return _ret
  @use_texture_padding.setter
  def use_texture_padding(self,  value:'bool'):
    self.set_use_texture_padding(value)
  @functools.native_method
  def set_texture(self, texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'


    self.py__texture = texture






    self._ptr.call_with_return(83,tuple([texture._ptr]))

  @functools.native_method
  def get_texture(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(84,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_margins(self, margins:'Vector2i'   ) -> None:
    r''''''

    assert(not margins is None)
    assert isinstance(margins, Vector2i), 'margins must be Vector2i'


    self.py__margins = margins






    self._ptr.call_with_return(85,tuple([margins._ptr]))

  @functools.native_method
  def get_margins(self) -> typing.Union['Vector2i']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([]))

    return _ret


  @functools.native_method
  def set_separation(self, separation:'Vector2i'   ) -> None:
    r''''''

    assert(not separation is None)
    assert isinstance(separation, Vector2i), 'separation must be Vector2i'


    self.py__separation = separation






    self._ptr.call_with_return(87,tuple([separation._ptr]))

  @functools.native_method
  def get_separation(self) -> typing.Union['Vector2i']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([]))

    return _ret


  @functools.native_method
  def set_texture_region_size(self, texture_region_size:'Vector2i'   ) -> None:
    r''''''

    assert(not texture_region_size is None)
    assert isinstance(texture_region_size, Vector2i), 'texture_region_size must be Vector2i'


    self.py__texture_region_size = texture_region_size






    self._ptr.call_with_return(89,tuple([texture_region_size._ptr]))

  @functools.native_method
  def get_texture_region_size(self) -> typing.Union['Vector2i']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(90,tuple([]))

    return _ret


  @functools.native_method
  def set_use_texture_padding(self, use_texture_padding:'bool'   ) -> None:
    r''''''

    assert isinstance(use_texture_padding, bool), 'use_texture_padding must be bool'


    self.py__use_texture_padding = use_texture_padding






    self._ptr.call_with_return(91,tuple([use_texture_padding]))

  @functools.native_method
  def get_use_texture_padding(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([]))

    return _ret


  @functools.native_method
  def create_tile(self, atlas_coords:'Vector2i'   , size:'Vector2i' = None  ) -> None:
    r'''
				Creates a new tile at coordinates `atlas_coords` with the given `size`.
			'''
    if size is None:
      size = Vector2i.new0()

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'








    self._ptr.call_with_return(93,tuple([atlas_coords._ptr, size._ptr]))

  @functools.native_method
  def remove_tile(self, atlas_coords:'Vector2i'   ) -> None:
    r'''
				Remove a tile and its alternative at coordinates `atlas_coords`.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'







    self._ptr.call_with_return(94,tuple([atlas_coords._ptr]))

  @functools.native_method
  def move_tile_in_atlas(self, atlas_coords:'Vector2i'   , new_atlas_coords:'Vector2i' = None  , new_size:'Vector2i' = None  ) -> None:
    r'''
				Move the tile and its alternatives at the `atlas_coords` coordinates to the `new_atlas_coords` coordinates with the `new_size` size. This functions will fail if a tile is already present in the given area.
				If `new_atlas_coords` is `Vector2i(-1, -1)`, keeps the tile's coordinates. If `new_size` is `Vector2i(-1, -1)`, keeps the tile's size.
				To avoid an error, first check if a move is possible using `has_room_for_tile`.
			'''
    if new_atlas_coords is None:
      new_atlas_coords = Vector2i.new0()
    if new_size is None:
      new_size = Vector2i.new0()

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'









    self._ptr.call_with_return(95,tuple([atlas_coords._ptr, new_atlas_coords._ptr, new_size._ptr]))

  @functools.native_method
  def get_tile_size_in_atlas(self, atlas_coords:'Vector2i'   ) -> typing.Union['Vector2i']:
    r'''
				Returns the size of the tile (in the grid coordinates system) at coordinates `atlas_coords`.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([atlas_coords._ptr]))
    return _ret


  @functools.native_method
  def has_room_for_tile(self, atlas_coords:'Vector2i'   , size:'Vector2i'   , animation_columns:'int'   , animation_separation:'Vector2i'   , frames_count:'int'   , ignored_tile:'Vector2i' = None  ) -> typing.Union[bool]:
    r'''
				Returns whether there is enough room in an atlas to create/modify a tile with the given properties. If `ignored_tile` is provided, act as is the given tile was not present in the atlas. This may be used when you want to modify a tile's properties.
			'''
    if ignored_tile is None:
      ignored_tile = Vector2i.new0()

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(animation_columns, (int, float)), 'animation_columns must be int or float'
    assert(not animation_separation is None)
    assert isinstance(animation_separation, Vector2i), 'animation_separation must be Vector2i'
    assert isinstance(frames_count, (int, float)), 'frames_count must be int or float'












    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([atlas_coords._ptr, size._ptr, animation_columns, animation_separation._ptr, frames_count, ignored_tile._ptr]))
    return _ret


  @functools.native_method
  def get_tiles_to_be_removed_on_change(self, texture:'py4godot_texture2d.Texture2D'   , margins:'Vector2i'   , separation:'Vector2i'   , texture_region_size:'Vector2i'   ) -> typing.Union['PackedVector2Array']:
    r'''
				Returns an array of tiles coordinates ID that will be automatically removed when modifying one or several of those properties: `texture`, `margins`, `separation` or `texture_region_size`. This can be used to undo changes that would have caused tiles data loss.
			'''

    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'
    assert(not margins is None)
    assert isinstance(margins, Vector2i), 'margins must be Vector2i'
    assert(not separation is None)
    assert isinstance(separation, Vector2i), 'separation must be Vector2i'
    assert(not texture_region_size is None)
    assert isinstance(texture_region_size, Vector2i), 'texture_region_size must be Vector2i'










    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(98,tuple([texture._ptr, margins._ptr, separation._ptr, texture_region_size._ptr]))
    return _ret


  @functools.native_method
  def get_tile_at_coords(self, atlas_coords:'Vector2i'   ) -> typing.Union['Vector2i']:
    r'''
				If there is a tile covering the `atlas_coords` coordinates, returns the top-left coordinates of the tile (thus its coordinate ID). Returns `Vector2i(-1, -1)` otherwise.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(99,tuple([atlas_coords._ptr]))
    return _ret


  @functools.native_method
  def has_tiles_outside_texture(self) -> typing.Union[bool]:
    r'''
				Checks if the source has any tiles that don't fit the texture area (either partially or completely).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([]))
    return _ret


  @functools.native_method
  def clear_tiles_outside_texture(self) -> None:
    r'''
				Removes all tiles that don't fit the available texture area. This method iterates over all the source's tiles, so it's advised to use `has_tiles_outside_texture` beforehand.
			'''




    self._ptr.call_with_return(101,tuple([]))

  @functools.native_method
  def set_tile_animation_columns(self, atlas_coords:'Vector2i'   , frame_columns:'int'   ) -> None:
    r'''
				Sets the number of columns in the animation layout of the tile at coordinates `atlas_coords`. If set to 0, then the different frames of the animation are laid out as a single horizontal line in the atlas.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'
    assert isinstance(frame_columns, (int, float)), 'frame_columns must be int or float'








    self._ptr.call_with_return(102,tuple([atlas_coords._ptr, frame_columns]))

  @functools.native_method
  def get_tile_animation_columns(self, atlas_coords:'Vector2i'   ) -> typing.Union[int]:
    r'''
				Returns how many columns the tile at `atlas_coords` has in its animation layout.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([atlas_coords._ptr]))
    return _ret


  @functools.native_method
  def set_tile_animation_separation(self, atlas_coords:'Vector2i'   , separation:'Vector2i'   ) -> None:
    r'''
				Sets the margin (in grid tiles) between each tile in the animation layout of the tile at coordinates `atlas_coords` has.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'
    assert(not separation is None)
    assert isinstance(separation, Vector2i), 'separation must be Vector2i'








    self._ptr.call_with_return(104,tuple([atlas_coords._ptr, separation._ptr]))

  @functools.native_method
  def get_tile_animation_separation(self, atlas_coords:'Vector2i'   ) -> typing.Union['Vector2i']:
    r'''
				Returns the separation (as in the atlas grid) between each frame of an animated tile at coordinates `atlas_coords`.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(105,tuple([atlas_coords._ptr]))
    return _ret


  @functools.native_method
  def set_tile_animation_speed(self, atlas_coords:'Vector2i'   , speed:'float'   ) -> None:
    r'''
				Sets the animation speed of the tile at coordinates `atlas_coords` has.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'
    assert isinstance(speed, (int, float)), 'speed must be int or float'








    self._ptr.call_with_return(106,tuple([atlas_coords._ptr, speed]))

  @functools.native_method
  def get_tile_animation_speed(self, atlas_coords:'Vector2i'   ) -> typing.Union[float]:
    r'''
				Returns the animation speed of the tile at coordinates `atlas_coords`.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(107,tuple([atlas_coords._ptr]))
    return _ret


  @functools.native_method
  def set_tile_animation_mode(self, atlas_coords:'Vector2i'   , mode:'int'  ) -> None:
    r'''
				Sets the tile animation mode of the tile at `atlas_coords` to `mode`. See also `get_tile_animation_mode`.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'
    assert isinstance(mode, (int, float)), 'mode must be int or float'








    self._ptr.call_with_return(108,tuple([atlas_coords._ptr, mode]))

  @functools.native_method
  def get_tile_animation_mode(self, atlas_coords:'Vector2i'   ) -> typing.Union[int]:
    r'''
				Returns the tile animation mode of the tile at `atlas_coords`. See also `set_tile_animation_mode`.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'







    _ret:int
    _ret = self._ptr.call_with_return(109,tuple([atlas_coords._ptr]))
    return _ret


  @functools.native_method
  def set_tile_animation_frames_count(self, atlas_coords:'Vector2i'   , frames_count:'int'   ) -> None:
    r'''
				Sets how many animation frames the tile at coordinates `atlas_coords` has.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'
    assert isinstance(frames_count, (int, float)), 'frames_count must be int or float'








    self._ptr.call_with_return(110,tuple([atlas_coords._ptr, frames_count]))

  @functools.native_method
  def get_tile_animation_frames_count(self, atlas_coords:'Vector2i'   ) -> typing.Union[int]:
    r'''
				Returns how many animation frames has the tile at coordinates `atlas_coords`.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(111,tuple([atlas_coords._ptr]))
    return _ret


  @functools.native_method
  def set_tile_animation_frame_duration(self, atlas_coords:'Vector2i'   , frame_index:'int'   , duration:'float'   ) -> None:
    r'''
				Sets the animation frame `duration` of frame `frame_index` for the tile at coordinates `atlas_coords`.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'
    assert isinstance(frame_index, (int, float)), 'frame_index must be int or float'
    assert isinstance(duration, (int, float)), 'duration must be int or float'









    self._ptr.call_with_return(112,tuple([atlas_coords._ptr, frame_index, duration]))

  @functools.native_method
  def get_tile_animation_frame_duration(self, atlas_coords:'Vector2i'   , frame_index:'int'   ) -> typing.Union[float]:
    r'''
				Returns the animation frame duration of frame `frame_index` for the tile at coordinates `atlas_coords`.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'
    assert isinstance(frame_index, (int, float)), 'frame_index must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(113,tuple([atlas_coords._ptr, frame_index]))
    return _ret


  @functools.native_method
  def get_tile_animation_total_duration(self, atlas_coords:'Vector2i'   ) -> typing.Union[float]:
    r'''
				Returns the sum of the sum of the frame durations of the tile at coordinates `atlas_coords`. This value needs to be divided by the animation speed to get the actual animation loop duration.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(114,tuple([atlas_coords._ptr]))
    return _ret


  @functools.native_method
  def create_alternative_tile(self, atlas_coords:'Vector2i'   , alternative_id_override:'int' =-1  ) -> typing.Union[int]:
    r'''
				Creates an alternative tile for the tile at coordinates `atlas_coords`. If `alternative_id_override` is -1, give it an automatically generated unique ID, or assigns it the given ID otherwise.
				Returns the new alternative identifier, or -1 if the alternative could not be created with a provided `alternative_id_override`.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'
    assert isinstance(alternative_id_override, (int, float)), 'alternative_id_override must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(115,tuple([atlas_coords._ptr, alternative_id_override]))
    return _ret


  @functools.native_method
  def remove_alternative_tile(self, atlas_coords:'Vector2i'   , alternative_tile:'int'   ) -> None:
    r'''
				Remove a tile's alternative with alternative ID `alternative_tile`.
				Calling this function with `alternative_tile` equals to 0 will fail, as the base tile alternative cannot be removed.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'
    assert isinstance(alternative_tile, (int, float)), 'alternative_tile must be int or float'








    self._ptr.call_with_return(116,tuple([atlas_coords._ptr, alternative_tile]))

  @functools.native_method
  def set_alternative_tile_id(self, atlas_coords:'Vector2i'   , alternative_tile:'int'   , new_id:'int'   ) -> None:
    r'''
				Change a tile's alternative ID from `alternative_tile` to `new_id`.
				Calling this function with `new_id` of 0 will fail, as the base tile alternative cannot be moved.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'
    assert isinstance(alternative_tile, (int, float)), 'alternative_tile must be int or float'
    assert isinstance(new_id, (int, float)), 'new_id must be int or float'









    self._ptr.call_with_return(117,tuple([atlas_coords._ptr, alternative_tile, new_id]))

  @functools.native_method
  def get_next_alternative_tile_id(self, atlas_coords:'Vector2i'   ) -> typing.Union[int]:
    r'''
				Returns the alternative ID a following call to `create_alternative_tile` would return.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(118,tuple([atlas_coords._ptr]))
    return _ret


  @functools.native_method
  def get_tile_data(self, atlas_coords:'Vector2i'   , alternative_tile:'int'   ) -> typing.Union['py4godot_tiledata.TileData']:
    r'''
				Returns the `TileData` object for the given atlas coordinates and alternative ID.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'
    assert isinstance(alternative_tile, (int, float)), 'alternative_tile must be int or float'








    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TileData
    _ret._ptr = self._ptr.call_with_return(119,tuple([atlas_coords._ptr, alternative_tile]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_atlas_grid_size(self) -> typing.Union['Vector2i']:
    r'''
				Returns the atlas grid size, which depends on how many tiles can fit in the texture. It thus depends on the `texture`'s size, the atlas `margins`, and the tiles' `texture_region_size`.
			'''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(120,tuple([]))
    return _ret


  @functools.native_method
  def get_tile_texture_region(self, atlas_coords:'Vector2i'   , frame:'int' =0  ) -> typing.Union['Rect2i']:
    r'''
				Returns a tile's texture region in the atlas texture. For animated tiles, a `frame` argument might be provided for the different frames of the animation.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'
    assert isinstance(frame, (int, float)), 'frame must be int or float'








    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(121,tuple([atlas_coords._ptr, frame]))
    return _ret


  @functools.native_method
  def get_runtime_texture(self) -> typing.Any:
    r'''
				If `use_texture_padding` is `false`, returns `texture`. Otherwise, returns an internal `ImageTexture` created that includes the padding.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(122,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_runtime_tile_texture_region(self, atlas_coords:'Vector2i'   , frame:'int'   ) -> typing.Union['Rect2i']:
    r'''
				Returns the region of the tile at coordinates `atlas_coords` for the given `frame` inside the texture returned by `get_runtime_texture`.
				**Note:** If `use_texture_padding` is `false`, returns the same as `get_tile_texture_region`.
			'''

    assert(not atlas_coords is None)
    assert isinstance(atlas_coords, Vector2i), 'atlas_coords must be Vector2i'
    assert isinstance(frame, (int, float)), 'frame must be int or float'








    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(123,tuple([atlas_coords._ptr, frame]))
    return _ret



register_cast_function('TileSetAtlasSource', TileSetAtlasSource.cast)
register_class('TileSetAtlasSource', TileSetAtlasSource)
