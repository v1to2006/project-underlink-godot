# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Curve as py4godot_curve 
import py4godot.classes.PrimitiveMesh as py4godot_primitivemesh 
from py4godot.wrappers.wrappers import CPPTubeTrailMeshWrapper


class TubeTrailMesh(py4godot_primitivemesh.PrimitiveMesh):
  r'''
		`TubeTrailMesh` represents a straight tube-shaped mesh with variable width. The tube is composed of a number of cylindrical sections, each with the same `section_length` and number of `section_rings`. A `curve` is sampled along the total length of the tube, meaning that the curve determines the radius of the tube along its length.
		This primitive mesh is usually used for particle trails.
	'''

  @staticmethod
  def constructor():
    class_ = TubeTrailMesh.construct_without_init()
    class_._ptr = constructor(852,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TubeTrailMesh.construct_without_init()
    class_._ptr = constructor(852,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTubeTrailMeshWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(852,0, ())


  def generate_wrapper(self):
    return CPPTubeTrailMeshWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = TubeTrailMesh.__new__(TubeTrailMesh)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TubeTrailMesh'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(134, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TubeTrailMesh.construct_without_init()
    cls._ptr = CPPTubeTrailMeshWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TubeTrailMesh.construct_without_init()
    cls._ptr = CPPTubeTrailMeshWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def radius(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_radius()
    return _ret
  @radius.setter
  def radius(self,  value:'float'):
    self.set_radius(value)
  @property
  def radial_steps(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_radial_steps()
    return _ret
  @radial_steps.setter
  def radial_steps(self,  value:'int'):
    self.set_radial_steps(value)
  @property
  def sections(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_sections()
    return _ret
  @sections.setter
  def sections(self,  value:'int'):
    self.set_sections(value)
  @property
  def section_length(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_section_length()
    return _ret
  @section_length.setter
  def section_length(self,  value:'float'):
    self.set_section_length(value)
  @property
  def section_rings(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_section_rings()
    return _ret
  @section_rings.setter
  def section_rings(self,  value:'int'):
    self.set_section_rings(value)
  @property
  def cap_top(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_cap_top()
    return _ret
  @cap_top.setter
  def cap_top(self,  value:'bool'):
    self.set_cap_top(value)
  @property
  def cap_bottom(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_cap_bottom()
    return _ret
  @cap_bottom.setter
  def cap_bottom(self,  value:'bool'):
    self.set_cap_bottom(value)
  @property
  def curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_curve()
    return _ret
  @curve.setter
  def curve(self,  value:'py4godot_object.Object'):
    self.set_curve(value)
  @functools.native_method
  def set_radius(self, radius:'float'   ) -> None:
    r''''''

    assert isinstance(radius, (int, float)), 'radius must be int or float'


    self.py__radius = radius






    self._ptr.call_with_return(118,tuple([radius]))

  @functools.native_method
  def get_radius(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(119,tuple([]))

    return _ret


  @functools.native_method
  def set_radial_steps(self, radial_steps:'int'   ) -> None:
    r''''''

    assert isinstance(radial_steps, (int, float)), 'radial_steps must be int or float'


    self.py__radial_steps = radial_steps






    self._ptr.call_with_return(120,tuple([radial_steps]))

  @functools.native_method
  def get_radial_steps(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(121,tuple([]))

    return _ret


  @functools.native_method
  def set_sections(self, sections:'int'   ) -> None:
    r''''''

    assert isinstance(sections, (int, float)), 'sections must be int or float'


    self.py__sections = sections






    self._ptr.call_with_return(122,tuple([sections]))

  @functools.native_method
  def get_sections(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(123,tuple([]))

    return _ret


  @functools.native_method
  def set_section_length(self, section_length:'float'   ) -> None:
    r''''''

    assert isinstance(section_length, (int, float)), 'section_length must be int or float'


    self.py__section_length = section_length






    self._ptr.call_with_return(124,tuple([section_length]))

  @functools.native_method
  def get_section_length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(125,tuple([]))

    return _ret


  @functools.native_method
  def set_section_rings(self, section_rings:'int'   ) -> None:
    r''''''

    assert isinstance(section_rings, (int, float)), 'section_rings must be int or float'


    self.py__section_rings = section_rings






    self._ptr.call_with_return(126,tuple([section_rings]))

  @functools.native_method
  def get_section_rings(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(127,tuple([]))

    return _ret


  @functools.native_method
  def set_cap_top(self, cap_top:'bool'   ) -> None:
    r''''''

    assert isinstance(cap_top, bool), 'cap_top must be bool'


    self.py__cap_top = cap_top






    self._ptr.call_with_return(128,tuple([cap_top]))

  @functools.native_method
  def is_cap_top(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(129,tuple([]))

    return _ret


  @functools.native_method
  def set_cap_bottom(self, cap_bottom:'bool'   ) -> None:
    r''''''

    assert isinstance(cap_bottom, bool), 'cap_bottom must be bool'


    self.py__cap_bottom = cap_bottom






    self._ptr.call_with_return(130,tuple([cap_bottom]))

  @functools.native_method
  def is_cap_bottom(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(131,tuple([]))

    return _ret


  @functools.native_method
  def set_curve(self, curve:'py4godot_curve.Curve'   ) -> None:
    r''''''

    assert(not curve is None)
    assert isinstance(curve, get_class('Curve')), 'curve must be Curve'


    self.py__curve = curve






    self._ptr.call_with_return(132,tuple([curve._ptr]))

  @functools.native_method
  def get_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Curve
    _ret._ptr = self._ptr.call_with_return(133,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('TubeTrailMesh', TubeTrailMesh.cast)
register_class('TubeTrailMesh', TubeTrailMesh)
