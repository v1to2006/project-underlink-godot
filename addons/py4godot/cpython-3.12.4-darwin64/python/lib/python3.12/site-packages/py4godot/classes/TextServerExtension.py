# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.TextServerAdvanced as py4godot_textserveradvanced 
  import py4godot.classes.RIDTypedArray as py4godot_ridtypedarray 
  import py4godot.classes.Image as py4godot_image 
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
  import py4godot.classes.TextServerDummy as py4godot_textserverdummy 
  import py4godot.classes.Vector2iTypedArray as py4godot_vector2itypedarray 
  import py4godot.classes.Vector3iTypedArray as py4godot_vector3itypedarray 
import py4godot.classes.RIDTypedArray as py4godot_ridtypedarray 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.TextServer as py4godot_textserver 
import py4godot.classes.Vector2iTypedArray as py4godot_vector2itypedarray 
import py4godot.classes.Vector3iTypedArray as py4godot_vector3itypedarray 
from py4godot.wrappers.wrappers import CPPTextServerExtensionWrapper


class TextServerExtension(py4godot_textserver.TextServer):
  r'''
		External `TextServer` implementations should inherit from this class.
	'''

  @staticmethod
  def constructor():
    class_ = TextServerExtension.construct_without_init()
    class_._ptr = constructor(815,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TextServerExtension.construct_without_init()
    class_._ptr = constructor(815,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTextServerExtensionWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(815,0, ())


  def generate_wrapper(self):
    return CPPTextServerExtensionWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = TextServerExtension.__new__(TextServerExtension)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TextServerExtension'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(519, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TextServerExtension.construct_without_init()
    cls._ptr = CPPTextServerExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TextServerExtension.construct_without_init()
    cls._ptr = CPPTextServerExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _has_feature(self, feature:'int'  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the server supports a feature.
			'''

    assert isinstance(feature, (int, float)), 'feature must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(286,tuple([feature]))
    return _ret


  @functools.native_method
  def _get_name(self) -> typing.Union[str]:
    r'''
				Returns the name of the server interface.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(287,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _get_features(self) -> typing.Union[int]:
    r'''
				Returns text server features, see `enum TextServer.Feature`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(288,tuple([]))
    return _ret


  @functools.native_method
  def _free_rid(self, rid:'RID'   ) -> None:
    r'''
				Frees an object created by this `TextServer`.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    self._ptr.call_with_return(289,tuple([rid._ptr]))

  @functools.native_method
  def _has(self, rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if `rid` is valid resource owned by this text server.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(290,tuple([rid._ptr]))
    return _ret


  @functools.native_method
  def _load_support_data(self, filename:'str'   ) -> typing.Union[bool]:
    r'''
				Loads optional TextServer database (e.g. ICU break iterators and dictionaries).
			'''

    assert(not filename is None)
    assert isinstance(filename, (str, String)), 'filename must be str or String'





    assert(isinstance(filename, (str, String)))
    py_string_filename = filename if isinstance(filename, StringName) else c_utils.py_string_to_string(filename)

    _ret = 0
    _ret = self._ptr.call_with_return(291,tuple([py_string_filename._ptr]))
    return _ret


  @functools.native_method
  def _get_support_data_filename(self) -> typing.Union[str]:
    r'''
				Returns default TextServer database (e.g. ICU break iterators and dictionaries) filename.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(292,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _get_support_data_info(self) -> typing.Union[str]:
    r'''
				Returns TextServer database (e.g. ICU break iterators and dictionaries) description.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(293,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _save_support_data(self, filename:'str'   ) -> typing.Union[bool]:
    r'''
				Saves optional TextServer database (e.g. ICU break iterators and dictionaries) to the file.
			'''

    assert(not filename is None)
    assert isinstance(filename, (str, String)), 'filename must be str or String'





    assert(isinstance(filename, (str, String)))
    py_string_filename = filename if isinstance(filename, StringName) else c_utils.py_string_to_string(filename)

    _ret = 0
    _ret = self._ptr.call_with_return(294,tuple([py_string_filename._ptr]))
    return _ret


  @functools.native_method
  def _get_support_data(self) -> typing.Union['PackedByteArray']:
    r'''
				Returns default TextServer database (e.g. ICU break iterators and dictionaries).
			'''




    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(295,tuple([]))
    return _ret


  @functools.native_method
  def _is_locale_right_to_left(self, locale:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if locale is right-to-left.
			'''

    assert(not locale is None)
    assert isinstance(locale, (str, String)), 'locale must be str or String'





    assert(isinstance(locale, (str, String)))
    py_string_locale = locale if isinstance(locale, StringName) else c_utils.py_string_to_string(locale)

    _ret = 0
    _ret = self._ptr.call_with_return(296,tuple([py_string_locale._ptr]))
    return _ret


  @functools.native_method
  def _name_to_tag(self, name:'str'   ) -> typing.Union[int]:
    r'''
				Converts the given readable name of a feature, variation, script, or language to an OpenType tag.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(297,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def _tag_to_name(self, tag:'int'   ) -> typing.Union[str]:
    r'''
				Converts the given OpenType tag to the readable name of a feature, variation, script, or language.
			'''

    assert isinstance(tag, (int, float)), 'tag must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(298,tuple([tag]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _create_font(self) -> typing.Union['RID']:
    r'''
				Creates a new, empty font cache entry resource.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(299,tuple([]))
    return _ret


  @functools.native_method
  def _create_font_linked_variation(self, font_rid:'RID'   ) -> typing.Union['RID']:
    r'''
				Optional, implement if font supports extra spacing or baseline offset.
				Creates a new variation existing font which is reusing the same glyph cache and font data.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(300,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_data(self, font_rid:'RID'   , data:'PackedByteArray'   ) -> None:
    r'''
				Sets font source data, e.g contents of the dynamic font source file.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not data is None)
    assert isinstance(data, PackedByteArray), 'data must be PackedByteArray'








    self._ptr.call_with_return(301,tuple([font_rid._ptr, data._ptr]))

  @functools.native_method
  def _font_set_face_index(self, font_rid:'RID'   , face_index:'int'   ) -> None:
    r'''
				Sets an active face index in the TrueType / OpenType collection.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(face_index, (int, float)), 'face_index must be int or float'








    self._ptr.call_with_return(302,tuple([font_rid._ptr, face_index]))

  @functools.native_method
  def _font_get_face_index(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns an active face index in the TrueType / OpenType collection.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(303,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_get_face_count(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns number of faces in the TrueType / OpenType collection.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(304,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_style(self, font_rid:'RID'   , style:'int'   ) -> None:
    r'''
				Sets the font style flags.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(style, (int, float)), 'style must be int or float'








    self._ptr.call_with_return(305,tuple([font_rid._ptr, style]))

  @functools.native_method
  def _font_get_style(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns font style flags.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret
    _ret = self._ptr.call_with_return(306,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_name(self, font_rid:'RID'   , name:'str'   ) -> None:
    r'''
				Sets the font family name.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(307,tuple([font_rid._ptr, py_string_name._ptr]))

  @functools.native_method
  def _font_get_name(self, font_rid:'RID'   ) -> typing.Union[str]:
    r'''
				Returns font family name.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(308,tuple([font_rid._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _font_get_ot_name_strings(self, font_rid:'RID'   ) -> typing.Union['Dictionary']:
    r'''
				Returns `Dictionary` with OpenType font name strings (localized font names, version, description, license information, sample text, etc.).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(309,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_style_name(self, font_rid:'RID'   , name_style:'str'   ) -> None:
    r'''
				Sets the font style name.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not name_style is None)
    assert isinstance(name_style, (str, String)), 'name_style must be str or String'






    assert(isinstance(name_style, (str, String)))
    py_string_name_style = name_style if isinstance(name_style, StringName) else c_utils.py_string_to_string(name_style)

    self._ptr.call_with_return(310,tuple([font_rid._ptr, py_string_name_style._ptr]))

  @functools.native_method
  def _font_get_style_name(self, font_rid:'RID'   ) -> typing.Union[str]:
    r'''
				Returns font style name.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(311,tuple([font_rid._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _font_set_weight(self, font_rid:'RID'   , weight:'int'   ) -> None:
    r'''
				Sets weight (boldness) of the font. A value in the `100...999` range, normal font weight is `400`, bold font weight is `700`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(weight, (int, float)), 'weight must be int or float'








    self._ptr.call_with_return(312,tuple([font_rid._ptr, weight]))

  @functools.native_method
  def _font_get_weight(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns weight (boldness) of the font. A value in the `100...999` range, normal font weight is `400`, bold font weight is `700`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(313,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_stretch(self, font_rid:'RID'   , stretch:'int'   ) -> None:
    r'''
				Sets font stretch amount, compared to a normal width. A percentage value between `50%` and `200%`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(stretch, (int, float)), 'stretch must be int or float'








    self._ptr.call_with_return(314,tuple([font_rid._ptr, stretch]))

  @functools.native_method
  def _font_get_stretch(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns font stretch amount, compared to a normal width. A percentage value between `50%` and `200%`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(315,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_antialiasing(self, font_rid:'RID'   , antialiasing:'int'  ) -> None:
    r'''
				Sets font anti-aliasing mode.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(antialiasing, (int, float)), 'antialiasing must be int or float'








    self._ptr.call_with_return(316,tuple([font_rid._ptr, antialiasing]))

  @functools.native_method
  def _font_get_antialiasing(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns font anti-aliasing mode.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(317,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_disable_embedded_bitmaps(self, font_rid:'RID'   , disable_embedded_bitmaps:'bool'   ) -> None:
    r'''
				If set to `true`, embedded font bitmap loading is disabled.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(disable_embedded_bitmaps, bool), 'disable_embedded_bitmaps must be bool'








    self._ptr.call_with_return(318,tuple([font_rid._ptr, disable_embedded_bitmaps]))

  @functools.native_method
  def _font_get_disable_embedded_bitmaps(self, font_rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns whether the font's embedded bitmap loading is disabled.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(319,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_generate_mipmaps(self, font_rid:'RID'   , generate_mipmaps:'bool'   ) -> None:
    r'''
				If set to `true` font texture mipmap generation is enabled.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(generate_mipmaps, bool), 'generate_mipmaps must be bool'








    self._ptr.call_with_return(320,tuple([font_rid._ptr, generate_mipmaps]))

  @functools.native_method
  def _font_get_generate_mipmaps(self, font_rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if font texture mipmap generation is enabled.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(321,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_multichannel_signed_distance_field(self, font_rid:'RID'   , msdf:'bool'   ) -> None:
    r'''
				If set to `true`, glyphs of all sizes are rendered using single multichannel signed distance field generated from the dynamic font vector data. MSDF rendering allows displaying the font at any scaling factor without blurriness, and without incurring a CPU cost when the font size changes (since the font no longer needs to be rasterized on the CPU). As a downside, font hinting is not available with MSDF. The lack of font hinting may result in less crisp and less readable fonts at small sizes.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(msdf, bool), 'msdf must be bool'








    self._ptr.call_with_return(322,tuple([font_rid._ptr, msdf]))

  @functools.native_method
  def _font_is_multichannel_signed_distance_field(self, font_rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if glyphs of all sizes are rendered using single multichannel signed distance field generated from the dynamic font vector data.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(323,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_msdf_pixel_range(self, font_rid:'RID'   , msdf_pixel_range:'int'   ) -> None:
    r'''
				Sets the width of the range around the shape between the minimum and maximum representable signed distance.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(msdf_pixel_range, (int, float)), 'msdf_pixel_range must be int or float'








    self._ptr.call_with_return(324,tuple([font_rid._ptr, msdf_pixel_range]))

  @functools.native_method
  def _font_get_msdf_pixel_range(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the width of the range around the shape between the minimum and maximum representable signed distance.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(325,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_msdf_size(self, font_rid:'RID'   , msdf_size:'int'   ) -> None:
    r'''
				Sets source font size used to generate MSDF textures.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(msdf_size, (int, float)), 'msdf_size must be int or float'








    self._ptr.call_with_return(326,tuple([font_rid._ptr, msdf_size]))

  @functools.native_method
  def _font_get_msdf_size(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns source font size used to generate MSDF textures.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(327,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_fixed_size(self, font_rid:'RID'   , fixed_size:'int'   ) -> None:
    r'''
				Sets bitmap font fixed size. If set to value greater than zero, same cache entry will be used for all font sizes.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(fixed_size, (int, float)), 'fixed_size must be int or float'








    self._ptr.call_with_return(328,tuple([font_rid._ptr, fixed_size]))

  @functools.native_method
  def _font_get_fixed_size(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns bitmap font fixed size.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(329,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_fixed_size_scale_mode(self, font_rid:'RID'   , fixed_size_scale_mode:'int'  ) -> None:
    r'''
				Sets bitmap font scaling mode. This property is used only if `fixed_size` is greater than zero.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(fixed_size_scale_mode, (int, float)), 'fixed_size_scale_mode must be int or float'








    self._ptr.call_with_return(330,tuple([font_rid._ptr, fixed_size_scale_mode]))

  @functools.native_method
  def _font_get_fixed_size_scale_mode(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns bitmap font scaling mode.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(331,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_allow_system_fallback(self, font_rid:'RID'   , allow_system_fallback:'bool'   ) -> None:
    r'''
				If set to `true`, system fonts can be automatically used as fallbacks.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(allow_system_fallback, bool), 'allow_system_fallback must be bool'








    self._ptr.call_with_return(332,tuple([font_rid._ptr, allow_system_fallback]))

  @functools.native_method
  def _font_is_allow_system_fallback(self, font_rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if system fonts can be automatically used as fallbacks.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(333,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_clear_system_fallback_cache(self) -> None:
    r'''
				Frees all automatically loaded system fonts.
			'''




    self._ptr.call_with_return(334,tuple([]))

  @functools.native_method
  def _font_set_force_autohinter(self, font_rid:'RID'   , force_autohinter:'bool'   ) -> None:
    r'''
				If set to `true` auto-hinting is preferred over font built-in hinting.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(force_autohinter, bool), 'force_autohinter must be bool'








    self._ptr.call_with_return(335,tuple([font_rid._ptr, force_autohinter]))

  @functools.native_method
  def _font_is_force_autohinter(self, font_rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if auto-hinting is supported and preferred over font built-in hinting.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(336,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_modulate_color_glyphs(self, font_rid:'RID'   , modulate:'bool'   ) -> None:
    r'''
				If set to `true`, color modulation is applied when drawing colored glyphs, otherwise it's applied to the monochrome glyphs only.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(modulate, bool), 'modulate must be bool'








    self._ptr.call_with_return(337,tuple([font_rid._ptr, modulate]))

  @functools.native_method
  def _font_is_modulate_color_glyphs(self, font_rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if color modulation is applied when drawing the font's colored glyphs.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(338,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_hinting(self, font_rid:'RID'   , hinting:'int'  ) -> None:
    r'''
				Sets font hinting mode. Used by dynamic fonts only.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(hinting, (int, float)), 'hinting must be int or float'








    self._ptr.call_with_return(339,tuple([font_rid._ptr, hinting]))

  @functools.native_method
  def _font_get_hinting(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the font hinting mode. Used by dynamic fonts only.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(340,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_subpixel_positioning(self, font_rid:'RID'   , subpixel_positioning:'int'  ) -> None:
    r'''
				Sets font subpixel glyph positioning mode.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(subpixel_positioning, (int, float)), 'subpixel_positioning must be int or float'








    self._ptr.call_with_return(341,tuple([font_rid._ptr, subpixel_positioning]))

  @functools.native_method
  def _font_get_subpixel_positioning(self, font_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns font subpixel glyph positioning mode.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(342,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_keep_rounding_remainders(self, font_rid:'RID'   , keep_rounding_remainders:'bool'   ) -> None:
    r'''
				Sets glyph position rounding behavior. If set to `true`, when aligning glyphs to the pixel boundaries rounding remainders are accumulated to ensure more uniform glyph distribution. This setting has no effect if subpixel positioning is enabled.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(keep_rounding_remainders, bool), 'keep_rounding_remainders must be bool'








    self._ptr.call_with_return(343,tuple([font_rid._ptr, keep_rounding_remainders]))

  @functools.native_method
  def _font_get_keep_rounding_remainders(self, font_rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns glyph position rounding behavior. If set to `true`, when aligning glyphs to the pixel boundaries rounding remainders are accumulated to ensure more uniform glyph distribution. This setting has no effect if subpixel positioning is enabled.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(344,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_embolden(self, font_rid:'RID'   , strength:'float'   ) -> None:
    r'''
				Sets font embolden strength. If `strength` is not equal to zero, emboldens the font outlines. Negative values reduce the outline thickness.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(strength, (int, float)), 'strength must be int or float'








    self._ptr.call_with_return(345,tuple([font_rid._ptr, strength]))

  @functools.native_method
  def _font_get_embolden(self, font_rid:'RID'   ) -> typing.Union[float]:
    r'''
				Returns font embolden strength.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(346,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_spacing(self, font_rid:'RID'   , spacing:'int'  , value:'int'   ) -> None:
    r'''
				Sets the spacing for `spacing` to `value` in pixels (not relative to the font size).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(spacing, (int, float)), 'spacing must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'









    self._ptr.call_with_return(347,tuple([font_rid._ptr, spacing, value]))

  @functools.native_method
  def _font_get_spacing(self, font_rid:'RID'   , spacing:'int'  ) -> typing.Union[int]:
    r'''
				Returns the spacing for `spacing` in pixels (not relative to the font size).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(spacing, (int, float)), 'spacing must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(348,tuple([font_rid._ptr, spacing]))
    return _ret


  @functools.native_method
  def _font_set_baseline_offset(self, font_rid:'RID'   , baseline_offset:'float'   ) -> None:
    r'''
				Sets extra baseline offset (as a fraction of font height).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(baseline_offset, (int, float)), 'baseline_offset must be int or float'








    self._ptr.call_with_return(349,tuple([font_rid._ptr, baseline_offset]))

  @functools.native_method
  def _font_get_baseline_offset(self, font_rid:'RID'   ) -> typing.Union[float]:
    r'''
				Returns extra baseline offset (as a fraction of font height).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(350,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_transform(self, font_rid:'RID'   , transform:'Transform2D'   ) -> None:
    r'''
				Sets 2D transform, applied to the font outlines, can be used for slanting, flipping, and rotating glyphs.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not transform is None)
    assert isinstance(transform, Transform2D), 'transform must be Transform2D'








    self._ptr.call_with_return(351,tuple([font_rid._ptr, transform._ptr]))

  @functools.native_method
  def _font_get_transform(self, font_rid:'RID'   ) -> typing.Union['Transform2D']:
    r'''
				Returns 2D transform applied to the font outlines.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(352,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_variation_coordinates(self, font_rid:'RID'   , variation_coordinates:'Dictionary'   ) -> None:
    r'''
				Sets variation coordinates for the specified font cache entry.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not variation_coordinates is None)
    assert isinstance(variation_coordinates, Dictionary), 'variation_coordinates must be Dictionary'








    self._ptr.call_with_return(353,tuple([font_rid._ptr, variation_coordinates._ptr]))

  @functools.native_method
  def _font_get_variation_coordinates(self, font_rid:'RID'   ) -> typing.Union['Dictionary']:
    r'''
				Returns variation coordinates for the specified font cache entry.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(354,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_oversampling(self, font_rid:'RID'   , oversampling:'float'   ) -> None:
    r'''
				If set to a positive value, overrides the oversampling factor of the viewport this font is used in. See `Viewport.oversampling`. This value doesn't override the `code skip-lint`oversampling` parameter of `code skip-lint`draw_*` methods. Used by dynamic fonts only.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'








    self._ptr.call_with_return(355,tuple([font_rid._ptr, oversampling]))

  @functools.native_method
  def _font_get_oversampling(self, font_rid:'RID'   ) -> typing.Union[float]:
    r'''
				Returns oversampling factor override. If set to a positive value, overrides the oversampling factor of the viewport this font is used in. See `Viewport.oversampling`. This value doesn't override the `code skip-lint`oversampling` parameter of `code skip-lint`draw_*` methods. Used by dynamic fonts only.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(356,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_get_size_cache_list(self, font_rid:'RID'   ) -> typing.Union['py4godot_vector2itypedarray.Vector2iTypedArray']:
    r'''
				Returns list of the font sizes in the cache. Each size is `Vector2i` with font size and outline size.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = py4godot_vector2itypedarray.Vector2iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(357,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_clear_size_cache(self, font_rid:'RID'   ) -> None:
    r'''
				Removes all font sizes from the cache entry.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    self._ptr.call_with_return(358,tuple([font_rid._ptr]))

  @functools.native_method
  def _font_remove_size_cache(self, font_rid:'RID'   , size:'Vector2i'   ) -> None:
    r'''
				Removes specified font size from the cache entry.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'








    self._ptr.call_with_return(359,tuple([font_rid._ptr, size._ptr]))

  @functools.native_method
  def _font_get_size_cache_info(self, font_rid:'RID'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns font cache information, each entry contains the following fields: `Vector2i size_px` - font size in pixels, `float viewport_oversampling` - viewport oversampling factor, `int glyphs` - number of rendered glyphs, `int textures` - number of used textures, `int textures_size` - size of texture data in bytes.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(360,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_ascent(self, font_rid:'RID'   , size:'int'   , ascent:'float'   ) -> None:
    r'''
				Sets the font ascent (number of pixels above the baseline).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(ascent, (int, float)), 'ascent must be int or float'









    self._ptr.call_with_return(361,tuple([font_rid._ptr, size, ascent]))

  @functools.native_method
  def _font_get_ascent(self, font_rid:'RID'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns the font ascent (number of pixels above the baseline).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(362,tuple([font_rid._ptr, size]))
    return _ret


  @functools.native_method
  def _font_set_descent(self, font_rid:'RID'   , size:'int'   , descent:'float'   ) -> None:
    r'''
				Sets the font descent (number of pixels below the baseline).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(descent, (int, float)), 'descent must be int or float'









    self._ptr.call_with_return(363,tuple([font_rid._ptr, size, descent]))

  @functools.native_method
  def _font_get_descent(self, font_rid:'RID'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns the font descent (number of pixels below the baseline).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(364,tuple([font_rid._ptr, size]))
    return _ret


  @functools.native_method
  def _font_set_underline_position(self, font_rid:'RID'   , size:'int'   , underline_position:'float'   ) -> None:
    r'''
				Sets pixel offset of the underline below the baseline.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(underline_position, (int, float)), 'underline_position must be int or float'









    self._ptr.call_with_return(365,tuple([font_rid._ptr, size, underline_position]))

  @functools.native_method
  def _font_get_underline_position(self, font_rid:'RID'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns pixel offset of the underline below the baseline.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(366,tuple([font_rid._ptr, size]))
    return _ret


  @functools.native_method
  def _font_set_underline_thickness(self, font_rid:'RID'   , size:'int'   , underline_thickness:'float'   ) -> None:
    r'''
				Sets thickness of the underline in pixels.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(underline_thickness, (int, float)), 'underline_thickness must be int or float'









    self._ptr.call_with_return(367,tuple([font_rid._ptr, size, underline_thickness]))

  @functools.native_method
  def _font_get_underline_thickness(self, font_rid:'RID'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns thickness of the underline in pixels.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(368,tuple([font_rid._ptr, size]))
    return _ret


  @functools.native_method
  def _font_set_scale(self, font_rid:'RID'   , size:'int'   , scale:'float'   ) -> None:
    r'''
				Sets scaling factor of the color bitmap font.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(scale, (int, float)), 'scale must be int or float'









    self._ptr.call_with_return(369,tuple([font_rid._ptr, size, scale]))

  @functools.native_method
  def _font_get_scale(self, font_rid:'RID'   , size:'int'   ) -> typing.Union[float]:
    r'''
				Returns scaling factor of the color bitmap font.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(370,tuple([font_rid._ptr, size]))
    return _ret


  @functools.native_method
  def _font_get_texture_count(self, font_rid:'RID'   , size:'Vector2i'   ) -> typing.Union[int]:
    r'''
				Returns number of textures used by font cache entry.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'








    _ret = 0
    _ret = self._ptr.call_with_return(371,tuple([font_rid._ptr, size._ptr]))
    return _ret


  @functools.native_method
  def _font_clear_textures(self, font_rid:'RID'   , size:'Vector2i'   ) -> None:
    r'''
				Removes all textures from font cache entry.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'








    self._ptr.call_with_return(372,tuple([font_rid._ptr, size._ptr]))

  @functools.native_method
  def _font_remove_texture(self, font_rid:'RID'   , size:'Vector2i'   , texture_index:'int'   ) -> None:
    r'''
				Removes specified texture from the cache entry.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'









    self._ptr.call_with_return(373,tuple([font_rid._ptr, size._ptr, texture_index]))

  @functools.native_method
  def _font_set_texture_image(self, font_rid:'RID'   , size:'Vector2i'   , texture_index:'int'   , image:'py4godot_image.Image'   ) -> None:
    r'''
				Sets font cache texture image data.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'
    assert(not image is None)
    assert isinstance(image, get_class('Image')), 'image must be Image'










    self._ptr.call_with_return(374,tuple([font_rid._ptr, size._ptr, texture_index, image._ptr]))

  @functools.native_method
  def _font_get_texture_image(self, font_rid:'RID'   , size:'Vector2i'   , texture_index:'int'   ) -> typing.Union['py4godot_image.Image']:
    r'''
				Returns font cache texture image data.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'









    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Image
    _ret._ptr = self._ptr.call_with_return(375,tuple([font_rid._ptr, size._ptr, texture_index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def _font_set_texture_offsets(self, font_rid:'RID'   , size:'Vector2i'   , texture_index:'int'   , offset:'PackedInt32Array'   ) -> None:
    r'''
				Sets array containing glyph packing data.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'
    assert(not offset is None)
    assert isinstance(offset, PackedInt32Array), 'offset must be PackedInt32Array'










    self._ptr.call_with_return(376,tuple([font_rid._ptr, size._ptr, texture_index, offset._ptr]))

  @functools.native_method
  def _font_get_texture_offsets(self, font_rid:'RID'   , size:'Vector2i'   , texture_index:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns array containing glyph packing data.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(texture_index, (int, float)), 'texture_index must be int or float'









    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(377,tuple([font_rid._ptr, size._ptr, texture_index]))
    return _ret


  @functools.native_method
  def _font_get_glyph_list(self, font_rid:'RID'   , size:'Vector2i'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns list of rendered glyphs in the cache entry.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'








    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(378,tuple([font_rid._ptr, size._ptr]))
    return _ret


  @functools.native_method
  def _font_clear_glyphs(self, font_rid:'RID'   , size:'Vector2i'   ) -> None:
    r'''
				Removes all rendered glyph information from the cache entry.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'








    self._ptr.call_with_return(379,tuple([font_rid._ptr, size._ptr]))

  @functools.native_method
  def _font_remove_glyph(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   ) -> None:
    r'''
				Removes specified rendered glyph information from the cache entry.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    self._ptr.call_with_return(380,tuple([font_rid._ptr, size._ptr, glyph]))

  @functools.native_method
  def _font_get_glyph_advance(self, font_rid:'RID'   , size:'int'   , glyph:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns glyph advance (offset of the next glyph).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(381,tuple([font_rid._ptr, size, glyph]))
    return _ret


  @functools.native_method
  def _font_set_glyph_advance(self, font_rid:'RID'   , size:'int'   , glyph:'int'   , advance:'Vector2'   ) -> None:
    r'''
				Sets glyph advance (offset of the next glyph).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert(not advance is None)
    assert isinstance(advance, Vector2), 'advance must be Vector2'










    self._ptr.call_with_return(382,tuple([font_rid._ptr, size, glyph, advance._ptr]))

  @functools.native_method
  def _font_get_glyph_offset(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns glyph offset from the baseline.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(383,tuple([font_rid._ptr, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def _font_set_glyph_offset(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   , offset:'Vector2'   ) -> None:
    r'''
				Sets glyph offset from the baseline.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'










    self._ptr.call_with_return(384,tuple([font_rid._ptr, size._ptr, glyph, offset._ptr]))

  @functools.native_method
  def _font_get_glyph_size(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns size of the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(385,tuple([font_rid._ptr, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def _font_set_glyph_size(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   , gl_size:'Vector2'   ) -> None:
    r'''
				Sets size of the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert(not gl_size is None)
    assert isinstance(gl_size, Vector2), 'gl_size must be Vector2'










    self._ptr.call_with_return(386,tuple([font_rid._ptr, size._ptr, glyph, gl_size._ptr]))

  @functools.native_method
  def _font_get_glyph_uv_rect(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union['Rect2']:
    r'''
				Returns rectangle in the cache texture containing the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(387,tuple([font_rid._ptr, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def _font_set_glyph_uv_rect(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   , uv_rect:'Rect2'   ) -> None:
    r'''
				Sets rectangle in the cache texture containing the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert(not uv_rect is None)
    assert isinstance(uv_rect, Rect2), 'uv_rect must be Rect2'










    self._ptr.call_with_return(388,tuple([font_rid._ptr, size._ptr, glyph, uv_rect._ptr]))

  @functools.native_method
  def _font_get_glyph_texture_idx(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union[int]:
    r'''
				Returns index of the cache texture containing the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    _ret = 0
    _ret = self._ptr.call_with_return(389,tuple([font_rid._ptr, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def _font_set_glyph_texture_idx(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   , texture_idx:'int'   ) -> None:
    r'''
				Sets index of the cache texture containing the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'
    assert isinstance(texture_idx, (int, float)), 'texture_idx must be int or float'










    self._ptr.call_with_return(390,tuple([font_rid._ptr, size._ptr, glyph, texture_idx]))

  @functools.native_method
  def _font_get_glyph_texture_rid(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union['RID']:
    r'''
				Returns resource ID of the cache texture containing the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(391,tuple([font_rid._ptr, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def _font_get_glyph_texture_size(self, font_rid:'RID'   , size:'Vector2i'   , glyph:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns size of the cache texture containing the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(glyph, (int, float)), 'glyph must be int or float'









    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(392,tuple([font_rid._ptr, size._ptr, glyph]))
    return _ret


  @functools.native_method
  def _font_get_glyph_contours(self, font_rid:'RID'   , size:'int'   , index:'int'   ) -> typing.Union['Dictionary']:
    r'''
				Returns outline contours of the glyph.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'









    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(393,tuple([font_rid._ptr, size, index]))
    return _ret


  @functools.native_method
  def _font_get_kerning_list(self, font_rid:'RID'   , size:'int'   ) -> typing.Union['py4godot_vector2itypedarray.Vector2iTypedArray']:
    r'''
				Returns list of the kerning overrides.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'








    _ret = py4godot_vector2itypedarray.Vector2iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(394,tuple([font_rid._ptr, size]))
    return _ret


  @functools.native_method
  def _font_clear_kerning_map(self, font_rid:'RID'   , size:'int'   ) -> None:
    r'''
				Removes all kerning overrides.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'








    self._ptr.call_with_return(395,tuple([font_rid._ptr, size]))

  @functools.native_method
  def _font_remove_kerning(self, font_rid:'RID'   , size:'int'   , glyph_pair:'Vector2i'   ) -> None:
    r'''
				Removes kerning override for the pair of glyphs.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not glyph_pair is None)
    assert isinstance(glyph_pair, Vector2i), 'glyph_pair must be Vector2i'









    self._ptr.call_with_return(396,tuple([font_rid._ptr, size, glyph_pair._ptr]))

  @functools.native_method
  def _font_set_kerning(self, font_rid:'RID'   , size:'int'   , glyph_pair:'Vector2i'   , kerning:'Vector2'   ) -> None:
    r'''
				Sets kerning for the pair of glyphs.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not glyph_pair is None)
    assert isinstance(glyph_pair, Vector2i), 'glyph_pair must be Vector2i'
    assert(not kerning is None)
    assert isinstance(kerning, Vector2), 'kerning must be Vector2'










    self._ptr.call_with_return(397,tuple([font_rid._ptr, size, glyph_pair._ptr, kerning._ptr]))

  @functools.native_method
  def _font_get_kerning(self, font_rid:'RID'   , size:'int'   , glyph_pair:'Vector2i'   ) -> typing.Union['Vector2']:
    r'''
				Returns kerning for the pair of glyphs.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not glyph_pair is None)
    assert isinstance(glyph_pair, Vector2i), 'glyph_pair must be Vector2i'









    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(398,tuple([font_rid._ptr, size, glyph_pair._ptr]))
    return _ret


  @functools.native_method
  def _font_get_glyph_index(self, font_rid:'RID'   , size:'int'   , char:'int'   , variation_selector:'int'   ) -> typing.Union[int]:
    r'''
				Returns the glyph index of a `char`, optionally modified by the `variation_selector`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(char, (int, float)), 'char must be int or float'
    assert isinstance(variation_selector, (int, float)), 'variation_selector must be int or float'










    _ret = 0
    _ret = self._ptr.call_with_return(399,tuple([font_rid._ptr, size, char, variation_selector]))
    return _ret


  @functools.native_method
  def _font_get_char_from_glyph_index(self, font_rid:'RID'   , size:'int'   , glyph_index:'int'   ) -> typing.Union[int]:
    r'''
				Returns character code associated with `glyph_index`, or `0` if `glyph_index` is invalid.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(glyph_index, (int, float)), 'glyph_index must be int or float'









    _ret = 0
    _ret = self._ptr.call_with_return(400,tuple([font_rid._ptr, size, glyph_index]))
    return _ret


  @functools.native_method
  def _font_has_char(self, font_rid:'RID'   , char:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if a Unicode `char` is available in the font.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert isinstance(char, (int, float)), 'char must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(401,tuple([font_rid._ptr, char]))
    return _ret


  @functools.native_method
  def _font_get_supported_chars(self, font_rid:'RID'   ) -> typing.Union[str]:
    r'''
				Returns a string containing all the characters available in the font.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(402,tuple([font_rid._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _font_get_supported_glyphs(self, font_rid:'RID'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns an array containing all glyph indices in the font.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(403,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_render_range(self, font_rid:'RID'   , size:'Vector2i'   , start:'int'   , end:'int'   ) -> None:
    r'''
				Renders the range of characters to the font cache texture.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(start, (int, float)), 'start must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'










    self._ptr.call_with_return(404,tuple([font_rid._ptr, size._ptr, start, end]))

  @functools.native_method
  def _font_render_glyph(self, font_rid:'RID'   , size:'Vector2i'   , index:'int'   ) -> None:
    r'''
				Renders specified glyph to the font cache texture.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'
    assert isinstance(index, (int, float)), 'index must be int or float'









    self._ptr.call_with_return(405,tuple([font_rid._ptr, size._ptr, index]))

  @functools.native_method
  def _font_draw_glyph(self, font_rid:'RID'   , canvas:'RID'   , size:'int'   , pos:'Vector2'   , index:'int'   , color:'Color'   , oversampling:'float'   ) -> None:
    r'''
				Draws single glyph into a canvas item at the position, using `font_rid` at the size `size`. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'













    self._ptr.call_with_return(406,tuple([font_rid._ptr, canvas._ptr, size, pos._ptr, index, color._ptr, oversampling]))

  @functools.native_method
  def _font_draw_glyph_outline(self, font_rid:'RID'   , canvas:'RID'   , size:'int'   , outline_size:'int'   , pos:'Vector2'   , index:'int'   , color:'Color'   , oversampling:'float'   ) -> None:
    r'''
				Draws single glyph outline of size `outline_size` into a canvas item at the position, using `font_rid` at the size `size`. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(outline_size, (int, float)), 'outline_size must be int or float'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'














    self._ptr.call_with_return(407,tuple([font_rid._ptr, canvas._ptr, size, outline_size, pos._ptr, index, color._ptr, oversampling]))

  @functools.native_method
  def _font_is_language_supported(self, font_rid:'RID'   , language:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the font supports the given language (as a `url=https://en.wikipedia.org/wiki/ISO_639-1`ISO 639`/url` code).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'






    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = 0
    _ret = self._ptr.call_with_return(408,tuple([font_rid._ptr, py_string_language._ptr]))
    return _ret


  @functools.native_method
  def _font_set_language_support_override(self, font_rid:'RID'   , language:'str'   , supported:'bool'   ) -> None:
    r'''
				Adds override for `_font_is_language_supported`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'
    assert isinstance(supported, bool), 'supported must be bool'






    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)


    self._ptr.call_with_return(409,tuple([font_rid._ptr, py_string_language._ptr, supported]))

  @functools.native_method
  def _font_get_language_support_override(self, font_rid:'RID'   , language:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if support override is enabled for the `language`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'






    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = 0
    _ret = self._ptr.call_with_return(410,tuple([font_rid._ptr, py_string_language._ptr]))
    return _ret


  @functools.native_method
  def _font_remove_language_support_override(self, font_rid:'RID'   , language:'str'   ) -> None:
    r'''
				Remove language support override.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'






    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    self._ptr.call_with_return(411,tuple([font_rid._ptr, py_string_language._ptr]))

  @functools.native_method
  def _font_get_language_support_overrides(self, font_rid:'RID'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns list of language support overrides.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(412,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_is_script_supported(self, font_rid:'RID'   , script:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the font supports the given script (as a `url=https://en.wikipedia.org/wiki/ISO_15924`ISO 15924`/url` code).
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not script is None)
    assert isinstance(script, (str, String)), 'script must be str or String'






    assert(isinstance(script, (str, String)))
    py_string_script = script if isinstance(script, StringName) else c_utils.py_string_to_string(script)

    _ret = 0
    _ret = self._ptr.call_with_return(413,tuple([font_rid._ptr, py_string_script._ptr]))
    return _ret


  @functools.native_method
  def _font_set_script_support_override(self, font_rid:'RID'   , script:'str'   , supported:'bool'   ) -> None:
    r'''
				Adds override for `_font_is_script_supported`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not script is None)
    assert isinstance(script, (str, String)), 'script must be str or String'
    assert isinstance(supported, bool), 'supported must be bool'






    assert(isinstance(script, (str, String)))
    py_string_script = script if isinstance(script, StringName) else c_utils.py_string_to_string(script)


    self._ptr.call_with_return(414,tuple([font_rid._ptr, py_string_script._ptr, supported]))

  @functools.native_method
  def _font_get_script_support_override(self, font_rid:'RID'   , script:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if support override is enabled for the `script`.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not script is None)
    assert isinstance(script, (str, String)), 'script must be str or String'






    assert(isinstance(script, (str, String)))
    py_string_script = script if isinstance(script, StringName) else c_utils.py_string_to_string(script)

    _ret = 0
    _ret = self._ptr.call_with_return(415,tuple([font_rid._ptr, py_string_script._ptr]))
    return _ret


  @functools.native_method
  def _font_remove_script_support_override(self, font_rid:'RID'   , script:'str'   ) -> None:
    r'''
				Removes script support override.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not script is None)
    assert isinstance(script, (str, String)), 'script must be str or String'






    assert(isinstance(script, (str, String)))
    py_string_script = script if isinstance(script, StringName) else c_utils.py_string_to_string(script)

    self._ptr.call_with_return(416,tuple([font_rid._ptr, py_string_script._ptr]))

  @functools.native_method
  def _font_get_script_support_overrides(self, font_rid:'RID'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns list of script support overrides.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(417,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_set_opentype_feature_overrides(self, font_rid:'RID'   , overrides:'Dictionary'   ) -> None:
    r'''
				Sets font OpenType feature set override.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'
    assert(not overrides is None)
    assert isinstance(overrides, Dictionary), 'overrides must be Dictionary'








    self._ptr.call_with_return(418,tuple([font_rid._ptr, overrides._ptr]))

  @functools.native_method
  def _font_get_opentype_feature_overrides(self, font_rid:'RID'   ) -> typing.Union['Dictionary']:
    r'''
				Returns font OpenType feature set override.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(419,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_supported_feature_list(self, font_rid:'RID'   ) -> typing.Union['Dictionary']:
    r'''
				Returns the dictionary of the supported OpenType features.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(420,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_supported_variation_list(self, font_rid:'RID'   ) -> typing.Union['Dictionary']:
    r'''
				Returns the dictionary of the supported OpenType variation coordinates.
			'''

    assert(not font_rid is None)
    assert isinstance(font_rid, RID), 'font_rid must be RID'







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(421,tuple([font_rid._ptr]))
    return _ret


  @functools.native_method
  def _font_get_global_oversampling(self) -> typing.Union[float]:
    r'''
				Returns the font oversampling factor, shared by all fonts in the TextServer.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(422,tuple([]))
    return _ret


  @functools.native_method
  def _font_set_global_oversampling(self, oversampling:'float'   ) -> None:
    r'''
				Sets oversampling factor, shared by all font in the TextServer.
			'''

    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'







    self._ptr.call_with_return(423,tuple([oversampling]))

  @functools.native_method
  def _reference_oversampling_level(self, oversampling:'float'   ) -> None:
    r'''
				Increases the reference count of the specified oversampling level. This method is called by `Viewport`, and should not be used directly.
			'''

    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'







    self._ptr.call_with_return(424,tuple([oversampling]))

  @functools.native_method
  def _unreference_oversampling_level(self, oversampling:'float'   ) -> None:
    r'''
				Decreases the reference count of the specified oversampling level, and frees the font cache for oversampling level when the reference count reaches zero. This method is called by `Viewport`, and should not be used directly.
			'''

    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'







    self._ptr.call_with_return(425,tuple([oversampling]))

  @functools.native_method
  def _get_hex_code_box_size(self, size:'int'   , index:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns size of the replacement character (box with character hexadecimal code that is drawn in place of invalid characters).
			'''

    assert isinstance(size, (int, float)), 'size must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(426,tuple([size, index]))
    return _ret


  @functools.native_method
  def _draw_hex_code_box(self, canvas:'RID'   , size:'int'   , pos:'Vector2'   , index:'int'   , color:'Color'   ) -> None:
    r'''
				Draws box displaying character hexadecimal code.
			'''

    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'











    self._ptr.call_with_return(427,tuple([canvas._ptr, size, pos._ptr, index, color._ptr]))

  @functools.native_method
  def _create_shaped_text(self, direction:'int'  , orientation:'int'  ) -> typing.Union['RID']:
    r'''
				Creates a new buffer for complex text layout, with the given `direction` and `orientation`.
			'''

    assert isinstance(direction, (int, float)), 'direction must be int or float'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(428,tuple([direction, orientation]))
    return _ret


  @functools.native_method
  def _shaped_text_clear(self, shaped:'RID'   ) -> None:
    r'''
				Clears text buffer (removes text and inline objects).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    self._ptr.call_with_return(429,tuple([shaped._ptr]))

  @functools.native_method
  def _shaped_text_set_direction(self, shaped:'RID'   , direction:'int'  ) -> None:
    r'''
				Sets desired text direction. If set to `constant TextServer.DIRECTION_AUTO`, direction will be detected based on the buffer contents and current locale.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(direction, (int, float)), 'direction must be int or float'








    self._ptr.call_with_return(430,tuple([shaped._ptr, direction]))

  @functools.native_method
  def _shaped_text_get_direction(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns direction of the text.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(431,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_get_inferred_direction(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns direction of the text, inferred by the BiDi algorithm.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(432,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_set_bidi_override(self, shaped:'RID'   , override:'Array'   ) -> None:
    r'''
				Overrides BiDi for the structured text.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert(not override is None)
    assert isinstance(override, Array), 'override must be Array'








    self._ptr.call_with_return(433,tuple([shaped._ptr, override._ptr]))

  @functools.native_method
  def _shaped_text_set_custom_punctuation(self, shaped:'RID'   , punct:'str'   ) -> None:
    r'''
				Sets custom punctuation character list, used for word breaking. If set to empty string, server defaults are used.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert(not punct is None)
    assert isinstance(punct, (str, String)), 'punct must be str or String'






    assert(isinstance(punct, (str, String)))
    py_string_punct = punct if isinstance(punct, StringName) else c_utils.py_string_to_string(punct)

    self._ptr.call_with_return(434,tuple([shaped._ptr, py_string_punct._ptr]))

  @functools.native_method
  def _shaped_text_get_custom_punctuation(self, shaped:'RID'   ) -> typing.Union[str]:
    r'''
				Returns custom punctuation character list, used for word breaking. If set to empty string, server defaults are used.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(435,tuple([shaped._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _shaped_text_set_custom_ellipsis(self, shaped:'RID'   , char:'int'   ) -> None:
    r'''
				Sets ellipsis character used for text clipping.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(char, (int, float)), 'char must be int or float'








    self._ptr.call_with_return(436,tuple([shaped._ptr, char]))

  @functools.native_method
  def _shaped_text_get_custom_ellipsis(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns ellipsis character used for text clipping.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(437,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_set_orientation(self, shaped:'RID'   , orientation:'int'  ) -> None:
    r'''
				Sets desired text orientation.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'








    self._ptr.call_with_return(438,tuple([shaped._ptr, orientation]))

  @functools.native_method
  def _shaped_text_get_orientation(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns text orientation.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret:int
    _ret = self._ptr.call_with_return(439,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_set_preserve_invalid(self, shaped:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If set to `true` text buffer will display invalid characters as hexadecimal codes, otherwise nothing is displayed.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(440,tuple([shaped._ptr, enabled]))

  @functools.native_method
  def _shaped_text_get_preserve_invalid(self, shaped:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if text buffer is configured to display hexadecimal codes in place of invalid characters.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(441,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_set_preserve_control(self, shaped:'RID'   , enabled:'bool'   ) -> None:
    r'''
				If set to `true` text buffer will display control characters.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(442,tuple([shaped._ptr, enabled]))

  @functools.native_method
  def _shaped_text_get_preserve_control(self, shaped:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if text buffer is configured to display control characters.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(443,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_set_spacing(self, shaped:'RID'   , spacing:'int'  , value:'int'   ) -> None:
    r'''
				Sets extra spacing added between glyphs or lines in pixels.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(spacing, (int, float)), 'spacing must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'









    self._ptr.call_with_return(444,tuple([shaped._ptr, spacing, value]))

  @functools.native_method
  def _shaped_text_get_spacing(self, shaped:'RID'   , spacing:'int'  ) -> typing.Union[int]:
    r'''
				Returns extra spacing added between glyphs or lines in pixels.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(spacing, (int, float)), 'spacing must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(445,tuple([shaped._ptr, spacing]))
    return _ret


  @functools.native_method
  def _shaped_text_add_string(self, shaped:'RID'   , text:'str'   , fonts:'py4godot_ridtypedarray.RIDTypedArray'   , size:'int'   , opentype_features:'Dictionary'   , language:'str'   , meta:'object'   ) -> typing.Union[bool]:
    r'''
				Adds text span and font to draw it to the text buffer.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert isinstance(fonts, Array), 'fonts must be Array'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not opentype_features is None)
    assert isinstance(opentype_features, Dictionary), 'opentype_features must be Dictionary'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'
    

    if not (type(meta).__name__ in py4godot.variant_types.core_types or isinstance(meta, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'meta': "
                f"{type(meta).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)



    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)


    _ret = 0
    _ret = self._ptr.call_with_return(446,tuple([shaped._ptr, py_string_text._ptr, fonts._ptr, size, opentype_features._ptr, py_string_language._ptr, meta]))
    return _ret


  @functools.native_method
  def _shaped_text_add_object(self, shaped:'RID'   , key:'object'   , size:'Vector2'   , inline_align:'int'  , length:'int'   , baseline:'float'   ) -> typing.Union[bool]:
    r'''
				Adds inline object to the text buffer, `key` must be unique. In the text, object is represented as `length` object replacement characters.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    
    assert(not size is None)
    assert isinstance(size, Vector2), 'size must be Vector2'
    assert isinstance(inline_align, (int, float)), 'inline_align must be int or float'
    assert isinstance(length, (int, float)), 'length must be int or float'
    assert isinstance(baseline, (int, float)), 'baseline must be int or float'

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )











    _ret = 0
    _ret = self._ptr.call_with_return(447,tuple([shaped._ptr, key, size._ptr, inline_align, length, baseline]))
    return _ret


  @functools.native_method
  def _shaped_text_resize_object(self, shaped:'RID'   , key:'object'   , size:'Vector2'   , inline_align:'int'  , baseline:'float'   ) -> typing.Union[bool]:
    r'''
				Sets new size and alignment of embedded object.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    
    assert(not size is None)
    assert isinstance(size, Vector2), 'size must be Vector2'
    assert isinstance(inline_align, (int, float)), 'inline_align must be int or float'
    assert isinstance(baseline, (int, float)), 'baseline must be int or float'

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )










    _ret = 0
    _ret = self._ptr.call_with_return(448,tuple([shaped._ptr, key, size._ptr, inline_align, baseline]))
    return _ret


  @functools.native_method
  def _shaped_get_text(self, shaped:'RID'   ) -> typing.Union[str]:
    r'''
				Returns the text buffer source text, including object replacement characters.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(449,tuple([shaped._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _shaped_get_span_count(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns number of text spans added using `_shaped_text_add_string` or `_shaped_text_add_object`.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(450,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_get_span_meta(self, shaped:'RID'   , index:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns text span metadata.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(451,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def _shaped_get_span_embedded_object(self, shaped:'RID'   , index:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns text embedded object key.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(452,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def _shaped_get_span_text(self, shaped:'RID'   , index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the text span source text.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(453,tuple([shaped._ptr, index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _shaped_get_span_object(self, shaped:'RID'   , index:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the text span embedded object key.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(454,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def _shaped_set_span_update_font(self, shaped:'RID'   , index:'int'   , fonts:'py4godot_ridtypedarray.RIDTypedArray'   , size:'int'   , opentype_features:'Dictionary'   ) -> None:
    r'''
				Changes text span font, font size, and OpenType features, without changing the text.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(fonts, Array), 'fonts must be Array'
    assert isinstance(size, (int, float)), 'size must be int or float'
    assert(not opentype_features is None)
    assert isinstance(opentype_features, Dictionary), 'opentype_features must be Dictionary'











    self._ptr.call_with_return(455,tuple([shaped._ptr, index, fonts._ptr, size, opentype_features._ptr]))

  @functools.native_method
  def _shaped_get_run_count(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the number of uniform text runs in the buffer.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(456,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_get_run_text(self, shaped:'RID'   , index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the source text of the `index` text run (in visual order).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(457,tuple([shaped._ptr, index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _shaped_get_run_range(self, shaped:'RID'   , index:'int'   ) -> typing.Union['Vector2i']:
    r'''
				Returns the source text range of the `index` text run (in visual order).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(458,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def _shaped_get_run_font_rid(self, shaped:'RID'   , index:'int'   ) -> typing.Union['RID']:
    r'''
				Returns the font RID of the `index` text run (in visual order).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(459,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def _shaped_get_run_font_size(self, shaped:'RID'   , index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the font size of the `index` text run (in visual order).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(460,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def _shaped_get_run_language(self, shaped:'RID'   , index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the language of the `index` text run (in visual order).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(461,tuple([shaped._ptr, index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _shaped_get_run_direction(self, shaped:'RID'   , index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the direction of the `index` text run (in visual order).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret:int
    _ret = self._ptr.call_with_return(462,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def _shaped_get_run_object(self, shaped:'RID'   , index:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the embedded object of the `index` text run (in visual order).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(463,tuple([shaped._ptr, index]))
    return _ret


  @functools.native_method
  def _shaped_text_substr(self, shaped:'RID'   , start:'int'   , length:'int'   ) -> typing.Union['RID']:
    r'''
				Returns text buffer for the substring of the text in the `shaped` text buffer (including inline objects).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(start, (int, float)), 'start must be int or float'
    assert isinstance(length, (int, float)), 'length must be int or float'









    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(464,tuple([shaped._ptr, start, length]))
    return _ret


  @functools.native_method
  def _shaped_text_get_parent(self, shaped:'RID'   ) -> typing.Union['RID']:
    r'''
				Returns the parent buffer from which the substring originates.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(465,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_fit_to_width(self, shaped:'RID'   , width:'float'   , justification_flags:'int'   ) -> typing.Union[float]:
    r'''
				Adjusts text width to fit to specified width, returns new text width.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(justification_flags, (int, float)), 'justification_flags must be int or float'









    _ret = 0
    _ret = self._ptr.call_with_return(466,tuple([shaped._ptr, width, justification_flags]))
    return _ret


  @functools.native_method
  def _shaped_text_tab_align(self, shaped:'RID'   , tab_stops:'PackedFloat32Array'   ) -> typing.Union[float]:
    r'''
				Aligns shaped text to the given tab-stops.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert(not tab_stops is None)
    assert isinstance(tab_stops, PackedFloat32Array), 'tab_stops must be PackedFloat32Array'








    _ret = 0
    _ret = self._ptr.call_with_return(467,tuple([shaped._ptr, tab_stops._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_shape(self, shaped:'RID'   ) -> typing.Union[bool]:
    r'''
				Shapes buffer if it's not shaped. Returns `true` if the string is shaped successfully.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(468,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_update_breaks(self, shaped:'RID'   ) -> typing.Union[bool]:
    r'''
				Updates break points in the shaped text. This method is called by default implementation of text breaking functions.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(469,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_update_justification_ops(self, shaped:'RID'   ) -> typing.Union[bool]:
    r'''
				Updates justification points in the shaped text. This method is called by default implementation of text justification functions.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(470,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_is_ready(self, shaped:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if buffer is successfully shaped.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(471,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_get_glyph_count(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns number of glyphs in the buffer.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(472,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_get_range(self, shaped:'RID'   ) -> typing.Union['Vector2i']:
    r'''
				Returns substring buffer character range in the parent buffer.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(473,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_get_line_breaks_adv(self, shaped:'RID'   , width:'PackedFloat32Array'   , start:'int'   , once:'bool'   , break_flags:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Breaks text to the lines and columns. Returns character ranges for each segment.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert(not width is None)
    assert isinstance(width, PackedFloat32Array), 'width must be PackedFloat32Array'
    assert isinstance(start, (int, float)), 'start must be int or float'
    assert isinstance(once, bool), 'once must be bool'
    assert isinstance(break_flags, (int, float)), 'break_flags must be int or float'











    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(474,tuple([shaped._ptr, width._ptr, start, once, break_flags]))
    return _ret


  @functools.native_method
  def _shaped_text_get_line_breaks(self, shaped:'RID'   , width:'float'   , start:'int'   , break_flags:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Breaks text to the lines and returns character ranges for each line.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(start, (int, float)), 'start must be int or float'
    assert isinstance(break_flags, (int, float)), 'break_flags must be int or float'










    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(475,tuple([shaped._ptr, width, start, break_flags]))
    return _ret


  @functools.native_method
  def _shaped_text_get_word_breaks(self, shaped:'RID'   , grapheme_flags:'int'   , skip_grapheme_flags:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Breaks text into words and returns array of character ranges. Use `grapheme_flags` to set what characters are used for breaking.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(grapheme_flags, (int, float)), 'grapheme_flags must be int or float'
    assert isinstance(skip_grapheme_flags, (int, float)), 'skip_grapheme_flags must be int or float'









    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(476,tuple([shaped._ptr, grapheme_flags, skip_grapheme_flags]))
    return _ret


  @functools.native_method
  def _shaped_text_get_trim_pos(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the position of the overrun trim.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(477,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_get_ellipsis_pos(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns position of the ellipsis.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(478,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_get_ellipsis_glyph_count(self, shaped:'RID'   ) -> typing.Union[int]:
    r'''
				Returns number of glyphs in the ellipsis.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(479,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_overrun_trim_to_width(self, shaped:'RID'   , width:'float'   , trim_flags:'int'   ) -> None:
    r'''
				Trims text if it exceeds the given width.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(width, (int, float)), 'width must be int or float'
    assert isinstance(trim_flags, (int, float)), 'trim_flags must be int or float'









    self._ptr.call_with_return(480,tuple([shaped._ptr, width, trim_flags]))

  @functools.native_method
  def _shaped_text_get_objects(self, shaped:'RID'   ) -> typing.Union['Array']:
    r'''
				Returns array of inline objects.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(481,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_get_object_rect(self, shaped:'RID'   , key:'object'   ) -> typing.Union['Rect2']:
    r'''
				Returns bounding rectangle of the inline object.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(482,tuple([shaped._ptr, key]))
    return _ret


  @functools.native_method
  def _shaped_text_get_object_range(self, shaped:'RID'   , key:'object'   ) -> typing.Union['Vector2i']:
    r'''
				Returns the character range of the inline object.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(483,tuple([shaped._ptr, key]))
    return _ret


  @functools.native_method
  def _shaped_text_get_object_glyph(self, shaped:'RID'   , key:'object'   ) -> typing.Union[int]:
    r'''
				Returns the glyph index of the inline object.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = 0
    _ret = self._ptr.call_with_return(484,tuple([shaped._ptr, key]))
    return _ret


  @functools.native_method
  def _shaped_text_get_size(self, shaped:'RID'   ) -> typing.Union['Vector2']:
    r'''
				Returns size of the text.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(485,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_get_ascent(self, shaped:'RID'   ) -> typing.Union[float]:
    r'''
				Returns the text ascent (number of pixels above the baseline for horizontal layout or to the left of baseline for vertical).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(486,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_get_descent(self, shaped:'RID'   ) -> typing.Union[float]:
    r'''
				Returns the text descent (number of pixels below the baseline for horizontal layout or to the right of baseline for vertical).
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(487,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_get_width(self, shaped:'RID'   ) -> typing.Union[float]:
    r'''
				Returns width (for horizontal layout) or height (for vertical) of the text.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(488,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_get_underline_position(self, shaped:'RID'   ) -> typing.Union[float]:
    r'''
				Returns pixel offset of the underline below the baseline.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(489,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_get_underline_thickness(self, shaped:'RID'   ) -> typing.Union[float]:
    r'''
				Returns thickness of the underline.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(490,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_get_dominant_direction_in_range(self, shaped:'RID'   , start:'int'   , end:'int'   ) -> typing.Union[int]:
    r'''
				Returns dominant direction of in the range of text.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(start, (int, float)), 'start must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'









    _ret = 0
    _ret = self._ptr.call_with_return(491,tuple([shaped._ptr, start, end]))
    return _ret


  @functools.native_method
  def _shaped_text_get_selection(self, shaped:'RID'   , start:'int'   , end:'int'   ) -> typing.Union['PackedVector2Array']:
    r'''
				Returns selection rectangles for the specified character range.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(start, (int, float)), 'start must be int or float'
    assert isinstance(end, (int, float)), 'end must be int or float'









    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(492,tuple([shaped._ptr, start, end]))
    return _ret


  @functools.native_method
  def _shaped_text_hit_test_grapheme(self, shaped:'RID'   , coord:'float'   ) -> typing.Union[int]:
    r'''
				Returns grapheme index at the specified pixel offset at the baseline, or `-1` if none is found.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(coord, (int, float)), 'coord must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(493,tuple([shaped._ptr, coord]))
    return _ret


  @functools.native_method
  def _shaped_text_hit_test_position(self, shaped:'RID'   , coord:'float'   ) -> typing.Union[int]:
    r'''
				Returns caret character offset at the specified pixel offset at the baseline. This function always returns a valid position.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(coord, (int, float)), 'coord must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(494,tuple([shaped._ptr, coord]))
    return _ret


  @functools.native_method
  def _shaped_text_draw(self, shaped:'RID'   , canvas:'RID'   , pos:'Vector2'   , clip_l:'float'   , clip_r:'float'   , color:'Color'   , oversampling:'float'   ) -> None:
    r'''
				Draw shaped text into a canvas item at a given position, with `color`. `pos` specifies the leftmost point of the baseline (for horizontal layout) or topmost point of the baseline (for vertical layout). If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(clip_l, (int, float)), 'clip_l must be int or float'
    assert isinstance(clip_r, (int, float)), 'clip_r must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'













    self._ptr.call_with_return(495,tuple([shaped._ptr, canvas._ptr, pos._ptr, clip_l, clip_r, color._ptr, oversampling]))

  @functools.native_method
  def _shaped_text_draw_outline(self, shaped:'RID'   , canvas:'RID'   , pos:'Vector2'   , clip_l:'float'   , clip_r:'float'   , outline_size:'int'   , color:'Color'   , oversampling:'float'   ) -> None:
    r'''
				Draw the outline of the shaped text into a canvas item at a given position, with `color`. `pos` specifies the leftmost point of the baseline (for horizontal layout) or topmost point of the baseline (for vertical layout). If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(clip_l, (int, float)), 'clip_l must be int or float'
    assert isinstance(clip_r, (int, float)), 'clip_r must be int or float'
    assert isinstance(outline_size, (int, float)), 'outline_size must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'














    self._ptr.call_with_return(496,tuple([shaped._ptr, canvas._ptr, pos._ptr, clip_l, clip_r, outline_size, color._ptr, oversampling]))

  @functools.native_method
  def _shaped_text_get_grapheme_bounds(self, shaped:'RID'   , pos:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns composite character's bounds as offsets from the start of the line.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(pos, (int, float)), 'pos must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(497,tuple([shaped._ptr, pos]))
    return _ret


  @functools.native_method
  def _shaped_text_next_grapheme_pos(self, shaped:'RID'   , pos:'int'   ) -> typing.Union[int]:
    r'''
				Returns grapheme end position closest to the `pos`.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(pos, (int, float)), 'pos must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(498,tuple([shaped._ptr, pos]))
    return _ret


  @functools.native_method
  def _shaped_text_prev_grapheme_pos(self, shaped:'RID'   , pos:'int'   ) -> typing.Union[int]:
    r'''
				Returns grapheme start position closest to the `pos`.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(pos, (int, float)), 'pos must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(499,tuple([shaped._ptr, pos]))
    return _ret


  @functools.native_method
  def _shaped_text_get_character_breaks(self, shaped:'RID'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns array of the composite character boundaries.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(500,tuple([shaped._ptr]))
    return _ret


  @functools.native_method
  def _shaped_text_next_character_pos(self, shaped:'RID'   , pos:'int'   ) -> typing.Union[int]:
    r'''
				Returns composite character end position closest to the `pos`.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(pos, (int, float)), 'pos must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(501,tuple([shaped._ptr, pos]))
    return _ret


  @functools.native_method
  def _shaped_text_prev_character_pos(self, shaped:'RID'   , pos:'int'   ) -> typing.Union[int]:
    r'''
				Returns composite character start position closest to the `pos`.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(pos, (int, float)), 'pos must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(502,tuple([shaped._ptr, pos]))
    return _ret


  @functools.native_method
  def _shaped_text_closest_character_pos(self, shaped:'RID'   , pos:'int'   ) -> typing.Union[int]:
    r'''
				Returns composite character position closest to the `pos`.
			'''

    assert(not shaped is None)
    assert isinstance(shaped, RID), 'shaped must be RID'
    assert isinstance(pos, (int, float)), 'pos must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(503,tuple([shaped._ptr, pos]))
    return _ret


  @functools.native_method
  def _format_number(self, number:'str'   , language:'str'   ) -> typing.Union[str]:
    r'''
				Converts a number from Western Arabic (0..9) to the numeral system used in the given `language`.
				If `language` is an empty string, the active locale will be used.
			'''

    assert(not number is None)
    assert isinstance(number, (str, String)), 'number must be str or String'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'





    assert(isinstance(number, (str, String)))
    py_string_number = number if isinstance(number, StringName) else c_utils.py_string_to_string(number)
    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(504,tuple([py_string_number._ptr, py_string_language._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _parse_number(self, number:'str'   , language:'str'   ) -> typing.Union[str]:
    r'''
				Converts `number` from the numeral system used in the given `language` to Western Arabic (0..9).
				If `language` is an empty string, the active locale will be used.
			'''

    assert(not number is None)
    assert isinstance(number, (str, String)), 'number must be str or String'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'





    assert(isinstance(number, (str, String)))
    py_string_number = number if isinstance(number, StringName) else c_utils.py_string_to_string(number)
    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(505,tuple([py_string_number._ptr, py_string_language._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _percent_sign(self, language:'str'   ) -> typing.Union[str]:
    r'''
				Returns percent sign used in the given `language`.
			'''

    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'





    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(506,tuple([py_string_language._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _strip_diacritics(self, string:'str'   ) -> typing.Union[str]:
    r'''
				Strips diacritics from the string.
			'''

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(507,tuple([py_string_string._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _is_valid_identifier(self, string:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if `string` is a valid identifier.
			'''

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)

    _ret = 0
    _ret = self._ptr.call_with_return(508,tuple([py_string_string._ptr]))
    return _ret


  @functools.native_method
  def _is_valid_letter(self, unicode:'int'   ) -> typing.Union[bool]:
    r'''
'''

    assert isinstance(unicode, (int, float)), 'unicode must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(509,tuple([unicode]))
    return _ret


  @functools.native_method
  def _string_get_word_breaks(self, string:'str'   , language:'str'   , chars_per_line:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns an array of the word break boundaries. Elements in the returned array are the offsets of the start and end of words. Therefore the length of the array is always even.
			'''

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'
    assert isinstance(chars_per_line, (int, float)), 'chars_per_line must be int or float'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)
    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)


    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(510,tuple([py_string_string._ptr, py_string_language._ptr, chars_per_line]))
    return _ret


  @functools.native_method
  def _string_get_character_breaks(self, string:'str'   , language:'str'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns array of the composite character boundaries.
			'''

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)
    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(511,tuple([py_string_string._ptr, py_string_language._ptr]))
    return _ret


  @functools.native_method
  def _is_confusable(self, string:'str'   , dict:'PackedStringArray'   ) -> typing.Union[int]:
    r'''
				Returns index of the first string in `dict` which is visually confusable with the `string`, or `-1` if none is found.
			'''

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'
    assert(not dict is None)
    assert isinstance(dict, PackedStringArray), 'dict must be PackedStringArray'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)


    _ret = 0
    _ret = self._ptr.call_with_return(512,tuple([py_string_string._ptr, dict._ptr]))
    return _ret


  @functools.native_method
  def _spoof_check(self, string:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if `string` is likely to be an attempt at confusing the reader.
			'''

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)

    _ret = 0
    _ret = self._ptr.call_with_return(513,tuple([py_string_string._ptr]))
    return _ret


  @functools.native_method
  def _string_to_upper(self, string:'str'   , language:'str'   ) -> typing.Union[str]:
    r'''
				Returns the string converted to `UPPERCASE`.
			'''

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)
    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(514,tuple([py_string_string._ptr, py_string_language._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _string_to_lower(self, string:'str'   , language:'str'   ) -> typing.Union[str]:
    r'''
				Returns the string converted to `lowercase`.
			'''

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)
    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(515,tuple([py_string_string._ptr, py_string_language._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _string_to_title(self, string:'str'   , language:'str'   ) -> typing.Union[str]:
    r'''
				Returns the string converted to `Title Case`.
			'''

    assert(not string is None)
    assert isinstance(string, (str, String)), 'string must be str or String'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'





    assert(isinstance(string, (str, String)))
    py_string_string = string if isinstance(string, StringName) else c_utils.py_string_to_string(string)
    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(516,tuple([py_string_string._ptr, py_string_language._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _parse_structured_text(self, parser_type:'int'  , args:'Array'   , text:'str'   ) -> typing.Union['py4godot_vector3itypedarray.Vector3iTypedArray']:
    r'''
				Default implementation of the BiDi algorithm override function.
			'''

    assert isinstance(parser_type, (int, float)), 'parser_type must be int or float'
    assert(not args is None)
    assert isinstance(args, Array), 'args must be Array'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'







    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = py4godot_vector3itypedarray.Vector3iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(517,tuple([parser_type, args._ptr, py_string_text._ptr]))
    return _ret


  @functools.native_method
  def _cleanup(self) -> None:
    r'''
				This method is called before text server is unregistered.
			'''




    self._ptr.call_with_return(518,tuple([]))


register_cast_function('TextServerExtension', TextServerExtension.cast)
register_class('TextServerExtension', TextServerExtension)
