# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.Tree as py4godot_tree 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.TextEdit as py4godot_textedit 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.GraphElement as py4godot_graphelement 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.RichTextLabel as py4godot_richtextlabel 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.GraphNode as py4godot_graphnode 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.Container as py4godot_container 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.FoldableContainer as py4godot_foldablecontainer 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.TabContainer as py4godot_tabcontainer 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
import py4godot.classes.Control as py4godot_control 
from py4godot.wrappers.wrappers import CPPTabBarWrapper

class AlignmentMode:
  ALIGNMENT_LEFT = 0
  ALIGNMENT_CENTER = 1
  ALIGNMENT_RIGHT = 2
  ALIGNMENT_MAX = 3
class CloseButtonDisplayPolicy:
  CLOSE_BUTTON_SHOW_NEVER = 0
  CLOSE_BUTTON_SHOW_ACTIVE_ONLY = 1
  CLOSE_BUTTON_SHOW_ALWAYS = 2
  CLOSE_BUTTON_MAX = 3


class TabBar(py4godot_control.Control):
  r'''
		A control that provides a horizontal bar with tabs. Similar to `TabContainer` but is only in charge of drawing tabs, not interacting with children.
	'''

  @staticmethod
  def constructor():
    class_ = TabBar.construct_without_init()
    class_._ptr = constructor(806,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TabBar.construct_without_init()
    class_._ptr = constructor(806,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTabBarWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(806,0, ())


  def generate_wrapper(self):
    return CPPTabBarWrapper()
  def init_signals(self):
    super().init_signals()
    tab_selected_name = utils.py_string_to_string_name("tab_selected")
    self.tab_selected = signals.BuiltinSignal(self, tab_selected_name)
    tab_changed_name = utils.py_string_to_string_name("tab_changed")
    self.tab_changed = signals.BuiltinSignal(self, tab_changed_name)
    tab_clicked_name = utils.py_string_to_string_name("tab_clicked")
    self.tab_clicked = signals.BuiltinSignal(self, tab_clicked_name)
    tab_rmb_clicked_name = utils.py_string_to_string_name("tab_rmb_clicked")
    self.tab_rmb_clicked = signals.BuiltinSignal(self, tab_rmb_clicked_name)
    tab_close_pressed_name = utils.py_string_to_string_name("tab_close_pressed")
    self.tab_close_pressed = signals.BuiltinSignal(self, tab_close_pressed_name)
    tab_button_pressed_name = utils.py_string_to_string_name("tab_button_pressed")
    self.tab_button_pressed = signals.BuiltinSignal(self, tab_button_pressed_name)
    tab_hovered_name = utils.py_string_to_string_name("tab_hovered")
    self.tab_hovered = signals.BuiltinSignal(self, tab_hovered_name)
    active_tab_rearranged_name = utils.py_string_to_string_name("active_tab_rearranged")
    self.active_tab_rearranged = signals.BuiltinSignal(self, active_tab_rearranged_name)

  @staticmethod
  def construct_without_init():
    cls = TabBar.__new__(TabBar)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TabBar'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TabBar.construct_without_init()
    cls._ptr = CPPTabBarWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TabBar.construct_without_init()
    cls._ptr = CPPTabBarWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def current_tab(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_current_tab()
    return _ret
  @current_tab.setter
  def current_tab(self,  value:'int'):
    self.set_current_tab(value)
  @property
  def tab_alignment(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tab_alignment()
    return _ret
  @tab_alignment.setter
  def tab_alignment(self,  value:'int'):
    self.set_tab_alignment(value)
  @property
  def clip_tabs(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_clip_tabs()
    return _ret
  @clip_tabs.setter
  def clip_tabs(self,  value:'bool'):
    self.set_clip_tabs(value)
  @property
  def close_with_middle_mouse(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_close_with_middle_mouse()
    return _ret
  @close_with_middle_mouse.setter
  def close_with_middle_mouse(self,  value:'bool'):
    self.set_close_with_middle_mouse(value)
  @property
  def tab_close_display_policy(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tab_close_display_policy()
    return _ret
  @tab_close_display_policy.setter
  def tab_close_display_policy(self,  value:'int'):
    self.set_tab_close_display_policy(value)
  @property
  def max_tab_width(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_tab_width()
    return _ret
  @max_tab_width.setter
  def max_tab_width(self,  value:'int'):
    self.set_max_tab_width(value)
  @property
  def scrolling_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_scrolling_enabled()
    return _ret
  @scrolling_enabled.setter
  def scrolling_enabled(self,  value:'bool'):
    self.set_scrolling_enabled(value)
  @property
  def drag_to_rearrange_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_drag_to_rearrange_enabled()
    return _ret
  @drag_to_rearrange_enabled.setter
  def drag_to_rearrange_enabled(self,  value:'bool'):
    self.set_drag_to_rearrange_enabled(value)
  @property
  def tabs_rearrange_group(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tabs_rearrange_group()
    return _ret
  @tabs_rearrange_group.setter
  def tabs_rearrange_group(self,  value:'int'):
    self.set_tabs_rearrange_group(value)
  @property
  def scroll_to_selected(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_scroll_to_selected()
    return _ret
  @scroll_to_selected.setter
  def scroll_to_selected(self,  value:'bool'):
    self.set_scroll_to_selected(value)
  @property
  def select_with_rmb(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_select_with_rmb()
    return _ret
  @select_with_rmb.setter
  def select_with_rmb(self,  value:'bool'):
    self.set_select_with_rmb(value)
  @property
  def deselect_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_deselect_enabled()
    return _ret
  @deselect_enabled.setter
  def deselect_enabled(self,  value:'bool'):
    self.set_deselect_enabled(value)
  @property
  def tab_count(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_tab_count()
    return _ret
  @tab_count.setter
  def tab_count(self,  value:'int'):
    self.set_tab_count(value)
  @functools.native_method
  def set_tab_count(self, count:'int'   ) -> None:
    r''''''

    assert isinstance(count, (int, float)), 'count must be int or float'


    self.py__tab_count = count






    self._ptr.call_with_return(433,tuple([count]))

  @functools.native_method
  def get_tab_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(434,tuple([]))

    return _ret


  @functools.native_method
  def set_current_tab(self, tab_idx:'int'   ) -> None:
    r''''''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'


    self.py__current_tab = tab_idx






    self._ptr.call_with_return(435,tuple([tab_idx]))

  @functools.native_method
  def get_current_tab(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(436,tuple([]))

    return _ret


  @functools.native_method
  def get_previous_tab(self) -> typing.Union[int]:
    r'''
				Returns the previously active tab index.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(437,tuple([]))
    return _ret


  @functools.native_method
  def select_previous_available(self) -> typing.Union[bool]:
    r'''
				Selects the first available tab with lower index than the currently selected. Returns `true` if tab selection changed.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(438,tuple([]))
    return _ret


  @functools.native_method
  def select_next_available(self) -> typing.Union[bool]:
    r'''
				Selects the first available tab with greater index than the currently selected. Returns `true` if tab selection changed.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(439,tuple([]))
    return _ret


  @functools.native_method
  def set_tab_title(self, tab_idx:'int'   , title:'str'   ) -> None:
    r'''
				Sets a `title` for the tab at index `tab_idx`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert(not title is None)
    assert isinstance(title, (str, String)), 'title must be str or String'






    assert(isinstance(title, (str, String)))
    py_string_title = title if isinstance(title, StringName) else c_utils.py_string_to_string(title)

    self._ptr.call_with_return(440,tuple([tab_idx, py_string_title._ptr]))

  @functools.native_method
  def get_tab_title(self, tab_idx:'int'   ) -> typing.Union[str]:
    r'''
				Returns the title of the tab at index `tab_idx`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(441,tuple([tab_idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_tab_tooltip(self, tab_idx:'int'   , tooltip:'str'   ) -> None:
    r'''
				Sets a `tooltip` for tab at index `tab_idx`.
				**Note:** By default, if the `tooltip` is empty and the tab text is truncated (not all characters fit into the tab), the title will be displayed as a tooltip. To hide the tooltip, assign `" "` as the `tooltip` text.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert(not tooltip is None)
    assert isinstance(tooltip, (str, String)), 'tooltip must be str or String'






    assert(isinstance(tooltip, (str, String)))
    py_string_tooltip = tooltip if isinstance(tooltip, StringName) else c_utils.py_string_to_string(tooltip)

    self._ptr.call_with_return(442,tuple([tab_idx, py_string_tooltip._ptr]))

  @functools.native_method
  def get_tab_tooltip(self, tab_idx:'int'   ) -> typing.Union[str]:
    r'''
				Returns the tooltip text of the tab at index `tab_idx`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(443,tuple([tab_idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_tab_text_direction(self, tab_idx:'int'   , direction:'int'  ) -> None:
    r'''
				Sets tab title base writing direction.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert isinstance(direction, (int, float)), 'direction must be int or float'








    self._ptr.call_with_return(444,tuple([tab_idx, direction]))

  @functools.native_method
  def get_tab_text_direction(self, tab_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns tab title text base writing direction.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(445,tuple([tab_idx]))
    return _ret


  @functools.native_method
  def set_tab_language(self, tab_idx:'int'   , language:'str'   ) -> None:
    r'''
				Sets the language code of the title for the tab at index `tab_idx` to `language`. This is used for line-breaking and text shaping algorithms. If `language` is empty, the current locale is used.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'






    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    self._ptr.call_with_return(446,tuple([tab_idx, py_string_language._ptr]))

  @functools.native_method
  def get_tab_language(self, tab_idx:'int'   ) -> typing.Union[str]:
    r'''
				Returns tab title language code.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(447,tuple([tab_idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_tab_icon(self, tab_idx:'int'   , icon:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets an `icon` for the tab at index `tab_idx`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'








    self._ptr.call_with_return(448,tuple([tab_idx, icon._ptr]))

  @functools.native_method
  def get_tab_icon(self, tab_idx:'int'   ) -> typing.Any:
    r'''
				Returns the icon for the tab at index `tab_idx` or `null` if the tab has no icon.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(449,tuple([tab_idx]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_tab_icon_max_width(self, tab_idx:'int'   , width:'int'   ) -> None:
    r'''
				Sets the maximum allowed width of the icon for the tab at index `tab_idx`. This limit is applied on top of the default size of the icon and on top of `theme_item icon_max_width`. The height is adjusted according to the icon's ratio.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert isinstance(width, (int, float)), 'width must be int or float'








    self._ptr.call_with_return(450,tuple([tab_idx, width]))

  @functools.native_method
  def get_tab_icon_max_width(self, tab_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the maximum allowed width of the icon for the tab at index `tab_idx`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(451,tuple([tab_idx]))
    return _ret


  @functools.native_method
  def set_tab_button_icon(self, tab_idx:'int'   , icon:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets an `icon` for the button of the tab at index `tab_idx` (located to the right, before the close button), making it visible and clickable (See `signal tab_button_pressed`). Giving it a `null` value will hide the button.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'








    self._ptr.call_with_return(452,tuple([tab_idx, icon._ptr]))

  @functools.native_method
  def get_tab_button_icon(self, tab_idx:'int'   ) -> typing.Any:
    r'''
				Returns the icon for the right button of the tab at index `tab_idx` or `null` if the right button has no icon.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(453,tuple([tab_idx]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_tab_disabled(self, tab_idx:'int'   , disabled:'bool'   ) -> None:
    r'''
				If `disabled` is `true`, disables the tab at index `tab_idx`, making it non-interactable.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert isinstance(disabled, bool), 'disabled must be bool'








    self._ptr.call_with_return(454,tuple([tab_idx, disabled]))

  @functools.native_method
  def is_tab_disabled(self, tab_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the tab at index `tab_idx` is disabled.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(455,tuple([tab_idx]))
    return _ret


  @functools.native_method
  def set_tab_hidden(self, tab_idx:'int'   , hidden:'bool'   ) -> None:
    r'''
				If `hidden` is `true`, hides the tab at index `tab_idx`, making it disappear from the tab area.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    assert isinstance(hidden, bool), 'hidden must be bool'








    self._ptr.call_with_return(456,tuple([tab_idx, hidden]))

  @functools.native_method
  def is_tab_hidden(self, tab_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the tab at index `tab_idx` is hidden.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(457,tuple([tab_idx]))
    return _ret


  @functools.native_method
  def set_tab_metadata(self, tab_idx:'int'   , metadata:'object'   ) -> None:
    r'''
				Sets the metadata value for the tab at index `tab_idx`, which can be retrieved later using `get_tab_metadata`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'
    

    if not (type(metadata).__name__ in py4godot.variant_types.core_types or isinstance(metadata, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'metadata': "
                f"{type(metadata).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    self._ptr.call_with_return(458,tuple([tab_idx, metadata]))

  @functools.native_method
  def get_tab_metadata(self, tab_idx:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the metadata value set to the tab at index `tab_idx` using `set_tab_metadata`. If no metadata was previously set, returns `null` by default.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = None
    _ret = self._ptr.call_with_return(459,tuple([tab_idx]))
    return _ret


  @functools.native_method
  def remove_tab(self, tab_idx:'int'   ) -> None:
    r'''
				Removes the tab at index `tab_idx`.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    self._ptr.call_with_return(460,tuple([tab_idx]))

  @functools.native_method
  def add_tab(self, title:'str' =""  , icon:'py4godot_texture2d.Texture2D' = None  ) -> None:
    r'''
				Adds a new tab.
			'''
    if title is None:
      title = String.new0()
    if icon is None:
      icon = c_utils.empty_object






    assert(isinstance(title, (str, String)))
    py_string_title = title if isinstance(title, StringName) else c_utils.py_string_to_string(title)


    self._ptr.call_with_return(461,tuple([py_string_title._ptr, icon._ptr]))

  @functools.native_method
  def get_tab_idx_at_point(self, point:'Vector2'   ) -> typing.Union[int]:
    r'''
				Returns the index of the tab at local coordinates `point`. Returns `-1` if the point is outside the control boundaries or if there's no tab at the queried position.
			'''

    assert(not point is None)
    assert isinstance(point, Vector2), 'point must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(462,tuple([point._ptr]))
    return _ret


  @functools.native_method
  def set_tab_alignment(self, alignment:'int'  ) -> None:
    r''''''

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'


    self.py__tab_alignment = alignment






    self._ptr.call_with_return(463,tuple([alignment]))

  @functools.native_method
  def get_tab_alignment(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(464,tuple([]))

    return _ret


  @functools.native_method
  def set_clip_tabs(self, clip_tabs:'bool'   ) -> None:
    r''''''

    assert isinstance(clip_tabs, bool), 'clip_tabs must be bool'


    self.py__clip_tabs = clip_tabs






    self._ptr.call_with_return(465,tuple([clip_tabs]))

  @functools.native_method
  def get_clip_tabs(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(466,tuple([]))

    return _ret


  @functools.native_method
  def get_tab_offset(self) -> typing.Union[int]:
    r'''
				Returns the number of hidden tabs offsetted to the left.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(467,tuple([]))
    return _ret


  @functools.native_method
  def get_offset_buttons_visible(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the offset buttons (the ones that appear when there's not enough space for all tabs) are visible.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(468,tuple([]))
    return _ret


  @functools.native_method
  def ensure_tab_visible(self, idx:'int'   ) -> None:
    r'''
				Moves the scroll view to make the tab visible.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    self._ptr.call_with_return(469,tuple([idx]))

  @functools.native_method
  def get_tab_rect(self, tab_idx:'int'   ) -> typing.Union['Rect2']:
    r'''
				Returns tab `Rect2` with local position and size.
			'''

    assert isinstance(tab_idx, (int, float)), 'tab_idx must be int or float'







    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(470,tuple([tab_idx]))
    return _ret


  @functools.native_method
  def move_tab(self, from_:'int'   , to:'int'   ) -> None:
    r'''
				Moves a tab from `from` to `to`.
			'''

    assert isinstance(from_, (int, float)), 'from_ must be int or float'
    assert isinstance(to, (int, float)), 'to must be int or float'








    self._ptr.call_with_return(471,tuple([from_, to]))

  @functools.native_method
  def set_close_with_middle_mouse(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__close_with_middle_mouse = enabled






    self._ptr.call_with_return(472,tuple([enabled]))

  @functools.native_method
  def get_close_with_middle_mouse(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(473,tuple([]))

    return _ret


  @functools.native_method
  def set_tab_close_display_policy(self, policy:'int'  ) -> None:
    r''''''

    assert isinstance(policy, (int, float)), 'policy must be int or float'


    self.py__tab_close_display_policy = policy






    self._ptr.call_with_return(474,tuple([policy]))

  @functools.native_method
  def get_tab_close_display_policy(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(475,tuple([]))

    return _ret


  @functools.native_method
  def set_max_tab_width(self, width:'int'   ) -> None:
    r''''''

    assert isinstance(width, (int, float)), 'width must be int or float'


    self.py__max_tab_width = width






    self._ptr.call_with_return(476,tuple([width]))

  @functools.native_method
  def get_max_tab_width(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(477,tuple([]))

    return _ret


  @functools.native_method
  def set_scrolling_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__scrolling_enabled = enabled






    self._ptr.call_with_return(478,tuple([enabled]))

  @functools.native_method
  def get_scrolling_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(479,tuple([]))

    return _ret


  @functools.native_method
  def set_drag_to_rearrange_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__drag_to_rearrange_enabled = enabled






    self._ptr.call_with_return(480,tuple([enabled]))

  @functools.native_method
  def get_drag_to_rearrange_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(481,tuple([]))

    return _ret


  @functools.native_method
  def set_tabs_rearrange_group(self, group_id:'int'   ) -> None:
    r''''''

    assert isinstance(group_id, (int, float)), 'group_id must be int or float'


    self.py__tabs_rearrange_group = group_id






    self._ptr.call_with_return(482,tuple([group_id]))

  @functools.native_method
  def get_tabs_rearrange_group(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(483,tuple([]))

    return _ret


  @functools.native_method
  def set_scroll_to_selected(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__scroll_to_selected = enabled






    self._ptr.call_with_return(484,tuple([enabled]))

  @functools.native_method
  def get_scroll_to_selected(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(485,tuple([]))

    return _ret


  @functools.native_method
  def set_select_with_rmb(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__select_with_rmb = enabled






    self._ptr.call_with_return(486,tuple([enabled]))

  @functools.native_method
  def get_select_with_rmb(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(487,tuple([]))

    return _ret


  @functools.native_method
  def set_deselect_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__deselect_enabled = enabled






    self._ptr.call_with_return(488,tuple([enabled]))

  @functools.native_method
  def get_deselect_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(489,tuple([]))

    return _ret


  @functools.native_method
  def clear_tabs(self) -> None:
    r'''
				Clears all tabs.
			'''




    self._ptr.call_with_return(490,tuple([]))


register_cast_function('TabBar', TabBar.cast)
register_class('TabBar', TabBar)
