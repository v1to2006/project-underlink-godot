# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.TileSet as py4godot_tileset 
  import py4godot.classes.TileData as py4godot_tiledata 
  import py4godot.classes.TileMapPattern as py4godot_tilemappattern 
  import py4godot.classes.Vector2iTypedArray as py4godot_vector2itypedarray 
import py4godot.classes.Vector2iTypedArray as py4godot_vector2itypedarray 
import py4godot.classes.Node2D as py4godot_node2d 
from py4godot.wrappers.wrappers import CPPTileMapWrapper

class VisibilityMode:
  VISIBILITY_MODE_DEFAULT = 0
  VISIBILITY_MODE_FORCE_HIDE = 2
  VISIBILITY_MODE_FORCE_SHOW = 1


class TileMap(py4godot_node2d.Node2D):
  r'''
		Node for 2D tile-based maps. Tilemaps use a `TileSet` which contain a list of tiles which are used to create grid-based maps. A TileMap may have several layers, layouting tiles on top of each other.
		For performance reasons, all TileMap updates are batched at the end of a frame. Notably, this means that scene tiles from a `TileSetScenesCollectionSource` may be initialized after their parent. This is only queued when inside the scene tree.
		To force an update earlier on, call `update_internals`.
		**Note:** For performance and compatibility reasons, the coordinates serialized by `TileMap` are limited to 16-bit signed integers, i.e. the range for X and Y coordinates is from `-32768` to `32767`. When saving tile data, tiles outside this range are wrapped.
	'''

  @staticmethod
  def constructor():
    class_ = TileMap.construct_without_init()
    class_._ptr = constructor(835,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TileMap.construct_without_init()
    class_._ptr = constructor(835,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTileMapWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(835,0, ())


  def generate_wrapper(self):
    return CPPTileMapWrapper()
  def init_signals(self):
    super().init_signals()
    changed_name = utils.py_string_to_string_name("changed")
    self.changed = signals.BuiltinSignal(self, changed_name)

  @staticmethod
  def construct_without_init():
    cls = TileMap.__new__(TileMap)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TileMap'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TileMap.construct_without_init()
    cls._ptr = CPPTileMapWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TileMap.construct_without_init()
    cls._ptr = CPPTileMapWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def tile_set(self) -> typing.Union['py4godot_tileset.TileSet']:
    r''''''
    _ret = self. get_tileset()
    return _ret
  @tile_set.setter
  def tile_set(self,  value:'py4godot_object.Object'):
    self.set_tileset(value)
  @property
  def rendering_quadrant_size(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_rendering_quadrant_size()
    return _ret
  @rendering_quadrant_size.setter
  def rendering_quadrant_size(self,  value:'int'):
    self.set_rendering_quadrant_size(value)
  @property
  def collision_animatable(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_collision_animatable()
    return _ret
  @collision_animatable.setter
  def collision_animatable(self,  value:'bool'):
    self.set_collision_animatable(value)
  @property
  def collision_visibility_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_collision_visibility_mode()
    return _ret
  @collision_visibility_mode.setter
  def collision_visibility_mode(self,  value:'int'):
    self.set_collision_visibility_mode(value)
  @property
  def navigation_visibility_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_navigation_visibility_mode()
    return _ret
  @navigation_visibility_mode.setter
  def navigation_visibility_mode(self,  value:'int'):
    self.set_navigation_visibility_mode(value)
  @functools.native_method
  def _use_tile_data_runtime_update(self, layer:'int'   , coords:'Vector2i'   ) -> typing.Union[bool]:
    r'''
				Should return `true` if the tile at coordinates `coords` on layer `layer` requires a runtime update.
				**Warning:** Make sure this function only return `true` when needed. Any tile processed at runtime without a need for it will imply a significant performance penalty.
				**Note:** If the result of this function should changed, use `notify_runtime_tile_data_update` to notify the TileMap it needs an update.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not coords is None)
    assert isinstance(coords, Vector2i), 'coords must be Vector2i'








    _ret = 0
    _ret = self._ptr.call_with_return(303,tuple([layer, coords._ptr]))
    return _ret


  @functools.native_method
  def _tile_data_runtime_update(self, layer:'int'   , coords:'Vector2i'   , tile_data:'py4godot_tiledata.TileData'   ) -> None:
    r'''
				Called with a TileData object about to be used internally by the TileMap, allowing its modification at runtime.
				This method is only called if `_use_tile_data_runtime_update` is implemented and returns `true` for the given tile `coords` and `layer`.
				**Warning:** The `tile_data` object's sub-resources are the same as the one in the TileSet. Modifying them might impact the whole TileSet. Instead, make sure to duplicate those resources.
				**Note:** If the properties of `tile_data` object should change over time, use `notify_runtime_tile_data_update` to notify the TileMap it needs an update.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not coords is None)
    assert isinstance(coords, Vector2i), 'coords must be Vector2i'
    assert(not tile_data is None)
    assert isinstance(tile_data, get_class('TileData')), 'tile_data must be TileData'









    self._ptr.call_with_return(304,tuple([layer, coords._ptr, tile_data._ptr]))

  @functools.native_method
  def set_navigation_map(self, layer:'int'   , map:'RID'   ) -> None:
    r'''
				Assigns `map` as a `NavigationServer2D` navigation map for the specified TileMap layer `layer`.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not map is None)
    assert isinstance(map, RID), 'map must be RID'








    self._ptr.call_with_return(305,tuple([layer, map._ptr]))

  @functools.native_method
  def get_navigation_map(self, layer:'int'   ) -> typing.Union['RID']:
    r'''
				Returns the `RID` of the `NavigationServer2D` navigation map assigned to the specified TileMap layer `layer`.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(306,tuple([layer]))
    return _ret


  @functools.native_method
  def force_update(self, layer:'int' =-1  ) -> None:
    r'''
				Forces the TileMap and the layer `layer` to update.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    self._ptr.call_with_return(307,tuple([layer]))

  @functools.native_method
  def set_tileset(self, tileset:'py4godot_tileset.TileSet'   ) -> None:
    r''''''

    assert(not tileset is None)
    assert isinstance(tileset, get_class('TileSet')), 'tileset must be TileSet'


    self.py__tile_set = tileset






    self._ptr.call_with_return(308,tuple([tileset._ptr]))

  @functools.native_method
  def get_tileset(self) -> typing.Union['py4godot_tileset.TileSet']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TileSet
    _ret._ptr = self._ptr.call_with_return(309,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_rendering_quadrant_size(self, size:'int'   ) -> None:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'


    self.py__rendering_quadrant_size = size






    self._ptr.call_with_return(310,tuple([size]))

  @functools.native_method
  def get_rendering_quadrant_size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(311,tuple([]))

    return _ret


  @functools.native_method
  def get_layers_count(self) -> typing.Union[int]:
    r'''
				Returns the number of layers in the TileMap.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(312,tuple([]))
    return _ret


  @functools.native_method
  def add_layer(self, to_position:'int'   ) -> None:
    r'''
				Adds a layer at the given position `to_position` in the array. If `to_position` is negative, the position is counted from the end, with `-1` adding the layer at the end of the array.
			'''

    assert isinstance(to_position, (int, float)), 'to_position must be int or float'







    self._ptr.call_with_return(313,tuple([to_position]))

  @functools.native_method
  def move_layer(self, layer:'int'   , to_position:'int'   ) -> None:
    r'''
				Moves the layer at index `layer` to the given position `to_position` in the array.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(to_position, (int, float)), 'to_position must be int or float'








    self._ptr.call_with_return(314,tuple([layer, to_position]))

  @functools.native_method
  def remove_layer(self, layer:'int'   ) -> None:
    r'''
				Removes the layer at index `layer`.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    self._ptr.call_with_return(315,tuple([layer]))

  @functools.native_method
  def set_layer_name(self, layer:'int'   , name:'str'   ) -> None:
    r'''
				Sets a layer's name. This is mostly useful in the editor.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(316,tuple([layer, py_string_name._ptr]))

  @functools.native_method
  def get_layer_name(self, layer:'int'   ) -> typing.Union[str]:
    r'''
				Returns a TileMap layer's name.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(317,tuple([layer]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_layer_enabled(self, layer:'int'   , enabled:'bool'   ) -> None:
    r'''
				Enables or disables the layer `layer`. A disabled layer is not processed at all (no rendering, no physics, etc.).
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(318,tuple([layer, enabled]))

  @functools.native_method
  def is_layer_enabled(self, layer:'int'   ) -> typing.Union[bool]:
    r'''
				Returns if a layer is enabled.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(319,tuple([layer]))
    return _ret


  @functools.native_method
  def set_layer_modulate(self, layer:'int'   , modulate:'Color'   ) -> None:
    r'''
				Sets a layer's color. It will be multiplied by tile's color and TileMap's modulate.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not modulate is None)
    assert isinstance(modulate, Color), 'modulate must be Color'








    self._ptr.call_with_return(320,tuple([layer, modulate._ptr]))

  @functools.native_method
  def get_layer_modulate(self, layer:'int'   ) -> typing.Union['Color']:
    r'''
				Returns a TileMap layer's modulate.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(321,tuple([layer]))
    return _ret


  @functools.native_method
  def set_layer_y_sort_enabled(self, layer:'int'   , y_sort_enabled:'bool'   ) -> None:
    r'''
				Enables or disables a layer's Y-sorting. If a layer is Y-sorted, the layer will behave as a CanvasItem node where each of its tile gets Y-sorted.
				Y-sorted layers should usually be on different Z-index values than not Y-sorted layers, otherwise, each of those layer will be Y-sorted as whole with the Y-sorted one. This is usually an undesired behavior.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(y_sort_enabled, bool), 'y_sort_enabled must be bool'








    self._ptr.call_with_return(322,tuple([layer, y_sort_enabled]))

  @functools.native_method
  def is_layer_y_sort_enabled(self, layer:'int'   ) -> typing.Union[bool]:
    r'''
				Returns if a layer Y-sorts its tiles.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(323,tuple([layer]))
    return _ret


  @functools.native_method
  def set_layer_y_sort_origin(self, layer:'int'   , y_sort_origin:'int'   ) -> None:
    r'''
				Sets a layer's Y-sort origin value. This Y-sort origin value is added to each tile's Y-sort origin value.
				This allows, for example, to fake a different height level on each layer. This can be useful for top-down view games.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(y_sort_origin, (int, float)), 'y_sort_origin must be int or float'








    self._ptr.call_with_return(324,tuple([layer, y_sort_origin]))

  @functools.native_method
  def get_layer_y_sort_origin(self, layer:'int'   ) -> typing.Union[int]:
    r'''
				Returns a TileMap layer's Y sort origin.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(325,tuple([layer]))
    return _ret


  @functools.native_method
  def set_layer_z_index(self, layer:'int'   , z_index:'int'   ) -> None:
    r'''
				Sets a layers Z-index value. This Z-index is added to each tile's Z-index value.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(z_index, (int, float)), 'z_index must be int or float'








    self._ptr.call_with_return(326,tuple([layer, z_index]))

  @functools.native_method
  def get_layer_z_index(self, layer:'int'   ) -> typing.Union[int]:
    r'''
				Returns a TileMap layer's Z-index value.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(327,tuple([layer]))
    return _ret


  @functools.native_method
  def set_layer_navigation_enabled(self, layer:'int'   , enabled:'bool'   ) -> None:
    r'''
				Enables or disables a layer's built-in navigation regions generation. Disable this if you need to bake navigation regions from a TileMap using a `NavigationRegion2D` node.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(328,tuple([layer, enabled]))

  @functools.native_method
  def is_layer_navigation_enabled(self, layer:'int'   ) -> typing.Union[bool]:
    r'''
				Returns if a layer's built-in navigation regions generation is enabled.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(329,tuple([layer]))
    return _ret


  @functools.native_method
  def set_layer_navigation_map(self, layer:'int'   , map:'RID'   ) -> None:
    r'''
				Assigns `map` as a `NavigationServer2D` navigation map for the specified TileMap layer `layer`.
				By default the TileMap uses the default `World2D` navigation map for the first TileMap layer. For each additional TileMap layer a new navigation map is created for the additional layer.
				In order to make `NavigationAgent2D` switch between TileMap layer navigation maps use `NavigationAgent2D.set_navigation_map` with the navigation map received from `get_layer_navigation_map`.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not map is None)
    assert isinstance(map, RID), 'map must be RID'








    self._ptr.call_with_return(330,tuple([layer, map._ptr]))

  @functools.native_method
  def get_layer_navigation_map(self, layer:'int'   ) -> typing.Union['RID']:
    r'''
				Returns the `RID` of the `NavigationServer2D` navigation map assigned to the specified TileMap layer `layer`.
				By default the TileMap uses the default `World2D` navigation map for the first TileMap layer. For each additional TileMap layer a new navigation map is created for the additional layer.
				In order to make `NavigationAgent2D` switch between TileMap layer navigation maps use `NavigationAgent2D.set_navigation_map` with the navigation map received from `get_layer_navigation_map`.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(331,tuple([layer]))
    return _ret


  @functools.native_method
  def set_collision_animatable(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__collision_animatable = enabled






    self._ptr.call_with_return(332,tuple([enabled]))

  @functools.native_method
  def is_collision_animatable(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(333,tuple([]))

    return _ret


  @functools.native_method
  def set_collision_visibility_mode(self, collision_visibility_mode:'int'  ) -> None:
    r''''''

    assert isinstance(collision_visibility_mode, (int, float)), 'collision_visibility_mode must be int or float'


    self.py__collision_visibility_mode = collision_visibility_mode






    self._ptr.call_with_return(334,tuple([collision_visibility_mode]))

  @functools.native_method
  def get_collision_visibility_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(335,tuple([]))

    return _ret


  @functools.native_method
  def set_navigation_visibility_mode(self, navigation_visibility_mode:'int'  ) -> None:
    r''''''

    assert isinstance(navigation_visibility_mode, (int, float)), 'navigation_visibility_mode must be int or float'


    self.py__navigation_visibility_mode = navigation_visibility_mode






    self._ptr.call_with_return(336,tuple([navigation_visibility_mode]))

  @functools.native_method
  def get_navigation_visibility_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(337,tuple([]))

    return _ret


  @functools.native_method
  def set_cell(self, layer:'int'   , coords:'Vector2i'   , source_id:'int' =-1  , atlas_coords:'Vector2i' = None  , alternative_tile:'int' =0  ) -> None:
    r'''
				Sets the tile identifiers for the cell on layer `layer` at coordinates `coords`. Each tile of the `TileSet` is identified using three parts:
				- The source identifier `source_id` identifies a `TileSetSource` identifier. See `TileSet.set_source_id`,
				- The atlas coordinates identifier `atlas_coords` identifies a tile coordinates in the atlas (if the source is a `TileSetAtlasSource`). For `TileSetScenesCollectionSource` it should always be `Vector2i(0, 0)`),
				- The alternative tile identifier `alternative_tile` identifies a tile alternative in the atlas (if the source is a `TileSetAtlasSource`), and the scene for a `TileSetScenesCollectionSource`.
				If `source_id` is set to `-1`, `atlas_coords` to `Vector2i(-1, -1)` or `alternative_tile` to `-1`, the cell will be erased. An erased cell gets **all** its identifiers automatically set to their respective invalid values, namely `-1`, `Vector2i(-1, -1)` and `-1`.
				If `layer` is negative, the layers are accessed from the last one.
			'''
    if atlas_coords is None:
      atlas_coords = Vector2i.new0()

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not coords is None)
    assert isinstance(coords, Vector2i), 'coords must be Vector2i'
    assert isinstance(source_id, (int, float)), 'source_id must be int or float'
    assert isinstance(alternative_tile, (int, float)), 'alternative_tile must be int or float'











    self._ptr.call_with_return(338,tuple([layer, coords._ptr, source_id, atlas_coords._ptr, alternative_tile]))

  @functools.native_method
  def erase_cell(self, layer:'int'   , coords:'Vector2i'   ) -> None:
    r'''
				Erases the cell on layer `layer` at coordinates `coords`.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not coords is None)
    assert isinstance(coords, Vector2i), 'coords must be Vector2i'








    self._ptr.call_with_return(339,tuple([layer, coords._ptr]))

  @functools.native_method
  def get_cell_source_id(self, layer:'int'   , coords:'Vector2i'   , use_proxies:'bool' =False  ) -> typing.Union[int]:
    r'''
				Returns the tile source ID of the cell on layer `layer` at coordinates `coords`. Returns `-1` if the cell does not exist.
				If `use_proxies` is `false`, ignores the `TileSet`'s tile proxies, returning the raw source identifier. See `TileSet.map_tile_proxy`.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not coords is None)
    assert isinstance(coords, Vector2i), 'coords must be Vector2i'
    assert isinstance(use_proxies, bool), 'use_proxies must be bool'









    _ret = 0
    _ret = self._ptr.call_with_return(340,tuple([layer, coords._ptr, use_proxies]))
    return _ret


  @functools.native_method
  def get_cell_atlas_coords(self, layer:'int'   , coords:'Vector2i'   , use_proxies:'bool' =False  ) -> typing.Union['Vector2i']:
    r'''
				Returns the tile atlas coordinates ID of the cell on layer `layer` at coordinates `coords`. Returns `Vector2i(-1, -1)` if the cell does not exist.
				If `use_proxies` is `false`, ignores the `TileSet`'s tile proxies, returning the raw atlas coordinate identifier. See `TileSet.map_tile_proxy`.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not coords is None)
    assert isinstance(coords, Vector2i), 'coords must be Vector2i'
    assert isinstance(use_proxies, bool), 'use_proxies must be bool'









    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(341,tuple([layer, coords._ptr, use_proxies]))
    return _ret


  @functools.native_method
  def get_cell_alternative_tile(self, layer:'int'   , coords:'Vector2i'   , use_proxies:'bool' =False  ) -> typing.Union[int]:
    r'''
				Returns the tile alternative ID of the cell on layer `layer` at `coords`.
				If `use_proxies` is `false`, ignores the `TileSet`'s tile proxies, returning the raw alternative identifier. See `TileSet.map_tile_proxy`.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not coords is None)
    assert isinstance(coords, Vector2i), 'coords must be Vector2i'
    assert isinstance(use_proxies, bool), 'use_proxies must be bool'









    _ret = 0
    _ret = self._ptr.call_with_return(342,tuple([layer, coords._ptr, use_proxies]))
    return _ret


  @functools.native_method
  def get_cell_tile_data(self, layer:'int'   , coords:'Vector2i'   , use_proxies:'bool' =False  ) -> typing.Union['py4godot_tiledata.TileData']:
    r'''
				Returns the `TileData` object associated with the given cell, or `null` if the cell does not exist or is not a `TileSetAtlasSource`.
				If `layer` is negative, the layers are accessed from the last one.
				```gdscript
				func get_clicked_tile_power():
					var clicked_cell = tile_map.local_to_map(tile_map.get_local_mouse_position())
					var data = tile_map.get_cell_tile_data(0, clicked_cell)
					if data:
						return data.get_custom_data("power")
					else:
						return 0
				```
				If `use_proxies` is `false`, ignores the `TileSet`'s tile proxies. See `TileSet.map_tile_proxy`.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not coords is None)
    assert isinstance(coords, Vector2i), 'coords must be Vector2i'
    assert isinstance(use_proxies, bool), 'use_proxies must be bool'









    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TileData
    _ret._ptr = self._ptr.call_with_return(343,tuple([layer, coords._ptr, use_proxies]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def is_cell_flipped_h(self, layer:'int'   , coords:'Vector2i'   , use_proxies:'bool' =False  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the cell on layer `layer` at coordinates `coords` is flipped horizontally. The result is valid only for atlas sources.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not coords is None)
    assert isinstance(coords, Vector2i), 'coords must be Vector2i'
    assert isinstance(use_proxies, bool), 'use_proxies must be bool'









    _ret = 0
    _ret = self._ptr.call_with_return(344,tuple([layer, coords._ptr, use_proxies]))
    return _ret


  @functools.native_method
  def is_cell_flipped_v(self, layer:'int'   , coords:'Vector2i'   , use_proxies:'bool' =False  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the cell on layer `layer` at coordinates `coords` is flipped vertically. The result is valid only for atlas sources.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not coords is None)
    assert isinstance(coords, Vector2i), 'coords must be Vector2i'
    assert isinstance(use_proxies, bool), 'use_proxies must be bool'









    _ret = 0
    _ret = self._ptr.call_with_return(345,tuple([layer, coords._ptr, use_proxies]))
    return _ret


  @functools.native_method
  def is_cell_transposed(self, layer:'int'   , coords:'Vector2i'   , use_proxies:'bool' =False  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the cell on layer `layer` at coordinates `coords` is transposed. The result is valid only for atlas sources.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not coords is None)
    assert isinstance(coords, Vector2i), 'coords must be Vector2i'
    assert isinstance(use_proxies, bool), 'use_proxies must be bool'









    _ret = 0
    _ret = self._ptr.call_with_return(346,tuple([layer, coords._ptr, use_proxies]))
    return _ret


  @functools.native_method
  def get_coords_for_body_rid(self, body:'RID'   ) -> typing.Union['Vector2i']:
    r'''
				Returns the coordinates of the tile for given physics body RID. Such RID can be retrieved from `KinematicCollision2D.get_collider_rid`, when colliding with a tile.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(347,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def get_layer_for_body_rid(self, body:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the tilemap layer of the tile for given physics body RID. Such RID can be retrieved from `KinematicCollision2D.get_collider_rid`, when colliding with a tile.
			'''

    assert(not body is None)
    assert isinstance(body, RID), 'body must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(348,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def get_pattern(self, layer:'int'   , coords_array:'py4godot_vector2itypedarray.Vector2iTypedArray'   ) -> typing.Union['py4godot_tilemappattern.TileMapPattern']:
    r'''
				Creates a new `TileMapPattern` from the given layer and set of cells.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(coords_array, Array), 'coords_array must be Array'








    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TileMapPattern
    _ret._ptr = self._ptr.call_with_return(349,tuple([layer, coords_array._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def map_pattern(self, position_in_tilemap:'Vector2i'   , coords_in_pattern:'Vector2i'   , pattern:'py4godot_tilemappattern.TileMapPattern'   ) -> typing.Union['Vector2i']:
    r'''
				Returns for the given coordinate `coords_in_pattern` in a `TileMapPattern` the corresponding cell coordinates if the pattern was pasted at the `position_in_tilemap` coordinates (see `set_pattern`). This mapping is required as in half-offset tile shapes, the mapping might not work by calculating `position_in_tile_map + coords_in_pattern`.
			'''

    assert(not position_in_tilemap is None)
    assert isinstance(position_in_tilemap, Vector2i), 'position_in_tilemap must be Vector2i'
    assert(not coords_in_pattern is None)
    assert isinstance(coords_in_pattern, Vector2i), 'coords_in_pattern must be Vector2i'
    assert(not pattern is None)
    assert isinstance(pattern, get_class('TileMapPattern')), 'pattern must be TileMapPattern'









    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(350,tuple([position_in_tilemap._ptr, coords_in_pattern._ptr, pattern._ptr]))
    return _ret


  @functools.native_method
  def set_pattern(self, layer:'int'   , position:'Vector2i'   , pattern:'py4godot_tilemappattern.TileMapPattern'   ) -> None:
    r'''
				Paste the given `TileMapPattern` at the given `position` and `layer` in the tile map.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'
    assert(not pattern is None)
    assert isinstance(pattern, get_class('TileMapPattern')), 'pattern must be TileMapPattern'









    self._ptr.call_with_return(351,tuple([layer, position._ptr, pattern._ptr]))

  @functools.native_method
  def set_cells_terrain_connect(self, layer:'int'   , cells:'py4godot_vector2itypedarray.Vector2iTypedArray'   , terrain_set:'int'   , terrain:'int'   , ignore_empty_terrains:'bool' =True  ) -> None:
    r'''
				Update all the cells in the `cells` coordinates array so that they use the given `terrain` for the given `terrain_set`. If an updated cell has the same terrain as one of its neighboring cells, this function tries to join the two. This function might update neighboring tiles if needed to create correct terrain transitions.
				If `ignore_empty_terrains` is `true`, empty terrains will be ignored when trying to find the best fitting tile for the given terrain constraints.
				If `layer` is negative, the layers are accessed from the last one.
				**Note:** To work correctly, this method requires the TileMap's TileSet to have terrains set up with all required terrain combinations. Otherwise, it may produce unexpected results.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(cells, Array), 'cells must be Array'
    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'
    assert isinstance(terrain, (int, float)), 'terrain must be int or float'
    assert isinstance(ignore_empty_terrains, bool), 'ignore_empty_terrains must be bool'











    self._ptr.call_with_return(352,tuple([layer, cells._ptr, terrain_set, terrain, ignore_empty_terrains]))

  @functools.native_method
  def set_cells_terrain_path(self, layer:'int'   , path:'py4godot_vector2itypedarray.Vector2iTypedArray'   , terrain_set:'int'   , terrain:'int'   , ignore_empty_terrains:'bool' =True  ) -> None:
    r'''
				Update all the cells in the `path` coordinates array so that they use the given `terrain` for the given `terrain_set`. The function will also connect two successive cell in the path with the same terrain. This function might update neighboring tiles if needed to create correct terrain transitions.
				If `ignore_empty_terrains` is `true`, empty terrains will be ignored when trying to find the best fitting tile for the given terrain constraints.
				If `layer` is negative, the layers are accessed from the last one.
				**Note:** To work correctly, this method requires the TileMap's TileSet to have terrains set up with all required terrain combinations. Otherwise, it may produce unexpected results.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(path, Array), 'path must be Array'
    assert isinstance(terrain_set, (int, float)), 'terrain_set must be int or float'
    assert isinstance(terrain, (int, float)), 'terrain must be int or float'
    assert isinstance(ignore_empty_terrains, bool), 'ignore_empty_terrains must be bool'











    self._ptr.call_with_return(353,tuple([layer, path._ptr, terrain_set, terrain, ignore_empty_terrains]))

  @functools.native_method
  def fix_invalid_tiles(self) -> None:
    r'''
				Clears cells that do not exist in the tileset.
			'''




    self._ptr.call_with_return(354,tuple([]))

  @functools.native_method
  def clear_layer(self, layer:'int'   ) -> None:
    r'''
				Clears all cells on the given layer.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    self._ptr.call_with_return(355,tuple([layer]))

  @functools.native_method
  def clear(self) -> None:
    r'''
				Clears all cells.
			'''




    self._ptr.call_with_return(356,tuple([]))

  @functools.native_method
  def update_internals(self) -> None:
    r'''
				Triggers a direct update of the TileMap. Usually, calling this function is not needed, as TileMap node updates automatically when one of its properties or cells is modified.
				However, for performance reasons, those updates are batched and delayed to the end of the frame. Calling this function will force the TileMap to update right away instead.
				**Warning:** Updating the TileMap is computationally expensive and may impact performance. Try to limit the number of updates and how many tiles they impact.
			'''




    self._ptr.call_with_return(357,tuple([]))

  @functools.native_method
  def notify_runtime_tile_data_update(self, layer:'int' =-1  ) -> None:
    r'''
				Notifies the TileMap node that calls to `_use_tile_data_runtime_update` or `_tile_data_runtime_update` will lead to different results. This will thus trigger a TileMap update.
				If `layer` is provided, only notifies changes for the given layer. Providing the `layer` argument (when applicable) is usually preferred for performance reasons.
				**Warning:** Updating the TileMap is computationally expensive and may impact performance. Try to limit the number of calls to this function to avoid unnecessary update.
				**Note:** This does not trigger a direct update of the TileMap, the update will be done at the end of the frame as usual (unless you call `update_internals`).
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    self._ptr.call_with_return(358,tuple([layer]))

  @functools.native_method
  def get_surrounding_cells(self, coords:'Vector2i'   ) -> typing.Union['py4godot_vector2itypedarray.Vector2iTypedArray']:
    r'''
				Returns the list of all neighbourings cells to the one at `coords`.
			'''

    assert(not coords is None)
    assert isinstance(coords, Vector2i), 'coords must be Vector2i'







    _ret = py4godot_vector2itypedarray.Vector2iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(359,tuple([coords._ptr]))
    return _ret


  @functools.native_method
  def get_used_cells(self, layer:'int'   ) -> typing.Union['py4godot_vector2itypedarray.Vector2iTypedArray']:
    r'''
				Returns a `Vector2i` array with the positions of all cells containing a tile in the given layer. A cell is considered empty if its source identifier equals -1, its atlas coordinates identifiers is `Vector2(-1, -1)` and its alternative identifier is -1.
				If `layer` is negative, the layers are accessed from the last one.
			'''

    assert isinstance(layer, (int, float)), 'layer must be int or float'







    _ret = py4godot_vector2itypedarray.Vector2iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(360,tuple([layer]))
    return _ret


  @functools.native_method
  def get_used_cells_by_id(self, layer:'int'   , source_id:'int' =-1  , atlas_coords:'Vector2i' = None  , alternative_tile:'int' =-1  ) -> typing.Union['py4godot_vector2itypedarray.Vector2iTypedArray']:
    r'''
				Returns a `Vector2i` array with the positions of all cells containing a tile in the given layer. Tiles may be filtered according to their source (`source_id`), their atlas coordinates (`atlas_coords`) or alternative id (`alternative_tile`).
				If a parameter has its value set to the default one, this parameter is not used to filter a cell. Thus, if all parameters have their respective default value, this method returns the same result as `get_used_cells`.
				A cell is considered empty if its source identifier equals -1, its atlas coordinates identifiers is `Vector2(-1, -1)` and its alternative identifier is -1.
				If `layer` is negative, the layers are accessed from the last one.
			'''
    if atlas_coords is None:
      atlas_coords = Vector2i.new0()

    assert isinstance(layer, (int, float)), 'layer must be int or float'
    assert isinstance(source_id, (int, float)), 'source_id must be int or float'
    assert isinstance(alternative_tile, (int, float)), 'alternative_tile must be int or float'










    _ret = py4godot_vector2itypedarray.Vector2iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(361,tuple([layer, source_id, atlas_coords._ptr, alternative_tile]))
    return _ret


  @functools.native_method
  def get_used_rect(self) -> typing.Union['Rect2i']:
    r'''
				Returns a rectangle enclosing the used (non-empty) tiles of the map, including all layers.
			'''




    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(362,tuple([]))
    return _ret


  @functools.native_method
  def map_to_local(self, map_position:'Vector2i'   ) -> typing.Union['Vector2']:
    r'''
				Returns the centered position of a cell in the TileMap's local coordinate space. To convert the returned value into global coordinates, use `Node2D.to_global`. See also `local_to_map`.
				**Note:** This may not correspond to the visual position of the tile, i.e. it ignores the `TileData.texture_origin` property of individual tiles.
			'''

    assert(not map_position is None)
    assert isinstance(map_position, Vector2i), 'map_position must be Vector2i'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(363,tuple([map_position._ptr]))
    return _ret


  @functools.native_method
  def local_to_map(self, local_position:'Vector2'   ) -> typing.Union['Vector2i']:
    r'''
				Returns the map coordinates of the cell containing the given `local_position`. If `local_position` is in global coordinates, consider using `Node2D.to_local` before passing it to this method. See also `map_to_local`.
			'''

    assert(not local_position is None)
    assert isinstance(local_position, Vector2), 'local_position must be Vector2'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(364,tuple([local_position._ptr]))
    return _ret


  @functools.native_method
  def get_neighbor_cell(self, coords:'Vector2i'   , neighbor:'int'  ) -> typing.Union['Vector2i']:
    r'''
				Returns the neighboring cell to the one at coordinates `coords`, identified by the `neighbor` direction. This method takes into account the different layouts a TileMap can take.
			'''

    assert(not coords is None)
    assert isinstance(coords, Vector2i), 'coords must be Vector2i'
    assert isinstance(neighbor, (int, float)), 'neighbor must be int or float'








    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(365,tuple([coords._ptr, neighbor]))
    return _ret



register_cast_function('TileMap', TileMap.cast)
register_class('TileMap', TileMap)
