# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPTranslationWrapper


class Translation(py4godot_resource.Resource):
  r'''
		`Translation` maps a collection of strings to their individual translations, and also provides convenience methods for pluralization.
		A `Translation` consists of messages. A message is identified by its context and untranslated string. Unlike `url=https://www.gnu.org/software/gettext/`gettext`/url`, using an empty context string in Godot means not using any context.
	'''

  @staticmethod
  def constructor():
    class_ = Translation.construct_without_init()
    class_._ptr = constructor(846,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Translation.construct_without_init()
    class_._ptr = constructor(846,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTranslationWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(846,0, ())


  def generate_wrapper(self):
    return CPPTranslationWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Translation.__new__(Translation)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Translation'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(89, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Translation.construct_without_init()
    cls._ptr = CPPTranslationWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Translation.construct_without_init()
    cls._ptr = CPPTranslationWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def messages(self) -> typing.Union['Dictionary']:
    r''''''
    _ret = self. _get_messages()
    return _ret
  @messages.setter
  def messages(self,  value:'Dictionary'):
    self._set_messages(value)
  @property
  def locale(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_locale()
    return _ret
  @locale.setter
  def locale(self,  value:'str'):
    self.set_locale(value)
  @functools.native_method
  def _get_plural_message(self, src_message:'object'   , src_plural_message:'object'   , n:'int'   , context:'object'   ) -> typing.Union['StringName']:
    r'''
				Virtual method to override `get_plural_message`.
			'''

    assert(not src_message is None)
    assert isinstance(src_message, (str, StringName)), 'src_message must be str or StringName'
    assert(not src_plural_message is None)
    assert isinstance(src_plural_message, (str, StringName)), 'src_plural_message must be str or StringName'
    assert isinstance(n, (int, float)), 'n must be int or float'
    assert(not context is None)
    assert isinstance(context, (str, StringName)), 'context must be str or StringName'





    assert(isinstance(src_message, (str, StringName)))
    py_stringname_src_message = src_message if isinstance(src_message, StringName) else c_utils.py_string_to_string_name(src_message)
    assert(isinstance(src_plural_message, (str, StringName)))
    py_stringname_src_plural_message = src_plural_message if isinstance(src_plural_message, StringName) else c_utils.py_string_to_string_name(src_plural_message)

    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(77,tuple([py_stringname_src_message._ptr, py_stringname_src_plural_message._ptr, n, py_stringname_context._ptr]))
    return str(_ret)


  @functools.native_method
  def _get_message(self, src_message:'object'   , context:'object'   ) -> typing.Union['StringName']:
    r'''
				Virtual method to override `get_message`.
			'''

    assert(not src_message is None)
    assert isinstance(src_message, (str, StringName)), 'src_message must be str or StringName'
    assert(not context is None)
    assert isinstance(context, (str, StringName)), 'context must be str or StringName'





    assert(isinstance(src_message, (str, StringName)))
    py_stringname_src_message = src_message if isinstance(src_message, StringName) else c_utils.py_string_to_string_name(src_message)
    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([py_stringname_src_message._ptr, py_stringname_context._ptr]))
    return str(_ret)


  @functools.native_method
  def set_locale(self, locale:'str'   ) -> None:
    r''''''

    assert(not locale is None)
    assert isinstance(locale, (str, String)), 'locale must be str or String'


    self.py__locale = locale



    assert(isinstance(locale, (str, String)))
    py_string_locale = locale if isinstance(locale, StringName) else c_utils.py_string_to_string(locale)

    py__string_locale = utils.py_string_to_string(locale)
    py__string_locale.shouldBeDeleted = False


    self._ptr.call_with_return(79,tuple([py__string_locale._ptr]))

  @functools.native_method
  def get_locale(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def add_message(self, src_message:'object'   , xlated_message:'object'   , context:'object' = None  ) -> None:
    r'''
				Adds a message if nonexistent, followed by its translation.
				An additional context could be used to specify the translation context or differentiate polysemic words.
			'''
    if context is None:
      context = StringName.new0()

    assert(not src_message is None)
    assert isinstance(src_message, (str, StringName)), 'src_message must be str or StringName'
    assert(not xlated_message is None)
    assert isinstance(xlated_message, (str, StringName)), 'xlated_message must be str or StringName'





    assert(isinstance(src_message, (str, StringName)))
    py_stringname_src_message = src_message if isinstance(src_message, StringName) else c_utils.py_string_to_string_name(src_message)
    assert(isinstance(xlated_message, (str, StringName)))
    py_stringname_xlated_message = xlated_message if isinstance(xlated_message, StringName) else c_utils.py_string_to_string_name(xlated_message)
    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    self._ptr.call_with_return(81,tuple([py_stringname_src_message._ptr, py_stringname_xlated_message._ptr, py_stringname_context._ptr]))

  @functools.native_method
  def add_plural_message(self, src_message:'object'   , xlated_messages:'PackedStringArray'   , context:'object' = None  ) -> None:
    r'''
				Adds a message involving plural translation if nonexistent, followed by its translation.
				An additional context could be used to specify the translation context or differentiate polysemic words.
			'''
    if context is None:
      context = StringName.new0()

    assert(not src_message is None)
    assert isinstance(src_message, (str, StringName)), 'src_message must be str or StringName'
    assert(not xlated_messages is None)
    assert isinstance(xlated_messages, PackedStringArray), 'xlated_messages must be PackedStringArray'





    assert(isinstance(src_message, (str, StringName)))
    py_stringname_src_message = src_message if isinstance(src_message, StringName) else c_utils.py_string_to_string_name(src_message)

    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    self._ptr.call_with_return(82,tuple([py_stringname_src_message._ptr, xlated_messages._ptr, py_stringname_context._ptr]))

  @functools.native_method
  def get_message(self, src_message:'object'   , context:'object' = None  ) -> typing.Union['StringName']:
    r'''
				Returns a message's translation.
			'''
    if context is None:
      context = StringName.new0()

    assert(not src_message is None)
    assert isinstance(src_message, (str, StringName)), 'src_message must be str or StringName'





    assert(isinstance(src_message, (str, StringName)))
    py_stringname_src_message = src_message if isinstance(src_message, StringName) else c_utils.py_string_to_string_name(src_message)
    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(83,tuple([py_stringname_src_message._ptr, py_stringname_context._ptr]))
    return str(_ret)


  @functools.native_method
  def get_plural_message(self, src_message:'object'   , src_plural_message:'object'   , n:'int'   , context:'object' = None  ) -> typing.Union['StringName']:
    r'''
				Returns a message's translation involving plurals.
				The number `n` is the number or quantity of the plural object. It will be used to guide the translation system to fetch the correct plural form for the selected language.
				**Note:** Plurals are only supported in `url=$DOCS_URL/tutorials/i18n/localization_using_gettext.html`gettext-based translations (PO)`/url`, not CSV.
			'''
    if context is None:
      context = StringName.new0()

    assert(not src_message is None)
    assert isinstance(src_message, (str, StringName)), 'src_message must be str or StringName'
    assert(not src_plural_message is None)
    assert isinstance(src_plural_message, (str, StringName)), 'src_plural_message must be str or StringName'
    assert isinstance(n, (int, float)), 'n must be int or float'





    assert(isinstance(src_message, (str, StringName)))
    py_stringname_src_message = src_message if isinstance(src_message, StringName) else c_utils.py_string_to_string_name(src_message)
    assert(isinstance(src_plural_message, (str, StringName)))
    py_stringname_src_plural_message = src_plural_message if isinstance(src_plural_message, StringName) else c_utils.py_string_to_string_name(src_plural_message)

    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(84,tuple([py_stringname_src_message._ptr, py_stringname_src_plural_message._ptr, n, py_stringname_context._ptr]))
    return str(_ret)


  @functools.native_method
  def erase_message(self, src_message:'object'   , context:'object' = None  ) -> None:
    r'''
				Erases a message.
			'''
    if context is None:
      context = StringName.new0()

    assert(not src_message is None)
    assert isinstance(src_message, (str, StringName)), 'src_message must be str or StringName'





    assert(isinstance(src_message, (str, StringName)))
    py_stringname_src_message = src_message if isinstance(src_message, StringName) else c_utils.py_string_to_string_name(src_message)
    assert(isinstance(context, (str, StringName)))
    py_stringname_context = context if isinstance(context, StringName) else c_utils.py_string_to_string_name(context)

    self._ptr.call_with_return(85,tuple([py_stringname_src_message._ptr, py_stringname_context._ptr]))

  @functools.native_method
  def get_message_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns the keys of all messages, that is, the context and untranslated strings of each message.
				**Note:** If a message does not use a context, the corresponding element is the untranslated string. Otherwise, the corresponding element is the context and untranslated string separated by the EOT character (`U+0004`). This is done for compatibility purposes.
				```gdscript
				for key in translation.get_message_list():
					var p = key.find("\u0004")
					if p == -1:
						var untranslated = key
						print("Message %s" % untranslated)
					else:
						var context = key.substr(0, p)
						var untranslated = key.substr(p + 1)
						print("Message %s with context %s" % `untranslated, context`)
				```
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def get_translated_message_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns all the translated strings.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([]))
    return _ret


  @functools.native_method
  def get_message_count(self) -> typing.Union[int]:
    r'''
				Returns the number of existing messages.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([]))
    return _ret



register_cast_function('Translation', Translation.cast)
register_class('Translation', Translation)
