# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
import py4godot.classes.Object as py4godot_object 
from py4godot.wrappers.wrappers import CPPNativeMenuWrapper

_NativeMenu_singleton_instance = None
class Feature:
  FEATURE_GLOBAL_MENU = 0
  FEATURE_POPUP_MENU = 1
  FEATURE_OPEN_CLOSE_CALLBACK = 2
  FEATURE_HOVER_CALLBACK = 3
  FEATURE_KEY_CALLBACK = 4
class SystemMenus:
  INVALID_MENU_ID = 0
  MAIN_MENU_ID = 1
  APPLICATION_MENU_ID = 2
  WINDOW_MENU_ID = 3
  HELP_MENU_ID = 4
  DOCK_MENU_ID = 5


class NativeMenu(py4godot_object.Object):
  r'''
		`NativeMenu` handles low-level access to the OS native global menu bar and popup menus.
		**Note:** This is low-level API, consider using `MenuBar` with `MenuBar.prefer_global_menu` set to `true`, and `PopupMenu` with `PopupMenu.prefer_native_menu` set to `true`.
		To create a menu, use `create_menu`, add menu items using `add_*_item` methods. To remove a menu, use `free_menu`.
		```gdscript
		var menu

		func _menu_callback(item_id):
			if item_id == "ITEM_CUT":
				cut()
			elif item_id == "ITEM_COPY":
				copy()
			elif item_id == "ITEM_PASTE":
				paste()

		func _enter_tree():
			# Create new menu and add items:
			menu = NativeMenu.create_menu()
			NativeMenu.add_item(menu, "Cut", _menu_callback, Callable(), "ITEM_CUT")
			NativeMenu.add_item(menu, "Copy", _menu_callback, Callable(), "ITEM_COPY")
			NativeMenu.add_separator(menu)
			NativeMenu.add_item(menu, "Paste", _menu_callback, Callable(), "ITEM_PASTE")

		func _on_button_pressed():
			# Show popup menu at mouse position:
			NativeMenu.popup(menu, DisplayServer.mouse_get_position())

		func _exit_tree():
			# Remove menu when it's no longer needed:
			NativeMenu.free_menu(menu)
		```
	'''


  def generate_wrapper(self):
    return CPPNativeMenuWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = NativeMenu.__new__(NativeMenu)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'NativeMenu'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = NativeMenu.construct_without_init()
    cls._ptr = CPPNativeMenuWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = NativeMenu.construct_without_init()
    cls._ptr = CPPNativeMenuWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _NativeMenu_singleton_instance
    if _NativeMenu_singleton_instance is None:
      singleton = NativeMenu()
      singleton._ptr = constructor(493,0, ())
      _NativeMenu_singleton_instance = singleton
    return _NativeMenu_singleton_instance

  @functools.native_method
  def has_feature(self, feature:'int'  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified `feature` is supported by the current `NativeMenu`, `false` otherwise.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert isinstance(feature, (int, float)), 'feature must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(49,tuple([feature]))
    return _ret


  @functools.native_method
  def has_system_menu(self, menu_id:'int'  ) -> typing.Union[bool]:
    r'''
				Returns `true` if a special system menu is supported.
				**Note:** This method is implemented only on macOS.
			'''

    assert isinstance(menu_id, (int, float)), 'menu_id must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(50,tuple([menu_id]))
    return _ret


  @functools.native_method
  def get_system_menu(self, menu_id:'int'  ) -> typing.Union['RID']:
    r'''
				Returns RID of a special system menu.
				**Note:** This method is implemented only on macOS.
			'''

    assert isinstance(menu_id, (int, float)), 'menu_id must be int or float'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(51,tuple([menu_id]))
    return _ret


  @functools.native_method
  def get_system_menu_name(self, menu_id:'int'  ) -> typing.Union[str]:
    r'''
				Returns readable name of a special system menu.
				**Note:** This method is implemented only on macOS.
			'''

    assert isinstance(menu_id, (int, float)), 'menu_id must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(52,tuple([menu_id]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def create_menu(self) -> typing.Union['RID']:
    r'''
				Creates a new global menu object.
				**Note:** This method is implemented on macOS and Windows.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([]))
    return _ret


  @functools.native_method
  def has_menu(self, rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if `rid` is valid global menu.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(54,tuple([rid._ptr]))
    return _ret


  @functools.native_method
  def free_menu(self, rid:'RID'   ) -> None:
    r'''
				Frees a global menu object created by this `NativeMenu`.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    self._ptr.call_with_return(55,tuple([rid._ptr]))

  @functools.native_method
  def get_size(self, rid:'RID'   ) -> typing.Union['Vector2']:
    r'''
				Returns global menu size.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(56,tuple([rid._ptr]))
    return _ret


  @functools.native_method
  def popup(self, rid:'RID'   , position:'Vector2i'   ) -> None:
    r'''
				Shows the global menu at `position` in the screen coordinates.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert(not position is None)
    assert isinstance(position, Vector2i), 'position must be Vector2i'








    self._ptr.call_with_return(57,tuple([rid._ptr, position._ptr]))

  @functools.native_method
  def set_interface_direction(self, rid:'RID'   , is_rtl:'bool'   ) -> None:
    r'''
				Sets the menu text layout direction from right-to-left if `is_rtl` is `true`.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(is_rtl, bool), 'is_rtl must be bool'








    self._ptr.call_with_return(58,tuple([rid._ptr, is_rtl]))

  @functools.native_method
  def set_popup_open_callback(self, rid:'RID'   , callback:'Callable'   ) -> None:
    r'''
				Registers callable to emit after the menu is closed.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'








    self._ptr.call_with_return(59,tuple([rid._ptr, callback._ptr]))

  @functools.native_method
  def get_popup_open_callback(self, rid:'RID'   ) -> typing.Union['Callable']:
    r'''
				Returns global menu open callback.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    _ret = Callable.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([rid._ptr]))
    return _ret


  @functools.native_method
  def set_popup_close_callback(self, rid:'RID'   , callback:'Callable'   ) -> None:
    r'''
				Registers callable to emit when the menu is about to show.
				**Note:** The OS can simulate menu opening to track menu item changes and global shortcuts, in which case the corresponding close callback is not triggered. Use `is_opened` to check if the menu is currently opened.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'








    self._ptr.call_with_return(61,tuple([rid._ptr, callback._ptr]))

  @functools.native_method
  def get_popup_close_callback(self, rid:'RID'   ) -> typing.Union['Callable']:
    r'''
				Returns global menu close callback.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    _ret = Callable.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([rid._ptr]))
    return _ret


  @functools.native_method
  def set_minimum_width(self, rid:'RID'   , width:'float'   ) -> None:
    r'''
				Sets the minimum width of the global menu.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(width, (int, float)), 'width must be int or float'








    self._ptr.call_with_return(63,tuple([rid._ptr, width]))

  @functools.native_method
  def get_minimum_width(self, rid:'RID'   ) -> typing.Union[float]:
    r'''
				Returns global menu minimum width.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(64,tuple([rid._ptr]))
    return _ret


  @functools.native_method
  def is_opened(self, rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the menu is currently opened.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(65,tuple([rid._ptr]))
    return _ret


  @functools.native_method
  def add_submenu_item(self, rid:'RID'   , label:'str'   , submenu_rid:'RID'   , tag:'object' =None  , index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds an item that will act as a submenu of the global menu `rid`. The `submenu_rid` argument is the RID of the global menu that will be shown when the item is clicked.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				**Note:** This method is implemented on macOS and Windows.
			'''


    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    assert(not submenu_rid is None)
    assert isinstance(submenu_rid, RID), 'submenu_rid must be RID'
    
    assert isinstance(index, (int, float)), 'index must be int or float'

    if not (type(tag).__name__ in py4godot.variant_types.core_types or isinstance(tag, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'tag': "
                f"{type(tag).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)




    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([rid._ptr, py_string_label._ptr, submenu_rid._ptr, tag, index]))
    return _ret


  @functools.native_method
  def add_item(self, rid:'RID'   , label:'str'   , callback:'Callable' = None  , key_callback:'Callable' = None  , tag:'object' =None  , accelerator:'int'  =0, index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a new item with text `label` to the global menu `rid`.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** The `callback` and `key_callback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
				**Note:** This method is implemented on macOS and Windows.
				**Note:** On Windows, `accelerator` and `key_callback` are ignored.
			'''
    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()



    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    
    assert isinstance(accelerator, (int, float)), 'accelerator must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'

    if not (type(tag).__name__ in py4godot.variant_types.core_types or isinstance(tag, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'tag': "
                f"{type(tag).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)






    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([rid._ptr, py_string_label._ptr, callback._ptr, key_callback._ptr, tag, accelerator, index]))
    return _ret


  @functools.native_method
  def add_check_item(self, rid:'RID'   , label:'str'   , callback:'Callable' = None  , key_callback:'Callable' = None  , tag:'object' =None  , accelerator:'int'  =0, index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a new checkable item with text `label` to the global menu `rid`.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** The `callback` and `key_callback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
				**Note:** This method is implemented on macOS and Windows.
				**Note:** On Windows, `accelerator` and `key_callback` are ignored.
			'''
    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()



    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    
    assert isinstance(accelerator, (int, float)), 'accelerator must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'

    if not (type(tag).__name__ in py4godot.variant_types.core_types or isinstance(tag, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'tag': "
                f"{type(tag).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)






    _ret = 0
    _ret = self._ptr.call_with_return(68,tuple([rid._ptr, py_string_label._ptr, callback._ptr, key_callback._ptr, tag, accelerator, index]))
    return _ret


  @functools.native_method
  def add_icon_item(self, rid:'RID'   , icon:'py4godot_texture2d.Texture2D'   , label:'str'   , callback:'Callable' = None  , key_callback:'Callable' = None  , tag:'object' =None  , accelerator:'int'  =0, index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a new item with text `label` and icon `icon` to the global menu `rid`.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** The `callback` and `key_callback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
				**Note:** This method is implemented on macOS and Windows.
				**Note:** On Windows, `accelerator` and `key_callback` are ignored.
			'''
    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()



    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    
    assert isinstance(accelerator, (int, float)), 'accelerator must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'

    if not (type(tag).__name__ in py4godot.variant_types.core_types or isinstance(tag, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'tag': "
                f"{type(tag).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)






    _ret = 0
    _ret = self._ptr.call_with_return(69,tuple([rid._ptr, icon._ptr, py_string_label._ptr, callback._ptr, key_callback._ptr, tag, accelerator, index]))
    return _ret


  @functools.native_method
  def add_icon_check_item(self, rid:'RID'   , icon:'py4godot_texture2d.Texture2D'   , label:'str'   , callback:'Callable' = None  , key_callback:'Callable' = None  , tag:'object' =None  , accelerator:'int'  =0, index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a new checkable item with text `label` and icon `icon` to the global menu `rid`.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** The `callback` and `key_callback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
				**Note:** This method is implemented on macOS and Windows.
				**Note:** On Windows, `accelerator` and `key_callback` are ignored.
			'''
    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()



    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    
    assert isinstance(accelerator, (int, float)), 'accelerator must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'

    if not (type(tag).__name__ in py4godot.variant_types.core_types or isinstance(tag, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'tag': "
                f"{type(tag).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)






    _ret = 0
    _ret = self._ptr.call_with_return(70,tuple([rid._ptr, icon._ptr, py_string_label._ptr, callback._ptr, key_callback._ptr, tag, accelerator, index]))
    return _ret


  @functools.native_method
  def add_radio_check_item(self, rid:'RID'   , label:'str'   , callback:'Callable' = None  , key_callback:'Callable' = None  , tag:'object' =None  , accelerator:'int'  =0, index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a new radio-checkable item with text `label` to the global menu `rid`.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** Radio-checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See `set_item_checked` for more info on how to control it.
				**Note:** The `callback` and `key_callback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
				**Note:** This method is implemented on macOS and Windows.
				**Note:** On Windows, `accelerator` and `key_callback` are ignored.
			'''
    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()



    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    
    assert isinstance(accelerator, (int, float)), 'accelerator must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'

    if not (type(tag).__name__ in py4godot.variant_types.core_types or isinstance(tag, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'tag': "
                f"{type(tag).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)






    _ret = 0
    _ret = self._ptr.call_with_return(71,tuple([rid._ptr, py_string_label._ptr, callback._ptr, key_callback._ptr, tag, accelerator, index]))
    return _ret


  @functools.native_method
  def add_icon_radio_check_item(self, rid:'RID'   , icon:'py4godot_texture2d.Texture2D'   , label:'str'   , callback:'Callable' = None  , key_callback:'Callable' = None  , tag:'object' =None  , accelerator:'int'  =0, index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a new radio-checkable item with text `label` and icon `icon` to the global menu `rid`.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** Radio-checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See `set_item_checked` for more info on how to control it.
				**Note:** The `callback` and `key_callback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
				**Note:** This method is implemented on macOS and Windows.
				**Note:** On Windows, `accelerator` and `key_callback` are ignored.
			'''
    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()



    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    
    assert isinstance(accelerator, (int, float)), 'accelerator must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'

    if not (type(tag).__name__ in py4godot.variant_types.core_types or isinstance(tag, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'tag': "
                f"{type(tag).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )






    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)






    _ret = 0
    _ret = self._ptr.call_with_return(72,tuple([rid._ptr, icon._ptr, py_string_label._ptr, callback._ptr, key_callback._ptr, tag, accelerator, index]))
    return _ret


  @functools.native_method
  def add_multistate_item(self, rid:'RID'   , label:'str'   , max_states:'int'   , default_state:'int'   , callback:'Callable' = None  , key_callback:'Callable' = None  , tag:'object' =None  , accelerator:'int'  =0, index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a new item with text `label` to the global menu `rid`.
				Contrarily to normal binary items, multistate items can have more than two states, as defined by `max_states`. Each press or activate of the item will increase the state by one. The default value is defined by `default_state`.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				An `accelerator` can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The `accelerator` is generally a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** By default, there's no indication of the current item state, it should be changed manually.
				**Note:** The `callback` and `key_callback` Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to `tag`.
				**Note:** This method is implemented on macOS and Windows.
				**Note:** On Windows, `accelerator` and `key_callback` are ignored.
			'''
    if callback is None:
      callback = Callable.new0()
    if key_callback is None:
      key_callback = Callable.new0()



    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert(not label is None)
    assert isinstance(label, (str, String)), 'label must be str or String'
    assert isinstance(max_states, (int, float)), 'max_states must be int or float'
    assert isinstance(default_state, (int, float)), 'default_state must be int or float'
    
    assert isinstance(accelerator, (int, float)), 'accelerator must be int or float'
    assert isinstance(index, (int, float)), 'index must be int or float'

    if not (type(tag).__name__ in py4godot.variant_types.core_types or isinstance(tag, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'tag': "
                f"{type(tag).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(label, (str, String)))
    py_string_label = label if isinstance(label, StringName) else c_utils.py_string_to_string(label)








    _ret = 0
    _ret = self._ptr.call_with_return(73,tuple([rid._ptr, py_string_label._ptr, max_states, default_state, callback._ptr, key_callback._ptr, tag, accelerator, index]))
    return _ret


  @functools.native_method
  def add_separator(self, rid:'RID'   , index:'int' =-1  ) -> typing.Union[int]:
    r'''
				Adds a separator between items to the global menu `rid`. Separators also occupy an index.
				Returns index of the inserted item, it's not guaranteed to be the same as `index` value.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(74,tuple([rid._ptr, index]))
    return _ret


  @functools.native_method
  def find_item_index_with_text(self, rid:'RID'   , text:'str'   ) -> typing.Union[int]:
    r'''
				Returns the index of the item with the specified `text`. Indices are automatically assigned to each item by the engine, and cannot be set manually.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'






    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    _ret = 0
    _ret = self._ptr.call_with_return(75,tuple([rid._ptr, py_string_text._ptr]))
    return _ret


  @functools.native_method
  def find_item_index_with_tag(self, rid:'RID'   , tag:'object'   ) -> typing.Union[int]:
    r'''
				Returns the index of the item with the specified `tag`. Indices are automatically assigned to each item by the engine, and cannot be set manually.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    

    if not (type(tag).__name__ in py4godot.variant_types.core_types or isinstance(tag, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'tag': "
                f"{type(tag).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = 0
    _ret = self._ptr.call_with_return(76,tuple([rid._ptr, tag]))
    return _ret


  @functools.native_method
  def find_item_index_with_submenu(self, rid:'RID'   , submenu_rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns the index of the item with the submenu specified by `submenu_rid`. Indices are automatically assigned to each item by the engine, and cannot be set manually.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert(not submenu_rid is None)
    assert isinstance(submenu_rid, RID), 'submenu_rid must be RID'








    _ret = 0
    _ret = self._ptr.call_with_return(77,tuple([rid._ptr, submenu_rid._ptr]))
    return _ret


  @functools.native_method
  def is_item_checked(self, rid:'RID'   , idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the item at index `idx` is checked.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([rid._ptr, idx]))
    return _ret


  @functools.native_method
  def is_item_checkable(self, rid:'RID'   , idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the item at index `idx` is checkable in some way, i.e. if it has a checkbox or radio button.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(79,tuple([rid._ptr, idx]))
    return _ret


  @functools.native_method
  def is_item_radio_checkable(self, rid:'RID'   , idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the item at index `idx` has radio button-style checkability.
				**Note:** This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(80,tuple([rid._ptr, idx]))
    return _ret


  @functools.native_method
  def get_item_callback(self, rid:'RID'   , idx:'int'   ) -> typing.Union['Callable']:
    r'''
				Returns the callback of the item at index `idx`.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = Callable.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([rid._ptr, idx]))
    return _ret


  @functools.native_method
  def get_item_key_callback(self, rid:'RID'   , idx:'int'   ) -> typing.Union['Callable']:
    r'''
				Returns the callback of the item accelerator at index `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = Callable.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(82,tuple([rid._ptr, idx]))
    return _ret


  @functools.native_method
  def get_item_tag(self, rid:'RID'   , idx:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the metadata of the specified item, which might be of any type. You can set it with `set_item_tag`, which provides a simple way of assigning context data to items.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = None
    _ret = self._ptr.call_with_return(83,tuple([rid._ptr, idx]))
    return _ret


  @functools.native_method
  def get_item_text(self, rid:'RID'   , idx:'int'   ) -> typing.Union[str]:
    r'''
				Returns the text of the item at index `idx`.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(84,tuple([rid._ptr, idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_item_submenu(self, rid:'RID'   , idx:'int'   ) -> typing.Union['RID']:
    r'''
				Returns the submenu ID of the item at index `idx`. See `add_submenu_item` for more info on how to add a submenu.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(85,tuple([rid._ptr, idx]))
    return _ret


  @functools.native_method
  def get_item_accelerator(self, rid:'RID'   , idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the accelerator of the item at index `idx`. Accelerators are special combinations of keys that activate the item, no matter which control is focused.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret:int
    _ret = self._ptr.call_with_return(86,tuple([rid._ptr, idx]))
    return _ret


  @functools.native_method
  def is_item_disabled(self, rid:'RID'   , idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the item at index `idx` is disabled. When it is disabled it can't be selected, or its action invoked.
				See `set_item_disabled` for more info on how to disable an item.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(87,tuple([rid._ptr, idx]))
    return _ret


  @functools.native_method
  def is_item_hidden(self, rid:'RID'   , idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the item at index `idx` is hidden.
				See `set_item_hidden` for more info on how to hide an item.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([rid._ptr, idx]))
    return _ret


  @functools.native_method
  def get_item_tooltip(self, rid:'RID'   , idx:'int'   ) -> typing.Union[str]:
    r'''
				Returns the tooltip associated with the specified index `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(89,tuple([rid._ptr, idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_item_state(self, rid:'RID'   , idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the state of a multistate item. See `add_multistate_item` for details.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([rid._ptr, idx]))
    return _ret


  @functools.native_method
  def get_item_max_states(self, rid:'RID'   , idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns number of states of a multistate item. See `add_multistate_item` for details.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(91,tuple([rid._ptr, idx]))
    return _ret


  @functools.native_method
  def get_item_icon(self, rid:'RID'   , idx:'int'   ) -> typing.Any:
    r'''
				Returns the icon of the item at index `idx`.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(92,tuple([rid._ptr, idx]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_item_indentation_level(self, rid:'RID'   , idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the horizontal offset of the item at the given `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([rid._ptr, idx]))
    return _ret


  @functools.native_method
  def set_item_checked(self, rid:'RID'   , idx:'int'   , checked:'bool'   ) -> None:
    r'''
				Sets the checkstate status of the item at index `idx`.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(checked, bool), 'checked must be bool'









    self._ptr.call_with_return(94,tuple([rid._ptr, idx, checked]))

  @functools.native_method
  def set_item_checkable(self, rid:'RID'   , idx:'int'   , checkable:'bool'   ) -> None:
    r'''
				Sets whether the item at index `idx` has a checkbox. If `false`, sets the type of the item to plain text.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(checkable, bool), 'checkable must be bool'









    self._ptr.call_with_return(95,tuple([rid._ptr, idx, checkable]))

  @functools.native_method
  def set_item_radio_checkable(self, rid:'RID'   , idx:'int'   , checkable:'bool'   ) -> None:
    r'''
				Sets the type of the item at the specified index `idx` to radio button. If `false`, sets the type of the item to plain text.
				**Note:** This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(checkable, bool), 'checkable must be bool'









    self._ptr.call_with_return(96,tuple([rid._ptr, idx, checkable]))

  @functools.native_method
  def set_item_callback(self, rid:'RID'   , idx:'int'   , callback:'Callable'   ) -> None:
    r'''
				Sets the callback of the item at index `idx`. Callback is emitted when an item is pressed.
				**Note:** The `callback` Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the `tag` parameter when the menu item was created.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'









    self._ptr.call_with_return(97,tuple([rid._ptr, idx, callback._ptr]))

  @functools.native_method
  def set_item_hover_callbacks(self, rid:'RID'   , idx:'int'   , callback:'Callable'   ) -> None:
    r'''
				Sets the callback of the item at index `idx`. The callback is emitted when an item is hovered.
				**Note:** The `callback` Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the `tag` parameter when the menu item was created.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'









    self._ptr.call_with_return(98,tuple([rid._ptr, idx, callback._ptr]))

  @functools.native_method
  def set_item_key_callback(self, rid:'RID'   , idx:'int'   , key_callback:'Callable'   ) -> None:
    r'''
				Sets the callback of the item at index `idx`. Callback is emitted when its accelerator is activated.
				**Note:** The `key_callback` Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the `tag` parameter when the menu item was created.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not key_callback is None)
    assert isinstance(key_callback, Callable), 'key_callback must be Callable'









    self._ptr.call_with_return(99,tuple([rid._ptr, idx, key_callback._ptr]))

  @functools.native_method
  def set_item_tag(self, rid:'RID'   , idx:'int'   , tag:'object'   ) -> None:
    r'''
				Sets the metadata of an item, which may be of any type. You can later get it with `get_item_tag`, which provides a simple way of assigning context data to items.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    

    if not (type(tag).__name__ in py4godot.variant_types.core_types or isinstance(tag, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'tag': "
                f"{type(tag).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )








    self._ptr.call_with_return(100,tuple([rid._ptr, idx, tag]))

  @functools.native_method
  def set_item_text(self, rid:'RID'   , idx:'int'   , text:'str'   ) -> None:
    r'''
				Sets the text of the item at index `idx`.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'







    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)

    self._ptr.call_with_return(101,tuple([rid._ptr, idx, py_string_text._ptr]))

  @functools.native_method
  def set_item_submenu(self, rid:'RID'   , idx:'int'   , submenu_rid:'RID'   ) -> None:
    r'''
				Sets the submenu RID of the item at index `idx`. The submenu is a global menu that would be shown when the item is clicked.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not submenu_rid is None)
    assert isinstance(submenu_rid, RID), 'submenu_rid must be RID'









    self._ptr.call_with_return(102,tuple([rid._ptr, idx, submenu_rid._ptr]))

  @functools.native_method
  def set_item_accelerator(self, rid:'RID'   , idx:'int'   , keycode:'int'  ) -> None:
    r'''
				Sets the accelerator of the item at index `idx`. `keycode` can be a single `enum Key`, or a combination of `enum KeyModifierMask`s and `enum Key`s using bitwise OR such as `KEY_MASK_CTRL | KEY_A` (`kbd`Ctrl + A`/kbd`).
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(keycode, (int, float)), 'keycode must be int or float'









    self._ptr.call_with_return(103,tuple([rid._ptr, idx, keycode]))

  @functools.native_method
  def set_item_disabled(self, rid:'RID'   , idx:'int'   , disabled:'bool'   ) -> None:
    r'''
				Enables/disables the item at index `idx`. When it is disabled, it can't be selected and its action can't be invoked.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(disabled, bool), 'disabled must be bool'









    self._ptr.call_with_return(104,tuple([rid._ptr, idx, disabled]))

  @functools.native_method
  def set_item_hidden(self, rid:'RID'   , idx:'int'   , hidden:'bool'   ) -> None:
    r'''
				Hides/shows the item at index `idx`. When it is hidden, an item does not appear in a menu and its action cannot be invoked.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(hidden, bool), 'hidden must be bool'









    self._ptr.call_with_return(105,tuple([rid._ptr, idx, hidden]))

  @functools.native_method
  def set_item_tooltip(self, rid:'RID'   , idx:'int'   , tooltip:'str'   ) -> None:
    r'''
				Sets the `String` tooltip of the item at the specified index `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not tooltip is None)
    assert isinstance(tooltip, (str, String)), 'tooltip must be str or String'







    assert(isinstance(tooltip, (str, String)))
    py_string_tooltip = tooltip if isinstance(tooltip, StringName) else c_utils.py_string_to_string(tooltip)

    self._ptr.call_with_return(106,tuple([rid._ptr, idx, py_string_tooltip._ptr]))

  @functools.native_method
  def set_item_state(self, rid:'RID'   , idx:'int'   , state:'int'   ) -> None:
    r'''
				Sets the state of a multistate item. See `add_multistate_item` for details.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(state, (int, float)), 'state must be int or float'









    self._ptr.call_with_return(107,tuple([rid._ptr, idx, state]))

  @functools.native_method
  def set_item_max_states(self, rid:'RID'   , idx:'int'   , max_states:'int'   ) -> None:
    r'''
				Sets number of state of a multistate item. See `add_multistate_item` for details.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(max_states, (int, float)), 'max_states must be int or float'









    self._ptr.call_with_return(108,tuple([rid._ptr, idx, max_states]))

  @functools.native_method
  def set_item_icon(self, rid:'RID'   , idx:'int'   , icon:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Replaces the `Texture2D` icon of the specified `idx`.
				**Note:** This method is implemented on macOS and Windows.
				**Note:** This method is not supported by macOS Dock menu items.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not icon is None)
    assert isinstance(icon, get_class('Texture2D')), 'icon must be Texture2D'









    self._ptr.call_with_return(109,tuple([rid._ptr, idx, icon._ptr]))

  @functools.native_method
  def set_item_indentation_level(self, rid:'RID'   , idx:'int'   , level:'int'   ) -> None:
    r'''
				Sets the horizontal offset of the item at the given `idx`.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(level, (int, float)), 'level must be int or float'









    self._ptr.call_with_return(110,tuple([rid._ptr, idx, level]))

  @functools.native_method
  def get_item_count(self, rid:'RID'   ) -> typing.Union[int]:
    r'''
				Returns number of items in the global menu `rid`.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(111,tuple([rid._ptr]))
    return _ret


  @functools.native_method
  def is_system_menu(self, rid:'RID'   ) -> typing.Union[bool]:
    r'''
				Return `true` is global menu is a special system menu.
				**Note:** This method is implemented only on macOS.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    _ret = 0
    _ret = self._ptr.call_with_return(112,tuple([rid._ptr]))
    return _ret


  @functools.native_method
  def remove_item(self, rid:'RID'   , idx:'int'   ) -> None:
    r'''
				Removes the item at index `idx` from the global menu `rid`.
				**Note:** The indices of items after the removed item will be shifted by one.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'
    assert isinstance(idx, (int, float)), 'idx must be int or float'








    self._ptr.call_with_return(113,tuple([rid._ptr, idx]))

  @functools.native_method
  def clear(self, rid:'RID'   ) -> None:
    r'''
				Removes all items from the global menu `rid`.
				**Note:** This method is implemented on macOS and Windows.
			'''

    assert(not rid is None)
    assert isinstance(rid, RID), 'rid must be RID'







    self._ptr.call_with_return(114,tuple([rid._ptr]))


register_cast_function('NativeMenu', NativeMenu.cast)
register_class('NativeMenu', NativeMenu)
