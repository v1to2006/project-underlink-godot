# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ENetMultiplayerPeer as py4godot_enetmultiplayerpeer 
  import py4godot.classes.OfflineMultiplayerPeer as py4godot_offlinemultiplayerpeer 
  import py4godot.classes.MultiplayerPeer as py4godot_multiplayerpeer 
  import py4godot.classes.WebSocketMultiplayerPeer as py4godot_websocketmultiplayerpeer 
  import py4godot.classes.WebRTCMultiplayerPeer as py4godot_webrtcmultiplayerpeer 
  import py4godot.classes.Object as py4godot_object 
  import py4godot.classes.MultiplayerPeerExtension as py4godot_multiplayerpeerextension 
import py4godot.classes.MultiplayerAPI as py4godot_multiplayerapi 
from py4godot.wrappers.wrappers import CPPMultiplayerAPIExtensionWrapper


class MultiplayerAPIExtension(py4godot_multiplayerapi.MultiplayerAPI):
  r'''
		This class can be used to extend or replace the default `MultiplayerAPI` implementation via script or extensions.
		The following example extend the default implementation (`SceneMultiplayer`) by logging every RPC being made, and every object being configured for replication.
		
		```gdscript
		extends MultiplayerAPIExtension
		class_name LogMultiplayer

		# We want to extend the default SceneMultiplayer.
		var base_multiplayer = SceneMultiplayer.new()

		func _init():
			# Just passthrough base signals (copied to var to avoid cyclic reference)
			var cts = connected_to_server
			var cf = connection_failed
			var sd = server_disconnected
			var pc = peer_connected
			var pd = peer_disconnected
			base_multiplayer.connected_to_server.connect(func(): cts.emit())
			base_multiplayer.connection_failed.connect(func(): cf.emit())
			base_multiplayer.server_disconnected.connect(func(): sd.emit())
			base_multiplayer.peer_connected.connect(func(id): pc.emit(id))
			base_multiplayer.peer_disconnected.connect(func(id): pd.emit(id))

		func _poll():
			return base_multiplayer.poll()

		# Log RPC being made and forward it to the default multiplayer.
		func _rpc(peer: int, object: Object, method: StringName, args: Array) -> Error:
			print("Got RPC for %d: %s::%s(%s)" % `peer, object, method, args`)
			return base_multiplayer.rpc(peer, object, method, args)

		# Log configuration add. E.g. root path (nullptr, NodePath), replication (Node, Spawner|Synchronizer), custom.
		func _object_configuration_add(object, config: Variant) -> Error:
			if config is MultiplayerSynchronizer:
				print("Adding synchronization configuration for %s. Synchronizer: %s" % `object, config`)
			elif config is MultiplayerSpawner:
				print("Adding node %s to the spawn list. Spawner: %s" % `object, config`)
			return base_multiplayer.object_configuration_add(object, config)

		# Log configuration remove. E.g. root path (nullptr, NodePath), replication (Node, Spawner|Synchronizer), custom.
		func _object_configuration_remove(object, config: Variant) -> Error:
			if config is MultiplayerSynchronizer:
				print("Removing synchronization configuration for %s. Synchronizer: %s" % `object, config`)
			elif config is MultiplayerSpawner:
				print("Removing node %s from the spawn list. Spawner: %s" % `object, config`)
			return base_multiplayer.object_configuration_remove(object, config)

		# These can be optional, but in our case we want to extend SceneMultiplayer, so forward everything.
		func _set_multiplayer_peer(p_peer: MultiplayerPeer):
			base_multiplayer.multiplayer_peer = p_peer

		func _get_multiplayer_peer() -> MultiplayerPeer:
			return base_multiplayer.multiplayer_peer

		func _get_unique_id() -> int:
			return base_multiplayer.get_unique_id()

		func _get_remote_sender_id() -> int:
			return base_multiplayer.get_remote_sender_id()

		func _get_peer_ids() -> PackedInt32Array:
			return base_multiplayer.get_peers()
		```
		
		Then in your main scene or in an autoload call `SceneTree.set_multiplayer` to start using your custom `MultiplayerAPI`:
		
		```gdscript
		# autoload.gd
		func _enter_tree():
			# Sets our custom multiplayer as the main one in SceneTree.
			get_tree().set_multiplayer(LogMultiplayer.new())
		```
		
		Native extensions can alternatively use the `MultiplayerAPI.set_default_interface` method during initialization to configure themselves as the default implementation.
	'''

  @staticmethod
  def constructor():
    class_ = MultiplayerAPIExtension.construct_without_init()
    class_._ptr = constructor(487,0, ())
    return class_
  @staticmethod
  def new():
    class_ = MultiplayerAPIExtension.construct_without_init()
    class_._ptr = constructor(487,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPMultiplayerAPIExtensionWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(487,0, ())


  def generate_wrapper(self):
    return CPPMultiplayerAPIExtensionWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = MultiplayerAPIExtension.__new__(MultiplayerAPIExtension)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'MultiplayerAPIExtension'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(73, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = MultiplayerAPIExtension.construct_without_init()
    cls._ptr = CPPMultiplayerAPIExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = MultiplayerAPIExtension.construct_without_init()
    cls._ptr = CPPMultiplayerAPIExtensionWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _poll(self) -> typing.Union[int]:
    r'''
				Callback for `MultiplayerAPI.poll`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(64,tuple([]))
    return _ret


  @functools.native_method
  def _set_multiplayer_peer(self, multiplayer_peer:'py4godot_multiplayerpeer.MultiplayerPeer'   ) -> None:
    r'''
				Called when the `MultiplayerAPI.multiplayer_peer` is set.
			'''

    assert(not multiplayer_peer is None)
    assert isinstance(multiplayer_peer, get_class('MultiplayerPeer')), 'multiplayer_peer must be MultiplayerPeer'







    self._ptr.call_with_return(65,tuple([multiplayer_peer._ptr]))

  @functools.native_method
  def _get_multiplayer_peer(self) -> typing.Any:
    r'''
				Called when the `MultiplayerAPI.multiplayer_peer` is retrieved.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: MultiplayerPeer
    _ret._ptr = self._ptr.call_with_return(66,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def _get_unique_id(self) -> typing.Union[int]:
    r'''
				Callback for `MultiplayerAPI.get_unique_id`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([]))
    return _ret


  @functools.native_method
  def _get_peer_ids(self) -> typing.Union['PackedInt32Array']:
    r'''
				Callback for `MultiplayerAPI.get_peers`.
			'''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(68,tuple([]))
    return _ret


  @functools.native_method
  def _rpc(self, peer:'int'   , object_:'py4godot_object.Object'   , method:'object'   , args:'Array'   ) -> typing.Union[int]:
    r'''
				Callback for `MultiplayerAPI.rpc`.
			'''

    assert isinstance(peer, (int, float)), 'peer must be int or float'
    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    assert(not method is None)
    assert isinstance(method, (str, StringName)), 'method must be str or StringName'
    assert(not args is None)
    assert isinstance(args, Array), 'args must be Array'







    assert(isinstance(method, (str, StringName)))
    py_stringname_method = method if isinstance(method, StringName) else c_utils.py_string_to_string_name(method)


    _ret:int
    _ret = self._ptr.call_with_return(69,tuple([peer, object_._ptr, py_stringname_method._ptr, args._ptr]))
    return _ret


  @functools.native_method
  def _get_remote_sender_id(self) -> typing.Union[int]:
    r'''
				Callback for `MultiplayerAPI.get_remote_sender_id`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(70,tuple([]))
    return _ret


  @functools.native_method
  def _object_configuration_add(self, object_:'py4godot_object.Object'   , configuration:'object'   ) -> typing.Union[int]:
    r'''
				Callback for `MultiplayerAPI.object_configuration_add`.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    

    if not (type(configuration).__name__ in py4godot.variant_types.core_types or isinstance(configuration, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'configuration': "
                f"{type(configuration).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret:int
    _ret = self._ptr.call_with_return(71,tuple([object_._ptr, configuration]))
    return _ret


  @functools.native_method
  def _object_configuration_remove(self, object_:'py4godot_object.Object'   , configuration:'object'   ) -> typing.Union[int]:
    r'''
				Callback for `MultiplayerAPI.object_configuration_remove`.
			'''

    assert(not object_ is None)
    assert isinstance(object_, get_class('Object')), 'object_ must be Object'
    

    if not (type(configuration).__name__ in py4godot.variant_types.core_types or isinstance(configuration, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'configuration': "
                f"{type(configuration).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret:int
    _ret = self._ptr.call_with_return(72,tuple([object_._ptr, configuration]))
    return _ret



register_cast_function('MultiplayerAPIExtension', MultiplayerAPIExtension.cast)
register_class('MultiplayerAPIExtension', MultiplayerAPIExtension)
