# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.AnimatedTexture as py4godot_animatedtexture 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.Texture2D as py4godot_texture2d 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
import py4godot.classes.Material as py4godot_material 
from py4godot.wrappers.wrappers import CPPParticleProcessMaterialWrapper

class Parameter:
  PARAM_INITIAL_LINEAR_VELOCITY = 0
  PARAM_ANGULAR_VELOCITY = 1
  PARAM_ORBIT_VELOCITY = 2
  PARAM_LINEAR_ACCEL = 3
  PARAM_RADIAL_ACCEL = 4
  PARAM_TANGENTIAL_ACCEL = 5
  PARAM_DAMPING = 6
  PARAM_ANGLE = 7
  PARAM_SCALE = 8
  PARAM_HUE_VARIATION = 9
  PARAM_ANIM_SPEED = 10
  PARAM_ANIM_OFFSET = 11
  PARAM_RADIAL_VELOCITY = 15
  PARAM_DIRECTIONAL_VELOCITY = 16
  PARAM_SCALE_OVER_VELOCITY = 17
  PARAM_MAX = 18
  PARAM_TURB_VEL_INFLUENCE = 13
  PARAM_TURB_INIT_DISPLACEMENT = 14
  PARAM_TURB_INFLUENCE_OVER_LIFE = 12
class ParticleFlags:
  PARTICLE_FLAG_ALIGN_Y_TO_VELOCITY = 0
  PARTICLE_FLAG_ROTATE_Y = 1
  PARTICLE_FLAG_DISABLE_Z = 2
  PARTICLE_FLAG_DAMPING_AS_FRICTION = 3
  PARTICLE_FLAG_MAX = 4
class EmissionShape:
  EMISSION_SHAPE_POINT = 0
  EMISSION_SHAPE_SPHERE = 1
  EMISSION_SHAPE_SPHERE_SURFACE = 2
  EMISSION_SHAPE_BOX = 3
  EMISSION_SHAPE_POINTS = 4
  EMISSION_SHAPE_DIRECTED_POINTS = 5
  EMISSION_SHAPE_RING = 6
  EMISSION_SHAPE_MAX = 7
class SubEmitterMode:
  SUB_EMITTER_DISABLED = 0
  SUB_EMITTER_CONSTANT = 1
  SUB_EMITTER_AT_END = 2
  SUB_EMITTER_AT_COLLISION = 3
  SUB_EMITTER_AT_START = 4
  SUB_EMITTER_MAX = 5
class CollisionMode:
  COLLISION_DISABLED = 0
  COLLISION_RIGID = 1
  COLLISION_HIDE_ON_CONTACT = 2
  COLLISION_MAX = 3


class ParticleProcessMaterial(py4godot_material.Material):
  r'''
		`ParticleProcessMaterial` defines particle properties and behavior. It is used in the `process_material` of the `GPUParticles2D` and `GPUParticles3D` nodes. Some of this material's properties are applied to each particle when emitted, while others can have a `CurveTexture` or a `GradientTexture1D` applied to vary numerical or color values over the lifetime of the particle.
	'''

  @staticmethod
  def constructor():
    class_ = ParticleProcessMaterial.construct_without_init()
    class_._ptr = constructor(579,0, ())
    return class_
  @staticmethod
  def new():
    class_ = ParticleProcessMaterial.construct_without_init()
    class_._ptr = constructor(579,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPParticleProcessMaterialWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(579,0, ())


  def generate_wrapper(self):
    return CPPParticleProcessMaterialWrapper()
  def init_signals(self):
    super().init_signals()
    emission_shape_changed_name = utils.py_string_to_string_name("emission_shape_changed")
    self.emission_shape_changed = signals.BuiltinSignal(self, emission_shape_changed_name)

  @staticmethod
  def construct_without_init():
    cls = ParticleProcessMaterial.__new__(ParticleProcessMaterial)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'ParticleProcessMaterial'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(183, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = ParticleProcessMaterial.construct_without_init()
    cls._ptr = CPPParticleProcessMaterialWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = ParticleProcessMaterial.construct_without_init()
    cls._ptr = CPPParticleProcessMaterialWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def lifetime_randomness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_lifetime_randomness()
    return _ret
  @lifetime_randomness.setter
  def lifetime_randomness(self,  value:'float'):
    self.set_lifetime_randomness(value)
  @property
  def particle_flag_align_y(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_particle_flag(0)
    return _ret
  @particle_flag_align_y.setter
  def particle_flag_align_y(self,  value:'bool'):
    self.set_particle_flag(0, value)
  @property
  def particle_flag_rotate_y(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_particle_flag(1)
    return _ret
  @particle_flag_rotate_y.setter
  def particle_flag_rotate_y(self,  value:'bool'):
    self.set_particle_flag(1, value)
  @property
  def particle_flag_disable_z(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_particle_flag(2)
    return _ret
  @particle_flag_disable_z.setter
  def particle_flag_disable_z(self,  value:'bool'):
    self.set_particle_flag(2, value)
  @property
  def particle_flag_damping_as_friction(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_particle_flag(3)
    return _ret
  @particle_flag_damping_as_friction.setter
  def particle_flag_damping_as_friction(self,  value:'bool'):
    self.set_particle_flag(3, value)
  @property
  def emission_shape_offset(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_emission_shape_offset()
    return _ret
  @emission_shape_offset.setter
  def emission_shape_offset(self,  value:'Vector3'):
    self.set_emission_shape_offset(value)
  @property
  def emission_shape_scale(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_emission_shape_scale()
    return _ret
  @emission_shape_scale.setter
  def emission_shape_scale(self,  value:'Vector3'):
    self.set_emission_shape_scale(value)
  @property
  def emission_shape(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_emission_shape()
    return _ret
  @emission_shape.setter
  def emission_shape(self,  value:'int'):
    self.set_emission_shape(value)
  @property
  def emission_sphere_radius(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_emission_sphere_radius()
    return _ret
  @emission_sphere_radius.setter
  def emission_sphere_radius(self,  value:'float'):
    self.set_emission_sphere_radius(value)
  @property
  def emission_box_extents(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_emission_box_extents()
    return _ret
  @emission_box_extents.setter
  def emission_box_extents(self,  value:'Vector3'):
    self.set_emission_box_extents(value)
  @property
  def emission_point_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_emission_point_texture()
    return _ret
  @emission_point_texture.setter
  def emission_point_texture(self,  value:'py4godot_object.Object'):
    self.set_emission_point_texture(value)
  @property
  def emission_normal_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_emission_normal_texture()
    return _ret
  @emission_normal_texture.setter
  def emission_normal_texture(self,  value:'py4godot_object.Object'):
    self.set_emission_normal_texture(value)
  @property
  def emission_color_texture(self) -> typing.Any:
    r''''''
    _ret = self. get_emission_color_texture()
    return _ret
  @emission_color_texture.setter
  def emission_color_texture(self,  value:'py4godot_object.Object'):
    self.set_emission_color_texture(value)
  @property
  def emission_point_count(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_emission_point_count()
    return _ret
  @emission_point_count.setter
  def emission_point_count(self,  value:'int'):
    self.set_emission_point_count(value)
  @property
  def emission_ring_axis(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_emission_ring_axis()
    return _ret
  @emission_ring_axis.setter
  def emission_ring_axis(self,  value:'Vector3'):
    self.set_emission_ring_axis(value)
  @property
  def emission_ring_height(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_emission_ring_height()
    return _ret
  @emission_ring_height.setter
  def emission_ring_height(self,  value:'float'):
    self.set_emission_ring_height(value)
  @property
  def emission_ring_radius(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_emission_ring_radius()
    return _ret
  @emission_ring_radius.setter
  def emission_ring_radius(self,  value:'float'):
    self.set_emission_ring_radius(value)
  @property
  def emission_ring_inner_radius(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_emission_ring_inner_radius()
    return _ret
  @emission_ring_inner_radius.setter
  def emission_ring_inner_radius(self,  value:'float'):
    self.set_emission_ring_inner_radius(value)
  @property
  def emission_ring_cone_angle(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_emission_ring_cone_angle()
    return _ret
  @emission_ring_cone_angle.setter
  def emission_ring_cone_angle(self,  value:'float'):
    self.set_emission_ring_cone_angle(value)
  @property
  def angle(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(7)
    return _ret
  @angle.setter
  def angle(self,  value:'Vector2'):
    self.set_param(7, value)
  @property
  def angle_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(7)
    return _ret
  @angle_min.setter
  def angle_min(self,  value:'float'):
    self.set_param_min(7, value)
  @property
  def angle_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(7)
    return _ret
  @angle_max.setter
  def angle_max(self,  value:'float'):
    self.set_param_max(7, value)
  @property
  def angle_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_param_texture(7)
    return _ret
  @angle_curve.setter
  def angle_curve(self,  value:'py4godot_object.Object'):
    self.set_param_texture(7, value)
  @property
  def inherit_velocity_ratio(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_inherit_velocity_ratio()
    return _ret
  @inherit_velocity_ratio.setter
  def inherit_velocity_ratio(self,  value:'float'):
    self.set_inherit_velocity_ratio(value)
  @property
  def velocity_pivot(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_velocity_pivot()
    return _ret
  @velocity_pivot.setter
  def velocity_pivot(self,  value:'Vector3'):
    self.set_velocity_pivot(value)
  @property
  def direction(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_direction()
    return _ret
  @direction.setter
  def direction(self,  value:'Vector3'):
    self.set_direction(value)
  @property
  def spread(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_spread()
    return _ret
  @spread.setter
  def spread(self,  value:'float'):
    self.set_spread(value)
  @property
  def flatness(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_flatness()
    return _ret
  @flatness.setter
  def flatness(self,  value:'float'):
    self.set_flatness(value)
  @property
  def initial_velocity(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(0)
    return _ret
  @initial_velocity.setter
  def initial_velocity(self,  value:'Vector2'):
    self.set_param(0, value)
  @property
  def initial_velocity_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(0)
    return _ret
  @initial_velocity_min.setter
  def initial_velocity_min(self,  value:'float'):
    self.set_param_min(0, value)
  @property
  def initial_velocity_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(0)
    return _ret
  @initial_velocity_max.setter
  def initial_velocity_max(self,  value:'float'):
    self.set_param_max(0, value)
  @property
  def angular_velocity(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(1)
    return _ret
  @angular_velocity.setter
  def angular_velocity(self,  value:'Vector2'):
    self.set_param(1, value)
  @property
  def angular_velocity_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(1)
    return _ret
  @angular_velocity_min.setter
  def angular_velocity_min(self,  value:'float'):
    self.set_param_min(1, value)
  @property
  def angular_velocity_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(1)
    return _ret
  @angular_velocity_max.setter
  def angular_velocity_max(self,  value:'float'):
    self.set_param_max(1, value)
  @property
  def angular_velocity_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_param_texture(1)
    return _ret
  @angular_velocity_curve.setter
  def angular_velocity_curve(self,  value:'py4godot_object.Object'):
    self.set_param_texture(1, value)
  @property
  def directional_velocity(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(16)
    return _ret
  @directional_velocity.setter
  def directional_velocity(self,  value:'Vector2'):
    self.set_param(16, value)
  @property
  def directional_velocity_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(16)
    return _ret
  @directional_velocity_min.setter
  def directional_velocity_min(self,  value:'float'):
    self.set_param_min(16, value)
  @property
  def directional_velocity_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(16)
    return _ret
  @directional_velocity_max.setter
  def directional_velocity_max(self,  value:'float'):
    self.set_param_max(16, value)
  @property
  def directional_velocity_curve(self) -> typing.Union['py4godot_curvexyztexture.CurveXYZTexture']:
    r''''''
    _ret = self. get_param_texture(16)
    return _ret
  @directional_velocity_curve.setter
  def directional_velocity_curve(self,  value:'py4godot_object.Object'):
    self.set_param_texture(16, value)
  @property
  def orbit_velocity(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(2)
    return _ret
  @orbit_velocity.setter
  def orbit_velocity(self,  value:'Vector2'):
    self.set_param(2, value)
  @property
  def orbit_velocity_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(2)
    return _ret
  @orbit_velocity_min.setter
  def orbit_velocity_min(self,  value:'float'):
    self.set_param_min(2, value)
  @property
  def orbit_velocity_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(2)
    return _ret
  @orbit_velocity_max.setter
  def orbit_velocity_max(self,  value:'float'):
    self.set_param_max(2, value)
  @property
  def orbit_velocity_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_param_texture(2)
    return _ret
  @orbit_velocity_curve.setter
  def orbit_velocity_curve(self,  value:'py4godot_object.Object'):
    self.set_param_texture(2, value)
  @property
  def radial_velocity(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(15)
    return _ret
  @radial_velocity.setter
  def radial_velocity(self,  value:'Vector2'):
    self.set_param(15, value)
  @property
  def radial_velocity_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(15)
    return _ret
  @radial_velocity_min.setter
  def radial_velocity_min(self,  value:'float'):
    self.set_param_min(15, value)
  @property
  def radial_velocity_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(15)
    return _ret
  @radial_velocity_max.setter
  def radial_velocity_max(self,  value:'float'):
    self.set_param_max(15, value)
  @property
  def radial_velocity_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_param_texture(15)
    return _ret
  @radial_velocity_curve.setter
  def radial_velocity_curve(self,  value:'py4godot_object.Object'):
    self.set_param_texture(15, value)
  @property
  def velocity_limit_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_velocity_limit_curve()
    return _ret
  @velocity_limit_curve.setter
  def velocity_limit_curve(self,  value:'py4godot_object.Object'):
    self.set_velocity_limit_curve(value)
  @property
  def gravity(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_gravity()
    return _ret
  @gravity.setter
  def gravity(self,  value:'Vector3'):
    self.set_gravity(value)
  @property
  def linear_accel(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(3)
    return _ret
  @linear_accel.setter
  def linear_accel(self,  value:'Vector2'):
    self.set_param(3, value)
  @property
  def linear_accel_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(3)
    return _ret
  @linear_accel_min.setter
  def linear_accel_min(self,  value:'float'):
    self.set_param_min(3, value)
  @property
  def linear_accel_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(3)
    return _ret
  @linear_accel_max.setter
  def linear_accel_max(self,  value:'float'):
    self.set_param_max(3, value)
  @property
  def linear_accel_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_param_texture(3)
    return _ret
  @linear_accel_curve.setter
  def linear_accel_curve(self,  value:'py4godot_object.Object'):
    self.set_param_texture(3, value)
  @property
  def radial_accel(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(4)
    return _ret
  @radial_accel.setter
  def radial_accel(self,  value:'Vector2'):
    self.set_param(4, value)
  @property
  def radial_accel_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(4)
    return _ret
  @radial_accel_min.setter
  def radial_accel_min(self,  value:'float'):
    self.set_param_min(4, value)
  @property
  def radial_accel_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(4)
    return _ret
  @radial_accel_max.setter
  def radial_accel_max(self,  value:'float'):
    self.set_param_max(4, value)
  @property
  def radial_accel_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_param_texture(4)
    return _ret
  @radial_accel_curve.setter
  def radial_accel_curve(self,  value:'py4godot_object.Object'):
    self.set_param_texture(4, value)
  @property
  def tangential_accel(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(5)
    return _ret
  @tangential_accel.setter
  def tangential_accel(self,  value:'Vector2'):
    self.set_param(5, value)
  @property
  def tangential_accel_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(5)
    return _ret
  @tangential_accel_min.setter
  def tangential_accel_min(self,  value:'float'):
    self.set_param_min(5, value)
  @property
  def tangential_accel_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(5)
    return _ret
  @tangential_accel_max.setter
  def tangential_accel_max(self,  value:'float'):
    self.set_param_max(5, value)
  @property
  def tangential_accel_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_param_texture(5)
    return _ret
  @tangential_accel_curve.setter
  def tangential_accel_curve(self,  value:'py4godot_object.Object'):
    self.set_param_texture(5, value)
  @property
  def damping(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(6)
    return _ret
  @damping.setter
  def damping(self,  value:'Vector2'):
    self.set_param(6, value)
  @property
  def damping_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(6)
    return _ret
  @damping_min.setter
  def damping_min(self,  value:'float'):
    self.set_param_min(6, value)
  @property
  def damping_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(6)
    return _ret
  @damping_max.setter
  def damping_max(self,  value:'float'):
    self.set_param_max(6, value)
  @property
  def damping_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_param_texture(6)
    return _ret
  @damping_curve.setter
  def damping_curve(self,  value:'py4godot_object.Object'):
    self.set_param_texture(6, value)
  @property
  def attractor_interaction_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_attractor_interaction_enabled()
    return _ret
  @attractor_interaction_enabled.setter
  def attractor_interaction_enabled(self,  value:'bool'):
    self.set_attractor_interaction_enabled(value)
  @property
  def scale(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(8)
    return _ret
  @scale.setter
  def scale(self,  value:'Vector2'):
    self.set_param(8, value)
  @property
  def scale_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(8)
    return _ret
  @scale_min.setter
  def scale_min(self,  value:'float'):
    self.set_param_min(8, value)
  @property
  def scale_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(8)
    return _ret
  @scale_max.setter
  def scale_max(self,  value:'float'):
    self.set_param_max(8, value)
  @property
  def scale_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_param_texture(8)
    return _ret
  @scale_curve.setter
  def scale_curve(self,  value:'py4godot_object.Object'):
    self.set_param_texture(8, value)
  @property
  def scale_over_velocity(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(17)
    return _ret
  @scale_over_velocity.setter
  def scale_over_velocity(self,  value:'Vector2'):
    self.set_param(17, value)
  @property
  def scale_over_velocity_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(17)
    return _ret
  @scale_over_velocity_min.setter
  def scale_over_velocity_min(self,  value:'float'):
    self.set_param_min(17, value)
  @property
  def scale_over_velocity_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(17)
    return _ret
  @scale_over_velocity_max.setter
  def scale_over_velocity_max(self,  value:'float'):
    self.set_param_max(17, value)
  @property
  def scale_over_velocity_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_param_texture(17)
    return _ret
  @scale_over_velocity_curve.setter
  def scale_over_velocity_curve(self,  value:'py4godot_object.Object'):
    self.set_param_texture(17, value)
  @property
  def color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_color()
    return _ret
  @color.setter
  def color(self,  value:'Color'):
    self.set_color(value)
  @property
  def color_ramp(self) -> typing.Union['py4godot_gradienttexture1d.GradientTexture1D']:
    r''''''
    _ret = self. get_color_ramp()
    return _ret
  @color_ramp.setter
  def color_ramp(self,  value:'py4godot_object.Object'):
    self.set_color_ramp(value)
  @property
  def color_initial_ramp(self) -> typing.Union['py4godot_gradienttexture1d.GradientTexture1D']:
    r''''''
    _ret = self. get_color_initial_ramp()
    return _ret
  @color_initial_ramp.setter
  def color_initial_ramp(self,  value:'py4godot_object.Object'):
    self.set_color_initial_ramp(value)
  @property
  def alpha_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_alpha_curve()
    return _ret
  @alpha_curve.setter
  def alpha_curve(self,  value:'py4godot_object.Object'):
    self.set_alpha_curve(value)
  @property
  def emission_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_emission_curve()
    return _ret
  @emission_curve.setter
  def emission_curve(self,  value:'py4godot_object.Object'):
    self.set_emission_curve(value)
  @property
  def hue_variation(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(9)
    return _ret
  @hue_variation.setter
  def hue_variation(self,  value:'Vector2'):
    self.set_param(9, value)
  @property
  def hue_variation_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(9)
    return _ret
  @hue_variation_min.setter
  def hue_variation_min(self,  value:'float'):
    self.set_param_min(9, value)
  @property
  def hue_variation_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(9)
    return _ret
  @hue_variation_max.setter
  def hue_variation_max(self,  value:'float'):
    self.set_param_max(9, value)
  @property
  def hue_variation_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_param_texture(9)
    return _ret
  @hue_variation_curve.setter
  def hue_variation_curve(self,  value:'py4godot_object.Object'):
    self.set_param_texture(9, value)
  @property
  def anim_speed(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(10)
    return _ret
  @anim_speed.setter
  def anim_speed(self,  value:'Vector2'):
    self.set_param(10, value)
  @property
  def anim_speed_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(10)
    return _ret
  @anim_speed_min.setter
  def anim_speed_min(self,  value:'float'):
    self.set_param_min(10, value)
  @property
  def anim_speed_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(10)
    return _ret
  @anim_speed_max.setter
  def anim_speed_max(self,  value:'float'):
    self.set_param_max(10, value)
  @property
  def anim_speed_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_param_texture(10)
    return _ret
  @anim_speed_curve.setter
  def anim_speed_curve(self,  value:'py4godot_object.Object'):
    self.set_param_texture(10, value)
  @property
  def anim_offset(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(11)
    return _ret
  @anim_offset.setter
  def anim_offset(self,  value:'Vector2'):
    self.set_param(11, value)
  @property
  def anim_offset_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(11)
    return _ret
  @anim_offset_min.setter
  def anim_offset_min(self,  value:'float'):
    self.set_param_min(11, value)
  @property
  def anim_offset_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(11)
    return _ret
  @anim_offset_max.setter
  def anim_offset_max(self,  value:'float'):
    self.set_param_max(11, value)
  @property
  def anim_offset_curve(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_param_texture(11)
    return _ret
  @anim_offset_curve.setter
  def anim_offset_curve(self,  value:'py4godot_object.Object'):
    self.set_param_texture(11, value)
  @property
  def turbulence_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_turbulence_enabled()
    return _ret
  @turbulence_enabled.setter
  def turbulence_enabled(self,  value:'bool'):
    self.set_turbulence_enabled(value)
  @property
  def turbulence_noise_strength(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_turbulence_noise_strength()
    return _ret
  @turbulence_noise_strength.setter
  def turbulence_noise_strength(self,  value:'float'):
    self.set_turbulence_noise_strength(value)
  @property
  def turbulence_noise_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_turbulence_noise_scale()
    return _ret
  @turbulence_noise_scale.setter
  def turbulence_noise_scale(self,  value:'float'):
    self.set_turbulence_noise_scale(value)
  @property
  def turbulence_noise_speed(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_turbulence_noise_speed()
    return _ret
  @turbulence_noise_speed.setter
  def turbulence_noise_speed(self,  value:'Vector3'):
    self.set_turbulence_noise_speed(value)
  @property
  def turbulence_noise_speed_random(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_turbulence_noise_speed_random()
    return _ret
  @turbulence_noise_speed_random.setter
  def turbulence_noise_speed_random(self,  value:'float'):
    self.set_turbulence_noise_speed_random(value)
  @property
  def turbulence_influence(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(13)
    return _ret
  @turbulence_influence.setter
  def turbulence_influence(self,  value:'Vector2'):
    self.set_param(13, value)
  @property
  def turbulence_influence_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(13)
    return _ret
  @turbulence_influence_min.setter
  def turbulence_influence_min(self,  value:'float'):
    self.set_param_min(13, value)
  @property
  def turbulence_influence_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(13)
    return _ret
  @turbulence_influence_max.setter
  def turbulence_influence_max(self,  value:'float'):
    self.set_param_max(13, value)
  @property
  def turbulence_initial_displacement(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_param(14)
    return _ret
  @turbulence_initial_displacement.setter
  def turbulence_initial_displacement(self,  value:'Vector2'):
    self.set_param(14, value)
  @property
  def turbulence_initial_displacement_min(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_min(14)
    return _ret
  @turbulence_initial_displacement_min.setter
  def turbulence_initial_displacement_min(self,  value:'float'):
    self.set_param_min(14, value)
  @property
  def turbulence_initial_displacement_max(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_param_max(14)
    return _ret
  @turbulence_initial_displacement_max.setter
  def turbulence_initial_displacement_max(self,  value:'float'):
    self.set_param_max(14, value)
  @property
  def turbulence_influence_over_life(self) -> typing.Union['py4godot_curvetexture.CurveTexture']:
    r''''''
    _ret = self. get_param_texture(12)
    return _ret
  @turbulence_influence_over_life.setter
  def turbulence_influence_over_life(self,  value:'py4godot_object.Object'):
    self.set_param_texture(12, value)
  @property
  def collision_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_collision_mode()
    return _ret
  @collision_mode.setter
  def collision_mode(self,  value:'int'):
    self.set_collision_mode(value)
  @property
  def collision_friction(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_collision_friction()
    return _ret
  @collision_friction.setter
  def collision_friction(self,  value:'float'):
    self.set_collision_friction(value)
  @property
  def collision_bounce(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_collision_bounce()
    return _ret
  @collision_bounce.setter
  def collision_bounce(self,  value:'float'):
    self.set_collision_bounce(value)
  @property
  def collision_use_scale(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_collision_using_scale()
    return _ret
  @collision_use_scale.setter
  def collision_use_scale(self,  value:'bool'):
    self.set_collision_use_scale(value)
  @property
  def sub_emitter_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_sub_emitter_mode()
    return _ret
  @sub_emitter_mode.setter
  def sub_emitter_mode(self,  value:'int'):
    self.set_sub_emitter_mode(value)
  @property
  def sub_emitter_frequency(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_sub_emitter_frequency()
    return _ret
  @sub_emitter_frequency.setter
  def sub_emitter_frequency(self,  value:'float'):
    self.set_sub_emitter_frequency(value)
  @property
  def sub_emitter_amount_at_end(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_sub_emitter_amount_at_end()
    return _ret
  @sub_emitter_amount_at_end.setter
  def sub_emitter_amount_at_end(self,  value:'int'):
    self.set_sub_emitter_amount_at_end(value)
  @property
  def sub_emitter_amount_at_collision(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_sub_emitter_amount_at_collision()
    return _ret
  @sub_emitter_amount_at_collision.setter
  def sub_emitter_amount_at_collision(self,  value:'int'):
    self.set_sub_emitter_amount_at_collision(value)
  @property
  def sub_emitter_amount_at_start(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_sub_emitter_amount_at_start()
    return _ret
  @sub_emitter_amount_at_start.setter
  def sub_emitter_amount_at_start(self,  value:'int'):
    self.set_sub_emitter_amount_at_start(value)
  @property
  def sub_emitter_keep_velocity(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_sub_emitter_keep_velocity()
    return _ret
  @sub_emitter_keep_velocity.setter
  def sub_emitter_keep_velocity(self,  value:'bool'):
    self.set_sub_emitter_keep_velocity(value)
  @functools.native_method
  def set_direction(self, degrees:'Vector3'   ) -> None:
    r''''''

    assert(not degrees is None)
    assert isinstance(degrees, Vector3), 'degrees must be Vector3'


    self.py__direction = degrees






    self._ptr.call_with_return(87,tuple([degrees._ptr]))

  @functools.native_method
  def get_direction(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([]))

    return _ret


  @functools.native_method
  def set_inherit_velocity_ratio(self, ratio:'float'   ) -> None:
    r''''''

    assert isinstance(ratio, (int, float)), 'ratio must be int or float'


    self.py__inherit_velocity_ratio = ratio






    self._ptr.call_with_return(89,tuple([ratio]))

  @functools.native_method
  def get_inherit_velocity_ratio(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([]))

    return _ret


  @functools.native_method
  def set_spread(self, degrees:'float'   ) -> None:
    r''''''

    assert isinstance(degrees, (int, float)), 'degrees must be int or float'


    self.py__spread = degrees






    self._ptr.call_with_return(91,tuple([degrees]))

  @functools.native_method
  def get_spread(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([]))

    return _ret


  @functools.native_method
  def set_flatness(self, amount:'float'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__flatness = amount






    self._ptr.call_with_return(93,tuple([amount]))

  @functools.native_method
  def get_flatness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([]))

    return _ret


  @functools.native_method
  def set_param(self, param:'int'  , value:'Vector2'   ) -> None:
    r'''
				Sets the minimum and maximum values of the given `param`.
				The `x` component of the argument vector corresponds to minimum and the `y` component corresponds to maximum.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'
    assert(not value is None)
    assert isinstance(value, Vector2), 'value must be Vector2'


    self.py__angle = param







    self._ptr.call_with_return(95,tuple([param, value._ptr]))

  @functools.native_method
  def get_param(self, param:'int'  ) -> typing.Union['Vector2']:
    r'''
				Returns the minimum and maximum values of the given `param` as a vector.
				The `x` component of the returned vector corresponds to minimum and the `y` component corresponds to maximum.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([param]))

    return _ret


  @functools.native_method
  def set_param_min(self, param:'int'  , value:'float'   ) -> None:
    r'''
				Sets the minimum value range for the given parameter.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'


    self.py__angle_min = param







    self._ptr.call_with_return(97,tuple([param, value]))

  @functools.native_method
  def get_param_min(self, param:'int'  ) -> typing.Union[float]:
    r'''
				Returns the minimum value range for the given parameter.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(98,tuple([param]))

    return _ret


  @functools.native_method
  def set_param_max(self, param:'int'  , value:'float'   ) -> None:
    r'''
				Sets the maximum value range for the given parameter.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'


    self.py__angle_max = param







    self._ptr.call_with_return(99,tuple([param, value]))

  @functools.native_method
  def get_param_max(self, param:'int'  ) -> typing.Union[float]:
    r'''
				Returns the maximum value range for the given parameter.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([param]))

    return _ret


  @functools.native_method
  def set_param_texture(self, param:'int'  , texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Sets the `Texture2D` for the specified `enum Parameter`.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'
    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'


    self.py__angle_curve = param







    self._ptr.call_with_return(101,tuple([param, texture._ptr]))

  @functools.native_method
  def get_param_texture(self, param:'int'  ) -> typing.Any:
    r'''
				Returns the `Texture2D` used by the specified parameter.
			'''

    assert isinstance(param, (int, float)), 'param must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(102,tuple([param]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__color = color






    self._ptr.call_with_return(103,tuple([color._ptr]))

  @functools.native_method
  def get_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(104,tuple([]))

    return _ret


  @functools.native_method
  def set_color_ramp(self, ramp:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not ramp is None)
    assert isinstance(ramp, get_class('Texture2D')), 'ramp must be Texture2D'


    self.py__color_ramp = ramp






    self._ptr.call_with_return(105,tuple([ramp._ptr]))

  @functools.native_method
  def get_color_ramp(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(106,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_alpha_curve(self, curve:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not curve is None)
    assert isinstance(curve, get_class('Texture2D')), 'curve must be Texture2D'


    self.py__alpha_curve = curve






    self._ptr.call_with_return(107,tuple([curve._ptr]))

  @functools.native_method
  def get_alpha_curve(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(108,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_emission_curve(self, curve:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not curve is None)
    assert isinstance(curve, get_class('Texture2D')), 'curve must be Texture2D'


    self.py__emission_curve = curve






    self._ptr.call_with_return(109,tuple([curve._ptr]))

  @functools.native_method
  def get_emission_curve(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(110,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_color_initial_ramp(self, ramp:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not ramp is None)
    assert isinstance(ramp, get_class('Texture2D')), 'ramp must be Texture2D'


    self.py__color_initial_ramp = ramp






    self._ptr.call_with_return(111,tuple([ramp._ptr]))

  @functools.native_method
  def get_color_initial_ramp(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(112,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_velocity_limit_curve(self, curve:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not curve is None)
    assert isinstance(curve, get_class('Texture2D')), 'curve must be Texture2D'


    self.py__velocity_limit_curve = curve






    self._ptr.call_with_return(113,tuple([curve._ptr]))

  @functools.native_method
  def get_velocity_limit_curve(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(114,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_particle_flag(self, particle_flag:'int'  , enable:'bool'   ) -> None:
    r'''
				Sets the `particle_flag` to `enable`.
			'''

    assert isinstance(particle_flag, (int, float)), 'particle_flag must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'


    self.py__particle_flag_align_y = particle_flag







    self._ptr.call_with_return(115,tuple([particle_flag, enable]))

  @functools.native_method
  def get_particle_flag(self, particle_flag:'int'  ) -> typing.Union[bool]:
    r'''
				Returns `true` if the specified particle flag is enabled.
			'''

    assert isinstance(particle_flag, (int, float)), 'particle_flag must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(116,tuple([particle_flag]))

    return _ret


  @functools.native_method
  def set_velocity_pivot(self, pivot:'Vector3'   ) -> None:
    r''''''

    assert(not pivot is None)
    assert isinstance(pivot, Vector3), 'pivot must be Vector3'


    self.py__velocity_pivot = pivot






    self._ptr.call_with_return(117,tuple([pivot._ptr]))

  @functools.native_method
  def get_velocity_pivot(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(118,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_shape(self, shape:'int'  ) -> None:
    r''''''

    assert isinstance(shape, (int, float)), 'shape must be int or float'


    self.py__emission_shape = shape






    self._ptr.call_with_return(119,tuple([shape]))

  @functools.native_method
  def get_emission_shape(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(120,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_sphere_radius(self, radius:'float'   ) -> None:
    r''''''

    assert isinstance(radius, (int, float)), 'radius must be int or float'


    self.py__emission_sphere_radius = radius






    self._ptr.call_with_return(121,tuple([radius]))

  @functools.native_method
  def get_emission_sphere_radius(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(122,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_box_extents(self, extents:'Vector3'   ) -> None:
    r''''''

    assert(not extents is None)
    assert isinstance(extents, Vector3), 'extents must be Vector3'


    self.py__emission_box_extents = extents






    self._ptr.call_with_return(123,tuple([extents._ptr]))

  @functools.native_method
  def get_emission_box_extents(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(124,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_point_texture(self, texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'


    self.py__emission_point_texture = texture






    self._ptr.call_with_return(125,tuple([texture._ptr]))

  @functools.native_method
  def get_emission_point_texture(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(126,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_emission_normal_texture(self, texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'


    self.py__emission_normal_texture = texture






    self._ptr.call_with_return(127,tuple([texture._ptr]))

  @functools.native_method
  def get_emission_normal_texture(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(128,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_emission_color_texture(self, texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r''''''

    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'


    self.py__emission_color_texture = texture






    self._ptr.call_with_return(129,tuple([texture._ptr]))

  @functools.native_method
  def get_emission_color_texture(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(130,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_emission_point_count(self, point_count:'int'   ) -> None:
    r''''''

    assert isinstance(point_count, (int, float)), 'point_count must be int or float'


    self.py__emission_point_count = point_count






    self._ptr.call_with_return(131,tuple([point_count]))

  @functools.native_method
  def get_emission_point_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(132,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_ring_axis(self, axis:'Vector3'   ) -> None:
    r''''''

    assert(not axis is None)
    assert isinstance(axis, Vector3), 'axis must be Vector3'


    self.py__emission_ring_axis = axis






    self._ptr.call_with_return(133,tuple([axis._ptr]))

  @functools.native_method
  def get_emission_ring_axis(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(134,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_ring_height(self, height:'float'   ) -> None:
    r''''''

    assert isinstance(height, (int, float)), 'height must be int or float'


    self.py__emission_ring_height = height






    self._ptr.call_with_return(135,tuple([height]))

  @functools.native_method
  def get_emission_ring_height(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(136,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_ring_radius(self, radius:'float'   ) -> None:
    r''''''

    assert isinstance(radius, (int, float)), 'radius must be int or float'


    self.py__emission_ring_radius = radius






    self._ptr.call_with_return(137,tuple([radius]))

  @functools.native_method
  def get_emission_ring_radius(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(138,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_ring_inner_radius(self, inner_radius:'float'   ) -> None:
    r''''''

    assert isinstance(inner_radius, (int, float)), 'inner_radius must be int or float'


    self.py__emission_ring_inner_radius = inner_radius






    self._ptr.call_with_return(139,tuple([inner_radius]))

  @functools.native_method
  def get_emission_ring_inner_radius(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(140,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_ring_cone_angle(self, cone_angle:'float'   ) -> None:
    r''''''

    assert isinstance(cone_angle, (int, float)), 'cone_angle must be int or float'


    self.py__emission_ring_cone_angle = cone_angle






    self._ptr.call_with_return(141,tuple([cone_angle]))

  @functools.native_method
  def get_emission_ring_cone_angle(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(142,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_shape_offset(self, emission_shape_offset:'Vector3'   ) -> None:
    r''''''

    assert(not emission_shape_offset is None)
    assert isinstance(emission_shape_offset, Vector3), 'emission_shape_offset must be Vector3'


    self.py__emission_shape_offset = emission_shape_offset






    self._ptr.call_with_return(143,tuple([emission_shape_offset._ptr]))

  @functools.native_method
  def get_emission_shape_offset(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(144,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_shape_scale(self, emission_shape_scale:'Vector3'   ) -> None:
    r''''''

    assert(not emission_shape_scale is None)
    assert isinstance(emission_shape_scale, Vector3), 'emission_shape_scale must be Vector3'


    self.py__emission_shape_scale = emission_shape_scale






    self._ptr.call_with_return(145,tuple([emission_shape_scale._ptr]))

  @functools.native_method
  def get_emission_shape_scale(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(146,tuple([]))

    return _ret


  @functools.native_method
  def get_turbulence_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(147,tuple([]))

    return _ret


  @functools.native_method
  def set_turbulence_enabled(self, turbulence_enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(turbulence_enabled, bool), 'turbulence_enabled must be bool'


    self.py__turbulence_enabled = turbulence_enabled






    self._ptr.call_with_return(148,tuple([turbulence_enabled]))

  @functools.native_method
  def get_turbulence_noise_strength(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(149,tuple([]))

    return _ret


  @functools.native_method
  def set_turbulence_noise_strength(self, turbulence_noise_strength:'float'   ) -> None:
    r''''''

    assert isinstance(turbulence_noise_strength, (int, float)), 'turbulence_noise_strength must be int or float'


    self.py__turbulence_noise_strength = turbulence_noise_strength






    self._ptr.call_with_return(150,tuple([turbulence_noise_strength]))

  @functools.native_method
  def get_turbulence_noise_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(151,tuple([]))

    return _ret


  @functools.native_method
  def set_turbulence_noise_scale(self, turbulence_noise_scale:'float'   ) -> None:
    r''''''

    assert isinstance(turbulence_noise_scale, (int, float)), 'turbulence_noise_scale must be int or float'


    self.py__turbulence_noise_scale = turbulence_noise_scale






    self._ptr.call_with_return(152,tuple([turbulence_noise_scale]))

  @functools.native_method
  def get_turbulence_noise_speed_random(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(153,tuple([]))

    return _ret


  @functools.native_method
  def set_turbulence_noise_speed_random(self, turbulence_noise_speed_random:'float'   ) -> None:
    r''''''

    assert isinstance(turbulence_noise_speed_random, (int, float)), 'turbulence_noise_speed_random must be int or float'


    self.py__turbulence_noise_speed_random = turbulence_noise_speed_random






    self._ptr.call_with_return(154,tuple([turbulence_noise_speed_random]))

  @functools.native_method
  def get_turbulence_noise_speed(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(155,tuple([]))

    return _ret


  @functools.native_method
  def set_turbulence_noise_speed(self, turbulence_noise_speed:'Vector3'   ) -> None:
    r''''''

    assert(not turbulence_noise_speed is None)
    assert isinstance(turbulence_noise_speed, Vector3), 'turbulence_noise_speed must be Vector3'


    self.py__turbulence_noise_speed = turbulence_noise_speed






    self._ptr.call_with_return(156,tuple([turbulence_noise_speed._ptr]))

  @functools.native_method
  def get_gravity(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(157,tuple([]))

    return _ret


  @functools.native_method
  def set_gravity(self, accel_vec:'Vector3'   ) -> None:
    r''''''

    assert(not accel_vec is None)
    assert isinstance(accel_vec, Vector3), 'accel_vec must be Vector3'


    self.py__gravity = accel_vec






    self._ptr.call_with_return(158,tuple([accel_vec._ptr]))

  @functools.native_method
  def set_lifetime_randomness(self, randomness:'float'   ) -> None:
    r''''''

    assert isinstance(randomness, (int, float)), 'randomness must be int or float'


    self.py__lifetime_randomness = randomness






    self._ptr.call_with_return(159,tuple([randomness]))

  @functools.native_method
  def get_lifetime_randomness(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(160,tuple([]))

    return _ret


  @functools.native_method
  def get_sub_emitter_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(161,tuple([]))

    return _ret


  @functools.native_method
  def set_sub_emitter_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__sub_emitter_mode = mode






    self._ptr.call_with_return(162,tuple([mode]))

  @functools.native_method
  def get_sub_emitter_frequency(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(163,tuple([]))

    return _ret


  @functools.native_method
  def set_sub_emitter_frequency(self, hz:'float'   ) -> None:
    r''''''

    assert isinstance(hz, (int, float)), 'hz must be int or float'


    self.py__sub_emitter_frequency = hz






    self._ptr.call_with_return(164,tuple([hz]))

  @functools.native_method
  def get_sub_emitter_amount_at_end(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(165,tuple([]))

    return _ret


  @functools.native_method
  def set_sub_emitter_amount_at_end(self, amount:'int'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__sub_emitter_amount_at_end = amount






    self._ptr.call_with_return(166,tuple([amount]))

  @functools.native_method
  def get_sub_emitter_amount_at_collision(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(167,tuple([]))

    return _ret


  @functools.native_method
  def set_sub_emitter_amount_at_collision(self, amount:'int'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__sub_emitter_amount_at_collision = amount






    self._ptr.call_with_return(168,tuple([amount]))

  @functools.native_method
  def get_sub_emitter_amount_at_start(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(169,tuple([]))

    return _ret


  @functools.native_method
  def set_sub_emitter_amount_at_start(self, amount:'int'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__sub_emitter_amount_at_start = amount






    self._ptr.call_with_return(170,tuple([amount]))

  @functools.native_method
  def get_sub_emitter_keep_velocity(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(171,tuple([]))

    return _ret


  @functools.native_method
  def set_sub_emitter_keep_velocity(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__sub_emitter_keep_velocity = enable






    self._ptr.call_with_return(172,tuple([enable]))

  @functools.native_method
  def set_attractor_interaction_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__attractor_interaction_enabled = enabled






    self._ptr.call_with_return(173,tuple([enabled]))

  @functools.native_method
  def is_attractor_interaction_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(174,tuple([]))

    return _ret


  @functools.native_method
  def set_collision_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__collision_mode = mode






    self._ptr.call_with_return(175,tuple([mode]))

  @functools.native_method
  def get_collision_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(176,tuple([]))

    return _ret


  @functools.native_method
  def set_collision_use_scale(self, radius:'bool'   ) -> None:
    r''''''

    assert isinstance(radius, bool), 'radius must be bool'


    self.py__collision_use_scale = radius






    self._ptr.call_with_return(177,tuple([radius]))

  @functools.native_method
  def is_collision_using_scale(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(178,tuple([]))

    return _ret


  @functools.native_method
  def set_collision_friction(self, friction:'float'   ) -> None:
    r''''''

    assert isinstance(friction, (int, float)), 'friction must be int or float'


    self.py__collision_friction = friction






    self._ptr.call_with_return(179,tuple([friction]))

  @functools.native_method
  def get_collision_friction(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(180,tuple([]))

    return _ret


  @functools.native_method
  def set_collision_bounce(self, bounce:'float'   ) -> None:
    r''''''

    assert isinstance(bounce, (int, float)), 'bounce must be int or float'


    self.py__collision_bounce = bounce






    self._ptr.call_with_return(181,tuple([bounce]))

  @functools.native_method
  def get_collision_bounce(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(182,tuple([]))

    return _ret



register_cast_function('ParticleProcessMaterial', ParticleProcessMaterial.cast)
register_class('ParticleProcessMaterial', ParticleProcessMaterial)
