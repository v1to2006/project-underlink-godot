# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.XRInterface as py4godot_xrinterface 
from py4godot.wrappers.wrappers import CPPOpenXRInterfaceWrapper

class SessionState:
  SESSION_STATE_UNKNOWN = 0
  SESSION_STATE_IDLE = 1
  SESSION_STATE_READY = 2
  SESSION_STATE_SYNCHRONIZED = 3
  SESSION_STATE_VISIBLE = 4
  SESSION_STATE_FOCUSED = 5
  SESSION_STATE_STOPPING = 6
  SESSION_STATE_LOSS_PENDING = 7
  SESSION_STATE_EXITING = 8
class Hand:
  HAND_LEFT = 0
  HAND_RIGHT = 1
  HAND_MAX = 2
class HandMotionRange:
  HAND_MOTION_RANGE_UNOBSTRUCTED = 0
  HAND_MOTION_RANGE_CONFORM_TO_CONTROLLER = 1
  HAND_MOTION_RANGE_MAX = 2
class HandTrackedSource:
  HAND_TRACKED_SOURCE_UNKNOWN = 0
  HAND_TRACKED_SOURCE_UNOBSTRUCTED = 1
  HAND_TRACKED_SOURCE_CONTROLLER = 2
  HAND_TRACKED_SOURCE_MAX = 3
class HandJoints:
  HAND_JOINT_PALM = 0
  HAND_JOINT_WRIST = 1
  HAND_JOINT_THUMB_METACARPAL = 2
  HAND_JOINT_THUMB_PROXIMAL = 3
  HAND_JOINT_THUMB_DISTAL = 4
  HAND_JOINT_THUMB_TIP = 5
  HAND_JOINT_INDEX_METACARPAL = 6
  HAND_JOINT_INDEX_PROXIMAL = 7
  HAND_JOINT_INDEX_INTERMEDIATE = 8
  HAND_JOINT_INDEX_DISTAL = 9
  HAND_JOINT_INDEX_TIP = 10
  HAND_JOINT_MIDDLE_METACARPAL = 11
  HAND_JOINT_MIDDLE_PROXIMAL = 12
  HAND_JOINT_MIDDLE_INTERMEDIATE = 13
  HAND_JOINT_MIDDLE_DISTAL = 14
  HAND_JOINT_MIDDLE_TIP = 15
  HAND_JOINT_RING_METACARPAL = 16
  HAND_JOINT_RING_PROXIMAL = 17
  HAND_JOINT_RING_INTERMEDIATE = 18
  HAND_JOINT_RING_DISTAL = 19
  HAND_JOINT_RING_TIP = 20
  HAND_JOINT_LITTLE_METACARPAL = 21
  HAND_JOINT_LITTLE_PROXIMAL = 22
  HAND_JOINT_LITTLE_INTERMEDIATE = 23
  HAND_JOINT_LITTLE_DISTAL = 24
  HAND_JOINT_LITTLE_TIP = 25
  HAND_JOINT_MAX = 26
class PerfSettingsLevel:
  PERF_SETTINGS_LEVEL_POWER_SAVINGS = 0
  PERF_SETTINGS_LEVEL_SUSTAINED_LOW = 1
  PERF_SETTINGS_LEVEL_SUSTAINED_HIGH = 2
  PERF_SETTINGS_LEVEL_BOOST = 3
class PerfSettingsSubDomain:
  PERF_SETTINGS_SUB_DOMAIN_COMPOSITING = 0
  PERF_SETTINGS_SUB_DOMAIN_RENDERING = 1
  PERF_SETTINGS_SUB_DOMAIN_THERMAL = 2
class PerfSettingsNotificationLevel:
  PERF_SETTINGS_NOTIF_LEVEL_NORMAL = 0
  PERF_SETTINGS_NOTIF_LEVEL_WARNING = 1
  PERF_SETTINGS_NOTIF_LEVEL_IMPAIRED = 2
class HandJointFlags:
  HAND_JOINT_NONE = 0
  HAND_JOINT_ORIENTATION_VALID = 1
  HAND_JOINT_ORIENTATION_TRACKED = 2
  HAND_JOINT_POSITION_VALID = 4
  HAND_JOINT_POSITION_TRACKED = 8
  HAND_JOINT_LINEAR_VELOCITY_VALID = 16
  HAND_JOINT_ANGULAR_VELOCITY_VALID = 32


class OpenXRInterface(py4godot_xrinterface.XRInterface):
  r''''''

  @staticmethod
  def constructor():
    class_ = OpenXRInterface.construct_without_init()
    class_._ptr = constructor(557,0, ())
    return class_
  @staticmethod
  def new():
    class_ = OpenXRInterface.construct_without_init()
    class_._ptr = constructor(557,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPOpenXRInterfaceWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(557,0, ())


  def generate_wrapper(self):
    return CPPOpenXRInterfaceWrapper()
  def init_signals(self):
    super().init_signals()
    session_begun_name = utils.py_string_to_string_name("session_begun")
    self.session_begun = signals.BuiltinSignal(self, session_begun_name)
    session_stopping_name = utils.py_string_to_string_name("session_stopping")
    self.session_stopping = signals.BuiltinSignal(self, session_stopping_name)
    session_synchronized_name = utils.py_string_to_string_name("session_synchronized")
    self.session_synchronized = signals.BuiltinSignal(self, session_synchronized_name)
    session_focussed_name = utils.py_string_to_string_name("session_focussed")
    self.session_focussed = signals.BuiltinSignal(self, session_focussed_name)
    session_visible_name = utils.py_string_to_string_name("session_visible")
    self.session_visible = signals.BuiltinSignal(self, session_visible_name)
    session_loss_pending_name = utils.py_string_to_string_name("session_loss_pending")
    self.session_loss_pending = signals.BuiltinSignal(self, session_loss_pending_name)
    instance_exiting_name = utils.py_string_to_string_name("instance_exiting")
    self.instance_exiting = signals.BuiltinSignal(self, instance_exiting_name)
    pose_recentered_name = utils.py_string_to_string_name("pose_recentered")
    self.pose_recentered = signals.BuiltinSignal(self, pose_recentered_name)
    refresh_rate_changed_name = utils.py_string_to_string_name("refresh_rate_changed")
    self.refresh_rate_changed = signals.BuiltinSignal(self, refresh_rate_changed_name)
    cpu_level_changed_name = utils.py_string_to_string_name("cpu_level_changed")
    self.cpu_level_changed = signals.BuiltinSignal(self, cpu_level_changed_name)
    gpu_level_changed_name = utils.py_string_to_string_name("gpu_level_changed")
    self.gpu_level_changed = signals.BuiltinSignal(self, gpu_level_changed_name)

  @staticmethod
  def construct_without_init():
    cls = OpenXRInterface.__new__(OpenXRInterface)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'OpenXRInterface'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(113, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = OpenXRInterface.construct_without_init()
    cls._ptr = CPPOpenXRInterfaceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = OpenXRInterface.construct_without_init()
    cls._ptr = CPPOpenXRInterfaceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def display_refresh_rate(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_display_refresh_rate()
    return _ret
  @display_refresh_rate.setter
  def display_refresh_rate(self,  value:'float'):
    self.set_display_refresh_rate(value)
  @property
  def render_target_size_multiplier(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_render_target_size_multiplier()
    return _ret
  @render_target_size_multiplier.setter
  def render_target_size_multiplier(self,  value:'float'):
    self.set_render_target_size_multiplier(value)
  @property
  def foveation_level(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_foveation_level()
    return _ret
  @foveation_level.setter
  def foveation_level(self,  value:'int'):
    self.set_foveation_level(value)
  @property
  def foveation_dynamic(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_foveation_dynamic()
    return _ret
  @foveation_dynamic.setter
  def foveation_dynamic(self,  value:'bool'):
    self.set_foveation_dynamic(value)
  @property
  def vrs_min_radius(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_vrs_min_radius()
    return _ret
  @vrs_min_radius.setter
  def vrs_min_radius(self,  value:'float'):
    self.set_vrs_min_radius(value)
  @property
  def vrs_strength(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_vrs_strength()
    return _ret
  @vrs_strength.setter
  def vrs_strength(self,  value:'float'):
    self.set_vrs_strength(value)
  @functools.native_method
  def get_session_state(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(81,tuple([]))
    return _ret


  @functools.native_method
  def get_display_refresh_rate(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([]))

    return _ret


  @functools.native_method
  def set_display_refresh_rate(self, refresh_rate:'float'   ) -> None:
    r''''''

    assert isinstance(refresh_rate, (int, float)), 'refresh_rate must be int or float'


    self.py__display_refresh_rate = refresh_rate






    self._ptr.call_with_return(83,tuple([refresh_rate]))

  @functools.native_method
  def get_render_target_size_multiplier(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([]))

    return _ret


  @functools.native_method
  def set_render_target_size_multiplier(self, multiplier:'float'   ) -> None:
    r''''''

    assert isinstance(multiplier, (int, float)), 'multiplier must be int or float'


    self.py__render_target_size_multiplier = multiplier






    self._ptr.call_with_return(85,tuple([multiplier]))

  @functools.native_method
  def is_foveation_supported(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def get_foveation_level(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(87,tuple([]))

    return _ret


  @functools.native_method
  def set_foveation_level(self, foveation_level:'int'   ) -> None:
    r''''''

    assert isinstance(foveation_level, (int, float)), 'foveation_level must be int or float'


    self.py__foveation_level = foveation_level






    self._ptr.call_with_return(88,tuple([foveation_level]))

  @functools.native_method
  def get_foveation_dynamic(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([]))

    return _ret


  @functools.native_method
  def set_foveation_dynamic(self, foveation_dynamic:'bool'   ) -> None:
    r''''''

    assert isinstance(foveation_dynamic, bool), 'foveation_dynamic must be bool'


    self.py__foveation_dynamic = foveation_dynamic






    self._ptr.call_with_return(90,tuple([foveation_dynamic]))

  @functools.native_method
  def is_action_set_active(self, name:'str'   ) -> typing.Union[bool]:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(91,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def set_action_set_active(self, name:'str'   , active:'bool'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert isinstance(active, bool), 'active must be bool'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    self._ptr.call_with_return(92,tuple([py_string_name._ptr, active]))

  @functools.native_method
  def get_action_sets(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(93,tuple([]))
    return _ret


  @functools.native_method
  def get_available_display_refresh_rates(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(94,tuple([]))
    return _ret


  @functools.native_method
  def set_motion_range(self, hand:'int'  , motion_range:'int'  ) -> None:
    r''''''

    assert isinstance(hand, (int, float)), 'hand must be int or float'
    assert isinstance(motion_range, (int, float)), 'motion_range must be int or float'








    self._ptr.call_with_return(95,tuple([hand, motion_range]))

  @functools.native_method
  def get_motion_range(self, hand:'int'  ) -> typing.Union[int]:
    r''''''

    assert isinstance(hand, (int, float)), 'hand must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(96,tuple([hand]))
    return _ret


  @functools.native_method
  def get_hand_tracking_source(self, hand:'int'  ) -> typing.Union[int]:
    r''''''

    assert isinstance(hand, (int, float)), 'hand must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(97,tuple([hand]))
    return _ret


  @functools.native_method
  def get_hand_joint_flags(self, hand:'int'  , joint:'int'  ) -> typing.Union[int]:
    r''''''

    assert isinstance(hand, (int, float)), 'hand must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret
    _ret = self._ptr.call_with_return(98,tuple([hand, joint]))
    return _ret


  @functools.native_method
  def get_hand_joint_rotation(self, hand:'int'  , joint:'int'  ) -> typing.Union['Quaternion']:
    r''''''

    assert isinstance(hand, (int, float)), 'hand must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(99,tuple([hand, joint]))
    return _ret


  @functools.native_method
  def get_hand_joint_position(self, hand:'int'  , joint:'int'  ) -> typing.Union['Vector3']:
    r''''''

    assert isinstance(hand, (int, float)), 'hand must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(100,tuple([hand, joint]))
    return _ret


  @functools.native_method
  def get_hand_joint_radius(self, hand:'int'  , joint:'int'  ) -> typing.Union[float]:
    r''''''

    assert isinstance(hand, (int, float)), 'hand must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(101,tuple([hand, joint]))
    return _ret


  @functools.native_method
  def get_hand_joint_linear_velocity(self, hand:'int'  , joint:'int'  ) -> typing.Union['Vector3']:
    r''''''

    assert isinstance(hand, (int, float)), 'hand must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(102,tuple([hand, joint]))
    return _ret


  @functools.native_method
  def get_hand_joint_angular_velocity(self, hand:'int'  , joint:'int'  ) -> typing.Union['Vector3']:
    r''''''

    assert isinstance(hand, (int, float)), 'hand must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(103,tuple([hand, joint]))
    return _ret


  @functools.native_method
  def is_hand_tracking_supported(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(104,tuple([]))
    return _ret


  @functools.native_method
  def is_hand_interaction_supported(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(105,tuple([]))
    return _ret


  @functools.native_method
  def is_eye_gaze_interaction_supported(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(106,tuple([]))
    return _ret


  @functools.native_method
  def get_vrs_min_radius(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(107,tuple([]))

    return _ret


  @functools.native_method
  def set_vrs_min_radius(self, radius:'float'   ) -> None:
    r''''''

    assert isinstance(radius, (int, float)), 'radius must be int or float'


    self.py__vrs_min_radius = radius






    self._ptr.call_with_return(108,tuple([radius]))

  @functools.native_method
  def get_vrs_strength(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(109,tuple([]))

    return _ret


  @functools.native_method
  def set_vrs_strength(self, strength:'float'   ) -> None:
    r''''''

    assert isinstance(strength, (int, float)), 'strength must be int or float'


    self.py__vrs_strength = strength






    self._ptr.call_with_return(110,tuple([strength]))

  @functools.native_method
  def set_cpu_level(self, level:'int'  ) -> None:
    r''''''

    assert isinstance(level, (int, float)), 'level must be int or float'







    self._ptr.call_with_return(111,tuple([level]))

  @functools.native_method
  def set_gpu_level(self, level:'int'  ) -> None:
    r''''''

    assert isinstance(level, (int, float)), 'level must be int or float'







    self._ptr.call_with_return(112,tuple([level]))


register_cast_function('OpenXRInterface', OpenXRInterface.cast)
register_class('OpenXRInterface', OpenXRInterface)
