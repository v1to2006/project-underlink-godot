# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Mesh as py4godot_mesh 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPNavigationMeshWrapper

class SamplePartitionType:
  SAMPLE_PARTITION_WATERSHED = 0
  SAMPLE_PARTITION_MONOTONE = 1
  SAMPLE_PARTITION_LAYERS = 2
  SAMPLE_PARTITION_MAX = 3
class ParsedGeometryType:
  PARSED_GEOMETRY_MESH_INSTANCES = 0
  PARSED_GEOMETRY_STATIC_COLLIDERS = 1
  PARSED_GEOMETRY_BOTH = 2
  PARSED_GEOMETRY_MAX = 3
class SourceGeometryMode:
  SOURCE_GEOMETRY_ROOT_NODE_CHILDREN = 0
  SOURCE_GEOMETRY_GROUPS_WITH_CHILDREN = 1
  SOURCE_GEOMETRY_GROUPS_EXPLICIT = 2
  SOURCE_GEOMETRY_MAX = 3


class NavigationMesh(py4godot_resource.Resource):
  r'''
		A navigation mesh is a collection of polygons that define which areas of an environment are traversable to aid agents in pathfinding through complicated spaces.
	'''

  @staticmethod
  def constructor():
    class_ = NavigationMesh.construct_without_init()
    class_._ptr = constructor(498,0, ())
    return class_
  @staticmethod
  def new():
    class_ = NavigationMesh.construct_without_init()
    class_._ptr = constructor(498,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPNavigationMeshWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(498,0, ())


  def generate_wrapper(self):
    return CPPNavigationMeshWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = NavigationMesh.__new__(NavigationMesh)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'NavigationMesh'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(135, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = NavigationMesh.construct_without_init()
    cls._ptr = CPPNavigationMeshWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = NavigationMesh.construct_without_init()
    cls._ptr = CPPNavigationMeshWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def vertices(self) -> typing.Union['PackedVector3Array']:
    r''''''
    _ret = self. get_vertices()
    return _ret
  @vertices.setter
  def vertices(self,  value:'PackedVector3Array'):
    self.set_vertices(value)
  @property
  def polygons(self) -> typing.Union['Array']:
    r''''''
    _ret = self. _get_polygons()
    return _ret
  @polygons.setter
  def polygons(self,  value:'Array'):
    self._set_polygons(value)
  @property
  def sample_partition_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_sample_partition_type()
    return _ret
  @sample_partition_type.setter
  def sample_partition_type(self,  value:'int'):
    self.set_sample_partition_type(value)
  @property
  def geometry_parsed_geometry_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_parsed_geometry_type()
    return _ret
  @geometry_parsed_geometry_type.setter
  def geometry_parsed_geometry_type(self,  value:'int'):
    self.set_parsed_geometry_type(value)
  @property
  def geometry_collision_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_collision_mask()
    return _ret
  @geometry_collision_mask.setter
  def geometry_collision_mask(self,  value:'int'):
    self.set_collision_mask(value)
  @property
  def geometry_source_geometry_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_source_geometry_mode()
    return _ret
  @geometry_source_geometry_mode.setter
  def geometry_source_geometry_mode(self,  value:'int'):
    self.set_source_geometry_mode(value)
  @property
  def geometry_source_group_name(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_source_group_name()
    return _ret
  @geometry_source_group_name.setter
  def geometry_source_group_name(self,  value:'str'):
    self.set_source_group_name(value)
  @property
  def cell_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_cell_size()
    return _ret
  @cell_size.setter
  def cell_size(self,  value:'float'):
    self.set_cell_size(value)
  @property
  def cell_height(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_cell_height()
    return _ret
  @cell_height.setter
  def cell_height(self,  value:'float'):
    self.set_cell_height(value)
  @property
  def border_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_border_size()
    return _ret
  @border_size.setter
  def border_size(self,  value:'float'):
    self.set_border_size(value)
  @property
  def agent_height(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_agent_height()
    return _ret
  @agent_height.setter
  def agent_height(self,  value:'float'):
    self.set_agent_height(value)
  @property
  def agent_radius(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_agent_radius()
    return _ret
  @agent_radius.setter
  def agent_radius(self,  value:'float'):
    self.set_agent_radius(value)
  @property
  def agent_max_climb(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_agent_max_climb()
    return _ret
  @agent_max_climb.setter
  def agent_max_climb(self,  value:'float'):
    self.set_agent_max_climb(value)
  @property
  def agent_max_slope(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_agent_max_slope()
    return _ret
  @agent_max_slope.setter
  def agent_max_slope(self,  value:'float'):
    self.set_agent_max_slope(value)
  @property
  def region_min_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_region_min_size()
    return _ret
  @region_min_size.setter
  def region_min_size(self,  value:'float'):
    self.set_region_min_size(value)
  @property
  def region_merge_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_region_merge_size()
    return _ret
  @region_merge_size.setter
  def region_merge_size(self,  value:'float'):
    self.set_region_merge_size(value)
  @property
  def edge_max_length(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_edge_max_length()
    return _ret
  @edge_max_length.setter
  def edge_max_length(self,  value:'float'):
    self.set_edge_max_length(value)
  @property
  def edge_max_error(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_edge_max_error()
    return _ret
  @edge_max_error.setter
  def edge_max_error(self,  value:'float'):
    self.set_edge_max_error(value)
  @property
  def vertices_per_polygon(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_vertices_per_polygon()
    return _ret
  @vertices_per_polygon.setter
  def vertices_per_polygon(self,  value:'float'):
    self.set_vertices_per_polygon(value)
  @property
  def detail_sample_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_detail_sample_distance()
    return _ret
  @detail_sample_distance.setter
  def detail_sample_distance(self,  value:'float'):
    self.set_detail_sample_distance(value)
  @property
  def detail_sample_max_error(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_detail_sample_max_error()
    return _ret
  @detail_sample_max_error.setter
  def detail_sample_max_error(self,  value:'float'):
    self.set_detail_sample_max_error(value)
  @property
  def filter_low_hanging_obstacles(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_filter_low_hanging_obstacles()
    return _ret
  @filter_low_hanging_obstacles.setter
  def filter_low_hanging_obstacles(self,  value:'bool'):
    self.set_filter_low_hanging_obstacles(value)
  @property
  def filter_ledge_spans(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_filter_ledge_spans()
    return _ret
  @filter_ledge_spans.setter
  def filter_ledge_spans(self,  value:'bool'):
    self.set_filter_ledge_spans(value)
  @property
  def filter_walkable_low_height_spans(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_filter_walkable_low_height_spans()
    return _ret
  @filter_walkable_low_height_spans.setter
  def filter_walkable_low_height_spans(self,  value:'bool'):
    self.set_filter_walkable_low_height_spans(value)
  @property
  def filter_baking_aabb(self) -> typing.Union['AABB']:
    r''''''
    _ret = self. get_filter_baking_aabb()
    return _ret
  @filter_baking_aabb.setter
  def filter_baking_aabb(self,  value:'AABB'):
    self.set_filter_baking_aabb(value)
  @property
  def filter_baking_aabb_offset(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_filter_baking_aabb_offset()
    return _ret
  @filter_baking_aabb_offset.setter
  def filter_baking_aabb_offset(self,  value:'Vector3'):
    self.set_filter_baking_aabb_offset(value)
  @functools.native_method
  def set_sample_partition_type(self, sample_partition_type:'int'  ) -> None:
    r''''''

    assert isinstance(sample_partition_type, (int, float)), 'sample_partition_type must be int or float'


    self.py__sample_partition_type = sample_partition_type






    self._ptr.call_with_return(77,tuple([sample_partition_type]))

  @functools.native_method
  def get_sample_partition_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(78,tuple([]))

    return _ret


  @functools.native_method
  def set_parsed_geometry_type(self, geometry_type:'int'  ) -> None:
    r''''''

    assert isinstance(geometry_type, (int, float)), 'geometry_type must be int or float'


    self.py__geometry_parsed_geometry_type = geometry_type






    self._ptr.call_with_return(79,tuple([geometry_type]))

  @functools.native_method
  def get_parsed_geometry_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(80,tuple([]))

    return _ret


  @functools.native_method
  def set_collision_mask(self, mask:'int'   ) -> None:
    r''''''

    assert isinstance(mask, (int, float)), 'mask must be int or float'


    self.py__geometry_collision_mask = mask






    self._ptr.call_with_return(81,tuple([mask]))

  @functools.native_method
  def get_collision_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([]))

    return _ret


  @functools.native_method
  def set_collision_mask_value(self, layer_number:'int'   , value:'bool'   ) -> None:
    r'''
				Based on `value`, enables or disables the specified layer in the `geometry_collision_mask`, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'








    self._ptr.call_with_return(83,tuple([layer_number, value]))

  @functools.native_method
  def get_collision_mask_value(self, layer_number:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether or not the specified layer of the `geometry_collision_mask` is enabled, given a `layer_number` between 1 and 32.
			'''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([layer_number]))
    return _ret


  @functools.native_method
  def set_source_geometry_mode(self, mask:'int'  ) -> None:
    r''''''

    assert isinstance(mask, (int, float)), 'mask must be int or float'


    self.py__geometry_source_geometry_mode = mask






    self._ptr.call_with_return(85,tuple([mask]))

  @functools.native_method
  def get_source_geometry_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(86,tuple([]))

    return _ret


  @functools.native_method
  def set_source_group_name(self, mask:'object'   ) -> None:
    r''''''

    assert(not mask is None)
    assert isinstance(mask, (str, StringName)), 'mask must be str or StringName'


    self.py__geometry_source_group_name = mask



    assert(isinstance(mask, (str, StringName)))
    py_stringname_mask = mask if isinstance(mask, StringName) else c_utils.py_string_to_string_name(mask)


    self._ptr.call_with_return(87,tuple([py_stringname_mask._ptr]))

  @functools.native_method
  def get_source_group_name(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([]))

    return str(_ret)


  @functools.native_method
  def set_cell_size(self, cell_size:'float'   ) -> None:
    r''''''

    assert isinstance(cell_size, (int, float)), 'cell_size must be int or float'


    self.py__cell_size = cell_size






    self._ptr.call_with_return(89,tuple([cell_size]))

  @functools.native_method
  def get_cell_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([]))

    return _ret


  @functools.native_method
  def set_cell_height(self, cell_height:'float'   ) -> None:
    r''''''

    assert isinstance(cell_height, (int, float)), 'cell_height must be int or float'


    self.py__cell_height = cell_height






    self._ptr.call_with_return(91,tuple([cell_height]))

  @functools.native_method
  def get_cell_height(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([]))

    return _ret


  @functools.native_method
  def set_border_size(self, border_size:'float'   ) -> None:
    r''''''

    assert isinstance(border_size, (int, float)), 'border_size must be int or float'


    self.py__border_size = border_size






    self._ptr.call_with_return(93,tuple([border_size]))

  @functools.native_method
  def get_border_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([]))

    return _ret


  @functools.native_method
  def set_agent_height(self, agent_height:'float'   ) -> None:
    r''''''

    assert isinstance(agent_height, (int, float)), 'agent_height must be int or float'


    self.py__agent_height = agent_height






    self._ptr.call_with_return(95,tuple([agent_height]))

  @functools.native_method
  def get_agent_height(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(96,tuple([]))

    return _ret


  @functools.native_method
  def set_agent_radius(self, agent_radius:'float'   ) -> None:
    r''''''

    assert isinstance(agent_radius, (int, float)), 'agent_radius must be int or float'


    self.py__agent_radius = agent_radius






    self._ptr.call_with_return(97,tuple([agent_radius]))

  @functools.native_method
  def get_agent_radius(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(98,tuple([]))

    return _ret


  @functools.native_method
  def set_agent_max_climb(self, agent_max_climb:'float'   ) -> None:
    r''''''

    assert isinstance(agent_max_climb, (int, float)), 'agent_max_climb must be int or float'


    self.py__agent_max_climb = agent_max_climb






    self._ptr.call_with_return(99,tuple([agent_max_climb]))

  @functools.native_method
  def get_agent_max_climb(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([]))

    return _ret


  @functools.native_method
  def set_agent_max_slope(self, agent_max_slope:'float'   ) -> None:
    r''''''

    assert isinstance(agent_max_slope, (int, float)), 'agent_max_slope must be int or float'


    self.py__agent_max_slope = agent_max_slope






    self._ptr.call_with_return(101,tuple([agent_max_slope]))

  @functools.native_method
  def get_agent_max_slope(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([]))

    return _ret


  @functools.native_method
  def set_region_min_size(self, region_min_size:'float'   ) -> None:
    r''''''

    assert isinstance(region_min_size, (int, float)), 'region_min_size must be int or float'


    self.py__region_min_size = region_min_size






    self._ptr.call_with_return(103,tuple([region_min_size]))

  @functools.native_method
  def get_region_min_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(104,tuple([]))

    return _ret


  @functools.native_method
  def set_region_merge_size(self, region_merge_size:'float'   ) -> None:
    r''''''

    assert isinstance(region_merge_size, (int, float)), 'region_merge_size must be int or float'


    self.py__region_merge_size = region_merge_size






    self._ptr.call_with_return(105,tuple([region_merge_size]))

  @functools.native_method
  def get_region_merge_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(106,tuple([]))

    return _ret


  @functools.native_method
  def set_edge_max_length(self, edge_max_length:'float'   ) -> None:
    r''''''

    assert isinstance(edge_max_length, (int, float)), 'edge_max_length must be int or float'


    self.py__edge_max_length = edge_max_length






    self._ptr.call_with_return(107,tuple([edge_max_length]))

  @functools.native_method
  def get_edge_max_length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(108,tuple([]))

    return _ret


  @functools.native_method
  def set_edge_max_error(self, edge_max_error:'float'   ) -> None:
    r''''''

    assert isinstance(edge_max_error, (int, float)), 'edge_max_error must be int or float'


    self.py__edge_max_error = edge_max_error






    self._ptr.call_with_return(109,tuple([edge_max_error]))

  @functools.native_method
  def get_edge_max_error(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(110,tuple([]))

    return _ret


  @functools.native_method
  def set_vertices_per_polygon(self, vertices_per_polygon:'float'   ) -> None:
    r''''''

    assert isinstance(vertices_per_polygon, (int, float)), 'vertices_per_polygon must be int or float'


    self.py__vertices_per_polygon = vertices_per_polygon






    self._ptr.call_with_return(111,tuple([vertices_per_polygon]))

  @functools.native_method
  def get_vertices_per_polygon(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(112,tuple([]))

    return _ret


  @functools.native_method
  def set_detail_sample_distance(self, detail_sample_dist:'float'   ) -> None:
    r''''''

    assert isinstance(detail_sample_dist, (int, float)), 'detail_sample_dist must be int or float'


    self.py__detail_sample_distance = detail_sample_dist






    self._ptr.call_with_return(113,tuple([detail_sample_dist]))

  @functools.native_method
  def get_detail_sample_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(114,tuple([]))

    return _ret


  @functools.native_method
  def set_detail_sample_max_error(self, detail_sample_max_error:'float'   ) -> None:
    r''''''

    assert isinstance(detail_sample_max_error, (int, float)), 'detail_sample_max_error must be int or float'


    self.py__detail_sample_max_error = detail_sample_max_error






    self._ptr.call_with_return(115,tuple([detail_sample_max_error]))

  @functools.native_method
  def get_detail_sample_max_error(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(116,tuple([]))

    return _ret


  @functools.native_method
  def set_filter_low_hanging_obstacles(self, filter_low_hanging_obstacles:'bool'   ) -> None:
    r''''''

    assert isinstance(filter_low_hanging_obstacles, bool), 'filter_low_hanging_obstacles must be bool'


    self.py__filter_low_hanging_obstacles = filter_low_hanging_obstacles






    self._ptr.call_with_return(117,tuple([filter_low_hanging_obstacles]))

  @functools.native_method
  def get_filter_low_hanging_obstacles(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(118,tuple([]))

    return _ret


  @functools.native_method
  def set_filter_ledge_spans(self, filter_ledge_spans:'bool'   ) -> None:
    r''''''

    assert isinstance(filter_ledge_spans, bool), 'filter_ledge_spans must be bool'


    self.py__filter_ledge_spans = filter_ledge_spans






    self._ptr.call_with_return(119,tuple([filter_ledge_spans]))

  @functools.native_method
  def get_filter_ledge_spans(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(120,tuple([]))

    return _ret


  @functools.native_method
  def set_filter_walkable_low_height_spans(self, filter_walkable_low_height_spans:'bool'   ) -> None:
    r''''''

    assert isinstance(filter_walkable_low_height_spans, bool), 'filter_walkable_low_height_spans must be bool'


    self.py__filter_walkable_low_height_spans = filter_walkable_low_height_spans






    self._ptr.call_with_return(121,tuple([filter_walkable_low_height_spans]))

  @functools.native_method
  def get_filter_walkable_low_height_spans(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(122,tuple([]))

    return _ret


  @functools.native_method
  def set_filter_baking_aabb(self, baking_aabb:'AABB'   ) -> None:
    r''''''

    assert(not baking_aabb is None)
    assert isinstance(baking_aabb, AABB), 'baking_aabb must be AABB'


    self.py__filter_baking_aabb = baking_aabb






    self._ptr.call_with_return(123,tuple([baking_aabb._ptr]))

  @functools.native_method
  def get_filter_baking_aabb(self) -> typing.Union['AABB']:
    r''''''




    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(124,tuple([]))

    return _ret


  @functools.native_method
  def set_filter_baking_aabb_offset(self, baking_aabb_offset:'Vector3'   ) -> None:
    r''''''

    assert(not baking_aabb_offset is None)
    assert isinstance(baking_aabb_offset, Vector3), 'baking_aabb_offset must be Vector3'


    self.py__filter_baking_aabb_offset = baking_aabb_offset






    self._ptr.call_with_return(125,tuple([baking_aabb_offset._ptr]))

  @functools.native_method
  def get_filter_baking_aabb_offset(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(126,tuple([]))

    return _ret


  @functools.native_method
  def set_vertices(self, vertices:'PackedVector3Array'   ) -> None:
    r'''
				Sets the vertices that can be then indexed to create polygons with the `add_polygon` method.
			'''

    assert(not vertices is None)
    assert isinstance(vertices, PackedVector3Array), 'vertices must be PackedVector3Array'


    self.py__vertices = vertices






    self._ptr.call_with_return(127,tuple([vertices._ptr]))

  @functools.native_method
  def get_vertices(self) -> typing.Union['PackedVector3Array']:
    r'''
				Returns a `PackedVector3Array` containing all the vertices being used to create the polygons.
			'''




    _ret = PackedVector3Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(128,tuple([]))

    return _ret


  @functools.native_method
  def add_polygon(self, polygon:'PackedInt32Array'   ) -> None:
    r'''
				Adds a polygon using the indices of the vertices you get when calling `get_vertices`.
			'''

    assert(not polygon is None)
    assert isinstance(polygon, PackedInt32Array), 'polygon must be PackedInt32Array'







    self._ptr.call_with_return(129,tuple([polygon._ptr]))

  @functools.native_method
  def get_polygon_count(self) -> typing.Union[int]:
    r'''
				Returns the number of polygons in the navigation mesh.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(130,tuple([]))
    return _ret


  @functools.native_method
  def get_polygon(self, idx:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns a `PackedInt32Array` containing the indices of the vertices of a created polygon.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(131,tuple([idx]))
    return _ret


  @functools.native_method
  def clear_polygons(self) -> None:
    r'''
				Clears the array of polygons, but it doesn't clear the array of vertices.
			'''




    self._ptr.call_with_return(132,tuple([]))

  @functools.native_method
  def create_from_mesh(self, mesh:'py4godot_mesh.Mesh'   ) -> None:
    r'''
				Initializes the navigation mesh by setting the vertices and indices according to a `Mesh`.
				**Note:** The given `mesh` must be of type `constant Mesh.PRIMITIVE_TRIANGLES` and have an index array.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, get_class('Mesh')), 'mesh must be Mesh'







    self._ptr.call_with_return(133,tuple([mesh._ptr]))

  @functools.native_method
  def clear(self) -> None:
    r'''
				Clears the internal arrays for vertices and polygon indices.
			'''




    self._ptr.call_with_return(134,tuple([]))


register_cast_function('NavigationMesh', NavigationMesh.cast)
register_class('NavigationMesh', NavigationMesh)
