# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.InputEventTypedArray as py4godot_inputeventtypedarray 
import py4godot.classes.InputEventTypedArray as py4godot_inputeventtypedarray 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPEditorSettingsWrapper


class EditorSettings(py4godot_resource.Resource):
  r'''
		Object that holds the project-independent editor settings. These settings are generally visible in the **Editor > Editor Settings** menu.
		Property names use slash delimiters to distinguish sections. Setting values can be of any `Variant` type. It's recommended to use `snake_case` for editor settings to be consistent with the Godot editor itself.
		Editor settings are saved automatically when changed.
		Accessing the settings can be done using the following methods, such as:
		
		```gdscript
		var settings = EditorInterface.get_editor_settings()
		# `settings.set("some/property", 10)` also works as this class overrides `_set()` internally.
		settings.set_setting("some/property", 10)
		# `settings.get("some/property")` also works as this class overrides `_get()` internally.
		settings.get_setting("some/property")
		var list_of_settings = settings.get_property_list()
		```
		
		
		**Note:** This class shouldn't be instantiated directly. Instead, access the singleton using `EditorInterface.get_editor_settings`.
	'''
  NOTIFICATION_EDITOR_SETTINGS_CHANGED:typing.ClassVar[int]

  @staticmethod
  def constructor():
    class_ = EditorSettings.construct_without_init()
    class_._ptr = constructor(312,0, ())
    return class_
  @staticmethod
  def new():
    class_ = EditorSettings.construct_without_init()
    class_._ptr = constructor(312,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEditorSettingsWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(312,0, ())


  def generate_wrapper(self):
    return CPPEditorSettingsWrapper()
  def init_signals(self):
    super().init_signals()
    settings_changed_name = utils.py_string_to_string_name("settings_changed")
    self.settings_changed = signals.BuiltinSignal(self, settings_changed_name)

  @staticmethod
  def construct_without_init():
    cls = EditorSettings.__new__(EditorSettings)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorSettings'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(93, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorSettings.construct_without_init()
    cls._ptr = CPPEditorSettingsWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorSettings.construct_without_init()
    cls._ptr = CPPEditorSettingsWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def has_setting(self, name:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the setting specified by `name` exists, `false` otherwise.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(77,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def set_setting(self, name:'str'   , value:'object'   ) -> None:
    r'''
				Sets the `value` of the setting specified by `name`. This is equivalent to using `Object.set` on the EditorSettings instance.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    self._ptr.call_with_return(78,tuple([py_string_name._ptr, value]))

  @functools.native_method
  def get_setting(self, name:'str'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the value of the setting specified by `name`. This is equivalent to using `Object.get` on the EditorSettings instance.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = None
    _ret = self._ptr.call_with_return(79,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def erase(self, property:'str'   ) -> None:
    r'''
				Erases the setting whose name is specified by `property`.
			'''

    assert(not property is None)
    assert isinstance(property, (str, String)), 'property must be str or String'





    assert(isinstance(property, (str, String)))
    py_string_property = property if isinstance(property, StringName) else c_utils.py_string_to_string(property)

    self._ptr.call_with_return(80,tuple([py_string_property._ptr]))

  @functools.native_method
  def set_initial_value(self, name:'object'   , value:'object'   , update_current:'bool'   ) -> None:
    r'''
				Sets the initial value of the setting specified by `name` to `value`. This is used to provide a value for the Revert button in the Editor Settings. If `update_current` is `true`, the setting is reset to `value` as well.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    
    assert isinstance(update_current, bool), 'update_current must be bool'

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)



    self._ptr.call_with_return(81,tuple([py_stringname_name._ptr, value, update_current]))

  @functools.native_method
  def add_property_info(self, info:'Dictionary'   ) -> None:
    r'''
				Adds a custom property info to a property. The dictionary must contain:
				- `name`: `String` (the name of the property)
				- `type`: `int` (see `enum Variant.Type`)
				- optionally `hint`: `int` (see `enum PropertyHint`) and `hint_string`: `String`
				
				```gdscript
				var settings = EditorInterface.get_editor_settings()
				settings.set("category/property_name", 0)

				var property_info = {
					"name": "category/property_name",
					"type": TYPE_INT,
					"hint": PROPERTY_HINT_ENUM,
					"hint_string": "one,two,three"
				}

				settings.add_property_info(property_info)
				```
				
				
			'''

    assert(not info is None)
    assert isinstance(info, Dictionary), 'info must be Dictionary'







    self._ptr.call_with_return(82,tuple([info._ptr]))

  @functools.native_method
  def set_project_metadata(self, section:'str'   , key:'str'   , data:'object'   ) -> None:
    r'''
				Sets project-specific metadata with the `section`, `key` and `data` specified. This metadata is stored outside the project folder and therefore won't be checked into version control. See also `get_project_metadata`.
			'''

    assert(not section is None)
    assert isinstance(section, (str, String)), 'section must be str or String'
    assert(not key is None)
    assert isinstance(key, (str, String)), 'key must be str or String'
    

    if not (type(data).__name__ in py4godot.variant_types.core_types or isinstance(data, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'data': "
                f"{type(data).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(section, (str, String)))
    py_string_section = section if isinstance(section, StringName) else c_utils.py_string_to_string(section)
    assert(isinstance(key, (str, String)))
    py_string_key = key if isinstance(key, StringName) else c_utils.py_string_to_string(key)


    self._ptr.call_with_return(83,tuple([py_string_section._ptr, py_string_key._ptr, data]))

  @functools.native_method
  def get_project_metadata(self, section:'str'   , key:'str'   , default:'object' =None  ) -> typing.Union[typing.Any]:
    r'''
				Returns project-specific metadata for the `section` and `key` specified. If the metadata doesn't exist, `default` will be returned instead. See also `set_project_metadata`.
			'''


    assert(not section is None)
    assert isinstance(section, (str, String)), 'section must be str or String'
    assert(not key is None)
    assert isinstance(key, (str, String)), 'key must be str or String'
    

    if not (type(default).__name__ in py4godot.variant_types.core_types or isinstance(default, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'default': "
                f"{type(default).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(section, (str, String)))
    py_string_section = section if isinstance(section, StringName) else c_utils.py_string_to_string(section)
    assert(isinstance(key, (str, String)))
    py_string_key = key if isinstance(key, StringName) else c_utils.py_string_to_string(key)


    _ret = None
    _ret = self._ptr.call_with_return(84,tuple([py_string_section._ptr, py_string_key._ptr, default]))
    return _ret


  @functools.native_method
  def set_favorites(self, dirs:'PackedStringArray'   ) -> None:
    r'''
				Sets the list of favorite files and directories for this project.
			'''

    assert(not dirs is None)
    assert isinstance(dirs, PackedStringArray), 'dirs must be PackedStringArray'







    self._ptr.call_with_return(85,tuple([dirs._ptr]))

  @functools.native_method
  def get_favorites(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns the list of favorite files and directories for this project.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def set_recent_dirs(self, dirs:'PackedStringArray'   ) -> None:
    r'''
				Sets the list of recently visited folders in the file dialog for this project.
			'''

    assert(not dirs is None)
    assert isinstance(dirs, PackedStringArray), 'dirs must be PackedStringArray'







    self._ptr.call_with_return(87,tuple([dirs._ptr]))

  @functools.native_method
  def get_recent_dirs(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns the list of recently visited folders in the file dialog for this project.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([]))
    return _ret


  @functools.native_method
  def set_builtin_action_override(self, name:'str'   , actions_list:'py4godot_inputeventtypedarray.InputEventTypedArray'   ) -> None:
    r'''
				Overrides the built-in editor action `name` with the input actions defined in `actions_list`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert isinstance(actions_list, Array), 'actions_list must be Array'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    self._ptr.call_with_return(89,tuple([py_string_name._ptr, actions_list._ptr]))

  @functools.native_method
  def check_changed_settings_in_group(self, setting_prefix:'str'   ) -> typing.Union[bool]:
    r'''
				Checks if any settings with the prefix `setting_prefix` exist in the set of changed settings. See also `get_changed_settings`.
			'''

    assert(not setting_prefix is None)
    assert isinstance(setting_prefix, (str, String)), 'setting_prefix must be str or String'





    assert(isinstance(setting_prefix, (str, String)))
    py_string_setting_prefix = setting_prefix if isinstance(setting_prefix, StringName) else c_utils.py_string_to_string(setting_prefix)

    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([py_string_setting_prefix._ptr]))
    return _ret


  @functools.native_method
  def get_changed_settings(self) -> typing.Union['PackedStringArray']:
    r'''
				Gets an array of the settings which have been changed since the last save. Note that internally `changed_settings` is cleared after a successful save, so generally the most appropriate place to use this method is when processing `constant NOTIFICATION_EDITOR_SETTINGS_CHANGED`.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([]))
    return _ret


  @functools.native_method
  def mark_setting_changed(self, setting:'str'   ) -> None:
    r'''
				Marks the passed editor setting as being changed, see `get_changed_settings`. Only settings which exist (see `has_setting`) will be accepted.
			'''

    assert(not setting is None)
    assert isinstance(setting, (str, String)), 'setting must be str or String'





    assert(isinstance(setting, (str, String)))
    py_string_setting = setting if isinstance(setting, StringName) else c_utils.py_string_to_string(setting)

    self._ptr.call_with_return(92,tuple([py_string_setting._ptr]))


register_cast_function('EditorSettings', EditorSettings.cast)
register_class('EditorSettings', EditorSettings)
