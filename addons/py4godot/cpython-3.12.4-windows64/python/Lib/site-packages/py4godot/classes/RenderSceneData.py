# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Object as py4godot_object 
from py4godot.wrappers.wrappers import CPPRenderSceneDataWrapper


class RenderSceneData(py4godot_object.Object):
  r'''
		Abstract scene data object, exists for the duration of rendering a single viewport. See also `RenderSceneDataRD`, `RenderData`, and `RenderDataRD`.
		**Note:** This is an internal rendering server object. Do not instantiate this class from a script.
	'''

  @staticmethod
  def constructor():
    class_ = RenderSceneData.construct_without_init()
    class_._ptr = constructor(680,0, ())
    return class_
  @staticmethod
  def new():
    class_ = RenderSceneData.construct_without_init()
    class_._ptr = constructor(680,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPRenderSceneDataWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(680,0, ())


  def generate_wrapper(self):
    return CPPRenderSceneDataWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = RenderSceneData.__new__(RenderSceneData)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'RenderSceneData'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = RenderSceneData.construct_without_init()
    cls._ptr = CPPRenderSceneDataWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = RenderSceneData.construct_without_init()
    cls._ptr = CPPRenderSceneDataWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def get_cam_transform(self) -> typing.Union['Transform3D']:
    r'''
				Returns the camera transform used to render this frame.
				**Note:** If more than one view is rendered, this will return a centered transform.
			'''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(49,tuple([]))
    return _ret


  @functools.native_method
  def get_cam_projection(self) -> typing.Union['Projection']:
    r'''
				Returns the camera projection used to render this frame.
				**Note:** If more than one view is rendered, this will return a combined projection.
			'''




    _ret = Projection.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(50,tuple([]))
    return _ret


  @functools.native_method
  def get_view_count(self) -> typing.Union[int]:
    r'''
				Returns the number of views being rendered.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(51,tuple([]))
    return _ret


  @functools.native_method
  def get_view_eye_offset(self, view:'int'   ) -> typing.Union['Vector3']:
    r'''
				Returns the eye offset per view used to render this frame. This is the offset between our camera transform and the eye transform.
			'''

    assert isinstance(view, (int, float)), 'view must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(52,tuple([view]))
    return _ret


  @functools.native_method
  def get_view_projection(self, view:'int'   ) -> typing.Union['Projection']:
    r'''
				Returns the view projection per view used to render this frame.
				**Note:** If a single view is rendered, this returns the camera projection. If more than one view is rendered, this will return a projection for the given view including the eye offset.
			'''

    assert isinstance(view, (int, float)), 'view must be int or float'







    _ret = Projection.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([view]))
    return _ret


  @functools.native_method
  def get_uniform_buffer(self) -> typing.Union['RID']:
    r'''
				Return the `RID` of the uniform buffer containing the scene data as a UBO.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([]))
    return _ret



register_cast_function('RenderSceneData', RenderSceneData.cast)
register_class('RenderSceneData', RenderSceneData)
