# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.AnimationTree as py4godot_animationtree 
  import py4godot.classes.Tween as py4godot_tween 
  import py4godot.classes.Animation as py4godot_animation 
  import py4godot.classes.AnimationLibrary as py4godot_animationlibrary 
  import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
  import py4godot.classes.AnimationPlayer as py4godot_animationplayer 
import py4godot.classes.Node as py4godot_node 
import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
from py4godot.wrappers.wrappers import CPPAnimationMixerWrapper

class AnimationCallbackModeProcess:
  ANIMATION_CALLBACK_MODE_PROCESS_PHYSICS = 0
  ANIMATION_CALLBACK_MODE_PROCESS_IDLE = 1
  ANIMATION_CALLBACK_MODE_PROCESS_MANUAL = 2
class AnimationCallbackModeMethod:
  ANIMATION_CALLBACK_MODE_METHOD_DEFERRED = 0
  ANIMATION_CALLBACK_MODE_METHOD_IMMEDIATE = 1
class AnimationCallbackModeDiscrete:
  ANIMATION_CALLBACK_MODE_DISCRETE_DOMINANT = 0
  ANIMATION_CALLBACK_MODE_DISCRETE_RECESSIVE = 1
  ANIMATION_CALLBACK_MODE_DISCRETE_FORCE_CONTINUOUS = 2


class AnimationMixer(py4godot_node.Node):
  r'''
		Base class for `AnimationPlayer` and `AnimationTree` to manage animation lists. It also has general properties and methods for playback and blending.
		After instantiating the playback information data within the extended class, the blending is processed by the `AnimationMixer`.
	'''

  @staticmethod
  def constructor():
    class_ = AnimationMixer.construct_without_init()
    class_._ptr = constructor(74,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AnimationMixer.construct_without_init()
    class_._ptr = constructor(74,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAnimationMixerWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(74,0, ())


  def generate_wrapper(self):
    return CPPAnimationMixerWrapper()
  def init_signals(self):
    super().init_signals()
    animation_list_changed_name = utils.py_string_to_string_name("animation_list_changed")
    self.animation_list_changed = signals.BuiltinSignal(self, animation_list_changed_name)
    animation_libraries_updated_name = utils.py_string_to_string_name("animation_libraries_updated")
    self.animation_libraries_updated = signals.BuiltinSignal(self, animation_libraries_updated_name)
    animation_finished_name = utils.py_string_to_string_name("animation_finished")
    self.animation_finished = signals.BuiltinSignal(self, animation_finished_name)
    animation_started_name = utils.py_string_to_string_name("animation_started")
    self.animation_started = signals.BuiltinSignal(self, animation_started_name)
    caches_cleared_name = utils.py_string_to_string_name("caches_cleared")
    self.caches_cleared = signals.BuiltinSignal(self, caches_cleared_name)
    mixer_applied_name = utils.py_string_to_string_name("mixer_applied")
    self.mixer_applied = signals.BuiltinSignal(self, mixer_applied_name)
    mixer_updated_name = utils.py_string_to_string_name("mixer_updated")
    self.mixer_updated = signals.BuiltinSignal(self, mixer_updated_name)

  @staticmethod
  def construct_without_init():
    cls = AnimationMixer.__new__(AnimationMixer)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AnimationMixer'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimationMixer.construct_without_init()
    cls._ptr = CPPAnimationMixerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimationMixer.construct_without_init()
    cls._ptr = CPPAnimationMixerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def active(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_active()
    return _ret
  @active.setter
  def active(self,  value:'bool'):
    self.set_active(value)
  @property
  def deterministic(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_deterministic()
    return _ret
  @deterministic.setter
  def deterministic(self,  value:'bool'):
    self.set_deterministic(value)
  @property
  def reset_on_save(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_reset_on_save_enabled()
    return _ret
  @reset_on_save.setter
  def reset_on_save(self,  value:'bool'):
    self.set_reset_on_save_enabled(value)
  @property
  def root_node(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_root_node()
    return _ret
  @root_node.setter
  def root_node(self,  value:'object'):
    self.set_root_node(value)
  @property
  def root_motion_track(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_root_motion_track()
    return _ret
  @root_motion_track.setter
  def root_motion_track(self,  value:'object'):
    self.set_root_motion_track(value)
  @property
  def root_motion_local(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_root_motion_local()
    return _ret
  @root_motion_local.setter
  def root_motion_local(self,  value:'bool'):
    self.set_root_motion_local(value)
  @property
  def audio_max_polyphony(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_audio_max_polyphony()
    return _ret
  @audio_max_polyphony.setter
  def audio_max_polyphony(self,  value:'int'):
    self.set_audio_max_polyphony(value)
  @property
  def callback_mode_process(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_callback_mode_process()
    return _ret
  @callback_mode_process.setter
  def callback_mode_process(self,  value:'int'):
    self.set_callback_mode_process(value)
  @property
  def callback_mode_method(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_callback_mode_method()
    return _ret
  @callback_mode_method.setter
  def callback_mode_method(self,  value:'int'):
    self.set_callback_mode_method(value)
  @property
  def callback_mode_discrete(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_callback_mode_discrete()
    return _ret
  @callback_mode_discrete.setter
  def callback_mode_discrete(self,  value:'int'):
    self.set_callback_mode_discrete(value)
  @functools.native_method
  def _post_process_key_value(self, animation:'py4godot_animation.Animation'   , track:'int'   , value:'object'   , object_id:'int'   , object_sub_idx:'int'   ) -> typing.Union[typing.Any]:
    r'''
				A virtual function for processing after getting a key during playback.
			'''

    assert(not animation is None)
    assert isinstance(animation, get_class('Animation')), 'animation must be Animation'
    assert isinstance(track, (int, float)), 'track must be int or float'
    
    assert isinstance(object_id, (int, float)), 'object_id must be int or float'
    assert isinstance(object_sub_idx, (int, float)), 'object_sub_idx must be int or float'

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )










    _ret = None
    _ret = self._ptr.call_with_return(180,tuple([animation._ptr, track, value, object_id, object_sub_idx]))
    return _ret


  @functools.native_method
  def add_animation_library(self, name:'object'   , library:'py4godot_animationlibrary.AnimationLibrary'   ) -> typing.Union[int]:
    r'''
				Adds `library` to the animation player, under the key `name`.
				AnimationMixer has a global library by default with an empty string as key. For adding an animation to the global library:
				
				```gdscript
				var global_library = mixer.get_animation_library("")
				global_library.add_animation("animation_name", animation_resource)
				```
				
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not library is None)
    assert isinstance(library, get_class('AnimationLibrary')), 'library must be AnimationLibrary'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    _ret:int
    _ret = self._ptr.call_with_return(181,tuple([py_stringname_name._ptr, library._ptr]))
    return _ret


  @functools.native_method
  def remove_animation_library(self, name:'object'   ) -> None:
    r'''
				Removes the `AnimationLibrary` associated with the key `name`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(182,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def rename_animation_library(self, name:'object'   , newname:'object'   ) -> None:
    r'''
				Moves the `AnimationLibrary` associated with the key `name` to the key `newname`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not newname is None)
    assert isinstance(newname, (str, StringName)), 'newname must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)
    assert(isinstance(newname, (str, StringName)))
    py_stringname_newname = newname if isinstance(newname, StringName) else c_utils.py_string_to_string_name(newname)

    self._ptr.call_with_return(183,tuple([py_stringname_name._ptr, py_stringname_newname._ptr]))

  @functools.native_method
  def has_animation_library(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the `AnimationMixer` stores an `AnimationLibrary` with key `name`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(184,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def get_animation_library(self, name:'object'   ) -> typing.Union['py4godot_animationlibrary.AnimationLibrary']:
    r'''
				Returns the first `AnimationLibrary` with key `name` or `null` if not found.
				To get the `AnimationMixer`'s global animation library, use `get_animation_library("")`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AnimationLibrary
    _ret._ptr = self._ptr.call_with_return(185,tuple([py_stringname_name._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_animation_library_list(self) -> typing.Union['py4godot_stringnametypedarray.StringNameTypedArray']:
    r'''
				Returns the list of stored library keys.
			'''




    _ret = py4godot_stringnametypedarray.StringNameTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(186,tuple([]))
    return _ret


  @functools.native_method
  def has_animation(self, name:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the `AnimationMixer` stores an `Animation` with key `name`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(187,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def get_animation(self, name:'object'   ) -> typing.Union['py4godot_animation.Animation']:
    r'''
				Returns the `Animation` with the key `name`. If the animation does not exist, `null` is returned and an error is logged.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Animation
    _ret._ptr = self._ptr.call_with_return(188,tuple([py_stringname_name._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_animation_list(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns the list of stored animation keys.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(189,tuple([]))
    return _ret


  @functools.native_method
  def set_active(self, active:'bool'   ) -> None:
    r''''''

    assert isinstance(active, bool), 'active must be bool'


    self.py__active = active






    self._ptr.call_with_return(190,tuple([active]))

  @functools.native_method
  def is_active(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(191,tuple([]))

    return _ret


  @functools.native_method
  def set_deterministic(self, deterministic:'bool'   ) -> None:
    r''''''

    assert isinstance(deterministic, bool), 'deterministic must be bool'


    self.py__deterministic = deterministic






    self._ptr.call_with_return(192,tuple([deterministic]))

  @functools.native_method
  def is_deterministic(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(193,tuple([]))

    return _ret


  @functools.native_method
  def set_root_node(self, path:'object'   ) -> None:
    r''''''

    assert(not path is None)
    assert isinstance(path, (str, NodePath)), 'path must be str or NodePath'


    self.py__root_node = path



    assert(isinstance(path, (str, NodePath)))
    py_nodepath_path = path if isinstance(path,NodePath) else NodePath.new2(path)


    self._ptr.call_with_return(194,tuple([py_nodepath_path._ptr]))

  @functools.native_method
  def get_root_node(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(195,tuple([]))

    return _ret


  @functools.native_method
  def set_callback_mode_process(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__callback_mode_process = mode






    self._ptr.call_with_return(196,tuple([mode]))

  @functools.native_method
  def get_callback_mode_process(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(197,tuple([]))

    return _ret


  @functools.native_method
  def set_callback_mode_method(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__callback_mode_method = mode






    self._ptr.call_with_return(198,tuple([mode]))

  @functools.native_method
  def get_callback_mode_method(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(199,tuple([]))

    return _ret


  @functools.native_method
  def set_callback_mode_discrete(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__callback_mode_discrete = mode






    self._ptr.call_with_return(200,tuple([mode]))

  @functools.native_method
  def get_callback_mode_discrete(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(201,tuple([]))

    return _ret


  @functools.native_method
  def set_audio_max_polyphony(self, max_polyphony:'int'   ) -> None:
    r''''''

    assert isinstance(max_polyphony, (int, float)), 'max_polyphony must be int or float'


    self.py__audio_max_polyphony = max_polyphony






    self._ptr.call_with_return(202,tuple([max_polyphony]))

  @functools.native_method
  def get_audio_max_polyphony(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(203,tuple([]))

    return _ret


  @functools.native_method
  def set_root_motion_track(self, path:'object'   ) -> None:
    r''''''

    assert(not path is None)
    assert isinstance(path, (str, NodePath)), 'path must be str or NodePath'


    self.py__root_motion_track = path



    assert(isinstance(path, (str, NodePath)))
    py_nodepath_path = path if isinstance(path,NodePath) else NodePath.new2(path)


    self._ptr.call_with_return(204,tuple([py_nodepath_path._ptr]))

  @functools.native_method
  def get_root_motion_track(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(205,tuple([]))

    return _ret


  @functools.native_method
  def set_root_motion_local(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__root_motion_local = enabled






    self._ptr.call_with_return(206,tuple([enabled]))

  @functools.native_method
  def is_root_motion_local(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(207,tuple([]))

    return _ret


  @functools.native_method
  def get_root_motion_position(self) -> typing.Union['Vector3']:
    r'''
				Retrieve the motion delta of position with the `root_motion_track` as a `Vector3` that can be used elsewhere.
				If `root_motion_track` is not a path to a track of type `constant Animation.TYPE_POSITION_3D`, returns `Vector3(0, 0, 0)`.
				See also `root_motion_track` and `RootMotionView`.
				The most basic example is applying position to `CharacterBody3D`:
				
				```gdscript
				var current_rotation

				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						current_rotation = get_quaternion()
						state_machine.travel("Animate")
					var velocity = current_rotation * animation_tree.get_root_motion_position() / delta
					set_velocity(velocity)
					move_and_slide()
				```
				
				By using this in combination with `get_root_motion_rotation_accumulator`, you can apply the root motion position more correctly to account for the rotation of the node.
				
				```gdscript
				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						state_machine.travel("Animate")
					set_quaternion(get_quaternion() * animation_tree.get_root_motion_rotation())
					var velocity = (animation_tree.get_root_motion_rotation_accumulator().inverse() * get_quaternion()) * animation_tree.get_root_motion_position() / delta
					set_velocity(velocity)
					move_and_slide()
				```
				
				If `root_motion_local` is `true`, returns the pre-multiplied translation value with the inverted rotation.
				In this case, the code can be written as follows:
				
				```gdscript
				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						state_machine.travel("Animate")
					set_quaternion(get_quaternion() * animation_tree.get_root_motion_rotation())
					var velocity = get_quaternion() * animation_tree.get_root_motion_position() / delta
					set_velocity(velocity)
					move_and_slide()
				```
				
			'''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(208,tuple([]))
    return _ret


  @functools.native_method
  def get_root_motion_rotation(self) -> typing.Union['Quaternion']:
    r'''
				Retrieve the motion delta of rotation with the `root_motion_track` as a `Quaternion` that can be used elsewhere.
				If `root_motion_track` is not a path to a track of type `constant Animation.TYPE_ROTATION_3D`, returns `Quaternion(0, 0, 0, 1)`.
				See also `root_motion_track` and `RootMotionView`.
				The most basic example is applying rotation to `CharacterBody3D`:
				
				```gdscript
				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						state_machine.travel("Animate")
					set_quaternion(get_quaternion() * animation_tree.get_root_motion_rotation())
				```
				
			'''




    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(209,tuple([]))
    return _ret


  @functools.native_method
  def get_root_motion_scale(self) -> typing.Union['Vector3']:
    r'''
				Retrieve the motion delta of scale with the `root_motion_track` as a `Vector3` that can be used elsewhere.
				If `root_motion_track` is not a path to a track of type `constant Animation.TYPE_SCALE_3D`, returns `Vector3(0, 0, 0)`.
				See also `root_motion_track` and `RootMotionView`.
				The most basic example is applying scale to `CharacterBody3D`:
				
				```gdscript
				var current_scale = Vector3(1, 1, 1)
				var scale_accum = Vector3(1, 1, 1)

				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						current_scale = get_scale()
						scale_accum = Vector3(1, 1, 1)
						state_machine.travel("Animate")
					scale_accum += animation_tree.get_root_motion_scale()
					set_scale(current_scale * scale_accum)
				```
				
			'''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(210,tuple([]))
    return _ret


  @functools.native_method
  def get_root_motion_position_accumulator(self) -> typing.Union['Vector3']:
    r'''
				Retrieve the blended value of the position tracks with the `root_motion_track` as a `Vector3` that can be used elsewhere.
				This is useful in cases where you want to respect the initial key values of the animation.
				For example, if an animation with only one key `Vector3(0, 0, 0)` is played in the previous frame and then an animation with only one key `Vector3(1, 0, 1)` is played in the next frame, the difference can be calculated as follows:
				
				```gdscript
				var prev_root_motion_position_accumulator

				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						state_machine.travel("Animate")
					var current_root_motion_position_accumulator = animation_tree.get_root_motion_position_accumulator()
					var difference = current_root_motion_position_accumulator - prev_root_motion_position_accumulator
					prev_root_motion_position_accumulator = current_root_motion_position_accumulator
					transform.origin += difference
				```
				
				However, if the animation loops, an unintended discrete change may occur, so this is only useful for some simple use cases.
			'''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(211,tuple([]))
    return _ret


  @functools.native_method
  def get_root_motion_rotation_accumulator(self) -> typing.Union['Quaternion']:
    r'''
				Retrieve the blended value of the rotation tracks with the `root_motion_track` as a `Quaternion` that can be used elsewhere.
				This is necessary to apply the root motion position correctly, taking rotation into account. See also `get_root_motion_position`.
				Also, this is useful in cases where you want to respect the initial key values of the animation.
				For example, if an animation with only one key `Quaternion(0, 0, 0, 1)` is played in the previous frame and then an animation with only one key `Quaternion(0, 0.707, 0, 0.707)` is played in the next frame, the difference can be calculated as follows:
				
				```gdscript
				var prev_root_motion_rotation_accumulator

				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						state_machine.travel("Animate")
					var current_root_motion_rotation_accumulator = animation_tree.get_root_motion_rotation_accumulator()
					var difference = prev_root_motion_rotation_accumulator.inverse() * current_root_motion_rotation_accumulator
					prev_root_motion_rotation_accumulator = current_root_motion_rotation_accumulator
					transform.basis *=  Basis(difference)
				```
				
				However, if the animation loops, an unintended discrete change may occur, so this is only useful for some simple use cases.
			'''




    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(212,tuple([]))
    return _ret


  @functools.native_method
  def get_root_motion_scale_accumulator(self) -> typing.Union['Vector3']:
    r'''
				Retrieve the blended value of the scale tracks with the `root_motion_track` as a `Vector3` that can be used elsewhere.
				For example, if an animation with only one key `Vector3(1, 1, 1)` is played in the previous frame and then an animation with only one key `Vector3(2, 2, 2)` is played in the next frame, the difference can be calculated as follows:
				
				```gdscript
				var prev_root_motion_scale_accumulator

				func _process(delta):
					if Input.is_action_just_pressed("animate"):
						state_machine.travel("Animate")
					var current_root_motion_scale_accumulator = animation_tree.get_root_motion_scale_accumulator()
					var difference = current_root_motion_scale_accumulator - prev_root_motion_scale_accumulator
					prev_root_motion_scale_accumulator = current_root_motion_scale_accumulator
					transform.basis = transform.basis.scaled(difference)
				```
				
				However, if the animation loops, an unintended discrete change may occur, so this is only useful for some simple use cases.
			'''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(213,tuple([]))
    return _ret


  @functools.native_method
  def clear_caches(self) -> None:
    r'''
				`AnimationMixer` caches animated nodes. It may not notice if a node disappears; `clear_caches` forces it to update the cache again.
			'''




    self._ptr.call_with_return(214,tuple([]))

  @functools.native_method
  def advance(self, delta:'float'   ) -> None:
    r'''
				Manually advance the animations by the specified time (in seconds).
			'''

    assert isinstance(delta, (int, float)), 'delta must be int or float'







    self._ptr.call_with_return(215,tuple([delta]))

  @functools.native_method
  def capture(self, name:'object'   , duration:'float'   , trans_type:'int'  =0, ease_type:'int'  =0) -> None:
    r'''
				If the animation track specified by `name` has an option `constant Animation.UPDATE_CAPTURE`, stores current values of the objects indicated by the track path as a cache. If there is already a captured cache, the old cache is discarded.
				After this it will interpolate with current animation blending result during the playback process for the time specified by `duration`, working like a crossfade.
				You can specify `trans_type` as the curve for the interpolation. For better results, it may be appropriate to specify `constant Tween.TRANS_LINEAR` for cases where the first key of the track begins with a non-zero value or where the key value does not change, and `constant Tween.TRANS_QUAD` for cases where the key value changes linearly.
			'''



    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert isinstance(duration, (int, float)), 'duration must be int or float'
    assert isinstance(trans_type, (int, float)), 'trans_type must be int or float'
    assert isinstance(ease_type, (int, float)), 'ease_type must be int or float'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)




    self._ptr.call_with_return(216,tuple([py_stringname_name._ptr, duration, trans_type, ease_type]))

  @functools.native_method
  def set_reset_on_save_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__reset_on_save = enabled






    self._ptr.call_with_return(217,tuple([enabled]))

  @functools.native_method
  def is_reset_on_save_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(218,tuple([]))

    return _ret


  @functools.native_method
  def find_animation(self, animation:'py4godot_animation.Animation'   ) -> typing.Union['StringName']:
    r'''
				Returns the key of `animation` or an empty `StringName` if not found.
			'''

    assert(not animation is None)
    assert isinstance(animation, get_class('Animation')), 'animation must be Animation'







    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(219,tuple([animation._ptr]))
    return str(_ret)


  @functools.native_method
  def find_animation_library(self, animation:'py4godot_animation.Animation'   ) -> typing.Union['StringName']:
    r'''
				Returns the key for the `AnimationLibrary` that contains `animation` or an empty `StringName` if not found.
			'''

    assert(not animation is None)
    assert isinstance(animation, get_class('Animation')), 'animation must be Animation'







    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(220,tuple([animation._ptr]))
    return str(_ret)



register_cast_function('AnimationMixer', AnimationMixer.cast)
register_class('AnimationMixer', AnimationMixer)
