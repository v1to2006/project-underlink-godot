# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.AudioStreamPolyphonic as py4godot_audiostreampolyphonic 
  import py4godot.classes.AudioServer as py4godot_audioserver 
  import py4godot.classes.AudioStreamPlaybackPolyphonic as py4godot_audiostreamplaybackpolyphonic 
  import py4godot.classes.AudioStreamPlaybackPlaylist as py4godot_audiostreamplaybackplaylist 
  import py4godot.classes.AudioStreamPlaylist as py4godot_audiostreamplaylist 
  import py4godot.classes.AudioStreamPlaybackInteractive as py4godot_audiostreamplaybackinteractive 
  import py4godot.classes.AudioStreamPlaybackResampled as py4godot_audiostreamplaybackresampled 
  import py4godot.classes.AudioStreamInteractive as py4godot_audiostreaminteractive 
  import py4godot.classes.AudioStream as py4godot_audiostream 
  import py4godot.classes.AudioStreamPlayback as py4godot_audiostreamplayback 
  import py4godot.classes.AudioStreamMicrophone as py4godot_audiostreammicrophone 
  import py4godot.classes.AudioStreamOggVorbis as py4godot_audiostreamoggvorbis 
  import py4godot.classes.AudioStreamSynchronized as py4godot_audiostreamsynchronized 
  import py4godot.classes.AudioStreamGeneratorPlayback as py4godot_audiostreamgeneratorplayback 
  import py4godot.classes.AudioStreamMP3 as py4godot_audiostreammp3 
  import py4godot.classes.AudioStreamPlaybackOggVorbis as py4godot_audiostreamplaybackoggvorbis 
  import py4godot.classes.AudioStreamWAV as py4godot_audiostreamwav 
  import py4godot.classes.AudioStreamGenerator as py4godot_audiostreamgenerator 
  import py4godot.classes.AudioStreamRandomizer as py4godot_audiostreamrandomizer 
  import py4godot.classes.AudioStreamPlaybackSynchronized as py4godot_audiostreamplaybacksynchronized 
import py4godot.classes.Node3D as py4godot_node3d 
from py4godot.wrappers.wrappers import CPPAudioStreamPlayer3DWrapper

class AttenuationModel:
  ATTENUATION_INVERSE_DISTANCE = 0
  ATTENUATION_INVERSE_SQUARE_DISTANCE = 1
  ATTENUATION_LOGARITHMIC = 2
  ATTENUATION_DISABLED = 3
class DopplerTracking:
  DOPPLER_TRACKING_DISABLED = 0
  DOPPLER_TRACKING_IDLE_STEP = 1
  DOPPLER_TRACKING_PHYSICS_STEP = 2


class AudioStreamPlayer3D(py4godot_node3d.Node3D):
  r'''
		Plays audio with positional sound effects, based on the relative position of the audio listener. Positional effects include distance attenuation, directionality, and the Doppler effect. For greater realism, a low-pass filter is applied to distant sounds. This can be disabled by setting `attenuation_filter_cutoff_hz` to `20500`.
		By default, audio is heard from the camera position. This can be changed by adding an `AudioListener3D` node to the scene and enabling it by calling `AudioListener3D.make_current` on it.
		See also `AudioStreamPlayer` to play a sound non-positionally.
		**Note:** Hiding an `AudioStreamPlayer3D` node does not disable its audio output. To temporarily disable an `AudioStreamPlayer3D`'s audio output, set `volume_db` to a very low value like `-100` (which isn't audible to human hearing).
	'''

  @staticmethod
  def constructor():
    class_ = AudioStreamPlayer3D.construct_without_init()
    class_._ptr = constructor(156,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AudioStreamPlayer3D.construct_without_init()
    class_._ptr = constructor(156,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAudioStreamPlayer3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(156,0, ())


  def generate_wrapper(self):
    return CPPAudioStreamPlayer3DWrapper()
  def init_signals(self):
    super().init_signals()
    finished_name = utils.py_string_to_string_name("finished")
    self.finished = signals.BuiltinSignal(self, finished_name)

  @staticmethod
  def construct_without_init():
    cls = AudioStreamPlayer3D.__new__(AudioStreamPlayer3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AudioStreamPlayer3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AudioStreamPlayer3D.construct_without_init()
    cls._ptr = CPPAudioStreamPlayer3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AudioStreamPlayer3D.construct_without_init()
    cls._ptr = CPPAudioStreamPlayer3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def stream(self) -> typing.Any:
    r''''''
    _ret = self. get_stream()
    return _ret
  @stream.setter
  def stream(self,  value:'py4godot_object.Object'):
    self.set_stream(value)
  @property
  def attenuation_model(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_attenuation_model()
    return _ret
  @attenuation_model.setter
  def attenuation_model(self,  value:'int'):
    self.set_attenuation_model(value)
  @property
  def volume_db(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volume_db()
    return _ret
  @volume_db.setter
  def volume_db(self,  value:'float'):
    self.set_volume_db(value)
  @property
  def volume_linear(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_volume_linear()
    return _ret
  @volume_linear.setter
  def volume_linear(self,  value:'float'):
    self.set_volume_linear(value)
  @property
  def unit_size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_unit_size()
    return _ret
  @unit_size.setter
  def unit_size(self,  value:'float'):
    self.set_unit_size(value)
  @property
  def max_db(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_max_db()
    return _ret
  @max_db.setter
  def max_db(self,  value:'float'):
    self.set_max_db(value)
  @property
  def pitch_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_pitch_scale()
    return _ret
  @pitch_scale.setter
  def pitch_scale(self,  value:'float'):
    self.set_pitch_scale(value)
  @property
  def playing(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_playing()
    return _ret
  @playing.setter
  def playing(self,  value:'bool'):
    self.set_playing(value)
  @property
  def autoplay(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_autoplay_enabled()
    return _ret
  @autoplay.setter
  def autoplay(self,  value:'bool'):
    self.set_autoplay(value)
  @property
  def stream_paused(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_stream_paused()
    return _ret
  @stream_paused.setter
  def stream_paused(self,  value:'bool'):
    self.set_stream_paused(value)
  @property
  def max_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_max_distance()
    return _ret
  @max_distance.setter
  def max_distance(self,  value:'float'):
    self.set_max_distance(value)
  @property
  def max_polyphony(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_polyphony()
    return _ret
  @max_polyphony.setter
  def max_polyphony(self,  value:'int'):
    self.set_max_polyphony(value)
  @property
  def panning_strength(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_panning_strength()
    return _ret
  @panning_strength.setter
  def panning_strength(self,  value:'float'):
    self.set_panning_strength(value)
  @property
  def bus(self) -> typing.Union['StringName']:
    r''''''
    _ret = self. get_bus()
    return _ret
  @bus.setter
  def bus(self,  value:'object'):
    self.set_bus(value)
  @property
  def area_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_area_mask()
    return _ret
  @area_mask.setter
  def area_mask(self,  value:'int'):
    self.set_area_mask(value)
  @property
  def playback_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_playback_type()
    return _ret
  @playback_type.setter
  def playback_type(self,  value:'int'):
    self.set_playback_type(value)
  @property
  def emission_angle_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_emission_angle_enabled()
    return _ret
  @emission_angle_enabled.setter
  def emission_angle_enabled(self,  value:'bool'):
    self.set_emission_angle_enabled(value)
  @property
  def emission_angle_degrees(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_emission_angle()
    return _ret
  @emission_angle_degrees.setter
  def emission_angle_degrees(self,  value:'float'):
    self.set_emission_angle(value)
  @property
  def emission_angle_filter_attenuation_db(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_emission_angle_filter_attenuation_db()
    return _ret
  @emission_angle_filter_attenuation_db.setter
  def emission_angle_filter_attenuation_db(self,  value:'float'):
    self.set_emission_angle_filter_attenuation_db(value)
  @property
  def attenuation_filter_cutoff_hz(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_attenuation_filter_cutoff_hz()
    return _ret
  @attenuation_filter_cutoff_hz.setter
  def attenuation_filter_cutoff_hz(self,  value:'float'):
    self.set_attenuation_filter_cutoff_hz(value)
  @property
  def attenuation_filter_db(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_attenuation_filter_db()
    return _ret
  @attenuation_filter_db.setter
  def attenuation_filter_db(self,  value:'float'):
    self.set_attenuation_filter_db(value)
  @property
  def doppler_tracking(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_doppler_tracking()
    return _ret
  @doppler_tracking.setter
  def doppler_tracking(self,  value:'int'):
    self.set_doppler_tracking(value)
  @functools.native_method
  def set_stream(self, stream:'py4godot_audiostream.AudioStream'   ) -> None:
    r''''''

    assert(not stream is None)
    assert isinstance(stream, get_class('AudioStream')), 'stream must be AudioStream'


    self.py__stream = stream






    self._ptr.call_with_return(251,tuple([stream._ptr]))

  @functools.native_method
  def get_stream(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioStream
    _ret._ptr = self._ptr.call_with_return(252,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_volume_db(self, volume_db:'float'   ) -> None:
    r''''''

    assert isinstance(volume_db, (int, float)), 'volume_db must be int or float'


    self.py__volume_db = volume_db






    self._ptr.call_with_return(253,tuple([volume_db]))

  @functools.native_method
  def get_volume_db(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(254,tuple([]))

    return _ret


  @functools.native_method
  def set_volume_linear(self, volume_linear:'float'   ) -> None:
    r''''''

    assert isinstance(volume_linear, (int, float)), 'volume_linear must be int or float'


    self.py__volume_linear = volume_linear






    self._ptr.call_with_return(255,tuple([volume_linear]))

  @functools.native_method
  def get_volume_linear(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(256,tuple([]))

    return _ret


  @functools.native_method
  def set_unit_size(self, unit_size:'float'   ) -> None:
    r''''''

    assert isinstance(unit_size, (int, float)), 'unit_size must be int or float'


    self.py__unit_size = unit_size






    self._ptr.call_with_return(257,tuple([unit_size]))

  @functools.native_method
  def get_unit_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(258,tuple([]))

    return _ret


  @functools.native_method
  def set_max_db(self, max_db:'float'   ) -> None:
    r''''''

    assert isinstance(max_db, (int, float)), 'max_db must be int or float'


    self.py__max_db = max_db






    self._ptr.call_with_return(259,tuple([max_db]))

  @functools.native_method
  def get_max_db(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(260,tuple([]))

    return _ret


  @functools.native_method
  def set_pitch_scale(self, pitch_scale:'float'   ) -> None:
    r''''''

    assert isinstance(pitch_scale, (int, float)), 'pitch_scale must be int or float'


    self.py__pitch_scale = pitch_scale






    self._ptr.call_with_return(261,tuple([pitch_scale]))

  @functools.native_method
  def get_pitch_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(262,tuple([]))

    return _ret


  @functools.native_method
  def play(self, from_position:'float' =0.0  ) -> None:
    r'''
				Queues the audio to play on the next physics frame, from the given position `from_position`, in seconds.
			'''

    assert isinstance(from_position, (int, float)), 'from_position must be int or float'







    self._ptr.call_with_return(263,tuple([from_position]))

  @functools.native_method
  def seek(self, to_position:'float'   ) -> None:
    r'''
				Sets the position from which audio will be played, in seconds.
			'''

    assert isinstance(to_position, (int, float)), 'to_position must be int or float'







    self._ptr.call_with_return(264,tuple([to_position]))

  @functools.native_method
  def stop(self) -> None:
    r'''
				Stops the audio.
			'''




    self._ptr.call_with_return(265,tuple([]))

  @functools.native_method
  def is_playing(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(266,tuple([]))

    return _ret


  @functools.native_method
  def get_playback_position(self) -> typing.Union[float]:
    r'''
				Returns the position in the `AudioStream`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(267,tuple([]))
    return _ret


  @functools.native_method
  def set_bus(self, bus:'object'   ) -> None:
    r''''''

    assert(not bus is None)
    assert isinstance(bus, (str, StringName)), 'bus must be str or StringName'


    self.py__bus = bus



    assert(isinstance(bus, (str, StringName)))
    py_stringname_bus = bus if isinstance(bus, StringName) else c_utils.py_string_to_string_name(bus)


    self._ptr.call_with_return(268,tuple([py_stringname_bus._ptr]))

  @functools.native_method
  def get_bus(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(269,tuple([]))

    return str(_ret)


  @functools.native_method
  def set_autoplay(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__autoplay = enable






    self._ptr.call_with_return(270,tuple([enable]))

  @functools.native_method
  def is_autoplay_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(271,tuple([]))

    return _ret


  @functools.native_method
  def set_playing(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__playing = enable






    self._ptr.call_with_return(272,tuple([enable]))

  @functools.native_method
  def set_max_distance(self, meters:'float'   ) -> None:
    r''''''

    assert isinstance(meters, (int, float)), 'meters must be int or float'


    self.py__max_distance = meters






    self._ptr.call_with_return(273,tuple([meters]))

  @functools.native_method
  def get_max_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(274,tuple([]))

    return _ret


  @functools.native_method
  def set_area_mask(self, mask:'int'   ) -> None:
    r''''''

    assert isinstance(mask, (int, float)), 'mask must be int or float'


    self.py__area_mask = mask






    self._ptr.call_with_return(275,tuple([mask]))

  @functools.native_method
  def get_area_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(276,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_angle(self, degrees:'float'   ) -> None:
    r''''''

    assert isinstance(degrees, (int, float)), 'degrees must be int or float'


    self.py__emission_angle_degrees = degrees






    self._ptr.call_with_return(277,tuple([degrees]))

  @functools.native_method
  def get_emission_angle(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(278,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_angle_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__emission_angle_enabled = enabled






    self._ptr.call_with_return(279,tuple([enabled]))

  @functools.native_method
  def is_emission_angle_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(280,tuple([]))

    return _ret


  @functools.native_method
  def set_emission_angle_filter_attenuation_db(self, db:'float'   ) -> None:
    r''''''

    assert isinstance(db, (int, float)), 'db must be int or float'


    self.py__emission_angle_filter_attenuation_db = db






    self._ptr.call_with_return(281,tuple([db]))

  @functools.native_method
  def get_emission_angle_filter_attenuation_db(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(282,tuple([]))

    return _ret


  @functools.native_method
  def set_attenuation_filter_cutoff_hz(self, degrees:'float'   ) -> None:
    r''''''

    assert isinstance(degrees, (int, float)), 'degrees must be int or float'


    self.py__attenuation_filter_cutoff_hz = degrees






    self._ptr.call_with_return(283,tuple([degrees]))

  @functools.native_method
  def get_attenuation_filter_cutoff_hz(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(284,tuple([]))

    return _ret


  @functools.native_method
  def set_attenuation_filter_db(self, db:'float'   ) -> None:
    r''''''

    assert isinstance(db, (int, float)), 'db must be int or float'


    self.py__attenuation_filter_db = db






    self._ptr.call_with_return(285,tuple([db]))

  @functools.native_method
  def get_attenuation_filter_db(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(286,tuple([]))

    return _ret


  @functools.native_method
  def set_attenuation_model(self, model:'int'  ) -> None:
    r''''''

    assert isinstance(model, (int, float)), 'model must be int or float'


    self.py__attenuation_model = model






    self._ptr.call_with_return(287,tuple([model]))

  @functools.native_method
  def get_attenuation_model(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(288,tuple([]))

    return _ret


  @functools.native_method
  def set_doppler_tracking(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__doppler_tracking = mode






    self._ptr.call_with_return(289,tuple([mode]))

  @functools.native_method
  def get_doppler_tracking(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(290,tuple([]))

    return _ret


  @functools.native_method
  def set_stream_paused(self, pause:'bool'   ) -> None:
    r''''''

    assert isinstance(pause, bool), 'pause must be bool'


    self.py__stream_paused = pause






    self._ptr.call_with_return(291,tuple([pause]))

  @functools.native_method
  def get_stream_paused(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(292,tuple([]))

    return _ret


  @functools.native_method
  def set_max_polyphony(self, max_polyphony:'int'   ) -> None:
    r''''''

    assert isinstance(max_polyphony, (int, float)), 'max_polyphony must be int or float'


    self.py__max_polyphony = max_polyphony






    self._ptr.call_with_return(293,tuple([max_polyphony]))

  @functools.native_method
  def get_max_polyphony(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(294,tuple([]))

    return _ret


  @functools.native_method
  def set_panning_strength(self, panning_strength:'float'   ) -> None:
    r''''''

    assert isinstance(panning_strength, (int, float)), 'panning_strength must be int or float'


    self.py__panning_strength = panning_strength






    self._ptr.call_with_return(295,tuple([panning_strength]))

  @functools.native_method
  def get_panning_strength(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(296,tuple([]))

    return _ret


  @functools.native_method
  def has_stream_playback(self) -> typing.Union[bool]:
    r'''
				Returns whether the `AudioStreamPlayer` can return the `AudioStreamPlayback` object or not.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(297,tuple([]))
    return _ret


  @functools.native_method
  def get_stream_playback(self) -> typing.Any:
    r'''
				Returns the `AudioStreamPlayback` object associated with this `AudioStreamPlayer3D`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioStreamPlayback
    _ret._ptr = self._ptr.call_with_return(298,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_playback_type(self, playback_type:'int'  ) -> None:
    r''''''

    assert isinstance(playback_type, (int, float)), 'playback_type must be int or float'


    self.py__playback_type = playback_type






    self._ptr.call_with_return(299,tuple([playback_type]))

  @functools.native_method
  def get_playback_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(300,tuple([]))

    return _ret



register_cast_function('AudioStreamPlayer3D', AudioStreamPlayer3D.cast)
register_class('AudioStreamPlayer3D', AudioStreamPlayer3D)
