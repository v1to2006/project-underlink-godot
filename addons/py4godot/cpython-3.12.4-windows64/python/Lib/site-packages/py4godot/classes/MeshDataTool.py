# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PhysicalSkyMaterial as py4godot_physicalskymaterial 
  import py4godot.classes.ParticleProcessMaterial as py4godot_particleprocessmaterial 
  import py4godot.classes.StandardMaterial3D as py4godot_standardmaterial3d 
  import py4godot.classes.PlaceholderMaterial as py4godot_placeholdermaterial 
  import py4godot.classes.ShaderMaterial as py4godot_shadermaterial 
  import py4godot.classes.PanoramaSkyMaterial as py4godot_panoramaskymaterial 
  import py4godot.classes.ProceduralSkyMaterial as py4godot_proceduralskymaterial 
  import py4godot.classes.BaseMaterial3D as py4godot_basematerial3d 
  import py4godot.classes.ArrayMesh as py4godot_arraymesh 
  import py4godot.classes.CanvasItemMaterial as py4godot_canvasitemmaterial 
  import py4godot.classes.FogMaterial as py4godot_fogmaterial 
  import py4godot.classes.Material as py4godot_material 
  import py4godot.classes.ORMMaterial3D as py4godot_ormmaterial3d 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPMeshDataToolWrapper


class MeshDataTool(py4godot_refcounted.RefCounted):
  r'''
		MeshDataTool provides access to individual vertices in a `Mesh`. It allows users to read and edit vertex data of meshes. It also creates an array of faces and edges.
		To use MeshDataTool, load a mesh with `create_from_surface`. When you are finished editing the data commit the data to a mesh with `commit_to_surface`.
		Below is an example of how MeshDataTool may be used.
		
		```gdscript
		var mesh = ArrayMesh.new()
		mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, BoxMesh.new().get_mesh_arrays())
		var mdt = MeshDataTool.new()
		mdt.create_from_surface(mesh, 0)
		for i in range(mdt.get_vertex_count()):
			var vertex = mdt.get_vertex(i)
			# In this example we extend the mesh by one unit, which results in separated faces as it is flat shaded.
			vertex += mdt.get_vertex_normal(i)
			# Save your change.
			mdt.set_vertex(i, vertex)
		mesh.clear_surfaces()
		mdt.commit_to_surface(mesh)
		var mi = MeshInstance.new()
		mi.mesh = mesh
		add_child(mi)
		```
		
		
		See also `ArrayMesh`, `ImmediateMesh` and `SurfaceTool` for procedural geometry generation.
		**Note:** Godot uses clockwise `url=https://learnopengl.com/Advanced-OpenGL/Face-culling`winding order`/url` for front faces of triangle primitive modes.
	'''

  @staticmethod
  def constructor():
    class_ = MeshDataTool.construct_without_init()
    class_._ptr = constructor(472,0, ())
    return class_
  @staticmethod
  def new():
    class_ = MeshDataTool.construct_without_init()
    class_._ptr = constructor(472,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPMeshDataToolWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(472,0, ())


  def generate_wrapper(self):
    return CPPMeshDataToolWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = MeshDataTool.__new__(MeshDataTool)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'MeshDataTool'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(91, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = MeshDataTool.construct_without_init()
    cls._ptr = CPPMeshDataToolWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = MeshDataTool.construct_without_init()
    cls._ptr = CPPMeshDataToolWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def clear(self) -> None:
    r'''
				Clears all data currently in MeshDataTool.
			'''




    self._ptr.call_with_return(53,tuple([]))

  @functools.native_method
  def create_from_surface(self, mesh:'py4godot_arraymesh.ArrayMesh'   , surface:'int'   ) -> typing.Union[int]:
    r'''
				Uses specified surface of given `Mesh` to populate data for MeshDataTool.
				Requires `Mesh` with primitive type `constant Mesh.PRIMITIVE_TRIANGLES`.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, get_class('ArrayMesh')), 'mesh must be ArrayMesh'
    assert isinstance(surface, (int, float)), 'surface must be int or float'








    _ret:int
    _ret = self._ptr.call_with_return(54,tuple([mesh._ptr, surface]))
    return _ret


  @functools.native_method
  def commit_to_surface(self, mesh:'py4godot_arraymesh.ArrayMesh'   , compression_flags:'int' =0  ) -> typing.Union[int]:
    r'''
				Adds a new surface to specified `Mesh` with edited data.
			'''

    assert(not mesh is None)
    assert isinstance(mesh, get_class('ArrayMesh')), 'mesh must be ArrayMesh'
    assert isinstance(compression_flags, (int, float)), 'compression_flags must be int or float'








    _ret:int
    _ret = self._ptr.call_with_return(55,tuple([mesh._ptr, compression_flags]))
    return _ret


  @functools.native_method
  def get_format(self) -> typing.Union[int]:
    r'''
				Returns the `Mesh`'s format as a combination of the `enum Mesh.ArrayFormat` flags. For example, a mesh containing both vertices and normals would return a format of `3` because `constant Mesh.ARRAY_FORMAT_VERTEX` is `1` and `constant Mesh.ARRAY_FORMAT_NORMAL` is `2`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([]))
    return _ret


  @functools.native_method
  def get_vertex_count(self) -> typing.Union[int]:
    r'''
				Returns the total number of vertices in `Mesh`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([]))
    return _ret


  @functools.native_method
  def get_edge_count(self) -> typing.Union[int]:
    r'''
				Returns the number of edges in this `Mesh`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(58,tuple([]))
    return _ret


  @functools.native_method
  def get_face_count(self) -> typing.Union[int]:
    r'''
				Returns the number of faces in this `Mesh`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(59,tuple([]))
    return _ret


  @functools.native_method
  def set_vertex(self, idx:'int'   , vertex:'Vector3'   ) -> None:
    r'''
				Sets the position of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not vertex is None)
    assert isinstance(vertex, Vector3), 'vertex must be Vector3'








    self._ptr.call_with_return(60,tuple([idx, vertex._ptr]))

  @functools.native_method
  def get_vertex(self, idx:'int'   ) -> typing.Union['Vector3']:
    r'''
				Returns the position of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([idx]))
    return _ret


  @functools.native_method
  def set_vertex_normal(self, idx:'int'   , normal:'Vector3'   ) -> None:
    r'''
				Sets the normal of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not normal is None)
    assert isinstance(normal, Vector3), 'normal must be Vector3'








    self._ptr.call_with_return(62,tuple([idx, normal._ptr]))

  @functools.native_method
  def get_vertex_normal(self, idx:'int'   ) -> typing.Union['Vector3']:
    r'''
				Returns the normal of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(63,tuple([idx]))
    return _ret


  @functools.native_method
  def set_vertex_tangent(self, idx:'int'   , tangent:'Plane'   ) -> None:
    r'''
				Sets the tangent of the given vertex.
				**Note:** Even though `tangent` is a `Plane`, it does not directly represent the tangent plane. Its `Plane.x`, `Plane.y`, and `Plane.z` represent the tangent vector and `Plane.d` should be either `-1` or `1`. See also `constant Mesh.ARRAY_TANGENT`.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not tangent is None)
    assert isinstance(tangent, Plane), 'tangent must be Plane'








    self._ptr.call_with_return(64,tuple([idx, tangent._ptr]))

  @functools.native_method
  def get_vertex_tangent(self, idx:'int'   ) -> typing.Union['Plane']:
    r'''
				Returns the tangent of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = Plane.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(65,tuple([idx]))
    return _ret


  @functools.native_method
  def set_vertex_uv(self, idx:'int'   , uv:'Vector2'   ) -> None:
    r'''
				Sets the UV of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not uv is None)
    assert isinstance(uv, Vector2), 'uv must be Vector2'








    self._ptr.call_with_return(66,tuple([idx, uv._ptr]))

  @functools.native_method
  def get_vertex_uv(self, idx:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the UV of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(67,tuple([idx]))
    return _ret


  @functools.native_method
  def set_vertex_uv2(self, idx:'int'   , uv2:'Vector2'   ) -> None:
    r'''
				Sets the UV2 of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not uv2 is None)
    assert isinstance(uv2, Vector2), 'uv2 must be Vector2'








    self._ptr.call_with_return(68,tuple([idx, uv2._ptr]))

  @functools.native_method
  def get_vertex_uv2(self, idx:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the UV2 of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(69,tuple([idx]))
    return _ret


  @functools.native_method
  def set_vertex_color(self, idx:'int'   , color:'Color'   ) -> None:
    r'''
				Sets the color of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'








    self._ptr.call_with_return(70,tuple([idx, color._ptr]))

  @functools.native_method
  def get_vertex_color(self, idx:'int'   ) -> typing.Union['Color']:
    r'''
				Returns the color of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(71,tuple([idx]))
    return _ret


  @functools.native_method
  def set_vertex_bones(self, idx:'int'   , bones:'PackedInt32Array'   ) -> None:
    r'''
				Sets the bones of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not bones is None)
    assert isinstance(bones, PackedInt32Array), 'bones must be PackedInt32Array'








    self._ptr.call_with_return(72,tuple([idx, bones._ptr]))

  @functools.native_method
  def get_vertex_bones(self, idx:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns the bones of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(73,tuple([idx]))
    return _ret


  @functools.native_method
  def set_vertex_weights(self, idx:'int'   , weights:'PackedFloat32Array'   ) -> None:
    r'''
				Sets the bone weights of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not weights is None)
    assert isinstance(weights, PackedFloat32Array), 'weights must be PackedFloat32Array'








    self._ptr.call_with_return(74,tuple([idx, weights._ptr]))

  @functools.native_method
  def get_vertex_weights(self, idx:'int'   ) -> typing.Union['PackedFloat32Array']:
    r'''
				Returns bone weights of the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = PackedFloat32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(75,tuple([idx]))
    return _ret


  @functools.native_method
  def set_vertex_meta(self, idx:'int'   , meta:'object'   ) -> None:
    r'''
				Sets the metadata associated with the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    

    if not (type(meta).__name__ in py4godot.variant_types.core_types or isinstance(meta, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'meta': "
                f"{type(meta).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    self._ptr.call_with_return(76,tuple([idx, meta]))

  @functools.native_method
  def get_vertex_meta(self, idx:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the metadata associated with the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = None
    _ret = self._ptr.call_with_return(77,tuple([idx]))
    return _ret


  @functools.native_method
  def get_vertex_edges(self, idx:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns an array of edges that share the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([idx]))
    return _ret


  @functools.native_method
  def get_vertex_faces(self, idx:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns an array of faces that share the given vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([idx]))
    return _ret


  @functools.native_method
  def get_edge_vertex(self, idx:'int'   , vertex:'int'   ) -> typing.Union[int]:
    r'''
				Returns the index of the specified `vertex` connected to the edge at index `idx`.
				`vertex` can only be `0` or `1`, as edges are composed of two vertices.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(vertex, (int, float)), 'vertex must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(80,tuple([idx, vertex]))
    return _ret


  @functools.native_method
  def get_edge_faces(self, idx:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns array of faces that touch given edge.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([idx]))
    return _ret


  @functools.native_method
  def set_edge_meta(self, idx:'int'   , meta:'object'   ) -> None:
    r'''
				Sets the metadata of the given edge.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    

    if not (type(meta).__name__ in py4godot.variant_types.core_types or isinstance(meta, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'meta': "
                f"{type(meta).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    self._ptr.call_with_return(82,tuple([idx, meta]))

  @functools.native_method
  def get_edge_meta(self, idx:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns meta information assigned to given edge.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = None
    _ret = self._ptr.call_with_return(83,tuple([idx]))
    return _ret


  @functools.native_method
  def get_face_vertex(self, idx:'int'   , vertex:'int'   ) -> typing.Union[int]:
    r'''
				Returns the specified vertex index of the given face.
				`vertex` must be either `0`, `1`, or `2` because faces contain three vertices.
				
				```gdscript
				var index = mesh_data_tool.get_face_vertex(0, 1) # Gets the index of the second vertex of the first face.
				var position = mesh_data_tool.get_vertex(index)
				var normal = mesh_data_tool.get_vertex_normal(index)
				```
				
				
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(vertex, (int, float)), 'vertex must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([idx, vertex]))
    return _ret


  @functools.native_method
  def get_face_edge(self, idx:'int'   , edge:'int'   ) -> typing.Union[int]:
    r'''
				Returns the edge associated with the face at index `idx`.
				`edge` argument must be either `0`, `1`, or `2` because a face only has three edges.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(edge, (int, float)), 'edge must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([idx, edge]))
    return _ret


  @functools.native_method
  def set_face_meta(self, idx:'int'   , meta:'object'   ) -> None:
    r'''
				Sets the metadata of the given face.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    

    if not (type(meta).__name__ in py4godot.variant_types.core_types or isinstance(meta, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'meta': "
                f"{type(meta).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    self._ptr.call_with_return(86,tuple([idx, meta]))

  @functools.native_method
  def get_face_meta(self, idx:'int'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the metadata associated with the given face.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = None
    _ret = self._ptr.call_with_return(87,tuple([idx]))
    return _ret


  @functools.native_method
  def get_face_normal(self, idx:'int'   ) -> typing.Union['Vector3']:
    r'''
				Calculates and returns the face normal of the given face.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([idx]))
    return _ret


  @functools.native_method
  def set_material(self, material:'py4godot_material.Material'   ) -> None:
    r'''
				Sets the material to be used by newly-constructed `Mesh`.
			'''

    assert(not material is None)
    assert isinstance(material, get_class('Material')), 'material must be Material'







    self._ptr.call_with_return(89,tuple([material._ptr]))

  @functools.native_method
  def get_material(self) -> typing.Any:
    r'''
				Returns the material assigned to the `Mesh`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Material
    _ret._ptr = self._ptr.call_with_return(90,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('MeshDataTool', MeshDataTool.cast)
register_class('MeshDataTool', MeshDataTool)
