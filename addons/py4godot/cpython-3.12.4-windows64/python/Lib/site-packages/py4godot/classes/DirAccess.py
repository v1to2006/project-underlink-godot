# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPDirAccessWrapper


class DirAccess(py4godot_refcounted.RefCounted):
  r'''
		This class is used to manage directories and their content, even outside of the project folder.
		`DirAccess` can't be instantiated directly. Instead it is created with a static method that takes a path for which it will be opened.
		Most of the methods have a static alternative that can be used without creating a `DirAccess`. Static methods only support absolute paths (including `res://` and `user://`).
		```gdscript
		# Standard
		var dir = DirAccess.open("user://levels")
		dir.make_dir("world1")
		# Static
		DirAccess.make_dir_absolute("user://levels/world1")
		```
		**Note:** Accessing project ("res://") directories once exported may behave unexpectedly as some files are converted to engine-specific formats and their original source files may not be present in the expected PCK package. Because of this, to access resources in an exported project, it is recommended to use `ResourceLoader` instead of `FileAccess`.
		Here is an example on how to iterate through the files of a directory:
		
		```gdscript
		func dir_contents(path):
			var dir = DirAccess.open(path)
			if dir:
				dir.list_dir_begin()
				var file_name = dir.get_next()
				while file_name != "":
					if dir.current_is_dir():
						print("Found directory: " + file_name)
					else:
						print("Found file: " + file_name)
					file_name = dir.get_next()
			else:
				print("An error occurred when trying to access the path.")
		```
		
		
		Keep in mind that file names may change or be remapped after export. If you want to see the actual resource file list as it appears in the editor, use `ResourceLoader.list_directory` instead.
	'''

  @staticmethod
  def constructor():
    class_ = DirAccess.construct_without_init()
    class_._ptr = constructor(259,0, ())
    return class_
  @staticmethod
  def new():
    class_ = DirAccess.construct_without_init()
    class_._ptr = constructor(259,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPDirAccessWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(259,0, ())


  def generate_wrapper(self):
    return CPPDirAccessWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = DirAccess.__new__(DirAccess)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'DirAccess'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(81, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = DirAccess.construct_without_init()
    cls._ptr = CPPDirAccessWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = DirAccess.construct_without_init()
    cls._ptr = CPPDirAccessWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def include_navigational(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_include_navigational()
    return _ret
  @include_navigational.setter
  def include_navigational(self,  value:'bool'):
    self.set_include_navigational(value)
  @property
  def include_hidden(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_include_hidden()
    return _ret
  @include_hidden.setter
  def include_hidden(self,  value:'bool'):
    self.set_include_hidden(value)
  @staticmethod
  def open(path:'str'   ) -> typing.Union['typing.Self']:
    r'''
				Creates a new `DirAccess` object and opens an existing directory of the filesystem. The `path` argument can be within the project tree (`res://folder`), the user directory (`user://folder`) or an absolute path of the user filesystem (e.g. `/tmp/folder` or `C:\tmp\folder`).
				Returns `null` if opening the directory failed. You can use `get_open_error` to check the error that occurred.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = DirAccess.construct_without_init()
    _ret._ptr = static_method(259,0,tuple([py_string_path._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @staticmethod
  def get_open_error() -> typing.Union[int]:
    r'''
				Returns the result of the last `open` call in the current thread.
			'''




    _ret:int
    _ret = static_method(259,1,tuple([]))
    return _ret


  @staticmethod
  def create_temp(prefix:'str' =""  , keep:'bool' =False  ) -> typing.Union['typing.Self']:
    r'''
				Creates a temporary directory. This directory will be freed when the returned `DirAccess` is freed.
				If `prefix` is not empty, it will be prefixed to the directory name, separated by a `-`.
				If `keep` is `true`, the directory is not deleted when the returned `DirAccess` is freed.
				Returns `null` if opening the directory failed. You can use `get_open_error` to check the error that occurred.
			'''
    if prefix is None:
      prefix = String.new0()

    assert isinstance(keep, bool), 'keep must be bool'





    assert(isinstance(prefix, (str, String)))
    py_string_prefix = prefix if isinstance(prefix, StringName) else c_utils.py_string_to_string(prefix)


    _ret = DirAccess.construct_without_init()
    _ret._ptr = static_method(259,2,tuple([py_string_prefix._ptr, keep]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def list_dir_begin(self) -> typing.Union[int]:
    r'''
				Initializes the stream used to list all files and directories using the `get_next` function, closing the currently opened stream if needed. Once the stream has been processed, it should typically be closed with `list_dir_end`.
				Affected by `include_hidden` and `include_navigational`.
				**Note:** The order of files and directories returned by this method is not deterministic, and can vary between operating systems. If you want a list of all files or folders sorted alphabetically, use `get_files` or `get_directories`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(53,tuple([]))
    return _ret


  @functools.native_method
  def get_next(self) -> typing.Union[str]:
    r'''
				Returns the next element (file or directory) in the current directory.
				The name of the file or directory is returned (and not its full path). Once the stream has been fully processed, the method returns an empty `String` and closes the stream automatically (i.e. `list_dir_end` would not be mandatory in such a case).
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def current_is_dir(self) -> typing.Union[bool]:
    r'''
				Returns whether the current item processed with the last `get_next` call is a directory (`.` and `..` are considered directories).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(55,tuple([]))
    return _ret


  @functools.native_method
  def list_dir_end(self) -> None:
    r'''
				Closes the current stream opened with `list_dir_begin` (whether it has been fully processed with `get_next` does not matter).
			'''




    self._ptr.call_with_return(56,tuple([]))

  @functools.native_method
  def get_files(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns a `PackedStringArray` containing filenames of the directory contents, excluding directories. The array is sorted alphabetically.
				Affected by `include_hidden`.
				**Note:** When used on a `res://` path in an exported project, only the files actually included in the PCK at the given folder level are returned. In practice, this means that since imported resources are stored in a top-level `.godot/` folder, only paths to `*.gd` and `*.import` files are returned (plus a few files such as `project.godot` or `project.binary` and the project icon). In an exported project, the list of returned files will also vary depending on whether `ProjectSettings.editor/export/convert_text_resources_to_binary` is `true`.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(57,tuple([]))
    return _ret


  @staticmethod
  def get_files_at(path:'str'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns a `PackedStringArray` containing filenames of the directory contents, excluding directories, at the given `path`. The array is sorted alphabetically.
				Use `get_files` if you want more control of what gets included.
				**Note:** When used on a `res://` path in an exported project, only the files included in the PCK at the given folder level are returned. In practice, this means that since imported resources are stored in a top-level `.godot/` folder, only paths to `.gd` and `.import` files are returned (plus a few other files, such as `project.godot` or `project.binary` and the project icon). In an exported project, the list of returned files will also vary depending on `ProjectSettings.editor/export/convert_text_resources_to_binary`.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = static_method(259,3,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def get_directories(self) -> typing.Union['PackedStringArray']:
    r'''
				Returns a `PackedStringArray` containing filenames of the directory contents, excluding files. The array is sorted alphabetically.
				Affected by `include_hidden` and `include_navigational`.
				**Note:** The returned directories in the editor and after exporting in the `res://` directory may differ as some files are converted to engine-specific formats when exported.
			'''




    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([]))
    return _ret


  @staticmethod
  def get_directories_at(path:'str'   ) -> typing.Union['PackedStringArray']:
    r'''
				Returns a `PackedStringArray` containing filenames of the directory contents, excluding files, at the given `path`. The array is sorted alphabetically.
				Use `get_directories` if you want more control of what gets included.
				**Note:** The returned directories in the editor and after exporting in the `res://` directory may differ as some files are converted to engine-specific formats when exported.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = PackedStringArray.construct_without_init()
    _ret._ptr = static_method(259,4,tuple([py_string_path._ptr]))
    return _ret


  @staticmethod
  def get_drive_count() -> typing.Union[int]:
    r'''
				On Windows, returns the number of drives (partitions) mounted on the current filesystem.
				On macOS and Android, returns the number of mounted volumes.
				On Linux, returns the number of mounted volumes and GTK 3 bookmarks.
				On other platforms, the method returns 0.
			'''




    _ret = 0
    _ret = static_method(259,5,tuple([]))
    return _ret


  @staticmethod
  def get_drive_name(idx:'int'   ) -> typing.Union[str]:
    r'''
				On Windows, returns the name of the drive (partition) passed as an argument (e.g. `C:`).
				On macOS, returns the path to the mounted volume passed as an argument.
				On Linux, returns the path to the mounted volume or GTK 3 bookmark passed as an argument.
				On Android (API level 30+), returns the path to the mounted volume as an argument.
				On other platforms, or if the requested drive does not exist, the method returns an empty String.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = static_method(259,6,tuple([idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_current_drive(self) -> typing.Union[int]:
    r'''
				Returns the currently opened directory's drive index. See `get_drive_name` to convert returned index to the name of the drive.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(59,tuple([]))
    return _ret


  @functools.native_method
  def change_dir(self, to_dir:'str'   ) -> typing.Union[int]:
    r'''
				Changes the currently opened directory to the one passed as an argument. The argument can be relative to the current directory (e.g. `newdir` or `../newdir`), or an absolute path (e.g. `/tmp/newdir` or `res://somedir/newdir`).
				Returns one of the `enum Error` code constants (`constant OK` on success).
				**Note:** The new directory must be within the same scope, e.g. when you had opened a directory inside `res://`, you can't change it to `user://` directory. If you need to open a directory in another access scope, use `open` to create a new instance instead.
			'''

    assert(not to_dir is None)
    assert isinstance(to_dir, (str, String)), 'to_dir must be str or String'





    assert(isinstance(to_dir, (str, String)))
    py_string_to_dir = to_dir if isinstance(to_dir, StringName) else c_utils.py_string_to_string(to_dir)

    _ret:int
    _ret = self._ptr.call_with_return(60,tuple([py_string_to_dir._ptr]))
    return _ret


  @functools.native_method
  def get_current_dir(self, include_drive:'bool' =True  ) -> typing.Union[str]:
    r'''
				Returns the absolute path to the currently opened directory (e.g. `res://folder` or `C:\tmp\folder`).
			'''

    assert isinstance(include_drive, bool), 'include_drive must be bool'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(61,tuple([include_drive]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def make_dir(self, path:'str'   ) -> typing.Union[int]:
    r'''
				Creates a directory. The argument can be relative to the current directory, or an absolute path. The target directory should be placed in an already existing directory (to create the full path recursively, see `make_dir_recursive`).
				Returns one of the `enum Error` code constants (`constant OK` on success).
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret:int
    _ret = self._ptr.call_with_return(62,tuple([py_string_path._ptr]))
    return _ret


  @staticmethod
  def make_dir_absolute(path:'str'   ) -> typing.Union[int]:
    r'''
				Static version of `make_dir`. Supports only absolute paths.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret:int
    _ret = static_method(259,7,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def make_dir_recursive(self, path:'str'   ) -> typing.Union[int]:
    r'''
				Creates a target directory and all necessary intermediate directories in its path, by calling `make_dir` recursively. The argument can be relative to the current directory, or an absolute path.
				Returns one of the `enum Error` code constants (`constant OK` on success).
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret:int
    _ret = self._ptr.call_with_return(63,tuple([py_string_path._ptr]))
    return _ret


  @staticmethod
  def make_dir_recursive_absolute(path:'str'   ) -> typing.Union[int]:
    r'''
				Static version of `make_dir_recursive`. Supports only absolute paths.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret:int
    _ret = static_method(259,8,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def file_exists(self, path:'str'   ) -> typing.Union[bool]:
    r'''
				Returns whether the target file exists. The argument can be relative to the current directory, or an absolute path.
				For a static equivalent, use `FileAccess.file_exists`.
				**Note:** Many resources types are imported (e.g. textures or sound files), and their source asset will not be included in the exported game, as only the imported version is used. See `ResourceLoader.exists` for an alternative approach that takes resource remapping into account.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = 0
    _ret = self._ptr.call_with_return(64,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def dir_exists(self, path:'str'   ) -> typing.Union[bool]:
    r'''
				Returns whether the target directory exists. The argument can be relative to the current directory, or an absolute path.
				**Note:** The returned `bool` in the editor and after exporting when used on a path in the `res://` directory may be different. Some files are converted to engine-specific formats when exported, potentially changing the directory structure.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = 0
    _ret = self._ptr.call_with_return(65,tuple([py_string_path._ptr]))
    return _ret


  @staticmethod
  def dir_exists_absolute(path:'str'   ) -> typing.Union[bool]:
    r'''
				Static version of `dir_exists`. Supports only absolute paths.
				**Note:** The returned `bool` in the editor and after exporting when used on a path in the `res://` directory may be different. Some files are converted to engine-specific formats when exported, potentially changing the directory structure.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = 0
    _ret = static_method(259,9,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def get_space_left(self) -> typing.Union[int]:
    r'''
				Returns the available space on the current directory's disk, in bytes. Returns `0` if the platform-specific method to query the available space fails.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([]))
    return _ret


  @functools.native_method
  def copy(self, from_:'str'   , to:'str'   , chmod_flags:'int' =-1  ) -> typing.Union[int]:
    r'''
				Copies the `from` file to the `to` destination. Both arguments should be paths to files, either relative or absolute. If the destination file exists and is not access-protected, it will be overwritten.
				If `chmod_flags` is different than `-1`, the Unix permissions for the destination path will be set to the provided value, if available on the current operating system.
				Returns one of the `enum Error` code constants (`constant OK` on success).
			'''

    assert(not from_ is None)
    assert isinstance(from_, (str, String)), 'from_ must be str or String'
    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'
    assert isinstance(chmod_flags, (int, float)), 'chmod_flags must be int or float'





    assert(isinstance(from_, (str, String)))
    py_string_from_ = from_ if isinstance(from_, StringName) else c_utils.py_string_to_string(from_)
    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)


    _ret:int
    _ret = self._ptr.call_with_return(67,tuple([py_string_from_._ptr, py_string_to._ptr, chmod_flags]))
    return _ret


  @staticmethod
  def copy_absolute(from_:'str'   , to:'str'   , chmod_flags:'int' =-1  ) -> typing.Union[int]:
    r'''
				Static version of `copy`. Supports only absolute paths.
			'''

    assert(not from_ is None)
    assert isinstance(from_, (str, String)), 'from_ must be str or String'
    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'
    assert isinstance(chmod_flags, (int, float)), 'chmod_flags must be int or float'





    assert(isinstance(from_, (str, String)))
    py_string_from_ = from_ if isinstance(from_, StringName) else c_utils.py_string_to_string(from_)
    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)


    _ret:int
    _ret = static_method(259,10,tuple([py_string_from_._ptr, py_string_to._ptr, chmod_flags]))
    return _ret


  @functools.native_method
  def rename(self, from_:'str'   , to:'str'   ) -> typing.Union[int]:
    r'''
				Renames (move) the `from` file or directory to the `to` destination. Both arguments should be paths to files or directories, either relative or absolute. If the destination file or directory exists and is not access-protected, it will be overwritten.
				Returns one of the `enum Error` code constants (`constant OK` on success).
			'''

    assert(not from_ is None)
    assert isinstance(from_, (str, String)), 'from_ must be str or String'
    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'





    assert(isinstance(from_, (str, String)))
    py_string_from_ = from_ if isinstance(from_, StringName) else c_utils.py_string_to_string(from_)
    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)

    _ret:int
    _ret = self._ptr.call_with_return(68,tuple([py_string_from_._ptr, py_string_to._ptr]))
    return _ret


  @staticmethod
  def rename_absolute(from_:'str'   , to:'str'   ) -> typing.Union[int]:
    r'''
				Static version of `rename`. Supports only absolute paths.
			'''

    assert(not from_ is None)
    assert isinstance(from_, (str, String)), 'from_ must be str or String'
    assert(not to is None)
    assert isinstance(to, (str, String)), 'to must be str or String'





    assert(isinstance(from_, (str, String)))
    py_string_from_ = from_ if isinstance(from_, StringName) else c_utils.py_string_to_string(from_)
    assert(isinstance(to, (str, String)))
    py_string_to = to if isinstance(to, StringName) else c_utils.py_string_to_string(to)

    _ret:int
    _ret = static_method(259,11,tuple([py_string_from_._ptr, py_string_to._ptr]))
    return _ret


  @functools.native_method
  def remove(self, path:'str'   ) -> typing.Union[int]:
    r'''
				Permanently deletes the target file or an empty directory. The argument can be relative to the current directory, or an absolute path. If the target directory is not empty, the operation will fail.
				If you don't want to delete the file/directory permanently, use `OS.move_to_trash` instead.
				Returns one of the `enum Error` code constants (`constant OK` on success).
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret:int
    _ret = self._ptr.call_with_return(69,tuple([py_string_path._ptr]))
    return _ret


  @staticmethod
  def remove_absolute(path:'str'   ) -> typing.Union[int]:
    r'''
				Static version of `remove`. Supports only absolute paths.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret:int
    _ret = static_method(259,12,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def is_link(self, path:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the file or directory is a symbolic link, directory junction, or other reparse point.
				**Note:** This method is implemented on macOS, Linux, and Windows.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = 0
    _ret = self._ptr.call_with_return(70,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def read_link(self, path:'str'   ) -> typing.Union[str]:
    r'''
				Returns target of the symbolic link.
				**Note:** This method is implemented on macOS, Linux, and Windows.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(71,tuple([py_string_path._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def create_link(self, source:'str'   , target:'str'   ) -> typing.Union[int]:
    r'''
				Creates symbolic link between files or folders.
				**Note:** On Windows, this method works only if the application is running with elevated privileges or Developer Mode is enabled.
				**Note:** This method is implemented on macOS, Linux, and Windows.
			'''

    assert(not source is None)
    assert isinstance(source, (str, String)), 'source must be str or String'
    assert(not target is None)
    assert isinstance(target, (str, String)), 'target must be str or String'





    assert(isinstance(source, (str, String)))
    py_string_source = source if isinstance(source, StringName) else c_utils.py_string_to_string(source)
    assert(isinstance(target, (str, String)))
    py_string_target = target if isinstance(target, StringName) else c_utils.py_string_to_string(target)

    _ret:int
    _ret = self._ptr.call_with_return(72,tuple([py_string_source._ptr, py_string_target._ptr]))
    return _ret


  @functools.native_method
  def is_bundle(self, path:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the directory is a macOS bundle.
				**Note:** This method is implemented on macOS.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = 0
    _ret = self._ptr.call_with_return(73,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def set_include_navigational(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__include_navigational = enable






    self._ptr.call_with_return(74,tuple([enable]))

  @functools.native_method
  def get_include_navigational(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(75,tuple([]))

    return _ret


  @functools.native_method
  def set_include_hidden(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__include_hidden = enable






    self._ptr.call_with_return(76,tuple([enable]))

  @functools.native_method
  def get_include_hidden(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(77,tuple([]))

    return _ret


  @functools.native_method
  def get_filesystem_type(self) -> typing.Union[str]:
    r'''
				Returns file system type name of the current directory's disk. Returned values are uppercase strings like `NTFS`, `FAT32`, `EXFAT`, `APFS`, `EXT4`, `BTRFS`, and so on.
				**Note:** This method is implemented on macOS, Linux, Windows and for PCK virtual file system.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def is_case_sensitive(self, path:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the file system or directory use case sensitive file names.
				**Note:** This method is implemented on macOS, Linux (for EXT4 and F2FS filesystems only) and Windows. On other platforms, it always returns `true`.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    _ret = 0
    _ret = self._ptr.call_with_return(79,tuple([py_string_path._ptr]))
    return _ret


  @functools.native_method
  def is_equivalent(self, path_a:'str'   , path_b:'str'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if paths `path_a` and `path_b` resolve to the same file system object. Returns `false` otherwise, even if the files are bit-for-bit identical (e.g., identical copies of the file that are not symbolic links).
			'''

    assert(not path_a is None)
    assert isinstance(path_a, (str, String)), 'path_a must be str or String'
    assert(not path_b is None)
    assert isinstance(path_b, (str, String)), 'path_b must be str or String'





    assert(isinstance(path_a, (str, String)))
    py_string_path_a = path_a if isinstance(path_a, StringName) else c_utils.py_string_to_string(path_a)
    assert(isinstance(path_b, (str, String)))
    py_string_path_b = path_b if isinstance(path_b, StringName) else c_utils.py_string_to_string(path_b)

    _ret = 0
    _ret = self._ptr.call_with_return(80,tuple([py_string_path_a._ptr, py_string_path_b._ptr]))
    return _ret



register_cast_function('DirAccess', DirAccess.cast)
register_class('DirAccess', DirAccess)
