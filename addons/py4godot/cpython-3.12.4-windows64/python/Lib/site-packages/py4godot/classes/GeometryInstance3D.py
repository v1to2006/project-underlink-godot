# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.CSGShape3D as py4godot_csgshape3d 
  import py4godot.classes.CSGCombiner3D as py4godot_csgcombiner3d 
  import py4godot.classes.ProceduralSkyMaterial as py4godot_proceduralskymaterial 
  import py4godot.classes.CSGBox3D as py4godot_csgbox3d 
  import py4godot.classes.Label3D as py4godot_label3d 
  import py4godot.classes.Material as py4godot_material 
  import py4godot.classes.StandardMaterial3D as py4godot_standardmaterial3d 
  import py4godot.classes.PlaceholderMaterial as py4godot_placeholdermaterial 
  import py4godot.classes.CSGPrimitive3D as py4godot_csgprimitive3d 
  import py4godot.classes.AnimatedSprite3D as py4godot_animatedsprite3d 
  import py4godot.classes.BaseMaterial3D as py4godot_basematerial3d 
  import py4godot.classes.Sprite3D as py4godot_sprite3d 
  import py4godot.classes.SpriteBase3D as py4godot_spritebase3d 
  import py4godot.classes.SoftBody3D as py4godot_softbody3d 
  import py4godot.classes.ShaderMaterial as py4godot_shadermaterial 
  import py4godot.classes.CSGCylinder3D as py4godot_csgcylinder3d 
  import py4godot.classes.GPUParticles3D as py4godot_gpuparticles3d 
  import py4godot.classes.ORMMaterial3D as py4godot_ormmaterial3d 
  import py4godot.classes.PanoramaSkyMaterial as py4godot_panoramaskymaterial 
  import py4godot.classes.CPUParticles3D as py4godot_cpuparticles3d 
  import py4godot.classes.CSGMesh3D as py4godot_csgmesh3d 
  import py4godot.classes.ParticleProcessMaterial as py4godot_particleprocessmaterial 
  import py4godot.classes.MeshInstance3D as py4godot_meshinstance3d 
  import py4godot.classes.PhysicalSkyMaterial as py4godot_physicalskymaterial 
  import py4godot.classes.CSGSphere3D as py4godot_csgsphere3d 
  import py4godot.classes.CSGTorus3D as py4godot_csgtorus3d 
  import py4godot.classes.CSGPolygon3D as py4godot_csgpolygon3d 
  import py4godot.classes.CanvasItemMaterial as py4godot_canvasitemmaterial 
  import py4godot.classes.FogMaterial as py4godot_fogmaterial 
  import py4godot.classes.MultiMeshInstance3D as py4godot_multimeshinstance3d 
import py4godot.classes.VisualInstance3D as py4godot_visualinstance3d 
from py4godot.wrappers.wrappers import CPPGeometryInstance3DWrapper

class ShadowCastingSetting:
  SHADOW_CASTING_SETTING_OFF = 0
  SHADOW_CASTING_SETTING_ON = 1
  SHADOW_CASTING_SETTING_DOUBLE_SIDED = 2
  SHADOW_CASTING_SETTING_SHADOWS_ONLY = 3
class GIMode:
  GI_MODE_DISABLED = 0
  GI_MODE_STATIC = 1
  GI_MODE_DYNAMIC = 2
class LightmapScale:
  LIGHTMAP_SCALE_1X = 0
  LIGHTMAP_SCALE_2X = 1
  LIGHTMAP_SCALE_4X = 2
  LIGHTMAP_SCALE_8X = 3
  LIGHTMAP_SCALE_MAX = 4
class VisibilityRangeFadeMode:
  VISIBILITY_RANGE_FADE_DISABLED = 0
  VISIBILITY_RANGE_FADE_SELF = 1
  VISIBILITY_RANGE_FADE_DEPENDENCIES = 2


class GeometryInstance3D(py4godot_visualinstance3d.VisualInstance3D):
  r'''
		Base node for geometry-based visual instances. Shares some common functionality like visibility and custom materials.
	'''

  @staticmethod
  def constructor():
    class_ = GeometryInstance3D.construct_without_init()
    class_._ptr = constructor(378,0, ())
    return class_
  @staticmethod
  def new():
    class_ = GeometryInstance3D.construct_without_init()
    class_._ptr = constructor(378,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPGeometryInstance3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(378,0, ())


  def generate_wrapper(self):
    return CPPGeometryInstance3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = GeometryInstance3D.__new__(GeometryInstance3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'GeometryInstance3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = GeometryInstance3D.construct_without_init()
    cls._ptr = CPPGeometryInstance3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = GeometryInstance3D.construct_without_init()
    cls._ptr = CPPGeometryInstance3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def material_override(self) -> typing.Union['py4godot_basematerial3d.BaseMaterial3D','py4godot_standardmaterial3d.StandardMaterial3D','py4godot_ormmaterial3d.ORMMaterial3D']:
    r''''''
    _ret = self. get_material_override()
    return _ret
  @material_override.setter
  def material_override(self,  value:'py4godot_object.Object'):
    self.set_material_override(value)
  @property
  def material_overlay(self) -> typing.Union['py4godot_basematerial3d.BaseMaterial3D','py4godot_standardmaterial3d.StandardMaterial3D','py4godot_ormmaterial3d.ORMMaterial3D']:
    r''''''
    _ret = self. get_material_overlay()
    return _ret
  @material_overlay.setter
  def material_overlay(self,  value:'py4godot_object.Object'):
    self.set_material_overlay(value)
  @property
  def transparency(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_transparency()
    return _ret
  @transparency.setter
  def transparency(self,  value:'float'):
    self.set_transparency(value)
  @property
  def cast_shadow(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_cast_shadows_setting()
    return _ret
  @cast_shadow.setter
  def cast_shadow(self,  value:'int'):
    self.set_cast_shadows_setting(value)
  @property
  def extra_cull_margin(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_extra_cull_margin()
    return _ret
  @extra_cull_margin.setter
  def extra_cull_margin(self,  value:'float'):
    self.set_extra_cull_margin(value)
  @property
  def custom_aabb(self) -> typing.Union['AABB']:
    r''''''
    _ret = self. get_custom_aabb()
    return _ret
  @custom_aabb.setter
  def custom_aabb(self,  value:'AABB'):
    self.set_custom_aabb(value)
  @property
  def lod_bias(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_lod_bias()
    return _ret
  @lod_bias.setter
  def lod_bias(self,  value:'float'):
    self.set_lod_bias(value)
  @property
  def ignore_occlusion_culling(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_ignoring_occlusion_culling()
    return _ret
  @ignore_occlusion_culling.setter
  def ignore_occlusion_culling(self,  value:'bool'):
    self.set_ignore_occlusion_culling(value)
  @property
  def gi_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_gi_mode()
    return _ret
  @gi_mode.setter
  def gi_mode(self,  value:'int'):
    self.set_gi_mode(value)
  @property
  def gi_lightmap_texel_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_lightmap_texel_scale()
    return _ret
  @gi_lightmap_texel_scale.setter
  def gi_lightmap_texel_scale(self,  value:'float'):
    self.set_lightmap_texel_scale(value)
  @property
  def gi_lightmap_scale(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_lightmap_scale()
    return _ret
  @gi_lightmap_scale.setter
  def gi_lightmap_scale(self,  value:'int'):
    self.set_lightmap_scale(value)
  @property
  def visibility_range_begin(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_visibility_range_begin()
    return _ret
  @visibility_range_begin.setter
  def visibility_range_begin(self,  value:'float'):
    self.set_visibility_range_begin(value)
  @property
  def visibility_range_begin_margin(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_visibility_range_begin_margin()
    return _ret
  @visibility_range_begin_margin.setter
  def visibility_range_begin_margin(self,  value:'float'):
    self.set_visibility_range_begin_margin(value)
  @property
  def visibility_range_end(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_visibility_range_end()
    return _ret
  @visibility_range_end.setter
  def visibility_range_end(self,  value:'float'):
    self.set_visibility_range_end(value)
  @property
  def visibility_range_end_margin(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_visibility_range_end_margin()
    return _ret
  @visibility_range_end_margin.setter
  def visibility_range_end_margin(self,  value:'float'):
    self.set_visibility_range_end_margin(value)
  @property
  def visibility_range_fade_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_visibility_range_fade_mode()
    return _ret
  @visibility_range_fade_mode.setter
  def visibility_range_fade_mode(self,  value:'int'):
    self.set_visibility_range_fade_mode(value)
  @functools.native_method
  def set_material_override(self, material:'py4godot_material.Material'   ) -> None:
    r''''''

    assert(not material is None)
    assert isinstance(material, get_class('Material')), 'material must be Material'


    self.py__material_override = material






    self._ptr.call_with_return(264,tuple([material._ptr]))

  @functools.native_method
  def get_material_override(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Material
    _ret._ptr = self._ptr.call_with_return(265,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_material_overlay(self, material:'py4godot_material.Material'   ) -> None:
    r''''''

    assert(not material is None)
    assert isinstance(material, get_class('Material')), 'material must be Material'


    self.py__material_overlay = material






    self._ptr.call_with_return(266,tuple([material._ptr]))

  @functools.native_method
  def get_material_overlay(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Material
    _ret._ptr = self._ptr.call_with_return(267,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_cast_shadows_setting(self, shadow_casting_setting:'int'  ) -> None:
    r''''''

    assert isinstance(shadow_casting_setting, (int, float)), 'shadow_casting_setting must be int or float'


    self.py__cast_shadow = shadow_casting_setting






    self._ptr.call_with_return(268,tuple([shadow_casting_setting]))

  @functools.native_method
  def get_cast_shadows_setting(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(269,tuple([]))

    return _ret


  @functools.native_method
  def set_lod_bias(self, bias:'float'   ) -> None:
    r''''''

    assert isinstance(bias, (int, float)), 'bias must be int or float'


    self.py__lod_bias = bias






    self._ptr.call_with_return(270,tuple([bias]))

  @functools.native_method
  def get_lod_bias(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(271,tuple([]))

    return _ret


  @functools.native_method
  def set_transparency(self, transparency:'float'   ) -> None:
    r''''''

    assert isinstance(transparency, (int, float)), 'transparency must be int or float'


    self.py__transparency = transparency






    self._ptr.call_with_return(272,tuple([transparency]))

  @functools.native_method
  def get_transparency(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(273,tuple([]))

    return _ret


  @functools.native_method
  def set_visibility_range_end_margin(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__visibility_range_end_margin = distance






    self._ptr.call_with_return(274,tuple([distance]))

  @functools.native_method
  def get_visibility_range_end_margin(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(275,tuple([]))

    return _ret


  @functools.native_method
  def set_visibility_range_end(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__visibility_range_end = distance






    self._ptr.call_with_return(276,tuple([distance]))

  @functools.native_method
  def get_visibility_range_end(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(277,tuple([]))

    return _ret


  @functools.native_method
  def set_visibility_range_begin_margin(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__visibility_range_begin_margin = distance






    self._ptr.call_with_return(278,tuple([distance]))

  @functools.native_method
  def get_visibility_range_begin_margin(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(279,tuple([]))

    return _ret


  @functools.native_method
  def set_visibility_range_begin(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__visibility_range_begin = distance






    self._ptr.call_with_return(280,tuple([distance]))

  @functools.native_method
  def get_visibility_range_begin(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(281,tuple([]))

    return _ret


  @functools.native_method
  def set_visibility_range_fade_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__visibility_range_fade_mode = mode






    self._ptr.call_with_return(282,tuple([mode]))

  @functools.native_method
  def get_visibility_range_fade_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(283,tuple([]))

    return _ret


  @functools.native_method
  def set_instance_shader_parameter(self, name:'object'   , value:'object'   ) -> None:
    r'''
				Set the value of a shader uniform for this instance only (`url=$DOCS_URL/tutorials/shaders/shader_reference/shading_language.html#per-instance-uniforms`per-instance uniform`/url`). See also `ShaderMaterial.set_shader_parameter` to assign a uniform on all instances using the same `ShaderMaterial`.
				**Note:** For a shader uniform to be assignable on a per-instance basis, it _must_ be defined with `instance uniform ...` rather than `uniform ...` in the shader code.
				**Note:** `name` is case-sensitive and must match the name of the uniform in the code exactly (not the capitalized name in the inspector).
				**Note:** Per-instance shader uniforms are only available in Spatial and CanvasItem shaders, but not for Fog, Sky, or Particles shaders.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(284,tuple([py_stringname_name._ptr, value]))

  @functools.native_method
  def get_instance_shader_parameter(self, name:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Get the value of a shader parameter as set on this instance.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = None
    _ret = self._ptr.call_with_return(285,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def set_extra_cull_margin(self, margin:'float'   ) -> None:
    r''''''

    assert isinstance(margin, (int, float)), 'margin must be int or float'


    self.py__extra_cull_margin = margin






    self._ptr.call_with_return(286,tuple([margin]))

  @functools.native_method
  def get_extra_cull_margin(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(287,tuple([]))

    return _ret


  @functools.native_method
  def set_lightmap_texel_scale(self, scale:'float'   ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'


    self.py__gi_lightmap_texel_scale = scale






    self._ptr.call_with_return(288,tuple([scale]))

  @functools.native_method
  def get_lightmap_texel_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(289,tuple([]))

    return _ret


  @functools.native_method
  def set_lightmap_scale(self, scale:'int'  ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'


    self.py__gi_lightmap_scale = scale






    self._ptr.call_with_return(290,tuple([scale]))

  @functools.native_method
  def get_lightmap_scale(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(291,tuple([]))

    return _ret


  @functools.native_method
  def set_gi_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__gi_mode = mode






    self._ptr.call_with_return(292,tuple([mode]))

  @functools.native_method
  def get_gi_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(293,tuple([]))

    return _ret


  @functools.native_method
  def set_ignore_occlusion_culling(self, ignore_culling:'bool'   ) -> None:
    r''''''

    assert isinstance(ignore_culling, bool), 'ignore_culling must be bool'


    self.py__ignore_occlusion_culling = ignore_culling






    self._ptr.call_with_return(294,tuple([ignore_culling]))

  @functools.native_method
  def is_ignoring_occlusion_culling(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(295,tuple([]))

    return _ret


  @functools.native_method
  def set_custom_aabb(self, aabb:'AABB'   ) -> None:
    r''''''

    assert(not aabb is None)
    assert isinstance(aabb, AABB), 'aabb must be AABB'


    self.py__custom_aabb = aabb






    self._ptr.call_with_return(296,tuple([aabb._ptr]))

  @functools.native_method
  def get_custom_aabb(self) -> typing.Union['AABB']:
    r''''''




    _ret = AABB.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(297,tuple([]))

    return _ret



register_cast_function('GeometryInstance3D', GeometryInstance3D.cast)
register_class('GeometryInstance3D', GeometryInstance3D)
