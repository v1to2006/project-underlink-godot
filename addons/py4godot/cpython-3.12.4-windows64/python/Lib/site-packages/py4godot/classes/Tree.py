# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.OpenXRInteractionProfileEditorBase as py4godot_openxrinteractionprofileeditorbase 
  import py4godot.classes.CodeEdit as py4godot_codeedit 
  import py4godot.classes.PanelContainer as py4godot_panelcontainer 
  import py4godot.classes.Label as py4godot_label 
  import py4godot.classes.ColorPicker as py4godot_colorpicker 
  import py4godot.classes.FileSystemDock as py4godot_filesystemdock 
  import py4godot.classes.TreeItem as py4godot_treeitem 
  import py4godot.classes.EditorScriptPicker as py4godot_editorscriptpicker 
  import py4godot.classes.CenterContainer as py4godot_centercontainer 
  import py4godot.classes.BaseButton as py4godot_basebutton 
  import py4godot.classes.TextureButton as py4godot_texturebutton 
  import py4godot.classes.SplitContainer as py4godot_splitcontainer 
  import py4godot.classes.ItemList as py4godot_itemlist 
  import py4godot.classes.Range as py4godot_range 
  import py4godot.classes.OpenXRBindingModifierEditor as py4godot_openxrbindingmodifiereditor 
  import py4godot.classes.ProgressBar as py4godot_progressbar 
  import py4godot.classes.ScrollContainer as py4godot_scrollcontainer 
  import py4godot.classes.GridContainer as py4godot_gridcontainer 
  import py4godot.classes.TextEdit as py4godot_textedit 
  import py4godot.classes.GraphEdit as py4godot_graphedit 
  import py4godot.classes.NinePatchRect as py4godot_ninepatchrect 
  import py4godot.classes.VSplitContainer as py4godot_vsplitcontainer 
  import py4godot.classes.GraphFrame as py4godot_graphframe 
  import py4godot.classes.GraphElement as py4godot_graphelement 
  import py4godot.classes.CheckBox as py4godot_checkbox 
  import py4godot.classes.RichTextLabel as py4godot_richtextlabel 
  import py4godot.classes.MenuBar as py4godot_menubar 
  import py4godot.classes.TabBar as py4godot_tabbar 
  import py4godot.classes.HFlowContainer as py4godot_hflowcontainer 
  import py4godot.classes.EditorToaster as py4godot_editortoaster 
  import py4godot.classes.ScriptEditorBase as py4godot_scripteditorbase 
  import py4godot.classes.OpenXRInteractionProfileEditor as py4godot_openxrinteractionprofileeditor 
  import py4godot.classes.MarginContainer as py4godot_margincontainer 
  import py4godot.classes.ColorRect as py4godot_colorrect 
  import py4godot.classes.Separator as py4godot_separator 
  import py4godot.classes.CheckButton as py4godot_checkbutton 
  import py4godot.classes.OptionButton as py4godot_optionbutton 
  import py4godot.classes.ReferenceRect as py4godot_referencerect 
  import py4godot.classes.GraphNode as py4godot_graphnode 
  import py4godot.classes.ColorPickerButton as py4godot_colorpickerbutton 
  import py4godot.classes.HScrollBar as py4godot_hscrollbar 
  import py4godot.classes.EditorResourcePicker as py4godot_editorresourcepicker 
  import py4godot.classes.MenuButton as py4godot_menubutton 
  import py4godot.classes.HBoxContainer as py4godot_hboxcontainer 
  import py4godot.classes.Slider as py4godot_slider 
  import py4godot.classes.TextureRect as py4godot_texturerect 
  import py4godot.classes.Container as py4godot_container 
  import py4godot.classes.VideoStreamPlayer as py4godot_videostreamplayer 
  import py4godot.classes.BoxContainer as py4godot_boxcontainer 
  import py4godot.classes.EditorInspector as py4godot_editorinspector 
  import py4godot.classes.VBoxContainer as py4godot_vboxcontainer 
  import py4godot.classes.VFlowContainer as py4godot_vflowcontainer 
  import py4godot.classes.LinkButton as py4godot_linkbutton 
  import py4godot.classes.HSplitContainer as py4godot_hsplitcontainer 
  import py4godot.classes.AspectRatioContainer as py4godot_aspectratiocontainer 
  import py4godot.classes.SpinBox as py4godot_spinbox 
  import py4godot.classes.FoldableContainer as py4godot_foldablecontainer 
  import py4godot.classes.HSeparator as py4godot_hseparator 
  import py4godot.classes.VScrollBar as py4godot_vscrollbar 
  import py4godot.classes.VSlider as py4godot_vslider 
  import py4godot.classes.EditorProperty as py4godot_editorproperty 
  import py4godot.classes.Button as py4godot_button 
  import py4godot.classes.ScriptEditor as py4godot_scripteditor 
  import py4godot.classes.EditorSpinSlider as py4godot_editorspinslider 
  import py4godot.classes.HSlider as py4godot_hslider 
  import py4godot.classes.SubViewportContainer as py4godot_subviewportcontainer 
  import py4godot.classes.TextureProgressBar as py4godot_textureprogressbar 
  import py4godot.classes.Panel as py4godot_panel 
  import py4godot.classes.ScrollBar as py4godot_scrollbar 
  import py4godot.classes.TabContainer as py4godot_tabcontainer 
  import py4godot.classes.LineEdit as py4godot_lineedit 
  import py4godot.classes.VSeparator as py4godot_vseparator 
  import py4godot.classes.FlowContainer as py4godot_flowcontainer 
import py4godot.classes.Control as py4godot_control 
from py4godot.wrappers.wrappers import CPPTreeWrapper

class SelectMode:
  SELECT_SINGLE = 0
  SELECT_ROW = 1
  SELECT_MULTI = 2
class DropModeFlags:
  DROP_MODE_DISABLED = 0
  DROP_MODE_ON_ITEM = 1
  DROP_MODE_INBETWEEN = 2


class Tree(py4godot_control.Control):
  r'''
		A control used to show a set of internal `TreeItem`s in a hierarchical structure. The tree items can be selected, expanded and collapsed. The tree can have multiple columns with custom controls like `LineEdit`s, buttons and popups. It can be useful for structured displays and interactions.
		Trees are built via code, using `TreeItem` objects to create the structure. They have a single root, but multiple roots can be simulated with `hide_root`:
		
		```gdscript
		func _ready():
			var tree = Tree.new()
			var root = tree.create_item()
			tree.hide_root = true
			var child1 = tree.create_item(root)
			var child2 = tree.create_item(root)
			var subchild1 = tree.create_item(child1)
			subchild1.set_text(0, "Subchild1")
		```
		
		
		To iterate over all the `TreeItem` objects in a `Tree` object, use `TreeItem.get_next` and `TreeItem.get_first_child` after getting the root through `get_root`. You can use `Object.free` on a `TreeItem` to remove it from the `Tree`.
		**Incremental search:** Like `ItemList` and `PopupMenu`, `Tree` supports searching within the list while the control is focused. Press a key that matches the first letter of an item's name to select the first item starting with the given letter. After that point, there are two ways to perform incremental search: 1) Press the same key again before the timeout duration to select the next item starting with the same letter. 2) Press letter keys that match the rest of the word before the timeout duration to match to select the item in question directly. Both of these actions will be reset to the beginning of the list if the timeout duration has passed since the last keystroke was registered. You can adjust the timeout duration by changing `ProjectSettings.gui/timers/incremental_search_max_interval_msec`.
	'''

  @staticmethod
  def constructor():
    class_ = Tree.construct_without_init()
    class_._ptr = constructor(849,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Tree.construct_without_init()
    class_._ptr = constructor(849,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTreeWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(849,0, ())


  def generate_wrapper(self):
    return CPPTreeWrapper()
  def init_signals(self):
    super().init_signals()
    item_selected_name = utils.py_string_to_string_name("item_selected")
    self.item_selected = signals.BuiltinSignal(self, item_selected_name)
    cell_selected_name = utils.py_string_to_string_name("cell_selected")
    self.cell_selected = signals.BuiltinSignal(self, cell_selected_name)
    multi_selected_name = utils.py_string_to_string_name("multi_selected")
    self.multi_selected = signals.BuiltinSignal(self, multi_selected_name)
    item_mouse_selected_name = utils.py_string_to_string_name("item_mouse_selected")
    self.item_mouse_selected = signals.BuiltinSignal(self, item_mouse_selected_name)
    empty_clicked_name = utils.py_string_to_string_name("empty_clicked")
    self.empty_clicked = signals.BuiltinSignal(self, empty_clicked_name)
    item_edited_name = utils.py_string_to_string_name("item_edited")
    self.item_edited = signals.BuiltinSignal(self, item_edited_name)
    custom_item_clicked_name = utils.py_string_to_string_name("custom_item_clicked")
    self.custom_item_clicked = signals.BuiltinSignal(self, custom_item_clicked_name)
    item_icon_double_clicked_name = utils.py_string_to_string_name("item_icon_double_clicked")
    self.item_icon_double_clicked = signals.BuiltinSignal(self, item_icon_double_clicked_name)
    item_collapsed_name = utils.py_string_to_string_name("item_collapsed")
    self.item_collapsed = signals.BuiltinSignal(self, item_collapsed_name)
    check_propagated_to_item_name = utils.py_string_to_string_name("check_propagated_to_item")
    self.check_propagated_to_item = signals.BuiltinSignal(self, check_propagated_to_item_name)
    button_clicked_name = utils.py_string_to_string_name("button_clicked")
    self.button_clicked = signals.BuiltinSignal(self, button_clicked_name)
    custom_popup_edited_name = utils.py_string_to_string_name("custom_popup_edited")
    self.custom_popup_edited = signals.BuiltinSignal(self, custom_popup_edited_name)
    item_activated_name = utils.py_string_to_string_name("item_activated")
    self.item_activated = signals.BuiltinSignal(self, item_activated_name)
    column_title_clicked_name = utils.py_string_to_string_name("column_title_clicked")
    self.column_title_clicked = signals.BuiltinSignal(self, column_title_clicked_name)
    nothing_selected_name = utils.py_string_to_string_name("nothing_selected")
    self.nothing_selected = signals.BuiltinSignal(self, nothing_selected_name)

  @staticmethod
  def construct_without_init():
    cls = Tree.__new__(Tree)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Tree'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Tree.construct_without_init()
    cls._ptr = CPPTreeWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Tree.construct_without_init()
    cls._ptr = CPPTreeWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def columns(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_columns()
    return _ret
  @columns.setter
  def columns(self,  value:'int'):
    self.set_columns(value)
  @property
  def column_titles_visible(self) -> typing.Union[bool]:
    r''''''
    _ret = self. are_column_titles_visible()
    return _ret
  @column_titles_visible.setter
  def column_titles_visible(self,  value:'bool'):
    self.set_column_titles_visible(value)
  @property
  def allow_reselect(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_allow_reselect()
    return _ret
  @allow_reselect.setter
  def allow_reselect(self,  value:'bool'):
    self.set_allow_reselect(value)
  @property
  def allow_rmb_select(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_allow_rmb_select()
    return _ret
  @allow_rmb_select.setter
  def allow_rmb_select(self,  value:'bool'):
    self.set_allow_rmb_select(value)
  @property
  def allow_search(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_allow_search()
    return _ret
  @allow_search.setter
  def allow_search(self,  value:'bool'):
    self.set_allow_search(value)
  @property
  def hide_folding(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_folding_hidden()
    return _ret
  @hide_folding.setter
  def hide_folding(self,  value:'bool'):
    self.set_hide_folding(value)
  @property
  def enable_recursive_folding(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_recursive_folding_enabled()
    return _ret
  @enable_recursive_folding.setter
  def enable_recursive_folding(self,  value:'bool'):
    self.set_enable_recursive_folding(value)
  @property
  def hide_root(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_root_hidden()
    return _ret
  @hide_root.setter
  def hide_root(self,  value:'bool'):
    self.set_hide_root(value)
  @property
  def drop_mode_flags(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_drop_mode_flags()
    return _ret
  @drop_mode_flags.setter
  def drop_mode_flags(self,  value:'int'):
    self.set_drop_mode_flags(value)
  @property
  def select_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_select_mode()
    return _ret
  @select_mode.setter
  def select_mode(self,  value:'int'):
    self.set_select_mode(value)
  @property
  def scroll_horizontal_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_h_scroll_enabled()
    return _ret
  @scroll_horizontal_enabled.setter
  def scroll_horizontal_enabled(self,  value:'bool'):
    self.set_h_scroll_enabled(value)
  @property
  def scroll_vertical_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_v_scroll_enabled()
    return _ret
  @scroll_vertical_enabled.setter
  def scroll_vertical_enabled(self,  value:'bool'):
    self.set_v_scroll_enabled(value)
  @property
  def auto_tooltip(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_auto_tooltip_enabled()
    return _ret
  @auto_tooltip.setter
  def auto_tooltip(self,  value:'bool'):
    self.set_auto_tooltip(value)
  @functools.native_method
  def clear(self) -> None:
    r'''
				Clears the tree. This removes all items.
			'''




    self._ptr.call_with_return(433,tuple([]))

  @functools.native_method
  def create_item(self, parent:'py4godot_treeitem.TreeItem' = None  , index:'int' =-1  ) -> typing.Union['py4godot_treeitem.TreeItem']:
    r'''
				Creates an item in the tree and adds it as a child of `parent`, which can be either a valid `TreeItem` or `null`.
				If `parent` is `null`, the root item will be the parent, or the new item will be the root itself if the tree is empty.
				The new item will be the `index`-th child of parent, or it will be the last child if there are not enough siblings.
			'''
    if parent is None:
      parent = c_utils.empty_object

    assert isinstance(index, (int, float)), 'index must be int or float'








    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TreeItem
    _ret._ptr = self._ptr.call_with_return(434,tuple([parent._ptr, index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_root(self) -> typing.Union['py4godot_treeitem.TreeItem']:
    r'''
				Returns the tree's root item, or `null` if the tree is empty.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TreeItem
    _ret._ptr = self._ptr.call_with_return(435,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_column_custom_minimum_width(self, column:'int'   , min_width:'int'   ) -> None:
    r'''
				Overrides the calculated minimum width of a column. It can be set to `0` to restore the default behavior. Columns that have the "Expand" flag will use their "min_width" in a similar fashion to `Control.size_flags_stretch_ratio`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(min_width, (int, float)), 'min_width must be int or float'








    self._ptr.call_with_return(436,tuple([column, min_width]))

  @functools.native_method
  def set_column_expand(self, column:'int'   , expand:'bool'   ) -> None:
    r'''
				If `true`, the column will have the "Expand" flag of `Control`. Columns that have the "Expand" flag will use their expand ratio in a similar fashion to `Control.size_flags_stretch_ratio` (see `set_column_expand_ratio`).
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(expand, bool), 'expand must be bool'








    self._ptr.call_with_return(437,tuple([column, expand]))

  @functools.native_method
  def set_column_expand_ratio(self, column:'int'   , ratio:'int'   ) -> None:
    r'''
				Sets the relative expand ratio for a column. See `set_column_expand`.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(ratio, (int, float)), 'ratio must be int or float'








    self._ptr.call_with_return(438,tuple([column, ratio]))

  @functools.native_method
  def set_column_clip_content(self, column:'int'   , enable:'bool'   ) -> None:
    r'''
				Allows to enable clipping for column's content, making the content size ignored.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(enable, bool), 'enable must be bool'








    self._ptr.call_with_return(439,tuple([column, enable]))

  @functools.native_method
  def is_column_expanding(self, column:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the column has enabled expanding (see `set_column_expand`).
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(440,tuple([column]))
    return _ret


  @functools.native_method
  def is_column_clipping_content(self, column:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the column has enabled clipping (see `set_column_clip_content`).
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(441,tuple([column]))
    return _ret


  @functools.native_method
  def get_column_expand_ratio(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the expand ratio assigned to the column.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(442,tuple([column]))
    return _ret


  @functools.native_method
  def get_column_width(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the column's width in pixels.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(443,tuple([column]))
    return _ret


  @functools.native_method
  def set_hide_root(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__hide_root = enable






    self._ptr.call_with_return(444,tuple([enable]))

  @functools.native_method
  def is_root_hidden(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(445,tuple([]))

    return _ret


  @functools.native_method
  def get_next_selected(self, from_:'py4godot_treeitem.TreeItem'   ) -> typing.Union['py4godot_treeitem.TreeItem']:
    r'''
				Returns the next selected `TreeItem` after the given one, or `null` if the end is reached.
				If `from` is `null`, this returns the first selected item.
			'''

    assert(not from_ is None)
    assert isinstance(from_, get_class('TreeItem')), 'from_ must be TreeItem'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TreeItem
    _ret._ptr = self._ptr.call_with_return(446,tuple([from_._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_selected(self) -> typing.Union['py4godot_treeitem.TreeItem']:
    r'''
				Returns the currently focused item, or `null` if no item is focused.
				In `constant SELECT_ROW` and `constant SELECT_SINGLE` modes, the focused item is same as the selected item. In `constant SELECT_MULTI` mode, the focused item is the item under the focus cursor, not necessarily selected.
				To get the currently selected item(s), use `get_next_selected`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TreeItem
    _ret._ptr = self._ptr.call_with_return(447,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_selected(self, item:'py4godot_treeitem.TreeItem'   , column:'int'   ) -> None:
    r'''
				Selects the specified `TreeItem` and column.
			'''

    assert(not item is None)
    assert isinstance(item, get_class('TreeItem')), 'item must be TreeItem'
    assert isinstance(column, (int, float)), 'column must be int or float'








    self._ptr.call_with_return(448,tuple([item._ptr, column]))

  @functools.native_method
  def get_selected_column(self) -> typing.Union[int]:
    r'''
				Returns the currently focused column, or -1 if no column is focused.
				In `constant SELECT_SINGLE` mode, the focused column is the selected column. In `constant SELECT_ROW` mode, the focused column is always 0 if any item is selected. In `constant SELECT_MULTI` mode, the focused column is the column under the focus cursor, and there are not necessarily any column selected.
				To tell whether a column of an item is selected, use `TreeItem.is_selected`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(449,tuple([]))
    return _ret


  @functools.native_method
  def get_pressed_button(self) -> typing.Union[int]:
    r'''
				Returns the last pressed button's index.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(450,tuple([]))
    return _ret


  @functools.native_method
  def set_select_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__select_mode = mode






    self._ptr.call_with_return(451,tuple([mode]))

  @functools.native_method
  def get_select_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(452,tuple([]))

    return _ret


  @functools.native_method
  def deselect_all(self) -> None:
    r'''
				Deselects all tree items (rows and columns). In `constant SELECT_MULTI` mode also removes selection cursor.
			'''




    self._ptr.call_with_return(453,tuple([]))

  @functools.native_method
  def set_columns(self, amount:'int'   ) -> None:
    r''''''

    assert isinstance(amount, (int, float)), 'amount must be int or float'


    self.py__columns = amount






    self._ptr.call_with_return(454,tuple([amount]))

  @functools.native_method
  def get_columns(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(455,tuple([]))

    return _ret


  @functools.native_method
  def get_edited(self) -> typing.Union['py4godot_treeitem.TreeItem']:
    r'''
				Returns the currently edited item. Can be used with `signal item_edited` to get the item that was modified.
				
				```gdscript
				func _ready():
					$Tree.item_edited.connect(on_Tree_item_edited)

				func on_Tree_item_edited():
					print($Tree.get_edited()) # This item just got edited (e.g. checked).
				```
				
				
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TreeItem
    _ret._ptr = self._ptr.call_with_return(456,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_edited_column(self) -> typing.Union[int]:
    r'''
				Returns the column for the currently edited item.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(457,tuple([]))
    return _ret


  @functools.native_method
  def edit_selected(self, force_edit:'bool' =False  ) -> typing.Union[bool]:
    r'''
				Edits the selected tree item as if it was clicked.
				Either the item must be set editable with `TreeItem.set_editable` or `force_edit` must be `true`.
				Returns `true` if the item could be edited. Fails if no item is selected.
			'''

    assert isinstance(force_edit, bool), 'force_edit must be bool'







    _ret = 0
    _ret = self._ptr.call_with_return(458,tuple([force_edit]))
    return _ret


  @functools.native_method
  def get_custom_popup_rect(self) -> typing.Union['Rect2']:
    r'''
				Returns the rectangle for custom popups. Helper to create custom cell controls that display a popup. See `TreeItem.set_cell_mode`.
			'''




    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(459,tuple([]))
    return _ret


  @functools.native_method
  def get_item_area_rect(self, item:'py4godot_treeitem.TreeItem'   , column:'int' =-1  , button_index:'int' =-1  ) -> typing.Union['Rect2']:
    r'''
				Returns the rectangle area for the specified `TreeItem`. If `column` is specified, only get the position and size of that column, otherwise get the rectangle containing all columns. If a button index is specified, the rectangle of that button will be returned.
			'''

    assert(not item is None)
    assert isinstance(item, get_class('TreeItem')), 'item must be TreeItem'
    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(button_index, (int, float)), 'button_index must be int or float'









    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(460,tuple([item._ptr, column, button_index]))
    return _ret


  @functools.native_method
  def get_item_at_position(self, position:'Vector2'   ) -> typing.Union['py4godot_treeitem.TreeItem']:
    r'''
				Returns the tree item at the specified position (relative to the tree origin position).
			'''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: TreeItem
    _ret._ptr = self._ptr.call_with_return(461,tuple([position._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_column_at_position(self, position:'Vector2'   ) -> typing.Union[int]:
    r'''
				Returns the column index at `position`, or -1 if no item is there.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(462,tuple([position._ptr]))
    return _ret


  @functools.native_method
  def get_drop_section_at_position(self, position:'Vector2'   ) -> typing.Union[int]:
    r'''
				Returns the drop section at `position`, or -100 if no item is there.
				Values -1, 0, or 1 will be returned for the "above item", "on item", and "below item" drop sections, respectively. See `enum DropModeFlags` for a description of each drop section.
				To get the item which the returned drop section is relative to, use `get_item_at_position`.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(463,tuple([position._ptr]))
    return _ret


  @functools.native_method
  def get_button_id_at_position(self, position:'Vector2'   ) -> typing.Union[int]:
    r'''
				Returns the button ID at `position`, or -1 if no button is there.
			'''

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(464,tuple([position._ptr]))
    return _ret


  @functools.native_method
  def ensure_cursor_is_visible(self) -> None:
    r'''
				Makes the currently focused cell visible.
				This will scroll the tree if necessary. In `constant SELECT_ROW` mode, this will not do horizontal scrolling, as all the cells in the selected row is focused logically.
				**Note:** Despite the name of this method, the focus cursor itself is only visible in `constant SELECT_MULTI` mode.
			'''




    self._ptr.call_with_return(465,tuple([]))

  @functools.native_method
  def set_column_titles_visible(self, visible:'bool'   ) -> None:
    r''''''

    assert isinstance(visible, bool), 'visible must be bool'


    self.py__column_titles_visible = visible






    self._ptr.call_with_return(466,tuple([visible]))

  @functools.native_method
  def are_column_titles_visible(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(467,tuple([]))

    return _ret


  @functools.native_method
  def set_column_title(self, column:'int'   , title:'str'   ) -> None:
    r'''
				Sets the title of a column.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not title is None)
    assert isinstance(title, (str, String)), 'title must be str or String'






    assert(isinstance(title, (str, String)))
    py_string_title = title if isinstance(title, StringName) else c_utils.py_string_to_string(title)

    self._ptr.call_with_return(468,tuple([column, py_string_title._ptr]))

  @functools.native_method
  def get_column_title(self, column:'int'   ) -> typing.Union[str]:
    r'''
				Returns the column's title.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(469,tuple([column]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_column_title_alignment(self, column:'int'   , title_alignment:'int'  ) -> None:
    r'''
				Sets the column title alignment. Note that `constant @GlobalScope.HORIZONTAL_ALIGNMENT_FILL` is not supported for column titles.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(title_alignment, (int, float)), 'title_alignment must be int or float'








    self._ptr.call_with_return(470,tuple([column, title_alignment]))

  @functools.native_method
  def get_column_title_alignment(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns the column title alignment.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(471,tuple([column]))
    return _ret


  @functools.native_method
  def set_column_title_direction(self, column:'int'   , direction:'int'  ) -> None:
    r'''
				Sets column title base writing direction.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert isinstance(direction, (int, float)), 'direction must be int or float'








    self._ptr.call_with_return(472,tuple([column, direction]))

  @functools.native_method
  def get_column_title_direction(self, column:'int'   ) -> typing.Union[int]:
    r'''
				Returns column title base writing direction.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(473,tuple([column]))
    return _ret


  @functools.native_method
  def set_column_title_language(self, column:'int'   , language:'str'   ) -> None:
    r'''
				Sets the language code of the given `column`'s title to `language`. This is used for line-breaking and text shaping algorithms. If `language` is empty, the current locale is used.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'
    assert(not language is None)
    assert isinstance(language, (str, String)), 'language must be str or String'






    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    self._ptr.call_with_return(474,tuple([column, py_string_language._ptr]))

  @functools.native_method
  def get_column_title_language(self, column:'int'   ) -> typing.Union[str]:
    r'''
				Returns column title language code.
			'''

    assert isinstance(column, (int, float)), 'column must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(475,tuple([column]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_scroll(self) -> typing.Union['Vector2']:
    r'''
				Returns the current scrolling position.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(476,tuple([]))
    return _ret


  @functools.native_method
  def scroll_to_item(self, item:'py4godot_treeitem.TreeItem'   , center_on_item:'bool' =False  ) -> None:
    r'''
				Causes the `Tree` to jump to the specified `TreeItem`.
			'''

    assert(not item is None)
    assert isinstance(item, get_class('TreeItem')), 'item must be TreeItem'
    assert isinstance(center_on_item, bool), 'center_on_item must be bool'








    self._ptr.call_with_return(477,tuple([item._ptr, center_on_item]))

  @functools.native_method
  def set_h_scroll_enabled(self, h_scroll:'bool'   ) -> None:
    r''''''

    assert isinstance(h_scroll, bool), 'h_scroll must be bool'


    self.py__scroll_horizontal_enabled = h_scroll






    self._ptr.call_with_return(478,tuple([h_scroll]))

  @functools.native_method
  def is_h_scroll_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(479,tuple([]))

    return _ret


  @functools.native_method
  def set_v_scroll_enabled(self, h_scroll:'bool'   ) -> None:
    r''''''

    assert isinstance(h_scroll, bool), 'h_scroll must be bool'


    self.py__scroll_vertical_enabled = h_scroll






    self._ptr.call_with_return(480,tuple([h_scroll]))

  @functools.native_method
  def is_v_scroll_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(481,tuple([]))

    return _ret


  @functools.native_method
  def set_hide_folding(self, hide:'bool'   ) -> None:
    r''''''

    assert isinstance(hide, bool), 'hide must be bool'


    self.py__hide_folding = hide






    self._ptr.call_with_return(482,tuple([hide]))

  @functools.native_method
  def is_folding_hidden(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(483,tuple([]))

    return _ret


  @functools.native_method
  def set_enable_recursive_folding(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__enable_recursive_folding = enable






    self._ptr.call_with_return(484,tuple([enable]))

  @functools.native_method
  def is_recursive_folding_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(485,tuple([]))

    return _ret


  @functools.native_method
  def set_drop_mode_flags(self, flags:'int'   ) -> None:
    r''''''

    assert isinstance(flags, (int, float)), 'flags must be int or float'


    self.py__drop_mode_flags = flags






    self._ptr.call_with_return(486,tuple([flags]))

  @functools.native_method
  def get_drop_mode_flags(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(487,tuple([]))

    return _ret


  @functools.native_method
  def set_allow_rmb_select(self, allow:'bool'   ) -> None:
    r''''''

    assert isinstance(allow, bool), 'allow must be bool'


    self.py__allow_rmb_select = allow






    self._ptr.call_with_return(488,tuple([allow]))

  @functools.native_method
  def get_allow_rmb_select(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(489,tuple([]))

    return _ret


  @functools.native_method
  def set_allow_reselect(self, allow:'bool'   ) -> None:
    r''''''

    assert isinstance(allow, bool), 'allow must be bool'


    self.py__allow_reselect = allow






    self._ptr.call_with_return(490,tuple([allow]))

  @functools.native_method
  def get_allow_reselect(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(491,tuple([]))

    return _ret


  @functools.native_method
  def set_allow_search(self, allow:'bool'   ) -> None:
    r''''''

    assert isinstance(allow, bool), 'allow must be bool'


    self.py__allow_search = allow






    self._ptr.call_with_return(492,tuple([allow]))

  @functools.native_method
  def get_allow_search(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(493,tuple([]))

    return _ret


  @functools.native_method
  def set_auto_tooltip(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__auto_tooltip = enable






    self._ptr.call_with_return(494,tuple([enable]))

  @functools.native_method
  def is_auto_tooltip_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(495,tuple([]))

    return _ret



register_cast_function('Tree', Tree.cast)
register_class('Tree', Tree)
