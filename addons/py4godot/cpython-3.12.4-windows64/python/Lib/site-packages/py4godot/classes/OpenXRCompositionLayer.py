# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Object as py4godot_object 
  import py4godot.classes.OpenXRCompositionLayerEquirect as py4godot_openxrcompositionlayerequirect 
  import py4godot.classes.JavaObject as py4godot_javaobject 
  import py4godot.classes.SubViewport as py4godot_subviewport 
  import py4godot.classes.OpenXRCompositionLayerQuad as py4godot_openxrcompositionlayerquad 
  import py4godot.classes.OpenXRCompositionLayerCylinder as py4godot_openxrcompositionlayercylinder 
import py4godot.classes.Node3D as py4godot_node3d 
from py4godot.wrappers.wrappers import CPPOpenXRCompositionLayerWrapper

class Filter:
  FILTER_NEAREST = 0
  FILTER_LINEAR = 1
  FILTER_CUBIC = 2
class MipmapMode:
  MIPMAP_MODE_DISABLED = 0
  MIPMAP_MODE_NEAREST = 1
  MIPMAP_MODE_LINEAR = 2
class Wrap:
  WRAP_CLAMP_TO_BORDER = 0
  WRAP_CLAMP_TO_EDGE = 1
  WRAP_REPEAT = 2
  WRAP_MIRRORED_REPEAT = 3
  WRAP_MIRROR_CLAMP_TO_EDGE = 4
class Swizzle:
  SWIZZLE_RED = 0
  SWIZZLE_GREEN = 1
  SWIZZLE_BLUE = 2
  SWIZZLE_ALPHA = 3
  SWIZZLE_ZERO = 4
  SWIZZLE_ONE = 5


class OpenXRCompositionLayer(py4godot_node3d.Node3D):
  r''''''

  @staticmethod
  def constructor():
    class_ = OpenXRCompositionLayer.construct_without_init()
    class_._ptr = constructor(539,0, ())
    return class_
  @staticmethod
  def new():
    class_ = OpenXRCompositionLayer.construct_without_init()
    class_._ptr = constructor(539,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPOpenXRCompositionLayerWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(539,0, ())


  def generate_wrapper(self):
    return CPPOpenXRCompositionLayerWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = OpenXRCompositionLayer.__new__(OpenXRCompositionLayer)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'OpenXRCompositionLayer'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = OpenXRCompositionLayer.construct_without_init()
    cls._ptr = CPPOpenXRCompositionLayerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = OpenXRCompositionLayer.construct_without_init()
    cls._ptr = CPPOpenXRCompositionLayerWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def layer_viewport(self) -> typing.Any:
    r''''''
    _ret = self. get_layer_viewport()
    return _ret
  @layer_viewport.setter
  def layer_viewport(self,  value:'py4godot_object.Object'):
    self.set_layer_viewport(value)
  @property
  def use_android_surface(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_use_android_surface()
    return _ret
  @use_android_surface.setter
  def use_android_surface(self,  value:'bool'):
    self.set_use_android_surface(value)
  @property
  def android_surface_size(self) -> typing.Union['Vector2i']:
    r''''''
    _ret = self. get_android_surface_size()
    return _ret
  @android_surface_size.setter
  def android_surface_size(self,  value:'Vector2i'):
    self.set_android_surface_size(value)
  @property
  def sort_order(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_sort_order()
    return _ret
  @sort_order.setter
  def sort_order(self,  value:'int'):
    self.set_sort_order(value)
  @property
  def alpha_blend(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_alpha_blend()
    return _ret
  @alpha_blend.setter
  def alpha_blend(self,  value:'bool'):
    self.set_alpha_blend(value)
  @property
  def enable_hole_punch(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_enable_hole_punch()
    return _ret
  @enable_hole_punch.setter
  def enable_hole_punch(self,  value:'bool'):
    self.set_enable_hole_punch(value)
  @property
  def swapchain_state_min_filter(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_min_filter()
    return _ret
  @swapchain_state_min_filter.setter
  def swapchain_state_min_filter(self,  value:'int'):
    self.set_min_filter(value)
  @property
  def swapchain_state_mag_filter(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_mag_filter()
    return _ret
  @swapchain_state_mag_filter.setter
  def swapchain_state_mag_filter(self,  value:'int'):
    self.set_mag_filter(value)
  @property
  def swapchain_state_mipmap_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_mipmap_mode()
    return _ret
  @swapchain_state_mipmap_mode.setter
  def swapchain_state_mipmap_mode(self,  value:'int'):
    self.set_mipmap_mode(value)
  @property
  def swapchain_state_horizontal_wrap(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_horizontal_wrap()
    return _ret
  @swapchain_state_horizontal_wrap.setter
  def swapchain_state_horizontal_wrap(self,  value:'int'):
    self.set_horizontal_wrap(value)
  @property
  def swapchain_state_vertical_wrap(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_vertical_wrap()
    return _ret
  @swapchain_state_vertical_wrap.setter
  def swapchain_state_vertical_wrap(self,  value:'int'):
    self.set_vertical_wrap(value)
  @property
  def swapchain_state_red_swizzle(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_red_swizzle()
    return _ret
  @swapchain_state_red_swizzle.setter
  def swapchain_state_red_swizzle(self,  value:'int'):
    self.set_red_swizzle(value)
  @property
  def swapchain_state_green_swizzle(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_green_swizzle()
    return _ret
  @swapchain_state_green_swizzle.setter
  def swapchain_state_green_swizzle(self,  value:'int'):
    self.set_green_swizzle(value)
  @property
  def swapchain_state_blue_swizzle(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_blue_swizzle()
    return _ret
  @swapchain_state_blue_swizzle.setter
  def swapchain_state_blue_swizzle(self,  value:'int'):
    self.set_blue_swizzle(value)
  @property
  def swapchain_state_alpha_swizzle(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_alpha_swizzle()
    return _ret
  @swapchain_state_alpha_swizzle.setter
  def swapchain_state_alpha_swizzle(self,  value:'int'):
    self.set_alpha_swizzle(value)
  @property
  def swapchain_state_max_anisotropy(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_max_anisotropy()
    return _ret
  @swapchain_state_max_anisotropy.setter
  def swapchain_state_max_anisotropy(self,  value:'float'):
    self.set_max_anisotropy(value)
  @property
  def swapchain_state_border_color(self) -> typing.Union['Color']:
    r''''''
    _ret = self. get_border_color()
    return _ret
  @swapchain_state_border_color.setter
  def swapchain_state_border_color(self,  value:'Color'):
    self.set_border_color(value)
  @functools.native_method
  def set_layer_viewport(self, viewport:'py4godot_subviewport.SubViewport'   ) -> None:
    r''''''

    assert(not viewport is None)
    assert isinstance(viewport, get_class('SubViewport')), 'viewport must be SubViewport'


    self.py__layer_viewport = viewport






    self._ptr.call_with_return(251,tuple([viewport._ptr]))

  @functools.native_method
  def get_layer_viewport(self) -> typing.Union['py4godot_subviewport.SubViewport']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: SubViewport
    _ret._ptr = self._ptr.call_with_return(252,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_use_android_surface(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__use_android_surface = enable






    self._ptr.call_with_return(253,tuple([enable]))

  @functools.native_method
  def get_use_android_surface(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(254,tuple([]))

    return _ret


  @functools.native_method
  def set_android_surface_size(self, size:'Vector2i'   ) -> None:
    r''''''

    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'


    self.py__android_surface_size = size






    self._ptr.call_with_return(255,tuple([size._ptr]))

  @functools.native_method
  def get_android_surface_size(self) -> typing.Union['Vector2i']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(256,tuple([]))

    return _ret


  @functools.native_method
  def set_enable_hole_punch(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__enable_hole_punch = enable






    self._ptr.call_with_return(257,tuple([enable]))

  @functools.native_method
  def get_enable_hole_punch(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(258,tuple([]))

    return _ret


  @functools.native_method
  def set_sort_order(self, order:'int'   ) -> None:
    r''''''

    assert isinstance(order, (int, float)), 'order must be int or float'


    self.py__sort_order = order






    self._ptr.call_with_return(259,tuple([order]))

  @functools.native_method
  def get_sort_order(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(260,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_blend(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__alpha_blend = enabled






    self._ptr.call_with_return(261,tuple([enabled]))

  @functools.native_method
  def get_alpha_blend(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(262,tuple([]))

    return _ret


  @functools.native_method
  def get_android_surface(self) -> typing.Union['py4godot_javaobject.JavaObject']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: JavaObject
    _ret._ptr = self._ptr.call_with_return(263,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def is_natively_supported(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(264,tuple([]))
    return _ret


  @functools.native_method
  def set_min_filter(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__swapchain_state_min_filter = mode






    self._ptr.call_with_return(265,tuple([mode]))

  @functools.native_method
  def get_min_filter(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(266,tuple([]))

    return _ret


  @functools.native_method
  def set_mag_filter(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__swapchain_state_mag_filter = mode






    self._ptr.call_with_return(267,tuple([mode]))

  @functools.native_method
  def get_mag_filter(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(268,tuple([]))

    return _ret


  @functools.native_method
  def set_mipmap_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__swapchain_state_mipmap_mode = mode






    self._ptr.call_with_return(269,tuple([mode]))

  @functools.native_method
  def get_mipmap_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(270,tuple([]))

    return _ret


  @functools.native_method
  def set_horizontal_wrap(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__swapchain_state_horizontal_wrap = mode






    self._ptr.call_with_return(271,tuple([mode]))

  @functools.native_method
  def get_horizontal_wrap(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(272,tuple([]))

    return _ret


  @functools.native_method
  def set_vertical_wrap(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__swapchain_state_vertical_wrap = mode






    self._ptr.call_with_return(273,tuple([mode]))

  @functools.native_method
  def get_vertical_wrap(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(274,tuple([]))

    return _ret


  @functools.native_method
  def set_red_swizzle(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__swapchain_state_red_swizzle = mode






    self._ptr.call_with_return(275,tuple([mode]))

  @functools.native_method
  def get_red_swizzle(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(276,tuple([]))

    return _ret


  @functools.native_method
  def set_green_swizzle(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__swapchain_state_green_swizzle = mode






    self._ptr.call_with_return(277,tuple([mode]))

  @functools.native_method
  def get_green_swizzle(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(278,tuple([]))

    return _ret


  @functools.native_method
  def set_blue_swizzle(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__swapchain_state_blue_swizzle = mode






    self._ptr.call_with_return(279,tuple([mode]))

  @functools.native_method
  def get_blue_swizzle(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(280,tuple([]))

    return _ret


  @functools.native_method
  def set_alpha_swizzle(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__swapchain_state_alpha_swizzle = mode






    self._ptr.call_with_return(281,tuple([mode]))

  @functools.native_method
  def get_alpha_swizzle(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(282,tuple([]))

    return _ret


  @functools.native_method
  def set_max_anisotropy(self, value:'float'   ) -> None:
    r''''''

    assert isinstance(value, (int, float)), 'value must be int or float'


    self.py__swapchain_state_max_anisotropy = value






    self._ptr.call_with_return(283,tuple([value]))

  @functools.native_method
  def get_max_anisotropy(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(284,tuple([]))

    return _ret


  @functools.native_method
  def set_border_color(self, color:'Color'   ) -> None:
    r''''''

    assert(not color is None)
    assert isinstance(color, Color), 'color must be Color'


    self.py__swapchain_state_border_color = color






    self._ptr.call_with_return(285,tuple([color._ptr]))

  @functools.native_method
  def get_border_color(self) -> typing.Union['Color']:
    r''''''




    _ret = Color.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(286,tuple([]))

    return _ret


  @functools.native_method
  def intersects_ray(self, origin:'Vector3'   , direction:'Vector3'   ) -> typing.Union['Vector2']:
    r''''''

    assert(not origin is None)
    assert isinstance(origin, Vector3), 'origin must be Vector3'
    assert(not direction is None)
    assert isinstance(direction, Vector3), 'direction must be Vector3'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(287,tuple([origin._ptr, direction._ptr]))
    return _ret



register_cast_function('OpenXRCompositionLayer', OpenXRCompositionLayer.cast)
register_class('OpenXRCompositionLayer', OpenXRCompositionLayer)
