# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Resource as py4godot_resource 
  import py4godot.classes.Node as py4godot_node 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPEditorScenePostImportPluginWrapper

class InternalImportCategory:
  INTERNAL_IMPORT_CATEGORY_NODE = 0
  INTERNAL_IMPORT_CATEGORY_MESH_3D_NODE = 1
  INTERNAL_IMPORT_CATEGORY_MESH = 2
  INTERNAL_IMPORT_CATEGORY_MATERIAL = 3
  INTERNAL_IMPORT_CATEGORY_ANIMATION = 4
  INTERNAL_IMPORT_CATEGORY_ANIMATION_NODE = 5
  INTERNAL_IMPORT_CATEGORY_SKELETON_3D_NODE = 6
  INTERNAL_IMPORT_CATEGORY_MAX = 7


class EditorScenePostImportPlugin(py4godot_refcounted.RefCounted):
  r'''
		This plugin type exists to modify the process of importing scenes, allowing to change the content as well as add importer options at every stage of the process.
	'''

  @staticmethod
  def constructor():
    class_ = EditorScenePostImportPlugin.construct_without_init()
    class_._ptr = constructor(308,0, ())
    return class_
  @staticmethod
  def new():
    class_ = EditorScenePostImportPlugin.construct_without_init()
    class_._ptr = constructor(308,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPEditorScenePostImportPluginWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(308,0, ())


  def generate_wrapper(self):
    return CPPEditorScenePostImportPluginWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = EditorScenePostImportPlugin.__new__(EditorScenePostImportPlugin)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'EditorScenePostImportPlugin'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(64, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorScenePostImportPlugin.construct_without_init()
    cls._ptr = CPPEditorScenePostImportPluginWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = EditorScenePostImportPlugin.construct_without_init()
    cls._ptr = CPPEditorScenePostImportPluginWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _get_internal_import_options(self, category:'int'   ) -> None:
    r'''
				Override to add internal import options. These will appear in the 3D scene import dialog. Add options via `add_import_option` and `add_import_option_advanced`.
			'''

    assert isinstance(category, (int, float)), 'category must be int or float'







    self._ptr.call_with_return(53,tuple([category]))

  @functools.native_method
  def _get_internal_option_visibility(self, category:'int'   , for_animation:'bool'   , option:'str'   ) -> typing.Union[typing.Any]:
    r'''
				Should return `true` to show the given option, `false` to hide the given option, or `null` to ignore.
			'''

    assert isinstance(category, (int, float)), 'category must be int or float'
    assert isinstance(for_animation, bool), 'for_animation must be bool'
    assert(not option is None)
    assert isinstance(option, (str, String)), 'option must be str or String'







    assert(isinstance(option, (str, String)))
    py_string_option = option if isinstance(option, StringName) else c_utils.py_string_to_string(option)

    _ret = None
    _ret = self._ptr.call_with_return(54,tuple([category, for_animation, py_string_option._ptr]))
    return _ret


  @functools.native_method
  def _get_internal_option_update_view_required(self, category:'int'   , option:'str'   ) -> typing.Union[typing.Any]:
    r'''
				Should return `true` if the 3D view of the import dialog needs to update when changing the given option.
			'''

    assert isinstance(category, (int, float)), 'category must be int or float'
    assert(not option is None)
    assert isinstance(option, (str, String)), 'option must be str or String'






    assert(isinstance(option, (str, String)))
    py_string_option = option if isinstance(option, StringName) else c_utils.py_string_to_string(option)

    _ret = None
    _ret = self._ptr.call_with_return(55,tuple([category, py_string_option._ptr]))
    return _ret


  @functools.native_method
  def _internal_process(self, category:'int'   , base_node:'py4godot_node.Node'   , node:'py4godot_node.Node'   , resource:'py4godot_resource.Resource'   ) -> None:
    r'''
				Process a specific node or resource for a given category.
			'''

    assert isinstance(category, (int, float)), 'category must be int or float'
    assert(not base_node is None)
    assert isinstance(base_node, get_class('Node')), 'base_node must be Node'
    assert(not node is None)
    assert isinstance(node, get_class('Node')), 'node must be Node'
    assert(not resource is None)
    assert isinstance(resource, get_class('Resource')), 'resource must be Resource'










    self._ptr.call_with_return(56,tuple([category, base_node._ptr, node._ptr, resource._ptr]))

  @functools.native_method
  def _get_import_options(self, path:'str'   ) -> None:
    r'''
				Override to add general import options. These will appear in the main import dock on the editor. Add options via `add_import_option` and `add_import_option_advanced`.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    self._ptr.call_with_return(57,tuple([py_string_path._ptr]))

  @functools.native_method
  def _get_option_visibility(self, path:'str'   , for_animation:'bool'   , option:'str'   ) -> typing.Union[typing.Any]:
    r'''
				Should return `true` to show the given option, `false` to hide the given option, or `null` to ignore.
			'''

    assert(not path is None)
    assert isinstance(path, (str, String)), 'path must be str or String'
    assert isinstance(for_animation, bool), 'for_animation must be bool'
    assert(not option is None)
    assert isinstance(option, (str, String)), 'option must be str or String'





    assert(isinstance(path, (str, String)))
    py_string_path = path if isinstance(path, StringName) else c_utils.py_string_to_string(path)

    assert(isinstance(option, (str, String)))
    py_string_option = option if isinstance(option, StringName) else c_utils.py_string_to_string(option)

    _ret = None
    _ret = self._ptr.call_with_return(58,tuple([py_string_path._ptr, for_animation, py_string_option._ptr]))
    return _ret


  @functools.native_method
  def _pre_process(self, scene:'py4godot_node.Node'   ) -> None:
    r'''
				Pre-process the scene. This function is called right after the scene format loader loaded the scene and no changes have been made.
				Pre-process may be used to adjust internal import options in the `"nodes"`, `"meshes"`, `"animations"` or `"materials"` keys inside `get_option_value("_subresources")`.
			'''

    assert(not scene is None)
    assert isinstance(scene, get_class('Node')), 'scene must be Node'







    self._ptr.call_with_return(59,tuple([scene._ptr]))

  @functools.native_method
  def _post_process(self, scene:'py4godot_node.Node'   ) -> None:
    r'''
				Post-process the scene. This function is called after the final scene has been configured.
			'''

    assert(not scene is None)
    assert isinstance(scene, get_class('Node')), 'scene must be Node'







    self._ptr.call_with_return(60,tuple([scene._ptr]))

  @functools.native_method
  def get_option_value(self, name:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Query the value of an option. This function can only be called from those querying visibility, or processing.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = None
    _ret = self._ptr.call_with_return(61,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def add_import_option(self, name:'str'   , value:'object'   ) -> None:
    r'''
				Add a specific import option (name and default value only). This function can only be called from `_get_import_options` and `_get_internal_import_options`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    self._ptr.call_with_return(62,tuple([py_string_name._ptr, value]))

  @functools.native_method
  def add_import_option_advanced(self, type:'int'  , name:'str'   , default_value:'object'   , hint:'int'  =0, hint_string:'str' =""  , usage_flags:'int' =6  ) -> None:
    r'''
				Add a specific import option. This function can only be called from `_get_import_options` and `_get_internal_import_options`.
			'''

    if hint_string is None:
      hint_string = String.new0()

    assert isinstance(type, (int, float)), 'type must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    
    assert isinstance(hint, (int, float)), 'hint must be int or float'
    assert isinstance(usage_flags, (int, float)), 'usage_flags must be int or float'

    if not (type(default_value).__name__ in py4godot.variant_types.core_types or isinstance(default_value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'default_value': "
                f"{type(default_value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    assert(isinstance(hint_string, (str, String)))
    py_string_hint_string = hint_string if isinstance(hint_string, StringName) else c_utils.py_string_to_string(hint_string)


    self._ptr.call_with_return(63,tuple([type, py_string_name._ptr, default_value, hint, py_string_hint_string._ptr, usage_flags]))


register_cast_function('EditorScenePostImportPlugin', EditorScenePostImportPlugin.cast)
register_class('EditorScenePostImportPlugin', EditorScenePostImportPlugin)
