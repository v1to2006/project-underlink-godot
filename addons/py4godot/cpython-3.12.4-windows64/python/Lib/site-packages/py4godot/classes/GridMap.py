# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PhysicsMaterial as py4godot_physicsmaterial 
  import py4godot.classes.Resource as py4godot_resource 
  import py4godot.classes.MeshLibrary as py4godot_meshlibrary 
  import py4godot.classes.Vector3iTypedArray as py4godot_vector3itypedarray 
import py4godot.classes.Node3D as py4godot_node3d 
import py4godot.classes.Vector3iTypedArray as py4godot_vector3itypedarray 
from py4godot.wrappers.wrappers import CPPGridMapWrapper


class GridMap(py4godot_node3d.Node3D):
  r''''''
  INVALID_CELL_ITEM:typing.ClassVar[int]

  @staticmethod
  def constructor():
    class_ = GridMap.construct_without_init()
    class_._ptr = constructor(387,0, ())
    return class_
  @staticmethod
  def new():
    class_ = GridMap.construct_without_init()
    class_._ptr = constructor(387,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPGridMapWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(387,0, ())


  def generate_wrapper(self):
    return CPPGridMapWrapper()
  def init_signals(self):
    super().init_signals()
    cell_size_changed_name = utils.py_string_to_string_name("cell_size_changed")
    self.cell_size_changed = signals.BuiltinSignal(self, cell_size_changed_name)
    changed_name = utils.py_string_to_string_name("changed")
    self.changed = signals.BuiltinSignal(self, changed_name)

  @staticmethod
  def construct_without_init():
    cls = GridMap.__new__(GridMap)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'GridMap'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = GridMap.construct_without_init()
    cls._ptr = CPPGridMapWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = GridMap.construct_without_init()
    cls._ptr = CPPGridMapWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def mesh_library(self) -> typing.Union['py4godot_meshlibrary.MeshLibrary']:
    r''''''
    _ret = self. get_mesh_library()
    return _ret
  @mesh_library.setter
  def mesh_library(self,  value:'py4godot_object.Object'):
    self.set_mesh_library(value)
  @property
  def physics_material(self) -> typing.Union['py4godot_physicsmaterial.PhysicsMaterial']:
    r''''''
    _ret = self. get_physics_material()
    return _ret
  @physics_material.setter
  def physics_material(self,  value:'py4godot_object.Object'):
    self.set_physics_material(value)
  @property
  def cell_size(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_cell_size()
    return _ret
  @cell_size.setter
  def cell_size(self,  value:'Vector3'):
    self.set_cell_size(value)
  @property
  def cell_octant_size(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_octant_size()
    return _ret
  @cell_octant_size.setter
  def cell_octant_size(self,  value:'int'):
    self.set_octant_size(value)
  @property
  def cell_center_x(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_center_x()
    return _ret
  @cell_center_x.setter
  def cell_center_x(self,  value:'bool'):
    self.set_center_x(value)
  @property
  def cell_center_y(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_center_y()
    return _ret
  @cell_center_y.setter
  def cell_center_y(self,  value:'bool'):
    self.set_center_y(value)
  @property
  def cell_center_z(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_center_z()
    return _ret
  @cell_center_z.setter
  def cell_center_z(self,  value:'bool'):
    self.set_center_z(value)
  @property
  def cell_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_cell_scale()
    return _ret
  @cell_scale.setter
  def cell_scale(self,  value:'float'):
    self.set_cell_scale(value)
  @property
  def collision_layer(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_collision_layer()
    return _ret
  @collision_layer.setter
  def collision_layer(self,  value:'int'):
    self.set_collision_layer(value)
  @property
  def collision_mask(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_collision_mask()
    return _ret
  @collision_mask.setter
  def collision_mask(self,  value:'int'):
    self.set_collision_mask(value)
  @property
  def collision_priority(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_collision_priority()
    return _ret
  @collision_priority.setter
  def collision_priority(self,  value:'float'):
    self.set_collision_priority(value)
  @property
  def bake_navigation(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_baking_navigation()
    return _ret
  @bake_navigation.setter
  def bake_navigation(self,  value:'bool'):
    self.set_bake_navigation(value)
  @functools.native_method
  def set_collision_layer(self, layer:'int'   ) -> None:
    r''''''

    assert isinstance(layer, (int, float)), 'layer must be int or float'


    self.py__collision_layer = layer






    self._ptr.call_with_return(251,tuple([layer]))

  @functools.native_method
  def get_collision_layer(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(252,tuple([]))

    return _ret


  @functools.native_method
  def set_collision_mask(self, mask:'int'   ) -> None:
    r''''''

    assert isinstance(mask, (int, float)), 'mask must be int or float'


    self.py__collision_mask = mask






    self._ptr.call_with_return(253,tuple([mask]))

  @functools.native_method
  def get_collision_mask(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(254,tuple([]))

    return _ret


  @functools.native_method
  def set_collision_mask_value(self, layer_number:'int'   , value:'bool'   ) -> None:
    r''''''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'








    self._ptr.call_with_return(255,tuple([layer_number, value]))

  @functools.native_method
  def get_collision_mask_value(self, layer_number:'int'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(256,tuple([layer_number]))
    return _ret


  @functools.native_method
  def set_collision_layer_value(self, layer_number:'int'   , value:'bool'   ) -> None:
    r''''''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'
    assert isinstance(value, bool), 'value must be bool'








    self._ptr.call_with_return(257,tuple([layer_number, value]))

  @functools.native_method
  def get_collision_layer_value(self, layer_number:'int'   ) -> typing.Union[bool]:
    r''''''

    assert isinstance(layer_number, (int, float)), 'layer_number must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(258,tuple([layer_number]))
    return _ret


  @functools.native_method
  def set_collision_priority(self, priority:'float'   ) -> None:
    r''''''

    assert isinstance(priority, (int, float)), 'priority must be int or float'


    self.py__collision_priority = priority






    self._ptr.call_with_return(259,tuple([priority]))

  @functools.native_method
  def get_collision_priority(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(260,tuple([]))

    return _ret


  @functools.native_method
  def set_physics_material(self, material:'py4godot_physicsmaterial.PhysicsMaterial'   ) -> None:
    r''''''

    assert(not material is None)
    assert isinstance(material, get_class('PhysicsMaterial')), 'material must be PhysicsMaterial'


    self.py__physics_material = material






    self._ptr.call_with_return(261,tuple([material._ptr]))

  @functools.native_method
  def get_physics_material(self) -> typing.Union['py4godot_physicsmaterial.PhysicsMaterial']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: PhysicsMaterial
    _ret._ptr = self._ptr.call_with_return(262,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_bake_navigation(self, bake_navigation:'bool'   ) -> None:
    r''''''

    assert isinstance(bake_navigation, bool), 'bake_navigation must be bool'


    self.py__bake_navigation = bake_navigation






    self._ptr.call_with_return(263,tuple([bake_navigation]))

  @functools.native_method
  def is_baking_navigation(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(264,tuple([]))

    return _ret


  @functools.native_method
  def set_navigation_map(self, navigation_map:'RID'   ) -> None:
    r''''''

    assert(not navigation_map is None)
    assert isinstance(navigation_map, RID), 'navigation_map must be RID'







    self._ptr.call_with_return(265,tuple([navigation_map._ptr]))

  @functools.native_method
  def get_navigation_map(self) -> typing.Union['RID']:
    r''''''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(266,tuple([]))
    return _ret


  @functools.native_method
  def set_mesh_library(self, mesh_library:'py4godot_meshlibrary.MeshLibrary'   ) -> None:
    r''''''

    assert(not mesh_library is None)
    assert isinstance(mesh_library, get_class('MeshLibrary')), 'mesh_library must be MeshLibrary'


    self.py__mesh_library = mesh_library






    self._ptr.call_with_return(267,tuple([mesh_library._ptr]))

  @functools.native_method
  def get_mesh_library(self) -> typing.Union['py4godot_meshlibrary.MeshLibrary']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: MeshLibrary
    _ret._ptr = self._ptr.call_with_return(268,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_cell_size(self, size:'Vector3'   ) -> None:
    r''''''

    assert(not size is None)
    assert isinstance(size, Vector3), 'size must be Vector3'


    self.py__cell_size = size






    self._ptr.call_with_return(269,tuple([size._ptr]))

  @functools.native_method
  def get_cell_size(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(270,tuple([]))

    return _ret


  @functools.native_method
  def set_cell_scale(self, scale:'float'   ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'


    self.py__cell_scale = scale






    self._ptr.call_with_return(271,tuple([scale]))

  @functools.native_method
  def get_cell_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(272,tuple([]))

    return _ret


  @functools.native_method
  def set_octant_size(self, size:'int'   ) -> None:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'


    self.py__cell_octant_size = size






    self._ptr.call_with_return(273,tuple([size]))

  @functools.native_method
  def get_octant_size(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(274,tuple([]))

    return _ret


  @functools.native_method
  def set_cell_item(self, position:'Vector3i'   , item:'int'   , orientation:'int' =0  ) -> None:
    r''''''

    assert(not position is None)
    assert isinstance(position, Vector3i), 'position must be Vector3i'
    assert isinstance(item, (int, float)), 'item must be int or float'
    assert isinstance(orientation, (int, float)), 'orientation must be int or float'









    self._ptr.call_with_return(275,tuple([position._ptr, item, orientation]))

  @functools.native_method
  def get_cell_item(self, position:'Vector3i'   ) -> typing.Union[int]:
    r''''''

    assert(not position is None)
    assert isinstance(position, Vector3i), 'position must be Vector3i'







    _ret = 0
    _ret = self._ptr.call_with_return(276,tuple([position._ptr]))
    return _ret


  @functools.native_method
  def get_cell_item_orientation(self, position:'Vector3i'   ) -> typing.Union[int]:
    r''''''

    assert(not position is None)
    assert isinstance(position, Vector3i), 'position must be Vector3i'







    _ret = 0
    _ret = self._ptr.call_with_return(277,tuple([position._ptr]))
    return _ret


  @functools.native_method
  def get_cell_item_basis(self, position:'Vector3i'   ) -> typing.Union['Basis']:
    r''''''

    assert(not position is None)
    assert isinstance(position, Vector3i), 'position must be Vector3i'







    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(278,tuple([position._ptr]))
    return _ret


  @functools.native_method
  def get_basis_with_orthogonal_index(self, index:'int'   ) -> typing.Union['Basis']:
    r''''''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = Basis.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(279,tuple([index]))
    return _ret


  @functools.native_method
  def get_orthogonal_index_from_basis(self, basis:'Basis'   ) -> typing.Union[int]:
    r''''''

    assert(not basis is None)
    assert isinstance(basis, Basis), 'basis must be Basis'







    _ret = 0
    _ret = self._ptr.call_with_return(280,tuple([basis._ptr]))
    return _ret


  @functools.native_method
  def local_to_map(self, local_position:'Vector3'   ) -> typing.Union['Vector3i']:
    r''''''

    assert(not local_position is None)
    assert isinstance(local_position, Vector3), 'local_position must be Vector3'







    _ret = Vector3i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(281,tuple([local_position._ptr]))
    return _ret


  @functools.native_method
  def map_to_local(self, map_position:'Vector3i'   ) -> typing.Union['Vector3']:
    r''''''

    assert(not map_position is None)
    assert isinstance(map_position, Vector3i), 'map_position must be Vector3i'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(282,tuple([map_position._ptr]))
    return _ret


  @functools.native_method
  def resource_changed(self, resource:'py4godot_resource.Resource'   ) -> None:
    r''''''

    assert(not resource is None)
    assert isinstance(resource, get_class('Resource')), 'resource must be Resource'







    self._ptr.call_with_return(283,tuple([resource._ptr]))

  @functools.native_method
  def set_center_x(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__cell_center_x = enable






    self._ptr.call_with_return(284,tuple([enable]))

  @functools.native_method
  def get_center_x(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(285,tuple([]))

    return _ret


  @functools.native_method
  def set_center_y(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__cell_center_y = enable






    self._ptr.call_with_return(286,tuple([enable]))

  @functools.native_method
  def get_center_y(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(287,tuple([]))

    return _ret


  @functools.native_method
  def set_center_z(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__cell_center_z = enable






    self._ptr.call_with_return(288,tuple([enable]))

  @functools.native_method
  def get_center_z(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(289,tuple([]))

    return _ret


  @functools.native_method
  def clear(self) -> None:
    r''''''




    self._ptr.call_with_return(290,tuple([]))

  @functools.native_method
  def get_used_cells(self) -> typing.Union['py4godot_vector3itypedarray.Vector3iTypedArray']:
    r''''''




    _ret = py4godot_vector3itypedarray.Vector3iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(291,tuple([]))
    return _ret


  @functools.native_method
  def get_used_cells_by_item(self, item:'int'   ) -> typing.Union['py4godot_vector3itypedarray.Vector3iTypedArray']:
    r''''''

    assert isinstance(item, (int, float)), 'item must be int or float'







    _ret = py4godot_vector3itypedarray.Vector3iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(292,tuple([item]))
    return _ret


  @functools.native_method
  def get_meshes(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(293,tuple([]))
    return _ret


  @functools.native_method
  def get_bake_meshes(self) -> typing.Union['Array']:
    r''''''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(294,tuple([]))
    return _ret


  @functools.native_method
  def get_bake_mesh_instance(self, idx:'int'   ) -> typing.Union['RID']:
    r''''''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(295,tuple([idx]))
    return _ret


  @functools.native_method
  def clear_baked_meshes(self) -> None:
    r''''''




    self._ptr.call_with_return(296,tuple([]))

  @functools.native_method
  def make_baked_meshes(self, gen_lightmap_uv:'bool' =False  , lightmap_uv_texel_size:'float' =0.1  ) -> None:
    r''''''

    assert isinstance(gen_lightmap_uv, bool), 'gen_lightmap_uv must be bool'
    assert isinstance(lightmap_uv_texel_size, (int, float)), 'lightmap_uv_texel_size must be int or float'








    self._ptr.call_with_return(297,tuple([gen_lightmap_uv, lightmap_uv_texel_size]))


register_cast_function('GridMap', GridMap.cast)
register_class('GridMap', GridMap)
