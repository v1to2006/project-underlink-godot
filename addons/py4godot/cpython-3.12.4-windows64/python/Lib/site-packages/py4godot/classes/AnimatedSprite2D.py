# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.SpriteFrames as py4godot_spriteframes 
import py4godot.classes.Node2D as py4godot_node2d 
from py4godot.wrappers.wrappers import CPPAnimatedSprite2DWrapper


class AnimatedSprite2D(py4godot_node2d.Node2D):
  r'''
		`AnimatedSprite2D` is similar to the `Sprite2D` node, except it carries multiple textures as animation frames. Animations are created using a `SpriteFrames` resource, which allows you to import image files (or a folder containing said files) to provide the animation frames for the sprite. The `SpriteFrames` resource can be configured in the editor via the SpriteFrames bottom panel.
	'''

  @staticmethod
  def constructor():
    class_ = AnimatedSprite2D.construct_without_init()
    class_._ptr = constructor(69,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AnimatedSprite2D.construct_without_init()
    class_._ptr = constructor(69,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAnimatedSprite2DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(69,0, ())


  def generate_wrapper(self):
    return CPPAnimatedSprite2DWrapper()
  def init_signals(self):
    super().init_signals()
    sprite_frames_changed_name = utils.py_string_to_string_name("sprite_frames_changed")
    self.sprite_frames_changed = signals.BuiltinSignal(self, sprite_frames_changed_name)
    animation_changed_name = utils.py_string_to_string_name("animation_changed")
    self.animation_changed = signals.BuiltinSignal(self, animation_changed_name)
    frame_changed_name = utils.py_string_to_string_name("frame_changed")
    self.frame_changed = signals.BuiltinSignal(self, frame_changed_name)
    animation_looped_name = utils.py_string_to_string_name("animation_looped")
    self.animation_looped = signals.BuiltinSignal(self, animation_looped_name)
    animation_finished_name = utils.py_string_to_string_name("animation_finished")
    self.animation_finished = signals.BuiltinSignal(self, animation_finished_name)

  @staticmethod
  def construct_without_init():
    cls = AnimatedSprite2D.__new__(AnimatedSprite2D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AnimatedSprite2D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimatedSprite2D.construct_without_init()
    cls._ptr = CPPAnimatedSprite2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimatedSprite2D.construct_without_init()
    cls._ptr = CPPAnimatedSprite2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def sprite_frames(self) -> typing.Union['py4godot_spriteframes.SpriteFrames']:
    r''''''
    _ret = self. get_sprite_frames()
    return _ret
  @sprite_frames.setter
  def sprite_frames(self,  value:'py4godot_object.Object'):
    self.set_sprite_frames(value)
  @property
  def animation(self) -> typing.Union['StringName']:
    r''''''
    _ret = self. get_animation()
    return _ret
  @animation.setter
  def animation(self,  value:'object'):
    self.set_animation(value)
  @property
  def autoplay(self) -> typing.Union['StringName']:
    r''''''
    _ret = self. get_autoplay()
    return _ret
  @autoplay.setter
  def autoplay(self,  value:'object'):
    self.set_autoplay(value)
  @property
  def frame(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_frame()
    return _ret
  @frame.setter
  def frame(self,  value:'int'):
    self.set_frame(value)
  @property
  def frame_progress(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_frame_progress()
    return _ret
  @frame_progress.setter
  def frame_progress(self,  value:'float'):
    self.set_frame_progress(value)
  @property
  def speed_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_speed_scale()
    return _ret
  @speed_scale.setter
  def speed_scale(self,  value:'float'):
    self.set_speed_scale(value)
  @property
  def centered(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_centered()
    return _ret
  @centered.setter
  def centered(self,  value:'bool'):
    self.set_centered(value)
  @property
  def offset(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_offset()
    return _ret
  @offset.setter
  def offset(self,  value:'Vector2'):
    self.set_offset(value)
  @property
  def flip_h(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_flipped_h()
    return _ret
  @flip_h.setter
  def flip_h(self,  value:'bool'):
    self.set_flip_h(value)
  @property
  def flip_v(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_flipped_v()
    return _ret
  @flip_v.setter
  def flip_v(self,  value:'bool'):
    self.set_flip_v(value)
  @functools.native_method
  def set_sprite_frames(self, sprite_frames:'py4godot_spriteframes.SpriteFrames'   ) -> None:
    r''''''

    assert(not sprite_frames is None)
    assert isinstance(sprite_frames, get_class('SpriteFrames')), 'sprite_frames must be SpriteFrames'


    self.py__sprite_frames = sprite_frames






    self._ptr.call_with_return(303,tuple([sprite_frames._ptr]))

  @functools.native_method
  def get_sprite_frames(self) -> typing.Union['py4godot_spriteframes.SpriteFrames']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: SpriteFrames
    _ret._ptr = self._ptr.call_with_return(304,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_animation(self, name:'object'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'


    self.py__animation = name



    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(305,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def get_animation(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(306,tuple([]))

    return str(_ret)


  @functools.native_method
  def set_autoplay(self, name:'str'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'


    self.py__autoplay = name



    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    py__string_name = utils.py_string_to_string(name)
    py__string_name.shouldBeDeleted = False


    self._ptr.call_with_return(307,tuple([py__string_name._ptr]))

  @functools.native_method
  def get_autoplay(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(308,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def is_playing(self) -> typing.Union[bool]:
    r'''
				Returns `true` if an animation is currently playing (even if `speed_scale` and/or `custom_speed` are `0`).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(309,tuple([]))
    return _ret


  @functools.native_method
  def play(self, name:'object' = None  , custom_speed:'float' =1.0  , from_end:'bool' =False  ) -> None:
    r'''
				Plays the animation with key `name`. If `custom_speed` is negative and `from_end` is `true`, the animation will play backwards (which is equivalent to calling `play_backwards`).
				If this method is called with that same animation `name`, or with no `name` parameter, the assigned animation will resume playing if it was paused.
			'''
    if name is None:
      name = StringName.new0()

    assert isinstance(custom_speed, (int, float)), 'custom_speed must be int or float'
    assert isinstance(from_end, bool), 'from_end must be bool'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)



    self._ptr.call_with_return(310,tuple([py_stringname_name._ptr, custom_speed, from_end]))

  @functools.native_method
  def play_backwards(self, name:'object' = None  ) -> None:
    r'''
				Plays the animation with key `name` in reverse.
				This method is a shorthand for `play` with `custom_speed = -1.0` and `from_end = true`, so see its description for more information.
			'''
    if name is None:
      name = StringName.new0()






    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    self._ptr.call_with_return(311,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def pause(self) -> None:
    r'''
				Pauses the currently playing animation. The `frame` and `frame_progress` will be kept and calling `play` or `play_backwards` without arguments will resume the animation from the current playback position.
				See also `stop`.
			'''




    self._ptr.call_with_return(312,tuple([]))

  @functools.native_method
  def stop(self) -> None:
    r'''
				Stops the currently playing animation. The animation position is reset to `0` and the `custom_speed` is reset to `1.0`. See also `pause`.
			'''




    self._ptr.call_with_return(313,tuple([]))

  @functools.native_method
  def set_centered(self, centered:'bool'   ) -> None:
    r''''''

    assert isinstance(centered, bool), 'centered must be bool'


    self.py__centered = centered






    self._ptr.call_with_return(314,tuple([centered]))

  @functools.native_method
  def is_centered(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(315,tuple([]))

    return _ret


  @functools.native_method
  def set_offset(self, offset:'Vector2'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'


    self.py__offset = offset






    self._ptr.call_with_return(316,tuple([offset._ptr]))

  @functools.native_method
  def get_offset(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(317,tuple([]))

    return _ret


  @functools.native_method
  def set_flip_h(self, flip_h:'bool'   ) -> None:
    r''''''

    assert isinstance(flip_h, bool), 'flip_h must be bool'


    self.py__flip_h = flip_h






    self._ptr.call_with_return(318,tuple([flip_h]))

  @functools.native_method
  def is_flipped_h(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(319,tuple([]))

    return _ret


  @functools.native_method
  def set_flip_v(self, flip_v:'bool'   ) -> None:
    r''''''

    assert isinstance(flip_v, bool), 'flip_v must be bool'


    self.py__flip_v = flip_v






    self._ptr.call_with_return(320,tuple([flip_v]))

  @functools.native_method
  def is_flipped_v(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(321,tuple([]))

    return _ret


  @functools.native_method
  def set_frame(self, frame:'int'   ) -> None:
    r''''''

    assert isinstance(frame, (int, float)), 'frame must be int or float'


    self.py__frame = frame






    self._ptr.call_with_return(322,tuple([frame]))

  @functools.native_method
  def get_frame(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(323,tuple([]))

    return _ret


  @functools.native_method
  def set_frame_progress(self, progress:'float'   ) -> None:
    r''''''

    assert isinstance(progress, (int, float)), 'progress must be int or float'


    self.py__frame_progress = progress






    self._ptr.call_with_return(324,tuple([progress]))

  @functools.native_method
  def get_frame_progress(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(325,tuple([]))

    return _ret


  @functools.native_method
  def set_frame_and_progress(self, frame:'int'   , progress:'float'   ) -> None:
    r'''
				Sets `frame` and `frame_progress` to the given values. Unlike setting `frame`, this method does not reset the `frame_progress` to `0.0` implicitly.
				**Example:** Change the animation while keeping the same `frame` and `frame_progress`:
				
				```gdscript
				var current_frame = animated_sprite.get_frame()
				var current_progress = animated_sprite.get_frame_progress()
				animated_sprite.play("walk_another_skin")
				animated_sprite.set_frame_and_progress(current_frame, current_progress)
				```
				
			'''

    assert isinstance(frame, (int, float)), 'frame must be int or float'
    assert isinstance(progress, (int, float)), 'progress must be int or float'








    self._ptr.call_with_return(326,tuple([frame, progress]))

  @functools.native_method
  def set_speed_scale(self, speed_scale:'float'   ) -> None:
    r''''''

    assert isinstance(speed_scale, (int, float)), 'speed_scale must be int or float'


    self.py__speed_scale = speed_scale






    self._ptr.call_with_return(327,tuple([speed_scale]))

  @functools.native_method
  def get_speed_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(328,tuple([]))

    return _ret


  @functools.native_method
  def get_playing_speed(self) -> typing.Union[float]:
    r'''
				Returns the actual playing speed of current animation or `0` if not playing. This speed is the `speed_scale` property multiplied by `custom_speed` argument specified when calling the `play` method.
				Returns a negative value if the current animation is playing backwards.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(329,tuple([]))
    return _ret



register_cast_function('AnimatedSprite2D', AnimatedSprite2D.cast)
register_class('AnimatedSprite2D', AnimatedSprite2D)
