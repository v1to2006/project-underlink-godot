# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Object as py4godot_object 
from py4godot.wrappers.wrappers import CPPJSONRPCWrapper

class ErrorCode:
  PARSE_ERROR = -32700
  INVALID_REQUEST = -32600
  METHOD_NOT_FOUND = -32601
  INVALID_PARAMS = -32602
  INTERNAL_ERROR = -32603


class JSONRPC(py4godot_object.Object):
  r'''
		`url=https://www.jsonrpc.org/`JSON-RPC`/url` is a standard which wraps a method call in a `JSON` object. The object has a particular structure and identifies which method is called, the parameters to that function, and carries an ID to keep track of responses. This class implements that standard on top of `Dictionary`; you will have to convert between a `Dictionary` and `JSON` with other functions.
	'''

  @staticmethod
  def constructor():
    class_ = JSONRPC.construct_without_init()
    class_._ptr = constructor(436,0, ())
    return class_
  @staticmethod
  def new():
    class_ = JSONRPC.construct_without_init()
    class_._ptr = constructor(436,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPJSONRPCWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(436,0, ())


  def generate_wrapper(self):
    return CPPJSONRPCWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = JSONRPC.__new__(JSONRPC)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'JSONRPC'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = JSONRPC.construct_without_init()
    cls._ptr = CPPJSONRPCWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = JSONRPC.construct_without_init()
    cls._ptr = CPPJSONRPCWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def set_method(self, name:'str'   , callback:'Callable'   ) -> None:
    r'''
				Registers a callback for the given method name.
				- `name`: The name that clients can use to access the callback.
				- `callback`: The callback which will handle the specified method.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'
    assert(not callback is None)
    assert isinstance(callback, Callable), 'callback must be Callable'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)


    self._ptr.call_with_return(49,tuple([py_string_name._ptr, callback._ptr]))

  @functools.native_method
  def process_action(self, action:'object'   , recurse:'bool' =False  ) -> typing.Union[typing.Any]:
    r'''
				Given a Dictionary which takes the form of a JSON-RPC request: unpack the request and run it. Methods are resolved by looking at the field called "method" and looking for an equivalently named function in the JSONRPC object. If one is found that method is called.
				To add new supported methods extend the JSONRPC class and call `process_action` on your subclass.
				`action`: The action to be run, as a Dictionary in the form of a JSON-RPC request or notification.
			'''

    
    assert isinstance(recurse, bool), 'recurse must be bool'

    if not (type(action).__name__ in py4godot.variant_types.core_types or isinstance(action, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'action': "
                f"{type(action).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = None
    _ret = self._ptr.call_with_return(50,tuple([action, recurse]))
    return _ret


  @functools.native_method
  def process_string(self, action:'str'   ) -> typing.Union[str]:
    r'''
'''

    assert(not action is None)
    assert isinstance(action, (str, String)), 'action must be str or String'





    assert(isinstance(action, (str, String)))
    py_string_action = action if isinstance(action, StringName) else c_utils.py_string_to_string(action)

    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(51,tuple([py_string_action._ptr]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def make_request(self, method:'str'   , params:'object'   , id:'object'   ) -> typing.Union['Dictionary']:
    r'''
				Returns a dictionary in the form of a JSON-RPC request. Requests are sent to a server with the expectation of a response. The ID field is used for the server to specify which exact request it is responding to.
				- `method`: Name of the method being called.
				- `params`: An array or dictionary of parameters being passed to the method.
				- `id`: Uniquely identifies this request. The server is expected to send a response with the same ID.
			'''

    assert(not method is None)
    assert isinstance(method, (str, String)), 'method must be str or String'
    
    

    if not (type(params).__name__ in py4godot.variant_types.core_types or isinstance(params, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'params': "
                f"{type(params).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )
    if not (type(id).__name__ in py4godot.variant_types.core_types or isinstance(id, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'id': "
                f"{type(id).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(method, (str, String)))
    py_string_method = method if isinstance(method, StringName) else c_utils.py_string_to_string(method)



    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(52,tuple([py_string_method._ptr, params, id]))
    return _ret


  @functools.native_method
  def make_response(self, result:'object'   , id:'object'   ) -> typing.Union['Dictionary']:
    r'''
				When a server has received and processed a request, it is expected to send a response. If you did not want a response then you need to have sent a Notification instead.
				- `result`: The return value of the function which was called.
				- `id`: The ID of the request this response is targeted to.
			'''

    
    

    if not (type(result).__name__ in py4godot.variant_types.core_types or isinstance(result, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'result': "
                f"{type(result).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )
    if not (type(id).__name__ in py4godot.variant_types.core_types or isinstance(id, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'id': "
                f"{type(id).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([result, id]))
    return _ret


  @functools.native_method
  def make_notification(self, method:'str'   , params:'object'   ) -> typing.Union['Dictionary']:
    r'''
				Returns a dictionary in the form of a JSON-RPC notification. Notifications are one-shot messages which do not expect a response.
				- `method`: Name of the method being called.
				- `params`: An array or dictionary of parameters being passed to the method.
			'''

    assert(not method is None)
    assert isinstance(method, (str, String)), 'method must be str or String'
    

    if not (type(params).__name__ in py4godot.variant_types.core_types or isinstance(params, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'params': "
                f"{type(params).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(method, (str, String)))
    py_string_method = method if isinstance(method, StringName) else c_utils.py_string_to_string(method)


    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(54,tuple([py_string_method._ptr, params]))
    return _ret


  @functools.native_method
  def make_response_error(self, code:'int'   , message:'str'   , id:'object' =None  ) -> typing.Union['Dictionary']:
    r'''
				Creates a response which indicates a previous reply has failed in some way.
				- `code`: The error code corresponding to what kind of error this is. See the `enum ErrorCode` constants.
				- `message`: A custom message about this error.
				- `id`: The request this error is a response to.
			'''


    assert isinstance(code, (int, float)), 'code must be int or float'
    assert(not message is None)
    assert isinstance(message, (str, String)), 'message must be str or String'
    

    if not (type(id).__name__ in py4godot.variant_types.core_types or isinstance(id, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'id': "
                f"{type(id).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(message, (str, String)))
    py_string_message = message if isinstance(message, StringName) else c_utils.py_string_to_string(message)


    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(55,tuple([code, py_string_message._ptr, id]))
    return _ret



register_cast_function('JSONRPC', JSONRPC.cast)
register_class('JSONRPC', JSONRPC)
