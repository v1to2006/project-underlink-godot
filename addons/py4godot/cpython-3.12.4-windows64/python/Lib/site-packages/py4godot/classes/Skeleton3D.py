# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Skin as py4godot_skin 
  import py4godot.classes.SkinReference as py4godot_skinreference 
  import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
import py4godot.classes.StringNameTypedArray as py4godot_stringnametypedarray 
import py4godot.classes.Node3D as py4godot_node3d 
from py4godot.wrappers.wrappers import CPPSkeleton3DWrapper

class ModifierCallbackModeProcess:
  MODIFIER_CALLBACK_MODE_PROCESS_PHYSICS = 0
  MODIFIER_CALLBACK_MODE_PROCESS_IDLE = 1
  MODIFIER_CALLBACK_MODE_PROCESS_MANUAL = 2


class Skeleton3D(py4godot_node3d.Node3D):
  r'''
		`Skeleton3D` provides an interface for managing a hierarchy of bones, including pose, rest and animation (see `Animation`). It can also use ragdoll physics.
		The overall transform of a bone with respect to the skeleton is determined by bone pose. Bone rest defines the initial transform of the bone pose.
		Note that "global pose" below refers to the overall transform of the bone with respect to skeleton, so it is not the actual global/world transform of the bone.
	'''
  NOTIFICATION_UPDATE_SKELETON:typing.ClassVar[int]

  @staticmethod
  def constructor():
    class_ = Skeleton3D.construct_without_init()
    class_._ptr = constructor(747,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Skeleton3D.construct_without_init()
    class_._ptr = constructor(747,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPSkeleton3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(747,0, ())


  def generate_wrapper(self):
    return CPPSkeleton3DWrapper()
  def init_signals(self):
    super().init_signals()
    rest_updated_name = utils.py_string_to_string_name("rest_updated")
    self.rest_updated = signals.BuiltinSignal(self, rest_updated_name)
    pose_updated_name = utils.py_string_to_string_name("pose_updated")
    self.pose_updated = signals.BuiltinSignal(self, pose_updated_name)
    skeleton_updated_name = utils.py_string_to_string_name("skeleton_updated")
    self.skeleton_updated = signals.BuiltinSignal(self, skeleton_updated_name)
    bone_enabled_changed_name = utils.py_string_to_string_name("bone_enabled_changed")
    self.bone_enabled_changed = signals.BuiltinSignal(self, bone_enabled_changed_name)
    bone_list_changed_name = utils.py_string_to_string_name("bone_list_changed")
    self.bone_list_changed = signals.BuiltinSignal(self, bone_list_changed_name)
    show_rest_only_changed_name = utils.py_string_to_string_name("show_rest_only_changed")
    self.show_rest_only_changed = signals.BuiltinSignal(self, show_rest_only_changed_name)

  @staticmethod
  def construct_without_init():
    cls = Skeleton3D.__new__(Skeleton3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Skeleton3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Skeleton3D.construct_without_init()
    cls._ptr = CPPSkeleton3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Skeleton3D.construct_without_init()
    cls._ptr = CPPSkeleton3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def motion_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_motion_scale()
    return _ret
  @motion_scale.setter
  def motion_scale(self,  value:'float'):
    self.set_motion_scale(value)
  @property
  def show_rest_only(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_show_rest_only()
    return _ret
  @show_rest_only.setter
  def show_rest_only(self,  value:'bool'):
    self.set_show_rest_only(value)
  @property
  def modifier_callback_mode_process(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_modifier_callback_mode_process()
    return _ret
  @modifier_callback_mode_process.setter
  def modifier_callback_mode_process(self,  value:'int'):
    self.set_modifier_callback_mode_process(value)
  @property
  def animate_physical_bones(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_animate_physical_bones()
    return _ret
  @animate_physical_bones.setter
  def animate_physical_bones(self,  value:'bool'):
    self.set_animate_physical_bones(value)
  @functools.native_method
  def add_bone(self, name:'str'   ) -> typing.Union[int]:
    r'''
				Adds a new bone with the given name. Returns the new bone's index, or `-1` if this method fails.
				**Note:** Bone names should be unique, non empty, and cannot include the `:` and `/` characters.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(251,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def find_bone(self, name:'str'   ) -> typing.Union[int]:
    r'''
				Returns the bone index that matches `name` as its name. Returns `-1` if no bone with this name exists.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(252,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def get_bone_name(self, bone_idx:'int'   ) -> typing.Union[str]:
    r'''
				Returns the name of the bone at index `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(253,tuple([bone_idx]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_bone_name(self, bone_idx:'int'   , name:'str'   ) -> None:
    r'''
				Sets the bone name, `name`, for the bone at `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    self._ptr.call_with_return(254,tuple([bone_idx, py_string_name._ptr]))

  @functools.native_method
  def get_bone_meta(self, bone_idx:'int'   , key:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Returns the metadata with the given `key` for the bone at index `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'
    assert(not key is None)
    assert isinstance(key, (str, StringName)), 'key must be str or StringName'






    assert(isinstance(key, (str, StringName)))
    py_stringname_key = key if isinstance(key, StringName) else c_utils.py_string_to_string_name(key)

    _ret = None
    _ret = self._ptr.call_with_return(255,tuple([bone_idx, py_stringname_key._ptr]))
    return _ret


  @functools.native_method
  def get_bone_meta_list(self, bone_idx:'int'   ) -> typing.Union['py4godot_stringnametypedarray.StringNameTypedArray']:
    r'''
				Returns the list of all metadata keys for the bone at index `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    _ret = py4godot_stringnametypedarray.StringNameTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(256,tuple([bone_idx]))
    return _ret


  @functools.native_method
  def has_bone_meta(self, bone_idx:'int'   , key:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the bone at index `bone_idx` has metadata with the given `key`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'
    assert(not key is None)
    assert isinstance(key, (str, StringName)), 'key must be str or StringName'






    assert(isinstance(key, (str, StringName)))
    py_stringname_key = key if isinstance(key, StringName) else c_utils.py_string_to_string_name(key)

    _ret = 0
    _ret = self._ptr.call_with_return(257,tuple([bone_idx, py_stringname_key._ptr]))
    return _ret


  @functools.native_method
  def set_bone_meta(self, bone_idx:'int'   , key:'object'   , value:'object'   ) -> None:
    r'''
				Sets the metadata with the given `key` to `value` for the bone at index `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'
    assert(not key is None)
    assert isinstance(key, (str, StringName)), 'key must be str or StringName'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(key, (str, StringName)))
    py_stringname_key = key if isinstance(key, StringName) else c_utils.py_string_to_string_name(key)


    self._ptr.call_with_return(258,tuple([bone_idx, py_stringname_key._ptr, value]))

  @functools.native_method
  def get_concatenated_bone_names(self) -> typing.Union['StringName']:
    r'''
				Returns all bone names concatenated with commas (`,`) as a single `StringName`.
				It is useful to set it as a hint for the enum property.
			'''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(259,tuple([]))
    return str(_ret)


  @functools.native_method
  def get_bone_parent(self, bone_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the bone index which is the parent of the bone at `bone_idx`. If -1, then bone has no parent.
				**Note:** The parent bone returned will always be less than `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(260,tuple([bone_idx]))
    return _ret


  @functools.native_method
  def set_bone_parent(self, bone_idx:'int'   , parent_idx:'int'   ) -> None:
    r'''
				Sets the bone index `parent_idx` as the parent of the bone at `bone_idx`. If -1, then bone has no parent.
				**Note:** `parent_idx` must be less than `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'
    assert isinstance(parent_idx, (int, float)), 'parent_idx must be int or float'








    self._ptr.call_with_return(261,tuple([bone_idx, parent_idx]))

  @functools.native_method
  def get_bone_count(self) -> typing.Union[int]:
    r'''
				Returns the number of bones in the skeleton.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(262,tuple([]))
    return _ret


  @functools.native_method
  def get_version(self) -> typing.Union[int]:
    r'''
				Returns the number of times the bone hierarchy has changed within this skeleton, including renames.
				The Skeleton version is not serialized: only use within a single instance of Skeleton3D.
				Use for invalidating caches in IK solvers and other nodes which process bones.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(263,tuple([]))
    return _ret


  @functools.native_method
  def unparent_bone_and_rest(self, bone_idx:'int'   ) -> None:
    r'''
				Unparents the bone at `bone_idx` and sets its rest position to that of its parent prior to being reset.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    self._ptr.call_with_return(264,tuple([bone_idx]))

  @functools.native_method
  def get_bone_children(self, bone_idx:'int'   ) -> typing.Union['PackedInt32Array']:
    r'''
				Returns an array containing the bone indexes of all the child node of the passed in bone, `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(265,tuple([bone_idx]))
    return _ret


  @functools.native_method
  def get_parentless_bones(self) -> typing.Union['PackedInt32Array']:
    r'''
				Returns an array with all of the bones that are parentless. Another way to look at this is that it returns the indexes of all the bones that are not dependent or modified by other bones in the Skeleton.
			'''




    _ret = PackedInt32Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(266,tuple([]))
    return _ret


  @functools.native_method
  def get_bone_rest(self, bone_idx:'int'   ) -> typing.Union['Transform3D']:
    r'''
				Returns the rest transform for a bone `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(267,tuple([bone_idx]))
    return _ret


  @functools.native_method
  def set_bone_rest(self, bone_idx:'int'   , rest:'Transform3D'   ) -> None:
    r'''
				Sets the rest transform for bone `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'
    assert(not rest is None)
    assert isinstance(rest, Transform3D), 'rest must be Transform3D'








    self._ptr.call_with_return(268,tuple([bone_idx, rest._ptr]))

  @functools.native_method
  def get_bone_global_rest(self, bone_idx:'int'   ) -> typing.Union['Transform3D']:
    r'''
				Returns the global rest transform for `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(269,tuple([bone_idx]))
    return _ret


  @functools.native_method
  def create_skin_from_rest_transforms(self) -> typing.Union['py4godot_skin.Skin']:
    r'''
'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Skin
    _ret._ptr = self._ptr.call_with_return(270,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def register_skin(self, skin:'py4godot_skin.Skin'   ) -> typing.Union['py4godot_skinreference.SkinReference']:
    r'''
				Binds the given Skin to the Skeleton.
			'''

    assert(not skin is None)
    assert isinstance(skin, get_class('Skin')), 'skin must be Skin'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: SkinReference
    _ret._ptr = self._ptr.call_with_return(271,tuple([skin._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def localize_rests(self) -> None:
    r'''
				Returns all bones in the skeleton to their rest poses.
			'''




    self._ptr.call_with_return(272,tuple([]))

  @functools.native_method
  def clear_bones(self) -> None:
    r'''
				Clear all the bones in this skeleton.
			'''




    self._ptr.call_with_return(273,tuple([]))

  @functools.native_method
  def get_bone_pose(self, bone_idx:'int'   ) -> typing.Union['Transform3D']:
    r'''
				Returns the pose transform of the specified bone.
				**Note:** This is the pose you set to the skeleton in the process, the final pose can get overridden by modifiers in the deferred process, if you want to access the final pose, use `signal SkeletonModifier3D.modification_processed`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(274,tuple([bone_idx]))
    return _ret


  @functools.native_method
  def set_bone_pose(self, bone_idx:'int'   , pose:'Transform3D'   ) -> None:
    r'''
				Sets the pose transform, `pose`, for the bone at `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'
    assert(not pose is None)
    assert isinstance(pose, Transform3D), 'pose must be Transform3D'








    self._ptr.call_with_return(275,tuple([bone_idx, pose._ptr]))

  @functools.native_method
  def set_bone_pose_position(self, bone_idx:'int'   , position:'Vector3'   ) -> None:
    r'''
				Sets the pose position of the bone at `bone_idx` to `position`. `position` is a `Vector3` describing a position local to the `Skeleton3D` node.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'
    assert(not position is None)
    assert isinstance(position, Vector3), 'position must be Vector3'








    self._ptr.call_with_return(276,tuple([bone_idx, position._ptr]))

  @functools.native_method
  def set_bone_pose_rotation(self, bone_idx:'int'   , rotation:'Quaternion'   ) -> None:
    r'''
				Sets the pose rotation of the bone at `bone_idx` to `rotation`. `rotation` is a `Quaternion` describing a rotation in the bone's local coordinate space with respect to the rotation of any parent bones.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'
    assert(not rotation is None)
    assert isinstance(rotation, Quaternion), 'rotation must be Quaternion'








    self._ptr.call_with_return(277,tuple([bone_idx, rotation._ptr]))

  @functools.native_method
  def set_bone_pose_scale(self, bone_idx:'int'   , scale:'Vector3'   ) -> None:
    r'''
				Sets the pose scale of the bone at `bone_idx` to `scale`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'
    assert(not scale is None)
    assert isinstance(scale, Vector3), 'scale must be Vector3'








    self._ptr.call_with_return(278,tuple([bone_idx, scale._ptr]))

  @functools.native_method
  def get_bone_pose_position(self, bone_idx:'int'   ) -> typing.Union['Vector3']:
    r'''
				Returns the pose position of the bone at `bone_idx`. The returned `Vector3` is in the local coordinate space of the `Skeleton3D` node.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(279,tuple([bone_idx]))
    return _ret


  @functools.native_method
  def get_bone_pose_rotation(self, bone_idx:'int'   ) -> typing.Union['Quaternion']:
    r'''
				Returns the pose rotation of the bone at `bone_idx`. The returned `Quaternion` is local to the bone with respect to the rotation of any parent bones.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    _ret = Quaternion.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(280,tuple([bone_idx]))
    return _ret


  @functools.native_method
  def get_bone_pose_scale(self, bone_idx:'int'   ) -> typing.Union['Vector3']:
    r'''
				Returns the pose scale of the bone at `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(281,tuple([bone_idx]))
    return _ret


  @functools.native_method
  def reset_bone_pose(self, bone_idx:'int'   ) -> None:
    r'''
				Sets the bone pose to rest for `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    self._ptr.call_with_return(282,tuple([bone_idx]))

  @functools.native_method
  def reset_bone_poses(self) -> None:
    r'''
				Sets all bone poses to rests.
			'''




    self._ptr.call_with_return(283,tuple([]))

  @functools.native_method
  def is_bone_enabled(self, bone_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether the bone pose for the bone at `bone_idx` is enabled.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(284,tuple([bone_idx]))
    return _ret


  @functools.native_method
  def set_bone_enabled(self, bone_idx:'int'   , enabled:'bool' =True  ) -> None:
    r'''
				Disables the pose for the bone at `bone_idx` if `false`, enables the bone pose if `true`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(285,tuple([bone_idx, enabled]))

  @functools.native_method
  def get_bone_global_pose(self, bone_idx:'int'   ) -> typing.Union['Transform3D']:
    r'''
				Returns the overall transform of the specified bone, with respect to the skeleton. Being relative to the skeleton frame, this is not the actual "global" transform of the bone.
				**Note:** This is the global pose you set to the skeleton in the process, the final global pose can get overridden by modifiers in the deferred process, if you want to access the final global pose, use `signal SkeletonModifier3D.modification_processed`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(286,tuple([bone_idx]))
    return _ret


  @functools.native_method
  def set_bone_global_pose(self, bone_idx:'int'   , pose:'Transform3D'   ) -> None:
    r'''
				Sets the global pose transform, `pose`, for the bone at `bone_idx`.
				**Note:** If other bone poses have been changed, this method executes a dirty poses recalculation and will cause performance to deteriorate. If you know that multiple global poses will be applied, consider using `set_bone_pose` with precalculation.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'
    assert(not pose is None)
    assert isinstance(pose, Transform3D), 'pose must be Transform3D'








    self._ptr.call_with_return(287,tuple([bone_idx, pose._ptr]))

  @functools.native_method
  def force_update_all_bone_transforms(self) -> None:
    r'''
				Force updates the bone transforms/poses for all bones in the skeleton.
			'''




    self._ptr.call_with_return(288,tuple([]))

  @functools.native_method
  def force_update_bone_child_transform(self, bone_idx:'int'   ) -> None:
    r'''
				Force updates the bone transform for the bone at `bone_idx` and all of its children.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    self._ptr.call_with_return(289,tuple([bone_idx]))

  @functools.native_method
  def set_motion_scale(self, motion_scale:'float'   ) -> None:
    r''''''

    assert isinstance(motion_scale, (int, float)), 'motion_scale must be int or float'


    self.py__motion_scale = motion_scale






    self._ptr.call_with_return(290,tuple([motion_scale]))

  @functools.native_method
  def get_motion_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(291,tuple([]))

    return _ret


  @functools.native_method
  def set_show_rest_only(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__show_rest_only = enabled






    self._ptr.call_with_return(292,tuple([enabled]))

  @functools.native_method
  def is_show_rest_only(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(293,tuple([]))

    return _ret


  @functools.native_method
  def set_modifier_callback_mode_process(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__modifier_callback_mode_process = mode






    self._ptr.call_with_return(294,tuple([mode]))

  @functools.native_method
  def get_modifier_callback_mode_process(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(295,tuple([]))

    return _ret


  @functools.native_method
  def advance(self, delta:'float'   ) -> None:
    r'''
				Manually advance the child `SkeletonModifier3D`s by the specified time (in seconds).
				**Note:** The `delta` is temporarily accumulated in the `Skeleton3D`, and the deferred process uses the accumulated value to process the modification.
			'''

    assert isinstance(delta, (int, float)), 'delta must be int or float'







    self._ptr.call_with_return(296,tuple([delta]))

  @functools.native_method
  def clear_bones_global_pose_override(self) -> None:
    r'''
				Removes the global pose override on all bones in the skeleton.
			'''




    self._ptr.call_with_return(297,tuple([]))

  @functools.native_method
  def set_bone_global_pose_override(self, bone_idx:'int'   , pose:'Transform3D'   , amount:'float'   , persistent:'bool' =False  ) -> None:
    r'''
				Sets the global pose transform, `pose`, for the bone at `bone_idx`.
				`amount` is the interpolation strength that will be used when applying the pose, and `persistent` determines if the applied pose will remain.
				**Note:** The pose transform needs to be a global pose! To convert a world transform from a `Node3D` to a global bone pose, multiply the `Transform3D.affine_inverse` of the node's `Node3D.global_transform` by the desired world transform.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'
    assert(not pose is None)
    assert isinstance(pose, Transform3D), 'pose must be Transform3D'
    assert isinstance(amount, (int, float)), 'amount must be int or float'
    assert isinstance(persistent, bool), 'persistent must be bool'










    self._ptr.call_with_return(298,tuple([bone_idx, pose._ptr, amount, persistent]))

  @functools.native_method
  def get_bone_global_pose_override(self, bone_idx:'int'   ) -> typing.Union['Transform3D']:
    r'''
				Returns the global pose override transform for `bone_idx`.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(299,tuple([bone_idx]))
    return _ret


  @functools.native_method
  def get_bone_global_pose_no_override(self, bone_idx:'int'   ) -> typing.Union['Transform3D']:
    r'''
				Returns the overall transform of the specified bone, with respect to the skeleton, but without any global pose overrides. Being relative to the skeleton frame, this is not the actual "global" transform of the bone.
			'''

    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'







    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(300,tuple([bone_idx]))
    return _ret


  @functools.native_method
  def set_animate_physical_bones(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__animate_physical_bones = enabled






    self._ptr.call_with_return(301,tuple([enabled]))

  @functools.native_method
  def get_animate_physical_bones(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(302,tuple([]))

    return _ret


  @functools.native_method
  def physical_bones_stop_simulation(self) -> None:
    r'''
				Tells the `PhysicalBone3D` nodes in the Skeleton to stop simulating.
			'''




    self._ptr.call_with_return(303,tuple([]))

  @functools.native_method
  def physical_bones_start_simulation(self, bones:'py4godot_stringnametypedarray.StringNameTypedArray' = None  ) -> None:
    r'''
				Tells the `PhysicalBone3D` nodes in the Skeleton to start simulating and reacting to the physics world.
				Optionally, a list of bone names can be passed-in, allowing only the passed-in bones to be simulated.
			'''


    assert isinstance(bones, Array), 'bones must be Array'







    self._ptr.call_with_return(304,tuple([bones._ptr]))

  @functools.native_method
  def physical_bones_add_collision_exception(self, exception:'RID'   ) -> None:
    r'''
				Adds a collision exception to the physical bone.
				Works just like the `RigidBody3D` node.
			'''

    assert(not exception is None)
    assert isinstance(exception, RID), 'exception must be RID'







    self._ptr.call_with_return(305,tuple([exception._ptr]))

  @functools.native_method
  def physical_bones_remove_collision_exception(self, exception:'RID'   ) -> None:
    r'''
				Removes a collision exception to the physical bone.
				Works just like the `RigidBody3D` node.
			'''

    assert(not exception is None)
    assert isinstance(exception, RID), 'exception must be RID'







    self._ptr.call_with_return(306,tuple([exception._ptr]))


register_cast_function('Skeleton3D', Skeleton3D.cast)
register_class('Skeleton3D', Skeleton3D)
