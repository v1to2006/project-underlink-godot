# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPJSONWrapper


class JSON(py4godot_resource.Resource):
  r'''
		The `JSON` class enables all data types to be converted to and from a JSON string. This is useful for serializing data, e.g. to save to a file or send over the network.
		`stringify` is used to convert any data type into a JSON string.
		`parse` is used to convert any existing JSON data into a `Variant` that can be used within Godot. If successfully parsed, use `data` to retrieve the `Variant`, and use `@GlobalScope.typeof` to check if the Variant's type is what you expect. JSON Objects are converted into a `Dictionary`, but JSON data can be used to store `Array`s, numbers, `String`s and even just a boolean.
		```gdscript
		var data_to_send = `"a", "b", "c"`
		var json_string = JSON.stringify(data_to_send)
		# Save data
		# ...
		# Retrieve data
		var json = JSON.new()
		var error = json.parse(json_string)
		if error == OK:
			var data_received = json.data
			if typeof(data_received) == TYPE_ARRAY:
				print(data_received) # Prints the array.
			else:
				print("Unexpected data")
		else:
			print("JSON Parse Error: ", json.get_error_message(), " in ", json_string, " at line ", json.get_error_line())
		```
		Alternatively, you can parse strings using the static `parse_string` method, but it doesn't handle errors.
		```gdscript
		var data = JSON.parse_string(json_string) # Returns null if parsing failed.
		```
		**Note:** Both parse methods do not fully comply with the JSON specification:
		- Trailing commas in arrays or objects are ignored, instead of causing a parser error.
		- New line and tab characters are accepted in string literals, and are treated like their corresponding escape sequences `\n` and `\t`.
		- Numbers are parsed using `String.to_float` which is generally more lax than the JSON specification.
		- Certain errors, such as invalid Unicode sequences, do not cause a parser error. Instead, the string is cleaned up and an error is logged to the console.
	'''

  @staticmethod
  def constructor():
    class_ = JSON.construct_without_init()
    class_._ptr = constructor(435,0, ())
    return class_
  @staticmethod
  def new():
    class_ = JSON.construct_without_init()
    class_._ptr = constructor(435,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPJSONWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(435,0, ())


  def generate_wrapper(self):
    return CPPJSONWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = JSON.__new__(JSON)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'JSON'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(83, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = JSON.construct_without_init()
    cls._ptr = CPPJSONWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = JSON.construct_without_init()
    cls._ptr = CPPJSONWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def data(self) -> typing.Union[typing.Any]:
    r''''''
    _ret = self. get_data()
    return _ret
  @data.setter
  def data(self,  value:'object'):
    self.set_data(value)
  @staticmethod
  def stringify(data:'object'   , indent:'str' =""  , sort_keys:'bool' =True  , full_precision:'bool' =False  ) -> typing.Union[str]:
    r'''
				Converts a `Variant` var to JSON text and returns the result. Useful for serializing data to store or send over the network.
				**Note:** The JSON specification does not define integer or float types, but only a _number_ type. Therefore, converting a Variant to JSON text will convert all numerical values to `float` types.
				**Note:** If `full_precision` is `true`, when stringifying floats, the unreliable digits are stringified in addition to the reliable digits to guarantee exact decoding.
				The `indent` parameter controls if and how something is indented; its contents will be used where there should be an indent in the output. Even spaces like `"   "` will work. `\t` and `\n` can also be used for a tab indent, or to make a newline for each indent respectively.
				**Warning:** Non-finite numbers are not supported in JSON. Any occurrences of `constant @GDScript.INF` will be replaced with `1e99999`, and negative `constant @GDScript.INF` will be replaced with `-1e99999`, but they will be interpreted correctly as infinity by most JSON parsers. `constant @GDScript.NAN` will be replaced with `null`, and it will not be interpreted as NaN in JSON parsers. If you expect non-finite numbers, consider passing your data through `from_native` first.
				**Example output:**
				```gdscript
				## JSON.stringify(my_dictionary)
				{"name":"my_dictionary","version":"1.0.0","entities":`{"name":"entity_0","value":"value_0"},{"name":"entity_1","value":"value_1"}`}

				## JSON.stringify(my_dictionary, "\t")
				{
					"name": "my_dictionary",
					"version": "1.0.0",
					"entities": `
						{
							"name": "entity_0",
							"value": "value_0"
						},
						{
							"name": "entity_1",
							"value": "value_1"
						}
					`
				}

				## JSON.stringify(my_dictionary, "...")
				{
				..."name": "my_dictionary",
				..."version": "1.0.0",
				..."entities": `
				......{
				........."name": "entity_0",
				........."value": "value_0"
				......},
				......{
				........."name": "entity_1",
				........."value": "value_1"
				......}
				...`
				}
				```
			'''
    if indent is None:
      indent = String.new0()

    
    assert isinstance(sort_keys, bool), 'sort_keys must be bool'
    assert isinstance(full_precision, bool), 'full_precision must be bool'

    if not (type(data).__name__ in py4godot.variant_types.core_types or isinstance(data, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'data': "
                f"{type(data).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )





    assert(isinstance(indent, (str, String)))
    py_string_indent = indent if isinstance(indent, StringName) else c_utils.py_string_to_string(indent)



    _ret = String.construct_without_init()
    _ret._ptr = static_method(435,1,tuple([data, py_string_indent._ptr, sort_keys, full_precision]))
    return utils.gd_string_to_py_string(_ret)


  @staticmethod
  def parse_string(json_string:'str'   ) -> typing.Union[typing.Any]:
    r'''
				Attempts to parse the `json_string` provided and returns the parsed data. Returns `null` if parse failed.
			'''

    assert(not json_string is None)
    assert isinstance(json_string, (str, String)), 'json_string must be str or String'





    assert(isinstance(json_string, (str, String)))
    py_string_json_string = json_string if isinstance(json_string, StringName) else c_utils.py_string_to_string(json_string)

    _ret = None
    _ret = static_method(435,2,tuple([py_string_json_string._ptr]))
    return _ret


  @functools.native_method
  def parse(self, json_text:'str'   , keep_text:'bool' =False  ) -> typing.Union[int]:
    r'''
				Attempts to parse the `json_text` provided.
				Returns an `enum Error`. If the parse was successful, it returns `constant OK` and the result can be retrieved using `data`. If unsuccessful, use `get_error_line` and `get_error_message` to identify the source of the failure.
				Non-static variant of `parse_string`, if you want custom error handling.
				The optional `keep_text` argument instructs the parser to keep a copy of the original text. This text can be obtained later by using the `get_parsed_text` function and is used when saving the resource (instead of generating new text from `data`).
			'''

    assert(not json_text is None)
    assert isinstance(json_text, (str, String)), 'json_text must be str or String'
    assert isinstance(keep_text, bool), 'keep_text must be bool'





    assert(isinstance(json_text, (str, String)))
    py_string_json_text = json_text if isinstance(json_text, StringName) else c_utils.py_string_to_string(json_text)


    _ret:int
    _ret = self._ptr.call_with_return(77,tuple([py_string_json_text._ptr, keep_text]))
    return _ret


  @functools.native_method
  def get_data(self) -> typing.Union[typing.Any]:
    r''''''




    _ret = None
    _ret = self._ptr.call_with_return(78,tuple([]))

    return _ret


  @functools.native_method
  def set_data(self, data:'object'   ) -> None:
    r''''''

    

    if not (type(data).__name__ in py4godot.variant_types.core_types or isinstance(data, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'data': "
                f"{type(data).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )

    self.py__data = data






    self._ptr.call_with_return(79,tuple([data]))

  @functools.native_method
  def get_parsed_text(self) -> typing.Union[str]:
    r'''
				Return the text parsed by `parse` (requires passing `keep_text` to `parse`).
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(80,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_error_line(self) -> typing.Union[int]:
    r'''
				Returns `0` if the last call to `parse` was successful, or the line number where the parse failed.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(81,tuple([]))
    return _ret


  @functools.native_method
  def get_error_message(self) -> typing.Union[str]:
    r'''
				Returns an empty string if the last call to `parse` was successful, or the error message if it failed.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(82,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @staticmethod
  def from_native(variant:'object'   , full_objects:'bool' =False  ) -> typing.Union[typing.Any]:
    r'''
				Converts a native engine type to a JSON-compliant value.
				By default, objects are ignored for security reasons, unless `full_objects` is `true`.
				You can convert a native value to a JSON string like this:
				```gdscript
				func encode_data(value, full_objects = false):
					return JSON.stringify(JSON.from_native(value, full_objects))
				```
			'''

    
    assert isinstance(full_objects, bool), 'full_objects must be bool'

    if not (type(variant).__name__ in py4godot.variant_types.core_types or isinstance(variant, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'variant': "
                f"{type(variant).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = None
    _ret = static_method(435,3,tuple([variant, full_objects]))
    return _ret


  @staticmethod
  def to_native(json:'object'   , allow_objects:'bool' =False  ) -> typing.Union[typing.Any]:
    r'''
				Converts a JSON-compliant value that was created with `from_native` back to native engine types.
				By default, objects are ignored for security reasons, unless `allow_objects` is `true`.
				You can convert a JSON string back to a native value like this:
				```gdscript
				func decode_data(string, allow_objects = false):
					return JSON.to_native(JSON.parse_string(string), allow_objects)
				```
			'''

    
    assert isinstance(allow_objects, bool), 'allow_objects must be bool'

    if not (type(json).__name__ in py4godot.variant_types.core_types or isinstance(json, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'json': "
                f"{type(json).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = None
    _ret = static_method(435,4,tuple([json, allow_objects]))
    return _ret



register_cast_function('JSON', JSON.cast)
register_class('JSON', JSON)
