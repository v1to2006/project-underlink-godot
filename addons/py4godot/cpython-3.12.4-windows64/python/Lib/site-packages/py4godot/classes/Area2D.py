# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Node as py4godot_node 
  import py4godot.classes.Area2DTypedArray as py4godot_area2dtypedarray 
  import py4godot.classes.Node2DTypedArray as py4godot_node2dtypedarray 
import py4godot.classes.CollisionObject2D as py4godot_collisionobject2d 
import py4godot.classes.Area2DTypedArray as py4godot_area2dtypedarray 
import py4godot.classes.Node2DTypedArray as py4godot_node2dtypedarray 
from py4godot.wrappers.wrappers import CPPArea2DWrapper

class SpaceOverride:
  SPACE_OVERRIDE_DISABLED = 0
  SPACE_OVERRIDE_COMBINE = 1
  SPACE_OVERRIDE_COMBINE_REPLACE = 2
  SPACE_OVERRIDE_REPLACE = 3
  SPACE_OVERRIDE_REPLACE_COMBINE = 4


class Area2D(py4godot_collisionobject2d.CollisionObject2D):
  r'''
		`Area2D` is a region of 2D space defined by one or multiple `CollisionShape2D` or `CollisionPolygon2D` child nodes. It detects when other `CollisionObject2D`s enter or exit it, and it also keeps track of which collision objects haven't exited it yet (i.e. which one are overlapping it).
		This node can also locally alter or override physics parameters (gravity, damping) and route audio to custom audio buses.
		**Note:** Areas and bodies created with `PhysicsServer2D` might not interact as expected with `Area2D`s, and might not emit signals or track objects correctly.
	'''

  @staticmethod
  def constructor():
    class_ = Area2D.construct_without_init()
    class_._ptr = constructor(98,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Area2D.construct_without_init()
    class_._ptr = constructor(98,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPArea2DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(98,0, ())


  def generate_wrapper(self):
    return CPPArea2DWrapper()
  def init_signals(self):
    super().init_signals()
    body_shape_entered_name = utils.py_string_to_string_name("body_shape_entered")
    self.body_shape_entered = signals.BuiltinSignal(self, body_shape_entered_name)
    body_shape_exited_name = utils.py_string_to_string_name("body_shape_exited")
    self.body_shape_exited = signals.BuiltinSignal(self, body_shape_exited_name)
    body_entered_name = utils.py_string_to_string_name("body_entered")
    self.body_entered = signals.BuiltinSignal(self, body_entered_name)
    body_exited_name = utils.py_string_to_string_name("body_exited")
    self.body_exited = signals.BuiltinSignal(self, body_exited_name)
    area_shape_entered_name = utils.py_string_to_string_name("area_shape_entered")
    self.area_shape_entered = signals.BuiltinSignal(self, area_shape_entered_name)
    area_shape_exited_name = utils.py_string_to_string_name("area_shape_exited")
    self.area_shape_exited = signals.BuiltinSignal(self, area_shape_exited_name)
    area_entered_name = utils.py_string_to_string_name("area_entered")
    self.area_entered = signals.BuiltinSignal(self, area_entered_name)
    area_exited_name = utils.py_string_to_string_name("area_exited")
    self.area_exited = signals.BuiltinSignal(self, area_exited_name)

  @staticmethod
  def construct_without_init():
    cls = Area2D.__new__(Area2D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Area2D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Area2D.construct_without_init()
    cls._ptr = CPPArea2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Area2D.construct_without_init()
    cls._ptr = CPPArea2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def monitoring(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_monitoring()
    return _ret
  @monitoring.setter
  def monitoring(self,  value:'bool'):
    self.set_monitoring(value)
  @property
  def monitorable(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_monitorable()
    return _ret
  @monitorable.setter
  def monitorable(self,  value:'bool'):
    self.set_monitorable(value)
  @property
  def priority(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_priority()
    return _ret
  @priority.setter
  def priority(self,  value:'int'):
    self.set_priority(value)
  @property
  def gravity_space_override(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_gravity_space_override_mode()
    return _ret
  @gravity_space_override.setter
  def gravity_space_override(self,  value:'int'):
    self.set_gravity_space_override_mode(value)
  @property
  def gravity_point(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_gravity_a_point()
    return _ret
  @gravity_point.setter
  def gravity_point(self,  value:'bool'):
    self.set_gravity_is_point(value)
  @property
  def gravity_point_unit_distance(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_gravity_point_unit_distance()
    return _ret
  @gravity_point_unit_distance.setter
  def gravity_point_unit_distance(self,  value:'float'):
    self.set_gravity_point_unit_distance(value)
  @property
  def gravity_point_center(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_gravity_point_center()
    return _ret
  @gravity_point_center.setter
  def gravity_point_center(self,  value:'Vector2'):
    self.set_gravity_point_center(value)
  @property
  def gravity_direction(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_gravity_direction()
    return _ret
  @gravity_direction.setter
  def gravity_direction(self,  value:'Vector2'):
    self.set_gravity_direction(value)
  @property
  def gravity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_gravity()
    return _ret
  @gravity.setter
  def gravity(self,  value:'float'):
    self.set_gravity(value)
  @property
  def linear_damp_space_override(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_linear_damp_space_override_mode()
    return _ret
  @linear_damp_space_override.setter
  def linear_damp_space_override(self,  value:'int'):
    self.set_linear_damp_space_override_mode(value)
  @property
  def linear_damp(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_linear_damp()
    return _ret
  @linear_damp.setter
  def linear_damp(self,  value:'float'):
    self.set_linear_damp(value)
  @property
  def angular_damp_space_override(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_angular_damp_space_override_mode()
    return _ret
  @angular_damp_space_override.setter
  def angular_damp_space_override(self,  value:'int'):
    self.set_angular_damp_space_override_mode(value)
  @property
  def angular_damp(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_angular_damp()
    return _ret
  @angular_damp.setter
  def angular_damp(self,  value:'float'):
    self.set_angular_damp(value)
  @property
  def audio_bus_override(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_overriding_audio_bus()
    return _ret
  @audio_bus_override.setter
  def audio_bus_override(self,  value:'bool'):
    self.set_audio_bus_override(value)
  @property
  def audio_bus_name(self) -> typing.Union['StringName']:
    r''''''
    _ret = self. get_audio_bus_name()
    return _ret
  @audio_bus_name.setter
  def audio_bus_name(self,  value:'object'):
    self.set_audio_bus_name(value)
  @functools.native_method
  def set_gravity_space_override_mode(self, space_override_mode:'int'  ) -> None:
    r''''''

    assert isinstance(space_override_mode, (int, float)), 'space_override_mode must be int or float'


    self.py__gravity_space_override = space_override_mode






    self._ptr.call_with_return(342,tuple([space_override_mode]))

  @functools.native_method
  def get_gravity_space_override_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(343,tuple([]))

    return _ret


  @functools.native_method
  def set_gravity_is_point(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__gravity_point = enable






    self._ptr.call_with_return(344,tuple([enable]))

  @functools.native_method
  def is_gravity_a_point(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(345,tuple([]))

    return _ret


  @functools.native_method
  def set_gravity_point_unit_distance(self, distance_scale:'float'   ) -> None:
    r''''''

    assert isinstance(distance_scale, (int, float)), 'distance_scale must be int or float'


    self.py__gravity_point_unit_distance = distance_scale






    self._ptr.call_with_return(346,tuple([distance_scale]))

  @functools.native_method
  def get_gravity_point_unit_distance(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(347,tuple([]))

    return _ret


  @functools.native_method
  def set_gravity_point_center(self, center:'Vector2'   ) -> None:
    r''''''

    assert(not center is None)
    assert isinstance(center, Vector2), 'center must be Vector2'


    self.py__gravity_point_center = center






    self._ptr.call_with_return(348,tuple([center._ptr]))

  @functools.native_method
  def get_gravity_point_center(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(349,tuple([]))

    return _ret


  @functools.native_method
  def set_gravity_direction(self, direction:'Vector2'   ) -> None:
    r''''''

    assert(not direction is None)
    assert isinstance(direction, Vector2), 'direction must be Vector2'


    self.py__gravity_direction = direction






    self._ptr.call_with_return(350,tuple([direction._ptr]))

  @functools.native_method
  def get_gravity_direction(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(351,tuple([]))

    return _ret


  @functools.native_method
  def set_gravity(self, gravity:'float'   ) -> None:
    r''''''

    assert isinstance(gravity, (int, float)), 'gravity must be int or float'


    self.py__gravity = gravity






    self._ptr.call_with_return(352,tuple([gravity]))

  @functools.native_method
  def get_gravity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(353,tuple([]))

    return _ret


  @functools.native_method
  def set_linear_damp_space_override_mode(self, space_override_mode:'int'  ) -> None:
    r''''''

    assert isinstance(space_override_mode, (int, float)), 'space_override_mode must be int or float'


    self.py__linear_damp_space_override = space_override_mode






    self._ptr.call_with_return(354,tuple([space_override_mode]))

  @functools.native_method
  def get_linear_damp_space_override_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(355,tuple([]))

    return _ret


  @functools.native_method
  def set_angular_damp_space_override_mode(self, space_override_mode:'int'  ) -> None:
    r''''''

    assert isinstance(space_override_mode, (int, float)), 'space_override_mode must be int or float'


    self.py__angular_damp_space_override = space_override_mode






    self._ptr.call_with_return(356,tuple([space_override_mode]))

  @functools.native_method
  def get_angular_damp_space_override_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(357,tuple([]))

    return _ret


  @functools.native_method
  def set_linear_damp(self, linear_damp:'float'   ) -> None:
    r''''''

    assert isinstance(linear_damp, (int, float)), 'linear_damp must be int or float'


    self.py__linear_damp = linear_damp






    self._ptr.call_with_return(358,tuple([linear_damp]))

  @functools.native_method
  def get_linear_damp(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(359,tuple([]))

    return _ret


  @functools.native_method
  def set_angular_damp(self, angular_damp:'float'   ) -> None:
    r''''''

    assert isinstance(angular_damp, (int, float)), 'angular_damp must be int or float'


    self.py__angular_damp = angular_damp






    self._ptr.call_with_return(360,tuple([angular_damp]))

  @functools.native_method
  def get_angular_damp(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(361,tuple([]))

    return _ret


  @functools.native_method
  def set_priority(self, priority:'int'   ) -> None:
    r''''''

    assert isinstance(priority, (int, float)), 'priority must be int or float'


    self.py__priority = priority






    self._ptr.call_with_return(362,tuple([priority]))

  @functools.native_method
  def get_priority(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(363,tuple([]))

    return _ret


  @functools.native_method
  def set_monitoring(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__monitoring = enable






    self._ptr.call_with_return(364,tuple([enable]))

  @functools.native_method
  def is_monitoring(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(365,tuple([]))

    return _ret


  @functools.native_method
  def set_monitorable(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__monitorable = enable






    self._ptr.call_with_return(366,tuple([enable]))

  @functools.native_method
  def is_monitorable(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(367,tuple([]))

    return _ret


  @functools.native_method
  def get_overlapping_bodies(self) -> typing.Union['py4godot_node2dtypedarray.Node2DTypedArray']:
    r'''
				Returns a list of intersecting `PhysicsBody2D`s and `TileMap`s. The overlapping body's `CollisionObject2D.collision_layer` must be part of this area's `CollisionObject2D.collision_mask` in order to be detected.
				For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
			'''




    _ret = py4godot_node2dtypedarray.Node2DTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(368,tuple([]))
    return _ret


  @functools.native_method
  def get_overlapping_areas(self) -> typing.Union['py4godot_area2dtypedarray.Area2DTypedArray']:
    r'''
				Returns a list of intersecting `Area2D`s. The overlapping area's `CollisionObject2D.collision_layer` must be part of this area's `CollisionObject2D.collision_mask` in order to be detected.
				For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
			'''




    _ret = py4godot_area2dtypedarray.Area2DTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(369,tuple([]))
    return _ret


  @functools.native_method
  def has_overlapping_bodies(self) -> typing.Union[bool]:
    r'''
				Returns `true` if intersecting any `PhysicsBody2D`s or `TileMap`s, otherwise returns `false`. The overlapping body's `CollisionObject2D.collision_layer` must be part of this area's `CollisionObject2D.collision_mask` in order to be detected.
				For performance reasons (collisions are all processed at the same time) the list of overlapping bodies is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(370,tuple([]))
    return _ret


  @functools.native_method
  def has_overlapping_areas(self) -> typing.Union[bool]:
    r'''
				Returns `true` if intersecting any `Area2D`s, otherwise returns `false`. The overlapping area's `CollisionObject2D.collision_layer` must be part of this area's `CollisionObject2D.collision_mask` in order to be detected.
				For performance reasons (collisions are all processed at the same time) the list of overlapping areas is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(371,tuple([]))
    return _ret


  @functools.native_method
  def overlaps_body(self, body:'py4godot_node.Node'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given physics body intersects or overlaps this `Area2D`, `false` otherwise.
				**Note:** The result of this test is not immediate after moving objects. For performance, list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
				The `body` argument can either be a `PhysicsBody2D` or a `TileMap` instance. While TileMaps are not physics bodies themselves, they register their tiles with collision shapes as a virtual physics body.
			'''

    assert(not body is None)
    assert isinstance(body, get_class('Node')), 'body must be Node'







    _ret = 0
    _ret = self._ptr.call_with_return(372,tuple([body._ptr]))
    return _ret


  @functools.native_method
  def overlaps_area(self, area:'py4godot_node.Node'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given `Area2D` intersects or overlaps this `Area2D`, `false` otherwise.
				**Note:** The result of this test is not immediate after moving objects. For performance, the list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
			'''

    assert(not area is None)
    assert isinstance(area, get_class('Node')), 'area must be Node'







    _ret = 0
    _ret = self._ptr.call_with_return(373,tuple([area._ptr]))
    return _ret


  @functools.native_method
  def set_audio_bus_name(self, name:'object'   ) -> None:
    r''''''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'


    self.py__audio_bus_name = name



    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(374,tuple([py_stringname_name._ptr]))

  @functools.native_method
  def get_audio_bus_name(self) -> typing.Union['StringName']:
    r''''''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(375,tuple([]))

    return str(_ret)


  @functools.native_method
  def set_audio_bus_override(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__audio_bus_override = enable






    self._ptr.call_with_return(376,tuple([enable]))

  @functools.native_method
  def is_overriding_audio_bus(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(377,tuple([]))

    return _ret



register_cast_function('Area2D', Area2D.cast)
register_class('Area2D', Area2D)
