# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.ProceduralSkyMaterial as py4godot_proceduralskymaterial 
  import py4godot.classes.PlaneMesh as py4godot_planemesh 
  import py4godot.classes.Material as py4godot_material 
  import py4godot.classes.TextMesh as py4godot_textmesh 
  import py4godot.classes.Skin as py4godot_skin 
  import py4godot.classes.RibbonTrailMesh as py4godot_ribbontrailmesh 
  import py4godot.classes.StandardMaterial3D as py4godot_standardmaterial3d 
  import py4godot.classes.PlaceholderMaterial as py4godot_placeholdermaterial 
  import py4godot.classes.TorusMesh as py4godot_torusmesh 
  import py4godot.classes.BaseMaterial3D as py4godot_basematerial3d 
  import py4godot.classes.TubeTrailMesh as py4godot_tubetrailmesh 
  import py4godot.classes.PlaceholderMesh as py4godot_placeholdermesh 
  import py4godot.classes.ShaderMaterial as py4godot_shadermaterial 
  import py4godot.classes.PrimitiveMesh as py4godot_primitivemesh 
  import py4godot.classes.ORMMaterial3D as py4godot_ormmaterial3d 
  import py4godot.classes.PanoramaSkyMaterial as py4godot_panoramaskymaterial 
  import py4godot.classes.CylinderMesh as py4godot_cylindermesh 
  import py4godot.classes.Mesh as py4godot_mesh 
  import py4godot.classes.ParticleProcessMaterial as py4godot_particleprocessmaterial 
  import py4godot.classes.PhysicalSkyMaterial as py4godot_physicalskymaterial 
  import py4godot.classes.SphereMesh as py4godot_spheremesh 
  import py4godot.classes.QuadMesh as py4godot_quadmesh 
  import py4godot.classes.PrismMesh as py4godot_prismmesh 
  import py4godot.classes.MeshConvexDecompositionSettings as py4godot_meshconvexdecompositionsettings 
  import py4godot.classes.ArrayMesh as py4godot_arraymesh 
  import py4godot.classes.CapsuleMesh as py4godot_capsulemesh 
  import py4godot.classes.SkinReference as py4godot_skinreference 
  import py4godot.classes.CanvasItemMaterial as py4godot_canvasitemmaterial 
  import py4godot.classes.FogMaterial as py4godot_fogmaterial 
  import py4godot.classes.BoxMesh as py4godot_boxmesh 
  import py4godot.classes.ImmediateMesh as py4godot_immediatemesh 
  import py4godot.classes.PointMesh as py4godot_pointmesh 
import py4godot.classes.GeometryInstance3D as py4godot_geometryinstance3d 
from py4godot.wrappers.wrappers import CPPMeshInstance3DWrapper


class MeshInstance3D(py4godot_geometryinstance3d.GeometryInstance3D):
  r'''
		MeshInstance3D is a node that takes a `Mesh` resource and adds it to the current scenario by creating an instance of it. This is the class most often used to render 3D geometry and can be used to instance a single `Mesh` in many places. This allows reusing geometry, which can save on resources. When a `Mesh` has to be instantiated more than thousands of times at close proximity, consider using a `MultiMesh` in a `MultiMeshInstance3D` instead.
	'''

  @staticmethod
  def constructor():
    class_ = MeshInstance3D.construct_without_init()
    class_._ptr = constructor(474,0, ())
    return class_
  @staticmethod
  def new():
    class_ = MeshInstance3D.construct_without_init()
    class_._ptr = constructor(474,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPMeshInstance3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(474,0, ())


  def generate_wrapper(self):
    return CPPMeshInstance3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = MeshInstance3D.__new__(MeshInstance3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'MeshInstance3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = MeshInstance3D.construct_without_init()
    cls._ptr = CPPMeshInstance3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = MeshInstance3D.construct_without_init()
    cls._ptr = CPPMeshInstance3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def mesh(self) -> typing.Any:
    r''''''
    _ret = self. get_mesh()
    return _ret
  @mesh.setter
  def mesh(self,  value:'py4godot_object.Object'):
    self.set_mesh(value)
  @property
  def skin(self) -> typing.Union['py4godot_skin.Skin']:
    r''''''
    _ret = self. get_skin()
    return _ret
  @skin.setter
  def skin(self,  value:'py4godot_object.Object'):
    self.set_skin(value)
  @property
  def skeleton(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_skeleton_path()
    return _ret
  @skeleton.setter
  def skeleton(self,  value:'object'):
    self.set_skeleton_path(value)
  @functools.native_method
  def set_mesh(self, mesh:'py4godot_mesh.Mesh'   ) -> None:
    r''''''

    assert(not mesh is None)
    assert isinstance(mesh, get_class('Mesh')), 'mesh must be Mesh'


    self.py__mesh = mesh






    self._ptr.call_with_return(298,tuple([mesh._ptr]))

  @functools.native_method
  def get_mesh(self) -> typing.Any:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Mesh
    _ret._ptr = self._ptr.call_with_return(299,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_skeleton_path(self, skeleton_path:'object'   ) -> None:
    r''''''

    assert(not skeleton_path is None)
    assert isinstance(skeleton_path, (str, NodePath)), 'skeleton_path must be str or NodePath'


    self.py__skeleton = skeleton_path



    assert(isinstance(skeleton_path, (str, NodePath)))
    py_nodepath_skeleton_path = skeleton_path if isinstance(skeleton_path,NodePath) else NodePath.new2(skeleton_path)


    self._ptr.call_with_return(300,tuple([py_nodepath_skeleton_path._ptr]))

  @functools.native_method
  def get_skeleton_path(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(301,tuple([]))

    return _ret


  @functools.native_method
  def set_skin(self, skin:'py4godot_skin.Skin'   ) -> None:
    r''''''

    assert(not skin is None)
    assert isinstance(skin, get_class('Skin')), 'skin must be Skin'


    self.py__skin = skin






    self._ptr.call_with_return(302,tuple([skin._ptr]))

  @functools.native_method
  def get_skin(self) -> typing.Union['py4godot_skin.Skin']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Skin
    _ret._ptr = self._ptr.call_with_return(303,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_skin_reference(self) -> typing.Union['py4godot_skinreference.SkinReference']:
    r'''
				Returns the internal `SkinReference` containing the skeleton's `RID` attached to this RID. See also `Resource.get_rid`, `SkinReference.get_skeleton`, and `RenderingServer.instance_attach_skeleton`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: SkinReference
    _ret._ptr = self._ptr.call_with_return(304,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_surface_override_material_count(self) -> typing.Union[int]:
    r'''
				Returns the number of surface override materials. This is equivalent to `Mesh.get_surface_count`. See also `get_surface_override_material`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(305,tuple([]))
    return _ret


  @functools.native_method
  def set_surface_override_material(self, surface:'int'   , material:'py4godot_material.Material'   ) -> None:
    r'''
				Sets the override `material` for the specified `surface` of the `Mesh` resource. This material is associated with this `MeshInstance3D` rather than with `mesh`.
				**Note:** This assigns the `Material` associated to the `MeshInstance3D`'s Surface Material Override properties, not the material within the `Mesh` resource. To set the material within the `Mesh` resource, use `Mesh.surface_set_material` instead.
			'''

    assert isinstance(surface, (int, float)), 'surface must be int or float'
    assert(not material is None)
    assert isinstance(material, get_class('Material')), 'material must be Material'








    self._ptr.call_with_return(306,tuple([surface, material._ptr]))

  @functools.native_method
  def get_surface_override_material(self, surface:'int'   ) -> typing.Any:
    r'''
				Returns the override `Material` for the specified `surface` of the `Mesh` resource. See also `get_surface_override_material_count`.
				**Note:** This returns the `Material` associated to the `MeshInstance3D`'s Surface Material Override properties, not the material within the `Mesh` resource. To get the material within the `Mesh` resource, use `Mesh.surface_get_material` instead.
			'''

    assert isinstance(surface, (int, float)), 'surface must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Material
    _ret._ptr = self._ptr.call_with_return(307,tuple([surface]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def get_active_material(self, surface:'int'   ) -> typing.Any:
    r'''
				Returns the `Material` that will be used by the `Mesh` when drawing. This can return the `GeometryInstance3D.material_override`, the surface override `Material` defined in this `MeshInstance3D`, or the surface `Material` defined in the `mesh`. For example, if `GeometryInstance3D.material_override` is used, all surfaces will return the override material.
				Returns `null` if no material is active, including when `mesh` is `null`.
			'''

    assert isinstance(surface, (int, float)), 'surface must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Material
    _ret._ptr = self._ptr.call_with_return(308,tuple([surface]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def create_trimesh_collision(self) -> None:
    r'''
				This helper creates a `StaticBody3D` child node with a `ConcavePolygonShape3D` collision shape calculated from the mesh geometry. It's mainly used for testing.
			'''




    self._ptr.call_with_return(309,tuple([]))

  @functools.native_method
  def create_convex_collision(self, clean:'bool' =True  , simplify:'bool' =False  ) -> None:
    r'''
				This helper creates a `StaticBody3D` child node with a `ConvexPolygonShape3D` collision shape calculated from the mesh geometry. It's mainly used for testing.
				If `clean` is `true` (default), duplicate and interior vertices are removed automatically. You can set it to `false` to make the process faster if not needed.
				If `simplify` is `true`, the geometry can be further simplified to reduce the number of vertices. Disabled by default.
			'''

    assert isinstance(clean, bool), 'clean must be bool'
    assert isinstance(simplify, bool), 'simplify must be bool'








    self._ptr.call_with_return(310,tuple([clean, simplify]))

  @functools.native_method
  def create_multiple_convex_collisions(self, settings:'py4godot_meshconvexdecompositionsettings.MeshConvexDecompositionSettings' = None  ) -> None:
    r'''
				This helper creates a `StaticBody3D` child node with multiple `ConvexPolygonShape3D` collision shapes calculated from the mesh geometry via convex decomposition. The convex decomposition operation can be controlled with parameters from the optional `settings`.
			'''
    if settings is None:
      settings = c_utils.empty_object








    self._ptr.call_with_return(311,tuple([settings._ptr]))

  @functools.native_method
  def get_blend_shape_count(self) -> typing.Union[int]:
    r'''
				Returns the number of blend shapes available. Produces an error if `mesh` is `null`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(312,tuple([]))
    return _ret


  @functools.native_method
  def find_blend_shape_by_name(self, name:'object'   ) -> typing.Union[int]:
    r'''
				Returns the index of the blend shape with the given `name`. Returns `-1` if no blend shape with this name exists, including when `mesh` is `null`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = 0
    _ret = self._ptr.call_with_return(313,tuple([py_stringname_name._ptr]))
    return _ret


  @functools.native_method
  def get_blend_shape_value(self, blend_shape_idx:'int'   ) -> typing.Union[float]:
    r'''
				Returns the value of the blend shape at the given `blend_shape_idx`. Returns `0.0` and produces an error if `mesh` is `null` or doesn't have a blend shape at that index.
			'''

    assert isinstance(blend_shape_idx, (int, float)), 'blend_shape_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(314,tuple([blend_shape_idx]))
    return _ret


  @functools.native_method
  def set_blend_shape_value(self, blend_shape_idx:'int'   , value:'float'   ) -> None:
    r'''
				Sets the value of the blend shape at `blend_shape_idx` to `value`. Produces an error if `mesh` is `null` or doesn't have a blend shape at that index.
			'''

    assert isinstance(blend_shape_idx, (int, float)), 'blend_shape_idx must be int or float'
    assert isinstance(value, (int, float)), 'value must be int or float'








    self._ptr.call_with_return(315,tuple([blend_shape_idx, value]))

  @functools.native_method
  def create_debug_tangents(self) -> None:
    r'''
				This helper creates a `MeshInstance3D` child node with gizmos at every vertex calculated from the mesh geometry. It's mainly used for testing.
			'''




    self._ptr.call_with_return(316,tuple([]))

  @functools.native_method
  def bake_mesh_from_current_blend_shape_mix(self, existing:'py4godot_arraymesh.ArrayMesh' = None  ) -> typing.Union['py4godot_arraymesh.ArrayMesh']:
    r'''
				Takes a snapshot from the current `ArrayMesh` with all blend shapes applied according to their current weights and bakes it to the provided `existing` mesh. If no `existing` mesh is provided a new `ArrayMesh` is created, baked and returned. Mesh surface materials are not copied.
				**Performance:** `Mesh` data needs to be received from the GPU, stalling the `RenderingServer` in the process.
			'''
    if existing is None:
      existing = c_utils.empty_object








    _ret = classes.Object.Object.construct_without_init() #Smart casted to: ArrayMesh
    _ret._ptr = self._ptr.call_with_return(317,tuple([existing._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def bake_mesh_from_current_skeleton_pose(self, existing:'py4godot_arraymesh.ArrayMesh' = None  ) -> typing.Union['py4godot_arraymesh.ArrayMesh']:
    r'''
				Takes a snapshot of the current animated skeleton pose of the skinned mesh and bakes it to the provided `existing` mesh. If no `existing` mesh is provided a new `ArrayMesh` is created, baked, and returned. Requires a skeleton with a registered skin to work. Blendshapes are ignored. Mesh surface materials are not copied.
				**Performance:** `Mesh` data needs to be retrieved from the GPU, stalling the `RenderingServer` in the process.
			'''
    if existing is None:
      existing = c_utils.empty_object








    _ret = classes.Object.Object.construct_without_init() #Smart casted to: ArrayMesh
    _ret._ptr = self._ptr.call_with_return(318,tuple([existing._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None



register_cast_function('MeshInstance3D', MeshInstance3D.cast)
register_class('MeshInstance3D', MeshInstance3D)
