# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.TextServerAdvanced as py4godot_textserveradvanced 
  import py4godot.classes.Font as py4godot_font 
  import py4godot.classes.TextServerDummy as py4godot_textserverdummy 
  import py4godot.classes.TextServer as py4godot_textserver 
  import py4godot.classes.TextServerExtension as py4godot_textserverextension 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPTextParagraphWrapper


class TextParagraph(py4godot_refcounted.RefCounted):
  r'''
		Abstraction over `TextServer` for handling a single paragraph of text.
	'''

  @staticmethod
  def constructor():
    class_ = TextParagraph.construct_without_init()
    class_._ptr = constructor(811,0, ())
    return class_
  @staticmethod
  def new():
    class_ = TextParagraph.construct_without_init()
    class_._ptr = constructor(811,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPTextParagraphWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(811,0, ())


  def generate_wrapper(self):
    return CPPTextParagraphWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = TextParagraph.__new__(TextParagraph)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'TextParagraph'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(113, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = TextParagraph.construct_without_init()
    cls._ptr = CPPTextParagraphWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = TextParagraph.construct_without_init()
    cls._ptr = CPPTextParagraphWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def direction(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_direction()
    return _ret
  @direction.setter
  def direction(self,  value:'int'):
    self.set_direction(value)
  @property
  def custom_punctuation(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_custom_punctuation()
    return _ret
  @custom_punctuation.setter
  def custom_punctuation(self,  value:'str'):
    self.set_custom_punctuation(value)
  @property
  def orientation(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_orientation()
    return _ret
  @orientation.setter
  def orientation(self,  value:'int'):
    self.set_orientation(value)
  @property
  def preserve_invalid(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_preserve_invalid()
    return _ret
  @preserve_invalid.setter
  def preserve_invalid(self,  value:'bool'):
    self.set_preserve_invalid(value)
  @property
  def preserve_control(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_preserve_control()
    return _ret
  @preserve_control.setter
  def preserve_control(self,  value:'bool'):
    self.set_preserve_control(value)
  @property
  def alignment(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_alignment()
    return _ret
  @alignment.setter
  def alignment(self,  value:'int'):
    self.set_alignment(value)
  @property
  def break_flags(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_break_flags()
    return _ret
  @break_flags.setter
  def break_flags(self,  value:'int'):
    self.set_break_flags(value)
  @property
  def justification_flags(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_justification_flags()
    return _ret
  @justification_flags.setter
  def justification_flags(self,  value:'int'):
    self.set_justification_flags(value)
  @property
  def text_overrun_behavior(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_text_overrun_behavior()
    return _ret
  @text_overrun_behavior.setter
  def text_overrun_behavior(self,  value:'int'):
    self.set_text_overrun_behavior(value)
  @property
  def ellipsis_char(self) -> typing.Union[str]:
    r''''''
    _ret = self. get_ellipsis_char()
    return _ret
  @ellipsis_char.setter
  def ellipsis_char(self,  value:'str'):
    self.set_ellipsis_char(value)
  @property
  def width(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_width()
    return _ret
  @width.setter
  def width(self,  value:'float'):
    self.set_width(value)
  @property
  def max_lines_visible(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_lines_visible()
    return _ret
  @max_lines_visible.setter
  def max_lines_visible(self,  value:'int'):
    self.set_max_lines_visible(value)
  @property
  def line_spacing(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_line_spacing()
    return _ret
  @line_spacing.setter
  def line_spacing(self,  value:'float'):
    self.set_line_spacing(value)
  @functools.native_method
  def clear(self) -> None:
    r'''
				Clears text paragraph (removes text and inline objects).
			'''




    self._ptr.call_with_return(53,tuple([]))

  @functools.native_method
  def set_direction(self, direction:'int'  ) -> None:
    r''''''

    assert isinstance(direction, (int, float)), 'direction must be int or float'


    self.py__direction = direction






    self._ptr.call_with_return(54,tuple([direction]))

  @functools.native_method
  def get_direction(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(55,tuple([]))

    return _ret


  @functools.native_method
  def get_inferred_direction(self) -> typing.Union[int]:
    r'''
				Returns the text writing direction inferred by the BiDi algorithm.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(56,tuple([]))
    return _ret


  @functools.native_method
  def set_custom_punctuation(self, custom_punctuation:'str'   ) -> None:
    r''''''

    assert(not custom_punctuation is None)
    assert isinstance(custom_punctuation, (str, String)), 'custom_punctuation must be str or String'


    self.py__custom_punctuation = custom_punctuation



    assert(isinstance(custom_punctuation, (str, String)))
    py_string_custom_punctuation = custom_punctuation if isinstance(custom_punctuation, StringName) else c_utils.py_string_to_string(custom_punctuation)

    py__string_custom_punctuation = utils.py_string_to_string(custom_punctuation)
    py__string_custom_punctuation.shouldBeDeleted = False


    self._ptr.call_with_return(57,tuple([py__string_custom_punctuation._ptr]))

  @functools.native_method
  def get_custom_punctuation(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_orientation(self, orientation:'int'  ) -> None:
    r''''''

    assert isinstance(orientation, (int, float)), 'orientation must be int or float'


    self.py__orientation = orientation






    self._ptr.call_with_return(59,tuple([orientation]))

  @functools.native_method
  def get_orientation(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(60,tuple([]))

    return _ret


  @functools.native_method
  def set_preserve_invalid(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__preserve_invalid = enabled






    self._ptr.call_with_return(61,tuple([enabled]))

  @functools.native_method
  def get_preserve_invalid(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(62,tuple([]))

    return _ret


  @functools.native_method
  def set_preserve_control(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__preserve_control = enabled






    self._ptr.call_with_return(63,tuple([enabled]))

  @functools.native_method
  def get_preserve_control(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(64,tuple([]))

    return _ret


  @functools.native_method
  def set_bidi_override(self, override:'Array'   ) -> None:
    r'''
				Overrides BiDi for the structured text.
				Override ranges should cover full source text without overlaps. BiDi algorithm will be used on each range separately.
			'''

    assert(not override is None)
    assert isinstance(override, Array), 'override must be Array'







    self._ptr.call_with_return(65,tuple([override._ptr]))

  @functools.native_method
  def set_dropcap(self, text:'str'   , font:'py4godot_font.Font'   , font_size:'int'   , dropcap_margins:'Rect2' = None  , language:'str' =""  ) -> typing.Union[bool]:
    r'''
				Sets drop cap, overrides previously set drop cap. Drop cap (dropped capital) is a decorative element at the beginning of a paragraph that is larger than the rest of the text.
			'''
    if dropcap_margins is None:
      dropcap_margins = Rect2.new0()
    if language is None:
      language = String.new0()

    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'





    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)



    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)

    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([py_string_text._ptr, font._ptr, font_size, dropcap_margins._ptr, py_string_language._ptr]))
    return _ret


  @functools.native_method
  def clear_dropcap(self) -> None:
    r'''
				Removes dropcap.
			'''




    self._ptr.call_with_return(67,tuple([]))

  @functools.native_method
  def add_string(self, text:'str'   , font:'py4godot_font.Font'   , font_size:'int'   , language:'str' =""  , meta:'object' =None  ) -> typing.Union[bool]:
    r'''
				Adds text span and font to draw it.
			'''
    if language is None:
      language = String.new0()


    assert(not text is None)
    assert isinstance(text, (str, String)), 'text must be str or String'
    assert(not font is None)
    assert isinstance(font, get_class('Font')), 'font must be Font'
    assert isinstance(font_size, (int, float)), 'font_size must be int or float'
    

    if not (type(meta).__name__ in py4godot.variant_types.core_types or isinstance(meta, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'meta': "
                f"{type(meta).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(text, (str, String)))
    py_string_text = text if isinstance(text, StringName) else c_utils.py_string_to_string(text)


    assert(isinstance(language, (str, String)))
    py_string_language = language if isinstance(language, StringName) else c_utils.py_string_to_string(language)


    _ret = 0
    _ret = self._ptr.call_with_return(68,tuple([py_string_text._ptr, font._ptr, font_size, py_string_language._ptr, meta]))
    return _ret


  @functools.native_method
  def add_object(self, key:'object'   , size:'Vector2'   , inline_align:'int'  =5, length:'int' =1  , baseline:'float' =0.0  ) -> typing.Union[bool]:
    r'''
				Adds inline object to the text buffer, `key` must be unique. In the text, object is represented as `length` object replacement characters.
			'''


    
    assert(not size is None)
    assert isinstance(size, Vector2), 'size must be Vector2'
    assert isinstance(inline_align, (int, float)), 'inline_align must be int or float'
    assert isinstance(length, (int, float)), 'length must be int or float'
    assert isinstance(baseline, (int, float)), 'baseline must be int or float'

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )










    _ret = 0
    _ret = self._ptr.call_with_return(69,tuple([key, size._ptr, inline_align, length, baseline]))
    return _ret


  @functools.native_method
  def resize_object(self, key:'object'   , size:'Vector2'   , inline_align:'int'  =5, baseline:'float' =0.0  ) -> typing.Union[bool]:
    r'''
				Sets new size and alignment of embedded object.
			'''


    
    assert(not size is None)
    assert isinstance(size, Vector2), 'size must be Vector2'
    assert isinstance(inline_align, (int, float)), 'inline_align must be int or float'
    assert isinstance(baseline, (int, float)), 'baseline must be int or float'

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )









    _ret = 0
    _ret = self._ptr.call_with_return(70,tuple([key, size._ptr, inline_align, baseline]))
    return _ret


  @functools.native_method
  def set_alignment(self, alignment:'int'  ) -> None:
    r''''''

    assert isinstance(alignment, (int, float)), 'alignment must be int or float'


    self.py__alignment = alignment






    self._ptr.call_with_return(71,tuple([alignment]))

  @functools.native_method
  def get_alignment(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(72,tuple([]))

    return _ret


  @functools.native_method
  def tab_align(self, tab_stops:'PackedFloat32Array'   ) -> None:
    r'''
				Aligns paragraph to the given tab-stops.
			'''

    assert(not tab_stops is None)
    assert isinstance(tab_stops, PackedFloat32Array), 'tab_stops must be PackedFloat32Array'







    self._ptr.call_with_return(73,tuple([tab_stops._ptr]))

  @functools.native_method
  def set_break_flags(self, flags:'int'   ) -> None:
    r''''''

    assert isinstance(flags, (int, float)), 'flags must be int or float'


    self.py__break_flags = flags






    self._ptr.call_with_return(74,tuple([flags]))

  @functools.native_method
  def get_break_flags(self) -> typing.Union[int]:
    r''''''




    _ret
    _ret = self._ptr.call_with_return(75,tuple([]))

    return _ret


  @functools.native_method
  def set_justification_flags(self, flags:'int'   ) -> None:
    r''''''

    assert isinstance(flags, (int, float)), 'flags must be int or float'


    self.py__justification_flags = flags






    self._ptr.call_with_return(76,tuple([flags]))

  @functools.native_method
  def get_justification_flags(self) -> typing.Union[int]:
    r''''''




    _ret
    _ret = self._ptr.call_with_return(77,tuple([]))

    return _ret


  @functools.native_method
  def set_text_overrun_behavior(self, overrun_behavior:'int'  ) -> None:
    r''''''

    assert isinstance(overrun_behavior, (int, float)), 'overrun_behavior must be int or float'


    self.py__text_overrun_behavior = overrun_behavior






    self._ptr.call_with_return(78,tuple([overrun_behavior]))

  @functools.native_method
  def get_text_overrun_behavior(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(79,tuple([]))

    return _ret


  @functools.native_method
  def set_ellipsis_char(self, char:'str'   ) -> None:
    r''''''

    assert(not char is None)
    assert isinstance(char, (str, String)), 'char must be str or String'


    self.py__ellipsis_char = char



    assert(isinstance(char, (str, String)))
    py_string_char = char if isinstance(char, StringName) else c_utils.py_string_to_string(char)

    py__string_char = utils.py_string_to_string(char)
    py__string_char.shouldBeDeleted = False


    self._ptr.call_with_return(80,tuple([py__string_char._ptr]))

  @functools.native_method
  def get_ellipsis_char(self) -> typing.Union[str]:
    r''''''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([]))

    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_width(self, width:'float'   ) -> None:
    r''''''

    assert isinstance(width, (int, float)), 'width must be int or float'


    self.py__width = width






    self._ptr.call_with_return(82,tuple([width]))

  @functools.native_method
  def get_width(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(83,tuple([]))

    return _ret


  @functools.native_method
  def get_non_wrapped_size(self) -> typing.Union['Vector2']:
    r'''
				Returns the size of the bounding box of the paragraph, without line breaks.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(84,tuple([]))
    return _ret


  @functools.native_method
  def get_size(self) -> typing.Union['Vector2']:
    r'''
				Returns the size of the bounding box of the paragraph.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(85,tuple([]))
    return _ret


  @functools.native_method
  def get_rid(self) -> typing.Union['RID']:
    r'''
				Returns TextServer full string buffer RID.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def get_line_rid(self, line:'int'   ) -> typing.Union['RID']:
    r'''
				Returns TextServer line buffer RID.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([line]))
    return _ret


  @functools.native_method
  def get_dropcap_rid(self) -> typing.Union['RID']:
    r'''
				Returns drop cap text buffer RID.
			'''




    _ret = RID.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([]))
    return _ret


  @functools.native_method
  def get_range(self) -> typing.Union['Vector2i']:
    r'''
				Returns the character range of the paragraph.
			'''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(89,tuple([]))
    return _ret


  @functools.native_method
  def get_line_count(self) -> typing.Union[int]:
    r'''
				Returns number of lines in the paragraph.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([]))
    return _ret


  @functools.native_method
  def set_max_lines_visible(self, max_lines_visible:'int'   ) -> None:
    r''''''

    assert isinstance(max_lines_visible, (int, float)), 'max_lines_visible must be int or float'


    self.py__max_lines_visible = max_lines_visible






    self._ptr.call_with_return(91,tuple([max_lines_visible]))

  @functools.native_method
  def get_max_lines_visible(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([]))

    return _ret


  @functools.native_method
  def set_line_spacing(self, line_spacing:'float'   ) -> None:
    r''''''

    assert isinstance(line_spacing, (int, float)), 'line_spacing must be int or float'


    self.py__line_spacing = line_spacing






    self._ptr.call_with_return(93,tuple([line_spacing]))

  @functools.native_method
  def get_line_spacing(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([]))

    return _ret


  @functools.native_method
  def get_line_objects(self, line:'int'   ) -> typing.Union['Array']:
    r'''
				Returns array of inline objects in the line.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(95,tuple([line]))
    return _ret


  @functools.native_method
  def get_line_object_rect(self, line:'int'   , key:'object'   ) -> typing.Union['Rect2']:
    r'''
				Returns bounding rectangle of the inline object.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'
    

    if not (type(key).__name__ in py4godot.variant_types.core_types or isinstance(key, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'key': "
                f"{type(key).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )







    _ret = Rect2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([line, key]))
    return _ret


  @functools.native_method
  def get_line_size(self, line:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns size of the bounding box of the line of text. Returned size is rounded up.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(97,tuple([line]))
    return _ret


  @functools.native_method
  def get_line_range(self, line:'int'   ) -> typing.Union['Vector2i']:
    r'''
				Returns character range of the line.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(98,tuple([line]))
    return _ret


  @functools.native_method
  def get_line_ascent(self, line:'int'   ) -> typing.Union[float]:
    r'''
				Returns the text line ascent (number of pixels above the baseline for horizontal layout or to the left of baseline for vertical).
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([line]))
    return _ret


  @functools.native_method
  def get_line_descent(self, line:'int'   ) -> typing.Union[float]:
    r'''
				Returns the text line descent (number of pixels below the baseline for horizontal layout or to the right of baseline for vertical).
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([line]))
    return _ret


  @functools.native_method
  def get_line_width(self, line:'int'   ) -> typing.Union[float]:
    r'''
				Returns width (for horizontal layout) or height (for vertical) of the line of text.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(101,tuple([line]))
    return _ret


  @functools.native_method
  def get_line_underline_position(self, line:'int'   ) -> typing.Union[float]:
    r'''
				Returns pixel offset of the underline below the baseline.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([line]))
    return _ret


  @functools.native_method
  def get_line_underline_thickness(self, line:'int'   ) -> typing.Union[float]:
    r'''
				Returns thickness of the underline.
			'''

    assert isinstance(line, (int, float)), 'line must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(103,tuple([line]))
    return _ret


  @functools.native_method
  def get_dropcap_size(self) -> typing.Union['Vector2']:
    r'''
				Returns drop cap bounding box size.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(104,tuple([]))
    return _ret


  @functools.native_method
  def get_dropcap_lines(self) -> typing.Union[int]:
    r'''
				Returns number of lines used by dropcap.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(105,tuple([]))
    return _ret


  @functools.native_method
  def draw(self, canvas:'RID'   , pos:'Vector2'   , color:'Color' = None  , dc_color:'Color' = None  , oversampling:'float' =0.0  ) -> None:
    r'''
				Draw all lines of the text and drop cap into a canvas item at a given position, with `color`. `pos` specifies the top left corner of the bounding box. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''
    if color is None:
      color = Color.new0()
    if dc_color is None:
      dc_color = Color.new0()

    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'











    self._ptr.call_with_return(106,tuple([canvas._ptr, pos._ptr, color._ptr, dc_color._ptr, oversampling]))

  @functools.native_method
  def draw_outline(self, canvas:'RID'   , pos:'Vector2'   , outline_size:'int' =1  , color:'Color' = None  , dc_color:'Color' = None  , oversampling:'float' =0.0  ) -> None:
    r'''
				Draw outlines of all lines of the text and drop cap into a canvas item at a given position, with `color`. `pos` specifies the top left corner of the bounding box. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''
    if color is None:
      color = Color.new0()
    if dc_color is None:
      dc_color = Color.new0()

    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(outline_size, (int, float)), 'outline_size must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'












    self._ptr.call_with_return(107,tuple([canvas._ptr, pos._ptr, outline_size, color._ptr, dc_color._ptr, oversampling]))

  @functools.native_method
  def draw_line(self, canvas:'RID'   , pos:'Vector2'   , line:'int'   , color:'Color' = None  , oversampling:'float' =0.0  ) -> None:
    r'''
				Draw single line of text into a canvas item at a given position, with `color`. `pos` specifies the top left corner of the bounding box. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''
    if color is None:
      color = Color.new0()

    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'











    self._ptr.call_with_return(108,tuple([canvas._ptr, pos._ptr, line, color._ptr, oversampling]))

  @functools.native_method
  def draw_line_outline(self, canvas:'RID'   , pos:'Vector2'   , line:'int'   , outline_size:'int' =1  , color:'Color' = None  , oversampling:'float' =0.0  ) -> None:
    r'''
				Draw outline of the single line of text into a canvas item at a given position, with `color`. `pos` specifies the top left corner of the bounding box. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''
    if color is None:
      color = Color.new0()

    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(line, (int, float)), 'line must be int or float'
    assert isinstance(outline_size, (int, float)), 'outline_size must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'












    self._ptr.call_with_return(109,tuple([canvas._ptr, pos._ptr, line, outline_size, color._ptr, oversampling]))

  @functools.native_method
  def draw_dropcap(self, canvas:'RID'   , pos:'Vector2'   , color:'Color' = None  , oversampling:'float' =0.0  ) -> None:
    r'''
				Draw drop cap into a canvas item at a given position, with `color`. `pos` specifies the top left corner of the bounding box. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''
    if color is None:
      color = Color.new0()

    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'










    self._ptr.call_with_return(110,tuple([canvas._ptr, pos._ptr, color._ptr, oversampling]))

  @functools.native_method
  def draw_dropcap_outline(self, canvas:'RID'   , pos:'Vector2'   , outline_size:'int' =1  , color:'Color' = None  , oversampling:'float' =0.0  ) -> None:
    r'''
				Draw drop cap outline into a canvas item at a given position, with `color`. `pos` specifies the top left corner of the bounding box. If `oversampling` is greater than zero, it is used as font oversampling factor, otherwise viewport oversampling settings are used.
			'''
    if color is None:
      color = Color.new0()

    assert(not canvas is None)
    assert isinstance(canvas, RID), 'canvas must be RID'
    assert(not pos is None)
    assert isinstance(pos, Vector2), 'pos must be Vector2'
    assert isinstance(outline_size, (int, float)), 'outline_size must be int or float'
    assert isinstance(oversampling, (int, float)), 'oversampling must be int or float'











    self._ptr.call_with_return(111,tuple([canvas._ptr, pos._ptr, outline_size, color._ptr, oversampling]))

  @functools.native_method
  def hit_test(self, coords:'Vector2'   ) -> typing.Union[int]:
    r'''
				Returns caret character offset at the specified coordinates. This function always returns a valid position.
			'''

    assert(not coords is None)
    assert isinstance(coords, Vector2), 'coords must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(112,tuple([coords._ptr]))
    return _ret



register_cast_function('TextParagraph', TextParagraph.cast)
register_class('TextParagraph', TextParagraph)
