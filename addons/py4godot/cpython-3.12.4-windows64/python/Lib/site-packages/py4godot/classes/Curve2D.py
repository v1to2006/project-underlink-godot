# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPCurve2DWrapper


class Curve2D(py4godot_resource.Resource):
  r'''
		This class describes a BÃ©zier curve in 2D space. It is mainly used to give a shape to a `Path2D`, but can be manually sampled for other purposes.
		It keeps a cache of precalculated points along the curve, to speed up further calculations.
	'''

  @staticmethod
  def constructor():
    class_ = Curve2D.construct_without_init()
    class_._ptr = constructor(249,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Curve2D.construct_without_init()
    class_._ptr = constructor(249,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPCurve2DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(249,0, ())


  def generate_wrapper(self):
    return CPPCurve2DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = Curve2D.__new__(Curve2D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Curve2D'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(100, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Curve2D.construct_without_init()
    cls._ptr = CPPCurve2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Curve2D.construct_without_init()
    cls._ptr = CPPCurve2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def bake_interval(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_bake_interval()
    return _ret
  @bake_interval.setter
  def bake_interval(self,  value:'float'):
    self.set_bake_interval(value)
  @property
  def point_count(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_point_count()
    return _ret
  @point_count.setter
  def point_count(self,  value:'int'):
    self.set_point_count(value)
  @functools.native_method
  def get_point_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(77,tuple([]))

    return _ret


  @functools.native_method
  def set_point_count(self, count:'int'   ) -> None:
    r''''''

    assert isinstance(count, (int, float)), 'count must be int or float'


    self.py__point_count = count






    self._ptr.call_with_return(78,tuple([count]))

  @functools.native_method
  def add_point(self, position:'Vector2'   , in_:'Vector2' = None  , out:'Vector2' = None  , index:'int' =-1  ) -> None:
    r'''
				Adds a point with the specified `position` relative to the curve's own position, with control points `in` and `out`. Appends the new point at the end of the point list.
				If `index` is given, the new point is inserted before the existing point identified by index `index`. Every existing point starting from `index` is shifted further down the list of points. The index must be greater than or equal to `0` and must not exceed the number of existing points in the line. See `point_count`.
			'''
    if in_ is None:
      in_ = Vector2.new0()
    if out is None:
      out = Vector2.new0()

    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'
    assert isinstance(index, (int, float)), 'index must be int or float'










    self._ptr.call_with_return(79,tuple([position._ptr, in_._ptr, out._ptr, index]))

  @functools.native_method
  def set_point_position(self, idx:'int'   , position:'Vector2'   ) -> None:
    r'''
				Sets the position for the vertex `idx`. If the index is out of bounds, the function sends an error to the console.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'








    self._ptr.call_with_return(80,tuple([idx, position._ptr]))

  @functools.native_method
  def get_point_position(self, idx:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the position of the vertex `idx`. If the index is out of bounds, the function sends an error to the console, and returns `(0, 0)`.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(81,tuple([idx]))
    return _ret


  @functools.native_method
  def set_point_in(self, idx:'int'   , position:'Vector2'   ) -> None:
    r'''
				Sets the position of the control point leading to the vertex `idx`. If the index is out of bounds, the function sends an error to the console. The position is relative to the vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'








    self._ptr.call_with_return(82,tuple([idx, position._ptr]))

  @functools.native_method
  def get_point_in(self, idx:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the position of the control point leading to the vertex `idx`. The returned position is relative to the vertex `idx`. If the index is out of bounds, the function sends an error to the console, and returns `(0, 0)`.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(83,tuple([idx]))
    return _ret


  @functools.native_method
  def set_point_out(self, idx:'int'   , position:'Vector2'   ) -> None:
    r'''
				Sets the position of the control point leading out of the vertex `idx`. If the index is out of bounds, the function sends an error to the console. The position is relative to the vertex.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'








    self._ptr.call_with_return(84,tuple([idx, position._ptr]))

  @functools.native_method
  def get_point_out(self, idx:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the position of the control point leading out of the vertex `idx`. The returned position is relative to the vertex `idx`. If the index is out of bounds, the function sends an error to the console, and returns `(0, 0)`.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(85,tuple([idx]))
    return _ret


  @functools.native_method
  def remove_point(self, idx:'int'   ) -> None:
    r'''
				Deletes the point `idx` from the curve. Sends an error to the console if `idx` is out of bounds.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'







    self._ptr.call_with_return(86,tuple([idx]))

  @functools.native_method
  def clear_points(self) -> None:
    r'''
				Removes all points from the curve.
			'''




    self._ptr.call_with_return(87,tuple([]))

  @functools.native_method
  def sample(self, idx:'int'   , t:'float'   ) -> typing.Union['Vector2']:
    r'''
				Returns the position between the vertex `idx` and the vertex `idx + 1`, where `t` controls if the point is the first vertex (`t = 0.0`), the last vertex (`t = 1.0`), or in between. Values of `t` outside the range (`0.0 <= t <= 1.0`) give strange, but predictable results.
				If `idx` is out of bounds it is truncated to the first or last vertex, and `t` is ignored. If the curve has no points, the function sends an error to the console, and returns `(0, 0)`.
			'''

    assert isinstance(idx, (int, float)), 'idx must be int or float'
    assert isinstance(t, (int, float)), 't must be int or float'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([idx, t]))
    return _ret


  @functools.native_method
  def samplef(self, fofs:'float'   ) -> typing.Union['Vector2']:
    r'''
				Returns the position at the vertex `fofs`. It calls `sample` using the integer part of `fofs` as `idx`, and its fractional part as `t`.
			'''

    assert isinstance(fofs, (int, float)), 'fofs must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(89,tuple([fofs]))
    return _ret


  @functools.native_method
  def set_bake_interval(self, distance:'float'   ) -> None:
    r''''''

    assert isinstance(distance, (int, float)), 'distance must be int or float'


    self.py__bake_interval = distance






    self._ptr.call_with_return(90,tuple([distance]))

  @functools.native_method
  def get_bake_interval(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(91,tuple([]))

    return _ret


  @functools.native_method
  def get_baked_length(self) -> typing.Union[float]:
    r'''
				Returns the total length of the curve, based on the cached points. Given enough density (see `bake_interval`), it should be approximate enough.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([]))
    return _ret


  @functools.native_method
  def sample_baked(self, offset:'float' =0.0  , cubic:'bool' =False  ) -> typing.Union['Vector2']:
    r'''
				Returns a point within the curve at position `offset`, where `offset` is measured as a pixel distance along the curve.
				To do that, it finds the two cached points where the `offset` lies between, then interpolates the values. This interpolation is cubic if `cubic` is set to `true`, or linear if set to `false`.
				Cubic interpolation tends to follow the curves better, but linear is faster (and often, precise enough).
			'''

    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert isinstance(cubic, bool), 'cubic must be bool'








    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(93,tuple([offset, cubic]))
    return _ret


  @functools.native_method
  def sample_baked_with_rotation(self, offset:'float' =0.0  , cubic:'bool' =False  ) -> typing.Union['Transform2D']:
    r'''
				Similar to `sample_baked`, but returns `Transform2D` that includes a rotation along the curve, with `Transform2D.origin` as the point position and the `Transform2D.x` vector pointing in the direction of the path at that point. Returns an empty transform if the length of the curve is `0`.
				```gdscript
				var baked = curve.sample_baked_with_rotation(offset)
				# The returned Transform2D can be set directly.
				transform = baked
				# You can also read the origin and rotation separately from the returned Transform2D.
				position = baked.get_origin()
				rotation = baked.get_rotation()
				```
			'''

    assert isinstance(offset, (int, float)), 'offset must be int or float'
    assert isinstance(cubic, bool), 'cubic must be bool'








    _ret = Transform2D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(94,tuple([offset, cubic]))
    return _ret


  @functools.native_method
  def get_baked_points(self) -> typing.Union['PackedVector2Array']:
    r'''
				Returns the cache of points as a `PackedVector2Array`.
			'''




    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(95,tuple([]))
    return _ret


  @functools.native_method
  def get_closest_point(self, to_point:'Vector2'   ) -> typing.Union['Vector2']:
    r'''
				Returns the closest point on baked segments (in curve's local space) to `to_point`.
				`to_point` must be in this curve's local space.
			'''

    assert(not to_point is None)
    assert isinstance(to_point, Vector2), 'to_point must be Vector2'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(96,tuple([to_point._ptr]))
    return _ret


  @functools.native_method
  def get_closest_offset(self, to_point:'Vector2'   ) -> typing.Union[float]:
    r'''
				Returns the closest offset to `to_point`. This offset is meant to be used in `sample_baked`.
				`to_point` must be in this curve's local space.
			'''

    assert(not to_point is None)
    assert isinstance(to_point, Vector2), 'to_point must be Vector2'







    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([to_point._ptr]))
    return _ret


  @functools.native_method
  def tessellate(self, max_stages:'int' =5  , tolerance_degrees:'float' =4  ) -> typing.Union['PackedVector2Array']:
    r'''
				Returns a list of points along the curve, with a curvature controlled point density. That is, the curvier parts will have more points than the straighter parts.
				This approximation makes straight segments between each point, then subdivides those segments until the resulting shape is similar enough.
				`max_stages` controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care!
				`tolerance_degrees` controls how many degrees the midpoint of a segment may deviate from the real curve, before the segment has to be subdivided.
			'''

    assert isinstance(max_stages, (int, float)), 'max_stages must be int or float'
    assert isinstance(tolerance_degrees, (int, float)), 'tolerance_degrees must be int or float'








    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(98,tuple([max_stages, tolerance_degrees]))
    return _ret


  @functools.native_method
  def tessellate_even_length(self, max_stages:'int' =5  , tolerance_length:'float' =20.0  ) -> typing.Union['PackedVector2Array']:
    r'''
				Returns a list of points along the curve, with almost uniform density. `max_stages` controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care!
				`tolerance_length` controls the maximal distance between two neighboring points, before the segment has to be subdivided.
			'''

    assert isinstance(max_stages, (int, float)), 'max_stages must be int or float'
    assert isinstance(tolerance_length, (int, float)), 'tolerance_length must be int or float'








    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(99,tuple([max_stages, tolerance_length]))
    return _ret



register_cast_function('Curve2D', Curve2D.cast)
register_class('Curve2D', Curve2D)
