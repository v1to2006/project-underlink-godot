# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Curve as py4godot_curve 
import py4godot.classes.SkeletonModifier3D as py4godot_skeletonmodifier3d 
from py4godot.wrappers.wrappers import CPPSpringBoneSimulator3DWrapper

class BoneDirection:
  BONE_DIRECTION_PLUS_X = 0
  BONE_DIRECTION_MINUS_X = 1
  BONE_DIRECTION_PLUS_Y = 2
  BONE_DIRECTION_MINUS_Y = 3
  BONE_DIRECTION_PLUS_Z = 4
  BONE_DIRECTION_MINUS_Z = 5
  BONE_DIRECTION_FROM_PARENT = 6
class CenterFrom:
  CENTER_FROM_WORLD_ORIGIN = 0
  CENTER_FROM_NODE = 1
  CENTER_FROM_BONE = 2
class RotationAxis:
  ROTATION_AXIS_X = 0
  ROTATION_AXIS_Y = 1
  ROTATION_AXIS_Z = 2
  ROTATION_AXIS_ALL = 3
  ROTATION_AXIS_CUSTOM = 4


class SpringBoneSimulator3D(py4godot_skeletonmodifier3d.SkeletonModifier3D):
  r'''
		This `SkeletonModifier3D` can be used to wiggle hair, cloth, and tails. This modifier behaves differently from `PhysicalBoneSimulator3D` as it attempts to return the original pose after modification.
		If you setup `set_root_bone` and `set_end_bone`, it is treated as one bone chain. Note that it does not support a branched chain like Y-shaped chains.
		When a bone chain is created, an array is generated from the bones that exist in between and listed in the joint list.
		Several properties can be applied to each joint, such as `set_joint_stiffness`, `set_joint_drag`, and `set_joint_gravity`.
		For simplicity, you can set values to all joints at the same time by using a `Curve`. If you want to specify detailed values individually, set `set_individual_config` to `true`.
		For physical simulation, `SpringBoneSimulator3D` can have children as self-standing collisions that are not related to `PhysicsServer3D`, see also `SpringBoneCollision3D`.
		**Warning:** A scaled `SpringBoneSimulator3D` will likely not behave as expected. Make sure that the parent `Skeleton3D` and its bones are not scaled.
	'''

  @staticmethod
  def constructor():
    class_ = SpringBoneSimulator3D.construct_without_init()
    class_._ptr = constructor(778,0, ())
    return class_
  @staticmethod
  def new():
    class_ = SpringBoneSimulator3D.construct_without_init()
    class_._ptr = constructor(778,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPSpringBoneSimulator3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(778,0, ())


  def generate_wrapper(self):
    return CPPSpringBoneSimulator3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = SpringBoneSimulator3D.__new__(SpringBoneSimulator3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'SpringBoneSimulator3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = SpringBoneSimulator3D.construct_without_init()
    cls._ptr = CPPSpringBoneSimulator3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = SpringBoneSimulator3D.construct_without_init()
    cls._ptr = CPPSpringBoneSimulator3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def external_force(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_external_force()
    return _ret
  @external_force.setter
  def external_force(self,  value:'Vector3'):
    self.set_external_force(value)
  @property
  def setting_count(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_setting_count()
    return _ret
  @setting_count.setter
  def setting_count(self,  value:'int'):
    self.set_setting_count(value)
  @functools.native_method
  def set_root_bone_name(self, index:'int'   , bone_name:'str'   ) -> None:
    r'''
				Sets the root bone name of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not bone_name is None)
    assert isinstance(bone_name, (str, String)), 'bone_name must be str or String'






    assert(isinstance(bone_name, (str, String)))
    py_string_bone_name = bone_name if isinstance(bone_name, StringName) else c_utils.py_string_to_string(bone_name)

    self._ptr.call_with_return(260,tuple([index, py_string_bone_name._ptr]))

  @functools.native_method
  def get_root_bone_name(self, index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the root bone name of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(261,tuple([index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_root_bone(self, index:'int'   , bone:'int'   ) -> None:
    r'''
				Sets the root bone index of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(bone, (int, float)), 'bone must be int or float'








    self._ptr.call_with_return(262,tuple([index, bone]))

  @functools.native_method
  def get_root_bone(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the root bone index of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(263,tuple([index]))
    return _ret


  @functools.native_method
  def set_end_bone_name(self, index:'int'   , bone_name:'str'   ) -> None:
    r'''
				Sets the end bone name of the bone chain.
				**Note:** End bone must be the root bone or a child of the root bone. If they are the same, the tail must be extended by `set_extend_end_bone` to jiggle the bone.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not bone_name is None)
    assert isinstance(bone_name, (str, String)), 'bone_name must be str or String'






    assert(isinstance(bone_name, (str, String)))
    py_string_bone_name = bone_name if isinstance(bone_name, StringName) else c_utils.py_string_to_string(bone_name)

    self._ptr.call_with_return(264,tuple([index, py_string_bone_name._ptr]))

  @functools.native_method
  def get_end_bone_name(self, index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the end bone name of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(265,tuple([index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_end_bone(self, index:'int'   , bone:'int'   ) -> None:
    r'''
				Sets the end bone index of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(bone, (int, float)), 'bone must be int or float'








    self._ptr.call_with_return(266,tuple([index, bone]))

  @functools.native_method
  def get_end_bone(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the end bone index of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(267,tuple([index]))
    return _ret


  @functools.native_method
  def set_extend_end_bone(self, index:'int'   , enabled:'bool'   ) -> None:
    r'''
				If `enabled` is `true`, the end bone is extended to have a tail.
				The extended tail config is allocated to the last element in the joint list. In other words, if you set `enabled` to `false`, the config of the last element in the joint list has no effect in the simulated result.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(268,tuple([index, enabled]))

  @functools.native_method
  def is_end_bone_extended(self, index:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the end bone is extended to have a tail.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(269,tuple([index]))
    return _ret


  @functools.native_method
  def set_end_bone_direction(self, index:'int'   , bone_direction:'int'  ) -> None:
    r'''
				Sets the end bone tail direction of the bone chain when `is_end_bone_extended` is `true`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(bone_direction, (int, float)), 'bone_direction must be int or float'








    self._ptr.call_with_return(270,tuple([index, bone_direction]))

  @functools.native_method
  def get_end_bone_direction(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the tail direction of the end bone of the bone chain when `is_end_bone_extended` is `true`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(271,tuple([index]))
    return _ret


  @functools.native_method
  def set_end_bone_length(self, index:'int'   , length:'float'   ) -> None:
    r'''
				Sets the end bone tail length of the bone chain when `is_end_bone_extended` is `true`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(length, (int, float)), 'length must be int or float'








    self._ptr.call_with_return(272,tuple([index, length]))

  @functools.native_method
  def get_end_bone_length(self, index:'int'   ) -> typing.Union[float]:
    r'''
				Returns the end bone tail length of the bone chain when `is_end_bone_extended` is `true`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(273,tuple([index]))
    return _ret


  @functools.native_method
  def set_center_from(self, index:'int'   , center_from:'int'  ) -> None:
    r'''
				Sets what the center originates from in the bone chain.
				Bone movement is calculated based on the difference in relative distance between center and bone in the previous and next frames.
				For example, if the parent `Skeleton3D` is used as the center, the bones are considered to have not moved if the `Skeleton3D` moves in the world.
				In this case, only a change in the bone pose is considered to be a bone movement.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(center_from, (int, float)), 'center_from must be int or float'








    self._ptr.call_with_return(274,tuple([index, center_from]))

  @functools.native_method
  def get_center_from(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns what the center originates from in the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(275,tuple([index]))
    return _ret


  @functools.native_method
  def set_center_node(self, index:'int'   , node_path:'object'   ) -> None:
    r'''
				Sets the center node path of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not node_path is None)
    assert isinstance(node_path, (str, NodePath)), 'node_path must be str or NodePath'






    assert(isinstance(node_path, (str, NodePath)))
    py_nodepath_node_path = node_path if isinstance(node_path,NodePath) else NodePath.new2(node_path)

    self._ptr.call_with_return(276,tuple([index, py_nodepath_node_path._ptr]))

  @functools.native_method
  def get_center_node(self, index:'int'   ) -> typing.Union['NodePath']:
    r'''
				Returns the center node path of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(277,tuple([index]))
    return _ret


  @functools.native_method
  def set_center_bone_name(self, index:'int'   , bone_name:'str'   ) -> None:
    r'''
				Sets the center bone name of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not bone_name is None)
    assert isinstance(bone_name, (str, String)), 'bone_name must be str or String'






    assert(isinstance(bone_name, (str, String)))
    py_string_bone_name = bone_name if isinstance(bone_name, StringName) else c_utils.py_string_to_string(bone_name)

    self._ptr.call_with_return(278,tuple([index, py_string_bone_name._ptr]))

  @functools.native_method
  def get_center_bone_name(self, index:'int'   ) -> typing.Union[str]:
    r'''
				Returns the center bone name of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(279,tuple([index]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def set_center_bone(self, index:'int'   , bone:'int'   ) -> None:
    r'''
				Sets the center bone index of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(bone, (int, float)), 'bone must be int or float'








    self._ptr.call_with_return(280,tuple([index, bone]))

  @functools.native_method
  def get_center_bone(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the center bone index of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(281,tuple([index]))
    return _ret


  @functools.native_method
  def set_radius(self, index:'int'   , radius:'float'   ) -> None:
    r'''
				Sets the joint radius of the bone chain. It is used to move and slide with the `SpringBoneCollision3D` in the collision list.
				The value is scaled by `set_radius_damping_curve` and cached in each joint setting in the joint list.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(radius, (int, float)), 'radius must be int or float'








    self._ptr.call_with_return(282,tuple([index, radius]))

  @functools.native_method
  def get_radius(self, index:'int'   ) -> typing.Union[float]:
    r'''
				Returns the joint radius of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(283,tuple([index]))
    return _ret


  @functools.native_method
  def set_rotation_axis(self, index:'int'   , axis:'int'  ) -> None:
    r'''
				Sets the rotation axis of the bone chain. If set to a specific axis, it acts like a hinge joint. The value is cached in each joint setting in the joint list.
				The axes are based on the `Skeleton3D.get_bone_rest`'s space, if `axis` is `constant SkeletonModifier3D.ROTATION_AXIS_CUSTOM`, you can specify any axis.
				**Note:** The rotation axis vector and the forward vector shouldn't be colinear to avoid unintended rotation since `SpringBoneSimulator3D` does not factor in twisting forces.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(axis, (int, float)), 'axis must be int or float'








    self._ptr.call_with_return(284,tuple([index, axis]))

  @functools.native_method
  def get_rotation_axis(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the rotation axis of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(285,tuple([index]))
    return _ret


  @functools.native_method
  def set_rotation_axis_vector(self, index:'int'   , vector:'Vector3'   ) -> None:
    r'''
				Sets the rotation axis vector of the bone chain. The value is cached in each joint setting in the joint list.
				This vector is normalized by an internal process and represents the axis around which the bone chain can rotate.
				If the vector length is `0`, it is considered synonymous with `constant SkeletonModifier3D.ROTATION_AXIS_ALL`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not vector is None)
    assert isinstance(vector, Vector3), 'vector must be Vector3'








    self._ptr.call_with_return(286,tuple([index, vector._ptr]))

  @functools.native_method
  def get_rotation_axis_vector(self, index:'int'   ) -> typing.Union['Vector3']:
    r'''
				Returns the rotation axis vector of the bone chain. This vector represents the axis around which the bone chain can rotate. It is determined based on the rotation axis set for the bone chain.
				If `get_rotation_axis` is `constant SkeletonModifier3D.ROTATION_AXIS_ALL`, this method returns `Vector3(0, 0, 0)`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(287,tuple([index]))
    return _ret


  @functools.native_method
  def set_radius_damping_curve(self, index:'int'   , curve:'py4godot_curve.Curve'   ) -> None:
    r'''
				Sets the joint radius damping curve of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not curve is None)
    assert isinstance(curve, get_class('Curve')), 'curve must be Curve'








    self._ptr.call_with_return(288,tuple([index, curve._ptr]))

  @functools.native_method
  def get_radius_damping_curve(self, index:'int'   ) -> typing.Union['py4godot_curve.Curve']:
    r'''
				Returns the joint radius damping curve of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Curve
    _ret._ptr = self._ptr.call_with_return(289,tuple([index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_stiffness(self, index:'int'   , stiffness:'float'   ) -> None:
    r'''
				Sets the stiffness force of the bone chain. The greater the value, the faster it recovers to its initial pose.
				If `stiffness` is `0`, the modified pose will not return to the original pose.
				The value is scaled by `set_stiffness_damping_curve` and cached in each joint setting in the joint list.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(stiffness, (int, float)), 'stiffness must be int or float'








    self._ptr.call_with_return(290,tuple([index, stiffness]))

  @functools.native_method
  def get_stiffness(self, index:'int'   ) -> typing.Union[float]:
    r'''
				Returns the stiffness force of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(291,tuple([index]))
    return _ret


  @functools.native_method
  def set_stiffness_damping_curve(self, index:'int'   , curve:'py4godot_curve.Curve'   ) -> None:
    r'''
				Sets the stiffness force damping curve of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not curve is None)
    assert isinstance(curve, get_class('Curve')), 'curve must be Curve'








    self._ptr.call_with_return(292,tuple([index, curve._ptr]))

  @functools.native_method
  def get_stiffness_damping_curve(self, index:'int'   ) -> typing.Union['py4godot_curve.Curve']:
    r'''
				Returns the stiffness force damping curve of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Curve
    _ret._ptr = self._ptr.call_with_return(293,tuple([index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_drag(self, index:'int'   , drag:'float'   ) -> None:
    r'''
				Sets the drag force of the bone chain. The greater the value, the more suppressed the wiggling.
				The value is scaled by `set_drag_damping_curve` and cached in each joint setting in the joint list.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(drag, (int, float)), 'drag must be int or float'








    self._ptr.call_with_return(294,tuple([index, drag]))

  @functools.native_method
  def get_drag(self, index:'int'   ) -> typing.Union[float]:
    r'''
				Returns the drag force damping curve of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(295,tuple([index]))
    return _ret


  @functools.native_method
  def set_drag_damping_curve(self, index:'int'   , curve:'py4godot_curve.Curve'   ) -> None:
    r'''
				Sets the drag force damping curve of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not curve is None)
    assert isinstance(curve, get_class('Curve')), 'curve must be Curve'








    self._ptr.call_with_return(296,tuple([index, curve._ptr]))

  @functools.native_method
  def get_drag_damping_curve(self, index:'int'   ) -> typing.Union['py4godot_curve.Curve']:
    r'''
				Returns the drag force damping curve of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Curve
    _ret._ptr = self._ptr.call_with_return(297,tuple([index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_gravity(self, index:'int'   , gravity:'float'   ) -> None:
    r'''
				Sets the gravity amount of the bone chain. This value is not an acceleration, but a constant velocity of movement in `set_gravity_direction`.
				If `gravity` is not `0`, the modified pose will not return to the original pose since it is always affected by gravity.
				The value is scaled by `set_gravity_damping_curve` and cached in each joint setting in the joint list.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(gravity, (int, float)), 'gravity must be int or float'








    self._ptr.call_with_return(298,tuple([index, gravity]))

  @functools.native_method
  def get_gravity(self, index:'int'   ) -> typing.Union[float]:
    r'''
				Returns the gravity amount of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(299,tuple([index]))
    return _ret


  @functools.native_method
  def set_gravity_damping_curve(self, index:'int'   , curve:'py4godot_curve.Curve'   ) -> None:
    r'''
				Sets the gravity amount damping curve of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not curve is None)
    assert isinstance(curve, get_class('Curve')), 'curve must be Curve'








    self._ptr.call_with_return(300,tuple([index, curve._ptr]))

  @functools.native_method
  def get_gravity_damping_curve(self, index:'int'   ) -> typing.Union['py4godot_curve.Curve']:
    r'''
				Returns the gravity amount damping curve of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Curve
    _ret._ptr = self._ptr.call_with_return(301,tuple([index]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_gravity_direction(self, index:'int'   , gravity_direction:'Vector3'   ) -> None:
    r'''
				Sets the gravity direction of the bone chain. This value is internally normalized and then multiplied by `set_gravity`.
				The value is cached in each joint setting in the joint list.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert(not gravity_direction is None)
    assert isinstance(gravity_direction, Vector3), 'gravity_direction must be Vector3'








    self._ptr.call_with_return(302,tuple([index, gravity_direction._ptr]))

  @functools.native_method
  def get_gravity_direction(self, index:'int'   ) -> typing.Union['Vector3']:
    r'''
				Returns the gravity direction of the bone chain.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(303,tuple([index]))
    return _ret


  @functools.native_method
  def set_setting_count(self, count:'int'   ) -> None:
    r''''''

    assert isinstance(count, (int, float)), 'count must be int or float'


    self.py__setting_count = count






    self._ptr.call_with_return(304,tuple([count]))

  @functools.native_method
  def get_setting_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(305,tuple([]))

    return _ret


  @functools.native_method
  def clear_settings(self) -> None:
    r'''
				Clears all settings.
			'''




    self._ptr.call_with_return(306,tuple([]))

  @functools.native_method
  def set_individual_config(self, index:'int'   , enabled:'bool'   ) -> None:
    r'''
				If `enabled` is `true`, the config can be edited individually for each joint.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(307,tuple([index, enabled]))

  @functools.native_method
  def is_config_individual(self, index:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the config can be edited individually for each joint.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(308,tuple([index]))
    return _ret


  @functools.native_method
  def get_joint_bone_name(self, index:'int'   , joint:'int'   ) -> typing.Union[str]:
    r'''
				Returns the bone name at `joint` in the bone chain's joint list.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(309,tuple([index, joint]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_joint_bone(self, index:'int'   , joint:'int'   ) -> typing.Union[int]:
    r'''
				Returns the bone index at `joint` in the bone chain's joint list.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(310,tuple([index, joint]))
    return _ret


  @functools.native_method
  def set_joint_rotation_axis(self, index:'int'   , joint:'int'   , axis:'int'  ) -> None:
    r'''
				Sets the rotation axis at `joint` in the bone chain's joint list when `is_config_individual` is `true`.
				The axes are based on the `Skeleton3D.get_bone_rest`'s space, if `axis` is `constant SkeletonModifier3D.ROTATION_AXIS_CUSTOM`, you can specify any axis.
				**Note:** The rotation axis and the forward vector shouldn't be colinear to avoid unintended rotation since `SpringBoneSimulator3D` does not factor in twisting forces.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'
    assert isinstance(axis, (int, float)), 'axis must be int or float'









    self._ptr.call_with_return(311,tuple([index, joint, axis]))

  @functools.native_method
  def get_joint_rotation_axis(self, index:'int'   , joint:'int'   ) -> typing.Union[int]:
    r'''
				Returns the rotation axis at `joint` in the bone chain's joint list.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret:int
    _ret = self._ptr.call_with_return(312,tuple([index, joint]))
    return _ret


  @functools.native_method
  def set_joint_rotation_axis_vector(self, index:'int'   , joint:'int'   , vector:'Vector3'   ) -> None:
    r'''
				Sets the rotation axis vector for the specified joint in the bone chain.
				This vector is normalized by an internal process and represents the axis around which the bone chain can rotate.
				If the vector length is `0`, it is considered synonymous with `constant SkeletonModifier3D.ROTATION_AXIS_ALL`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'
    assert(not vector is None)
    assert isinstance(vector, Vector3), 'vector must be Vector3'









    self._ptr.call_with_return(313,tuple([index, joint, vector._ptr]))

  @functools.native_method
  def get_joint_rotation_axis_vector(self, index:'int'   , joint:'int'   ) -> typing.Union['Vector3']:
    r'''
				Returns the rotation axis vector for the specified joint in the bone chain. This vector represents the axis around which the joint can rotate. It is determined based on the rotation axis set for the joint.
				If `get_joint_rotation_axis` is `constant SkeletonModifier3D.ROTATION_AXIS_ALL`, this method returns `Vector3(0, 0, 0)`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(314,tuple([index, joint]))
    return _ret


  @functools.native_method
  def set_joint_radius(self, index:'int'   , joint:'int'   , radius:'float'   ) -> None:
    r'''
				Sets the joint radius at `joint` in the bone chain's joint list when `is_config_individual` is `true`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'
    assert isinstance(radius, (int, float)), 'radius must be int or float'









    self._ptr.call_with_return(315,tuple([index, joint, radius]))

  @functools.native_method
  def get_joint_radius(self, index:'int'   , joint:'int'   ) -> typing.Union[float]:
    r'''
				Returns the radius at `joint` in the bone chain's joint list.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(316,tuple([index, joint]))
    return _ret


  @functools.native_method
  def set_joint_stiffness(self, index:'int'   , joint:'int'   , stiffness:'float'   ) -> None:
    r'''
				Sets the stiffness force at `joint` in the bone chain's joint list when `is_config_individual` is `true`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'
    assert isinstance(stiffness, (int, float)), 'stiffness must be int or float'









    self._ptr.call_with_return(317,tuple([index, joint, stiffness]))

  @functools.native_method
  def get_joint_stiffness(self, index:'int'   , joint:'int'   ) -> typing.Union[float]:
    r'''
				Returns the stiffness force at `joint` in the bone chain's joint list.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(318,tuple([index, joint]))
    return _ret


  @functools.native_method
  def set_joint_drag(self, index:'int'   , joint:'int'   , drag:'float'   ) -> None:
    r'''
				Sets the drag force at `joint` in the bone chain's joint list when `is_config_individual` is `true`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'
    assert isinstance(drag, (int, float)), 'drag must be int or float'









    self._ptr.call_with_return(319,tuple([index, joint, drag]))

  @functools.native_method
  def get_joint_drag(self, index:'int'   , joint:'int'   ) -> typing.Union[float]:
    r'''
				Returns the drag force at `joint` in the bone chain's joint list.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(320,tuple([index, joint]))
    return _ret


  @functools.native_method
  def set_joint_gravity(self, index:'int'   , joint:'int'   , gravity:'float'   ) -> None:
    r'''
				Sets the gravity amount at `joint` in the bone chain's joint list when `is_config_individual` is `true`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'
    assert isinstance(gravity, (int, float)), 'gravity must be int or float'









    self._ptr.call_with_return(321,tuple([index, joint, gravity]))

  @functools.native_method
  def get_joint_gravity(self, index:'int'   , joint:'int'   ) -> typing.Union[float]:
    r'''
				Returns the gravity amount at `joint` in the bone chain's joint list.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(322,tuple([index, joint]))
    return _ret


  @functools.native_method
  def set_joint_gravity_direction(self, index:'int'   , joint:'int'   , gravity_direction:'Vector3'   ) -> None:
    r'''
				Sets the gravity direction at `joint` in the bone chain's joint list when `is_config_individual` is `true`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'
    assert(not gravity_direction is None)
    assert isinstance(gravity_direction, Vector3), 'gravity_direction must be Vector3'









    self._ptr.call_with_return(323,tuple([index, joint, gravity_direction._ptr]))

  @functools.native_method
  def get_joint_gravity_direction(self, index:'int'   , joint:'int'   ) -> typing.Union['Vector3']:
    r'''
				Returns the gravity direction at `joint` in the bone chain's joint list.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(joint, (int, float)), 'joint must be int or float'








    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(324,tuple([index, joint]))
    return _ret


  @functools.native_method
  def get_joint_count(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the joint count of the bone chain's joint list.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(325,tuple([index]))
    return _ret


  @functools.native_method
  def set_enable_all_child_collisions(self, index:'int'   , enabled:'bool'   ) -> None:
    r'''
				If `enabled` is `true`, all child `SpringBoneCollision3D`s are colliding and `set_exclude_collision_path` is enabled as an exclusion list at `index` in the settings.
				If `enabled` is `false`, you need to manually register all valid collisions with `set_collision_path`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(enabled, bool), 'enabled must be bool'








    self._ptr.call_with_return(326,tuple([index, enabled]))

  @functools.native_method
  def are_all_child_collisions_enabled(self, index:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if all child `SpringBoneCollision3D`s are contained in the collision list at `index` in the settings.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(327,tuple([index]))
    return _ret


  @functools.native_method
  def set_exclude_collision_path(self, index:'int'   , collision:'int'   , node_path:'object'   ) -> None:
    r'''
				Sets the node path of the `SpringBoneCollision3D` at `collision` in the bone chain's exclude collision list when `are_all_child_collisions_enabled` is `true`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(collision, (int, float)), 'collision must be int or float'
    assert(not node_path is None)
    assert isinstance(node_path, (str, NodePath)), 'node_path must be str or NodePath'







    assert(isinstance(node_path, (str, NodePath)))
    py_nodepath_node_path = node_path if isinstance(node_path,NodePath) else NodePath.new2(node_path)

    self._ptr.call_with_return(328,tuple([index, collision, py_nodepath_node_path._ptr]))

  @functools.native_method
  def get_exclude_collision_path(self, index:'int'   , collision:'int'   ) -> typing.Union['NodePath']:
    r'''
				Returns the node path of the `SpringBoneCollision3D` at `collision` in the bone chain's exclude collision list when `are_all_child_collisions_enabled` is `true`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(collision, (int, float)), 'collision must be int or float'








    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(329,tuple([index, collision]))
    return _ret


  @functools.native_method
  def set_exclude_collision_count(self, index:'int'   , count:'int'   ) -> None:
    r'''
				Sets the number of exclude collisions in the exclude collision list at `index` in the settings when `are_all_child_collisions_enabled` is `true`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(count, (int, float)), 'count must be int or float'








    self._ptr.call_with_return(330,tuple([index, count]))

  @functools.native_method
  def get_exclude_collision_count(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the exclude collision count of the bone chain's exclude collision list when `are_all_child_collisions_enabled` is `true`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(331,tuple([index]))
    return _ret


  @functools.native_method
  def clear_exclude_collisions(self, index:'int'   ) -> None:
    r'''
				Clears all exclude collisions from the collision list at `index` in the settings when `are_all_child_collisions_enabled` is `true`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(332,tuple([index]))

  @functools.native_method
  def set_collision_path(self, index:'int'   , collision:'int'   , node_path:'object'   ) -> None:
    r'''
				Sets the node path of the `SpringBoneCollision3D` at `collision` in the bone chain's collision list when `are_all_child_collisions_enabled` is `false`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(collision, (int, float)), 'collision must be int or float'
    assert(not node_path is None)
    assert isinstance(node_path, (str, NodePath)), 'node_path must be str or NodePath'







    assert(isinstance(node_path, (str, NodePath)))
    py_nodepath_node_path = node_path if isinstance(node_path,NodePath) else NodePath.new2(node_path)

    self._ptr.call_with_return(333,tuple([index, collision, py_nodepath_node_path._ptr]))

  @functools.native_method
  def get_collision_path(self, index:'int'   , collision:'int'   ) -> typing.Union['NodePath']:
    r'''
				Returns the node path of the `SpringBoneCollision3D` at `collision` in the bone chain's collision list when `are_all_child_collisions_enabled` is `false`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(collision, (int, float)), 'collision must be int or float'








    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(334,tuple([index, collision]))
    return _ret


  @functools.native_method
  def set_collision_count(self, index:'int'   , count:'int'   ) -> None:
    r'''
				Sets the number of collisions in the collision list at `index` in the settings when `are_all_child_collisions_enabled` is `false`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(count, (int, float)), 'count must be int or float'








    self._ptr.call_with_return(335,tuple([index, count]))

  @functools.native_method
  def get_collision_count(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the collision count of the bone chain's collision list when `are_all_child_collisions_enabled` is `false`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(336,tuple([index]))
    return _ret


  @functools.native_method
  def clear_collisions(self, index:'int'   ) -> None:
    r'''
				Clears all collisions from the collision list at `index` in the settings when `are_all_child_collisions_enabled` is `false`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(337,tuple([index]))

  @functools.native_method
  def set_external_force(self, force:'Vector3'   ) -> None:
    r''''''

    assert(not force is None)
    assert isinstance(force, Vector3), 'force must be Vector3'


    self.py__external_force = force






    self._ptr.call_with_return(338,tuple([force._ptr]))

  @functools.native_method
  def get_external_force(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(339,tuple([]))

    return _ret


  @functools.native_method
  def reset(self) -> None:
    r'''
				Resets a simulating state with respect to the current bone pose.
				It is useful to prevent the simulation result getting violent. For example, calling this immediately after a call to `AnimationPlayer.play` without a fading, or within the previous `signal SkeletonModifier3D.modification_processed` signal if it's condition changes significantly.
			'''




    self._ptr.call_with_return(340,tuple([]))


register_cast_function('SpringBoneSimulator3D', SpringBoneSimulator3D.cast)
register_class('SpringBoneSimulator3D', SpringBoneSimulator3D)
