# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Vector2iTypedArray as py4godot_vector2itypedarray 
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.RefCounted as py4godot_refcounted 
import py4godot.classes.Vector2iTypedArray as py4godot_vector2itypedarray 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
from py4godot.wrappers.wrappers import CPPAStarGrid2DWrapper

class Heuristic:
  HEURISTIC_EUCLIDEAN = 0
  HEURISTIC_MANHATTAN = 1
  HEURISTIC_OCTILE = 2
  HEURISTIC_CHEBYSHEV = 3
  HEURISTIC_MAX = 4
class DiagonalMode:
  DIAGONAL_MODE_ALWAYS = 0
  DIAGONAL_MODE_NEVER = 1
  DIAGONAL_MODE_AT_LEAST_ONE_WALKABLE = 2
  DIAGONAL_MODE_ONLY_IF_NO_OBSTACLES = 3
  DIAGONAL_MODE_MAX = 4
class CellShape:
  CELL_SHAPE_SQUARE = 0
  CELL_SHAPE_ISOMETRIC_RIGHT = 1
  CELL_SHAPE_ISOMETRIC_DOWN = 2
  CELL_SHAPE_MAX = 3


class AStarGrid2D(py4godot_refcounted.RefCounted):
  r'''
		`AStarGrid2D` is a variant of `AStar2D` that is specialized for partial 2D grids. It is simpler to use because it doesn't require you to manually create points and connect them together. This class also supports multiple types of heuristics, modes for diagonal movement, and a jumping mode to speed up calculations.
		To use `AStarGrid2D`, you only need to set the `region` of the grid, optionally set the `cell_size`, and then call the `update` method:
		
		```gdscript
		var astar_grid = AStarGrid2D.new()
		astar_grid.region = Rect2i(0, 0, 32, 32)
		astar_grid.cell_size = Vector2(16, 16)
		astar_grid.update()
		print(astar_grid.get_id_path(Vector2i(0, 0), Vector2i(3, 4))) # Prints `(0, 0), (1, 1), (2, 2), (3, 3), (3, 4)`
		print(astar_grid.get_point_path(Vector2i(0, 0), Vector2i(3, 4))) # Prints `(0, 0), (16, 16), (32, 32), (48, 48), (48, 64)`
		```
		
		
		To remove a point from the pathfinding grid, it must be set as "solid" with `set_point_solid`.
	'''

  @staticmethod
  def constructor():
    class_ = AStarGrid2D.construct_without_init()
    class_._ptr = constructor(64,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AStarGrid2D.construct_without_init()
    class_._ptr = constructor(64,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAStarGrid2DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(64,0, ())


  def generate_wrapper(self):
    return CPPAStarGrid2DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = AStarGrid2D.__new__(AStarGrid2D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AStarGrid2D'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(88, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AStarGrid2D.construct_without_init()
    cls._ptr = CPPAStarGrid2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AStarGrid2D.construct_without_init()
    cls._ptr = CPPAStarGrid2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def region(self) -> typing.Union['Rect2i']:
    r''''''
    _ret = self. get_region()
    return _ret
  @region.setter
  def region(self,  value:'Rect2i'):
    self.set_region(value)
  @property
  def size(self) -> typing.Union['Vector2i']:
    r''''''
    _ret = self. get_size()
    return _ret
  @size.setter
  def size(self,  value:'Vector2i'):
    self.set_size(value)
  @property
  def offset(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_offset()
    return _ret
  @offset.setter
  def offset(self,  value:'Vector2'):
    self.set_offset(value)
  @property
  def cell_size(self) -> typing.Union['Vector2']:
    r''''''
    _ret = self. get_cell_size()
    return _ret
  @cell_size.setter
  def cell_size(self,  value:'Vector2'):
    self.set_cell_size(value)
  @property
  def cell_shape(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_cell_shape()
    return _ret
  @cell_shape.setter
  def cell_shape(self,  value:'int'):
    self.set_cell_shape(value)
  @property
  def jumping_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_jumping_enabled()
    return _ret
  @jumping_enabled.setter
  def jumping_enabled(self,  value:'bool'):
    self.set_jumping_enabled(value)
  @property
  def default_compute_heuristic(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_default_compute_heuristic()
    return _ret
  @default_compute_heuristic.setter
  def default_compute_heuristic(self,  value:'int'):
    self.set_default_compute_heuristic(value)
  @property
  def default_estimate_heuristic(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_default_estimate_heuristic()
    return _ret
  @default_estimate_heuristic.setter
  def default_estimate_heuristic(self,  value:'int'):
    self.set_default_estimate_heuristic(value)
  @property
  def diagonal_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_diagonal_mode()
    return _ret
  @diagonal_mode.setter
  def diagonal_mode(self,  value:'int'):
    self.set_diagonal_mode(value)
  @functools.native_method
  def _estimate_cost(self, from_id:'Vector2i'   , end_id:'Vector2i'   ) -> typing.Union[float]:
    r'''
				Called when estimating the cost between a point and the path's ending point.
				Note that this function is hidden in the default `AStarGrid2D` class.
			'''

    assert(not from_id is None)
    assert isinstance(from_id, Vector2i), 'from_id must be Vector2i'
    assert(not end_id is None)
    assert isinstance(end_id, Vector2i), 'end_id must be Vector2i'








    _ret = 0
    _ret = self._ptr.call_with_return(53,tuple([from_id._ptr, end_id._ptr]))
    return _ret


  @functools.native_method
  def _compute_cost(self, from_id:'Vector2i'   , to_id:'Vector2i'   ) -> typing.Union[float]:
    r'''
				Called when computing the cost between two connected points.
				Note that this function is hidden in the default `AStarGrid2D` class.
			'''

    assert(not from_id is None)
    assert isinstance(from_id, Vector2i), 'from_id must be Vector2i'
    assert(not to_id is None)
    assert isinstance(to_id, Vector2i), 'to_id must be Vector2i'








    _ret = 0
    _ret = self._ptr.call_with_return(54,tuple([from_id._ptr, to_id._ptr]))
    return _ret


  @functools.native_method
  def set_region(self, region:'Rect2i'   ) -> None:
    r''''''

    assert(not region is None)
    assert isinstance(region, Rect2i), 'region must be Rect2i'


    self.py__region = region






    self._ptr.call_with_return(55,tuple([region._ptr]))

  @functools.native_method
  def get_region(self) -> typing.Union['Rect2i']:
    r''''''




    _ret = Rect2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(56,tuple([]))

    return _ret


  @functools.native_method
  def set_size(self, size:'Vector2i'   ) -> None:
    r''''''

    assert(not size is None)
    assert isinstance(size, Vector2i), 'size must be Vector2i'


    self.py__size = size






    self._ptr.call_with_return(57,tuple([size._ptr]))

  @functools.native_method
  def get_size(self) -> typing.Union['Vector2i']:
    r''''''




    _ret = Vector2i.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(58,tuple([]))

    return _ret


  @functools.native_method
  def set_offset(self, offset:'Vector2'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Vector2), 'offset must be Vector2'


    self.py__offset = offset






    self._ptr.call_with_return(59,tuple([offset._ptr]))

  @functools.native_method
  def get_offset(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([]))

    return _ret


  @functools.native_method
  def set_cell_size(self, cell_size:'Vector2'   ) -> None:
    r''''''

    assert(not cell_size is None)
    assert isinstance(cell_size, Vector2), 'cell_size must be Vector2'


    self.py__cell_size = cell_size






    self._ptr.call_with_return(61,tuple([cell_size._ptr]))

  @functools.native_method
  def get_cell_size(self) -> typing.Union['Vector2']:
    r''''''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([]))

    return _ret


  @functools.native_method
  def set_cell_shape(self, cell_shape:'int'  ) -> None:
    r''''''

    assert isinstance(cell_shape, (int, float)), 'cell_shape must be int or float'


    self.py__cell_shape = cell_shape






    self._ptr.call_with_return(63,tuple([cell_shape]))

  @functools.native_method
  def get_cell_shape(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(64,tuple([]))

    return _ret


  @functools.native_method
  def is_in_bounds(self, x:'int'   , y:'int'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the `x` and `y` is a valid grid coordinate (id), i.e. if it is inside `region`. Equivalent to `region.has_point(Vector2i(x, y))`.
			'''

    assert isinstance(x, (int, float)), 'x must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(65,tuple([x, y]))
    return _ret


  @functools.native_method
  def is_in_boundsv(self, id:'Vector2i'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the `id` vector is a valid grid coordinate, i.e. if it is inside `region`. Equivalent to `region.has_point(id)`.
			'''

    assert(not id is None)
    assert isinstance(id, Vector2i), 'id must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([id._ptr]))
    return _ret


  @functools.native_method
  def is_dirty(self) -> typing.Union[bool]:
    r'''
				Indicates that the grid parameters were changed and `update` needs to be called.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([]))
    return _ret


  @functools.native_method
  def update(self) -> None:
    r'''
				Updates the internal state of the grid according to the parameters to prepare it to search the path. Needs to be called if parameters like `region`, `cell_size` or `offset` are changed. `is_dirty` will return `true` if this is the case and this needs to be called.
				**Note:** All point data (solidity and weight scale) will be cleared.
			'''




    self._ptr.call_with_return(68,tuple([]))

  @functools.native_method
  def set_jumping_enabled(self, enabled:'bool'   ) -> None:
    r''''''

    assert isinstance(enabled, bool), 'enabled must be bool'


    self.py__jumping_enabled = enabled






    self._ptr.call_with_return(69,tuple([enabled]))

  @functools.native_method
  def is_jumping_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(70,tuple([]))

    return _ret


  @functools.native_method
  def set_diagonal_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__diagonal_mode = mode






    self._ptr.call_with_return(71,tuple([mode]))

  @functools.native_method
  def get_diagonal_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(72,tuple([]))

    return _ret


  @functools.native_method
  def set_default_compute_heuristic(self, heuristic:'int'  ) -> None:
    r''''''

    assert isinstance(heuristic, (int, float)), 'heuristic must be int or float'


    self.py__default_compute_heuristic = heuristic






    self._ptr.call_with_return(73,tuple([heuristic]))

  @functools.native_method
  def get_default_compute_heuristic(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(74,tuple([]))

    return _ret


  @functools.native_method
  def set_default_estimate_heuristic(self, heuristic:'int'  ) -> None:
    r''''''

    assert isinstance(heuristic, (int, float)), 'heuristic must be int or float'


    self.py__default_estimate_heuristic = heuristic






    self._ptr.call_with_return(75,tuple([heuristic]))

  @functools.native_method
  def get_default_estimate_heuristic(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(76,tuple([]))

    return _ret


  @functools.native_method
  def set_point_solid(self, id:'Vector2i'   , solid:'bool' =True  ) -> None:
    r'''
				Disables or enables the specified point for pathfinding. Useful for making an obstacle. By default, all points are enabled.
				**Note:** Calling `update` is not needed after the call of this function.
			'''

    assert(not id is None)
    assert isinstance(id, Vector2i), 'id must be Vector2i'
    assert isinstance(solid, bool), 'solid must be bool'








    self._ptr.call_with_return(77,tuple([id._ptr, solid]))

  @functools.native_method
  def is_point_solid(self, id:'Vector2i'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if a point is disabled for pathfinding. By default, all points are enabled.
			'''

    assert(not id is None)
    assert isinstance(id, Vector2i), 'id must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([id._ptr]))
    return _ret


  @functools.native_method
  def set_point_weight_scale(self, id:'Vector2i'   , weight_scale:'float'   ) -> None:
    r'''
				Sets the `weight_scale` for the point with the given `id`. The `weight_scale` is multiplied by the result of `_compute_cost` when determining the overall cost of traveling across a segment from a neighboring point to this point.
				**Note:** Calling `update` is not needed after the call of this function.
			'''

    assert(not id is None)
    assert isinstance(id, Vector2i), 'id must be Vector2i'
    assert isinstance(weight_scale, (int, float)), 'weight_scale must be int or float'








    self._ptr.call_with_return(79,tuple([id._ptr, weight_scale]))

  @functools.native_method
  def get_point_weight_scale(self, id:'Vector2i'   ) -> typing.Union[float]:
    r'''
				Returns the weight scale of the point associated with the given `id`.
			'''

    assert(not id is None)
    assert isinstance(id, Vector2i), 'id must be Vector2i'







    _ret = 0
    _ret = self._ptr.call_with_return(80,tuple([id._ptr]))
    return _ret


  @functools.native_method
  def fill_solid_region(self, region:'Rect2i'   , solid:'bool' =True  ) -> None:
    r'''
				Fills the given `region` on the grid with the specified value for the solid flag.
				**Note:** Calling `update` is not needed after the call of this function.
			'''

    assert(not region is None)
    assert isinstance(region, Rect2i), 'region must be Rect2i'
    assert isinstance(solid, bool), 'solid must be bool'








    self._ptr.call_with_return(81,tuple([region._ptr, solid]))

  @functools.native_method
  def fill_weight_scale_region(self, region:'Rect2i'   , weight_scale:'float'   ) -> None:
    r'''
				Fills the given `region` on the grid with the specified value for the weight scale.
				**Note:** Calling `update` is not needed after the call of this function.
			'''

    assert(not region is None)
    assert isinstance(region, Rect2i), 'region must be Rect2i'
    assert isinstance(weight_scale, (int, float)), 'weight_scale must be int or float'








    self._ptr.call_with_return(82,tuple([region._ptr, weight_scale]))

  @functools.native_method
  def clear(self) -> None:
    r'''
				Clears the grid and sets the `region` to `Rect2i(0, 0, 0, 0)`.
			'''




    self._ptr.call_with_return(83,tuple([]))

  @functools.native_method
  def get_point_position(self, id:'Vector2i'   ) -> typing.Union['Vector2']:
    r'''
				Returns the position of the point associated with the given `id`.
			'''

    assert(not id is None)
    assert isinstance(id, Vector2i), 'id must be Vector2i'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(84,tuple([id._ptr]))
    return _ret


  @functools.native_method
  def get_point_data_in_region(self, region:'Rect2i'   ) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Returns an array of dictionaries with point data (`id`: `Vector2i`, `position`: `Vector2`, `solid`: `bool`, `weight_scale`: `float`) within a `region`.
			'''

    assert(not region is None)
    assert isinstance(region, Rect2i), 'region must be Rect2i'







    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(85,tuple([region._ptr]))
    return _ret


  @functools.native_method
  def get_point_path(self, from_id:'Vector2i'   , to_id:'Vector2i'   , allow_partial_path:'bool' =False  ) -> typing.Union['PackedVector2Array']:
    r'''
				Returns an array with the points that are in the path found by `AStarGrid2D` between the given points. The array is ordered from the starting point to the ending point of the path.
				If `from_id` point is disabled, returns an empty array (even if `from_id == to_id`).
				If `from_id` point is not disabled, there is no valid path to the target, and `allow_partial_path` is `true`, returns a path to the point closest to the target that can be reached.
				**Note:** This method is not thread-safe; it can only be used from a single `Thread` at a given time. Consider using `Mutex` to ensure exclusive access to one thread to avoid race conditions.
				Additionally, when `allow_partial_path` is `true` and `to_id` is solid the search may take an unusually long time to finish.
			'''

    assert(not from_id is None)
    assert isinstance(from_id, Vector2i), 'from_id must be Vector2i'
    assert(not to_id is None)
    assert isinstance(to_id, Vector2i), 'to_id must be Vector2i'
    assert isinstance(allow_partial_path, bool), 'allow_partial_path must be bool'









    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([from_id._ptr, to_id._ptr, allow_partial_path]))
    return _ret


  @functools.native_method
  def get_id_path(self, from_id:'Vector2i'   , to_id:'Vector2i'   , allow_partial_path:'bool' =False  ) -> typing.Union['py4godot_vector2itypedarray.Vector2iTypedArray']:
    r'''
				Returns an array with the IDs of the points that form the path found by AStar2D between the given points. The array is ordered from the starting point to the ending point of the path.
				If `from_id` point is disabled, returns an empty array (even if `from_id == to_id`).
				If `from_id` point is not disabled, there is no valid path to the target, and `allow_partial_path` is `true`, returns a path to the point closest to the target that can be reached.
				**Note:** When `allow_partial_path` is `true` and `to_id` is solid the search may take an unusually long time to finish.
			'''

    assert(not from_id is None)
    assert isinstance(from_id, Vector2i), 'from_id must be Vector2i'
    assert(not to_id is None)
    assert isinstance(to_id, Vector2i), 'to_id must be Vector2i'
    assert isinstance(allow_partial_path, bool), 'allow_partial_path must be bool'









    _ret = py4godot_vector2itypedarray.Vector2iTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(87,tuple([from_id._ptr, to_id._ptr, allow_partial_path]))
    return _ret



register_cast_function('AStarGrid2D', AStarGrid2D.cast)
register_class('AStarGrid2D', AStarGrid2D)
