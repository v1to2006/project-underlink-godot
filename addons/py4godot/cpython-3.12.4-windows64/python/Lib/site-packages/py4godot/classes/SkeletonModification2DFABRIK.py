# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.SkeletonModification2D as py4godot_skeletonmodification2d 
from py4godot.wrappers.wrappers import CPPSkeletonModification2DFABRIKWrapper


class SkeletonModification2DFABRIK(py4godot_skeletonmodification2d.SkeletonModification2D):
  r'''
		This `SkeletonModification2D` uses an algorithm called Forward And Backward Reaching Inverse Kinematics, or FABRIK, to rotate a bone chain so that it reaches a target.
		FABRIK works by knowing the positions and lengths of a series of bones, typically called a "bone chain". It first starts by running a forward pass, which places the final bone at the target's position. Then all other bones are moved towards the tip bone, so they stay at the defined bone length away. Then a backwards pass is performed, where the root/first bone in the FABRIK chain is placed back at the origin. Then all other bones are moved so they stay at the defined bone length away. This positions the bone chain so that it reaches the target when possible, but all of the bones stay the correct length away from each other.
		Because of how FABRIK works, it often gives more natural results than those seen in `SkeletonModification2DCCDIK`.
		**Note:** The FABRIK modifier has `fabrik_joints`, which are the data objects that hold the data for each joint in the FABRIK chain. This is different from `Bone2D` nodes! FABRIK joints hold the data needed for each `Bone2D` in the bone chain used by FABRIK.
		To help control how the FABRIK joints move, a magnet vector can be passed, which can nudge the bones in a certain direction prior to solving, giving a level of control over the final result.
	'''

  @staticmethod
  def constructor():
    class_ = SkeletonModification2DFABRIK.construct_without_init()
    class_._ptr = constructor(751,0, ())
    return class_
  @staticmethod
  def new():
    class_ = SkeletonModification2DFABRIK.construct_without_init()
    class_._ptr = constructor(751,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPSkeletonModification2DFABRIKWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(751,0, ())


  def generate_wrapper(self):
    return CPPSkeletonModification2DFABRIKWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = SkeletonModification2DFABRIK.__new__(SkeletonModification2DFABRIK)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'SkeletonModification2DFABRIK'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(102, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = SkeletonModification2DFABRIK.construct_without_init()
    cls._ptr = CPPSkeletonModification2DFABRIKWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = SkeletonModification2DFABRIK.construct_without_init()
    cls._ptr = CPPSkeletonModification2DFABRIKWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def target_nodepath(self) -> typing.Union['NodePath']:
    r''''''
    _ret = self. get_target_node()
    return _ret
  @target_nodepath.setter
  def target_nodepath(self,  value:'object'):
    self.set_target_node(value)
  @property
  def fabrik_data_chain_length(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_fabrik_data_chain_length()
    return _ret
  @fabrik_data_chain_length.setter
  def fabrik_data_chain_length(self,  value:'int'):
    self.set_fabrik_data_chain_length(value)
  @functools.native_method
  def set_target_node(self, target_nodepath:'object'   ) -> None:
    r''''''

    assert(not target_nodepath is None)
    assert isinstance(target_nodepath, (str, NodePath)), 'target_nodepath must be str or NodePath'


    self.py__target_nodepath = target_nodepath



    assert(isinstance(target_nodepath, (str, NodePath)))
    py_nodepath_target_nodepath = target_nodepath if isinstance(target_nodepath,NodePath) else NodePath.new2(target_nodepath)


    self._ptr.call_with_return(90,tuple([py_nodepath_target_nodepath._ptr]))

  @functools.native_method
  def get_target_node(self) -> typing.Union['NodePath']:
    r''''''




    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(91,tuple([]))

    return _ret


  @functools.native_method
  def set_fabrik_data_chain_length(self, length:'int'   ) -> None:
    r''''''

    assert isinstance(length, (int, float)), 'length must be int or float'


    self.py__fabrik_data_chain_length = length






    self._ptr.call_with_return(92,tuple([length]))

  @functools.native_method
  def get_fabrik_data_chain_length(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(93,tuple([]))

    return _ret


  @functools.native_method
  def set_fabrik_joint_bone2d_node(self, joint_idx:'int'   , bone2d_nodepath:'object'   ) -> None:
    r'''
				Sets the `Bone2D` node assigned to the FABRIK joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert(not bone2d_nodepath is None)
    assert isinstance(bone2d_nodepath, (str, NodePath)), 'bone2d_nodepath must be str or NodePath'






    assert(isinstance(bone2d_nodepath, (str, NodePath)))
    py_nodepath_bone2d_nodepath = bone2d_nodepath if isinstance(bone2d_nodepath,NodePath) else NodePath.new2(bone2d_nodepath)

    self._ptr.call_with_return(94,tuple([joint_idx, py_nodepath_bone2d_nodepath._ptr]))

  @functools.native_method
  def get_fabrik_joint_bone2d_node(self, joint_idx:'int'   ) -> typing.Union['NodePath']:
    r'''
				Returns the `Bone2D` node assigned to the FABRIK joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = NodePath.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(95,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_fabrik_joint_bone_index(self, joint_idx:'int'   , bone_idx:'int'   ) -> None:
    r'''
				Sets the bone index, `bone_idx`, of the FABRIK joint at `joint_idx`. When possible, this will also update the `bone2d_node` of the FABRIK joint based on data provided by the linked skeleton.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert isinstance(bone_idx, (int, float)), 'bone_idx must be int or float'








    self._ptr.call_with_return(96,tuple([joint_idx, bone_idx]))

  @functools.native_method
  def get_fabrik_joint_bone_index(self, joint_idx:'int'   ) -> typing.Union[int]:
    r'''
				Returns the index of the `Bone2D` node assigned to the FABRIK joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_fabrik_joint_magnet_position(self, joint_idx:'int'   , magnet_position:'Vector2'   ) -> None:
    r'''
				Sets the magnet position vector for the joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert(not magnet_position is None)
    assert isinstance(magnet_position, Vector2), 'magnet_position must be Vector2'








    self._ptr.call_with_return(98,tuple([joint_idx, magnet_position._ptr]))

  @functools.native_method
  def get_fabrik_joint_magnet_position(self, joint_idx:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the magnet position vector for the joint at `joint_idx`.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(99,tuple([joint_idx]))
    return _ret


  @functools.native_method
  def set_fabrik_joint_use_target_rotation(self, joint_idx:'int'   , use_target_rotation:'bool'   ) -> None:
    r'''
				Sets whether the joint at `joint_idx` will use the target node's rotation rather than letting FABRIK rotate the node.
				**Note:** This option only works for the tip/final joint in the chain. For all other nodes, this option will be ignored.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'
    assert isinstance(use_target_rotation, bool), 'use_target_rotation must be bool'








    self._ptr.call_with_return(100,tuple([joint_idx, use_target_rotation]))

  @functools.native_method
  def get_fabrik_joint_use_target_rotation(self, joint_idx:'int'   ) -> typing.Union[bool]:
    r'''
				Returns whether the joint is using the target's rotation rather than allowing FABRIK to rotate the joint. This option only applies to the tip/final joint in the chain.
			'''

    assert isinstance(joint_idx, (int, float)), 'joint_idx must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(101,tuple([joint_idx]))
    return _ret



register_cast_function('SkeletonModification2DFABRIK', SkeletonModification2DFABRIK.cast)
register_class('SkeletonModification2DFABRIK', SkeletonModification2DFABRIK)
