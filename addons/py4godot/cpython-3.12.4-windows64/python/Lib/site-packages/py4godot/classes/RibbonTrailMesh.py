# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.Curve as py4godot_curve 
import py4godot.classes.PrimitiveMesh as py4godot_primitivemesh 
from py4godot.wrappers.wrappers import CPPRibbonTrailMeshWrapper

class Shape:
  SHAPE_FLAT = 0
  SHAPE_CROSS = 1


class RibbonTrailMesh(py4godot_primitivemesh.PrimitiveMesh):
  r'''
		`RibbonTrailMesh` represents a straight ribbon-shaped mesh with variable width. The ribbon is composed of a number of flat or cross-shaped sections, each with the same `section_length` and number of `section_segments`. A `curve` is sampled along the total length of the ribbon, meaning that the curve determines the size of the ribbon along its length.
		This primitive mesh is usually used for particle trails.
	'''

  @staticmethod
  def constructor():
    class_ = RibbonTrailMesh.construct_without_init()
    class_._ptr = constructor(710,0, ())
    return class_
  @staticmethod
  def new():
    class_ = RibbonTrailMesh.construct_without_init()
    class_._ptr = constructor(710,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPRibbonTrailMeshWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(710,0, ())


  def generate_wrapper(self):
    return CPPRibbonTrailMeshWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = RibbonTrailMesh.__new__(RibbonTrailMesh)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'RibbonTrailMesh'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(130, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = RibbonTrailMesh.construct_without_init()
    cls._ptr = CPPRibbonTrailMeshWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = RibbonTrailMesh.construct_without_init()
    cls._ptr = CPPRibbonTrailMeshWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def shape(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_shape()
    return _ret
  @shape.setter
  def shape(self,  value:'int'):
    self.set_shape(value)
  @property
  def size(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_size()
    return _ret
  @size.setter
  def size(self,  value:'float'):
    self.set_size(value)
  @property
  def sections(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_sections()
    return _ret
  @sections.setter
  def sections(self,  value:'int'):
    self.set_sections(value)
  @property
  def section_length(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_section_length()
    return _ret
  @section_length.setter
  def section_length(self,  value:'float'):
    self.set_section_length(value)
  @property
  def section_segments(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_section_segments()
    return _ret
  @section_segments.setter
  def section_segments(self,  value:'int'):
    self.set_section_segments(value)
  @property
  def curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''
    _ret = self. get_curve()
    return _ret
  @curve.setter
  def curve(self,  value:'py4godot_object.Object'):
    self.set_curve(value)
  @functools.native_method
  def set_size(self, size:'float'   ) -> None:
    r''''''

    assert isinstance(size, (int, float)), 'size must be int or float'


    self.py__size = size






    self._ptr.call_with_return(118,tuple([size]))

  @functools.native_method
  def get_size(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(119,tuple([]))

    return _ret


  @functools.native_method
  def set_sections(self, sections:'int'   ) -> None:
    r''''''

    assert isinstance(sections, (int, float)), 'sections must be int or float'


    self.py__sections = sections






    self._ptr.call_with_return(120,tuple([sections]))

  @functools.native_method
  def get_sections(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(121,tuple([]))

    return _ret


  @functools.native_method
  def set_section_length(self, section_length:'float'   ) -> None:
    r''''''

    assert isinstance(section_length, (int, float)), 'section_length must be int or float'


    self.py__section_length = section_length






    self._ptr.call_with_return(122,tuple([section_length]))

  @functools.native_method
  def get_section_length(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(123,tuple([]))

    return _ret


  @functools.native_method
  def set_section_segments(self, section_segments:'int'   ) -> None:
    r''''''

    assert isinstance(section_segments, (int, float)), 'section_segments must be int or float'


    self.py__section_segments = section_segments






    self._ptr.call_with_return(124,tuple([section_segments]))

  @functools.native_method
  def get_section_segments(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(125,tuple([]))

    return _ret


  @functools.native_method
  def set_curve(self, curve:'py4godot_curve.Curve'   ) -> None:
    r''''''

    assert(not curve is None)
    assert isinstance(curve, get_class('Curve')), 'curve must be Curve'


    self.py__curve = curve






    self._ptr.call_with_return(126,tuple([curve._ptr]))

  @functools.native_method
  def get_curve(self) -> typing.Union['py4godot_curve.Curve']:
    r''''''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Curve
    _ret._ptr = self._ptr.call_with_return(127,tuple([]))

    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_shape(self, shape:'int'  ) -> None:
    r''''''

    assert isinstance(shape, (int, float)), 'shape must be int or float'


    self.py__shape = shape






    self._ptr.call_with_return(128,tuple([shape]))

  @functools.native_method
  def get_shape(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(129,tuple([]))

    return _ret



register_cast_function('RibbonTrailMesh', RibbonTrailMesh.cast)
register_class('RibbonTrailMesh', RibbonTrailMesh)
