# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PhysicsDirectBodyState3D as py4godot_physicsdirectbodystate3d 
import py4godot.classes.PhysicsBody3D as py4godot_physicsbody3d 
from py4godot.wrappers.wrappers import CPPPhysicalBone3DWrapper

class DampMode:
  DAMP_MODE_COMBINE = 0
  DAMP_MODE_REPLACE = 1
class JointType:
  JOINT_TYPE_NONE = 0
  JOINT_TYPE_PIN = 1
  JOINT_TYPE_CONE = 2
  JOINT_TYPE_HINGE = 3
  JOINT_TYPE_SLIDER = 4
  JOINT_TYPE_6DOF = 5


class PhysicalBone3D(py4godot_physicsbody3d.PhysicsBody3D):
  r'''
		The `PhysicalBone3D` node is a physics body that can be used to make bones in a `Skeleton3D` react to physics.
		**Note:** In order to detect physical bones with raycasts, the `SkeletonModifier3D.active` property of the parent `PhysicalBoneSimulator3D` must be `true` and the `Skeleton3D`'s bone must be assigned to `PhysicalBone3D` correctly; it means that `get_bone_id` should return a valid id (`>= 0`).
	'''

  @staticmethod
  def constructor():
    class_ = PhysicalBone3D.construct_without_init()
    class_._ptr = constructor(586,0, ())
    return class_
  @staticmethod
  def new():
    class_ = PhysicalBone3D.construct_without_init()
    class_._ptr = constructor(586,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPPhysicalBone3DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(586,0, ())


  def generate_wrapper(self):
    return CPPPhysicalBone3DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = PhysicalBone3D.__new__(PhysicalBone3D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'PhysicalBone3D'

  def __del__(self):
    pass
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = PhysicalBone3D.construct_without_init()
    cls._ptr = CPPPhysicalBone3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = PhysicalBone3D.construct_without_init()
    cls._ptr = CPPPhysicalBone3DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def joint_type(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_joint_type()
    return _ret
  @joint_type.setter
  def joint_type(self,  value:'int'):
    self.set_joint_type(value)
  @property
  def joint_offset(self) -> typing.Union['Transform3D']:
    r''''''
    _ret = self. get_joint_offset()
    return _ret
  @joint_offset.setter
  def joint_offset(self,  value:'Transform3D'):
    self.set_joint_offset(value)
  @property
  def joint_rotation(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_joint_rotation()
    return _ret
  @joint_rotation.setter
  def joint_rotation(self,  value:'Vector3'):
    self.set_joint_rotation(value)
  @property
  def body_offset(self) -> typing.Union['Transform3D']:
    r''''''
    _ret = self. get_body_offset()
    return _ret
  @body_offset.setter
  def body_offset(self,  value:'Transform3D'):
    self.set_body_offset(value)
  @property
  def mass(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_mass()
    return _ret
  @mass.setter
  def mass(self,  value:'float'):
    self.set_mass(value)
  @property
  def friction(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_friction()
    return _ret
  @friction.setter
  def friction(self,  value:'float'):
    self.set_friction(value)
  @property
  def bounce(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_bounce()
    return _ret
  @bounce.setter
  def bounce(self,  value:'float'):
    self.set_bounce(value)
  @property
  def gravity_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_gravity_scale()
    return _ret
  @gravity_scale.setter
  def gravity_scale(self,  value:'float'):
    self.set_gravity_scale(value)
  @property
  def custom_integrator(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_using_custom_integrator()
    return _ret
  @custom_integrator.setter
  def custom_integrator(self,  value:'bool'):
    self.set_use_custom_integrator(value)
  @property
  def linear_damp_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_linear_damp_mode()
    return _ret
  @linear_damp_mode.setter
  def linear_damp_mode(self,  value:'int'):
    self.set_linear_damp_mode(value)
  @property
  def linear_damp(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_linear_damp()
    return _ret
  @linear_damp.setter
  def linear_damp(self,  value:'float'):
    self.set_linear_damp(value)
  @property
  def angular_damp_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_angular_damp_mode()
    return _ret
  @angular_damp_mode.setter
  def angular_damp_mode(self,  value:'int'):
    self.set_angular_damp_mode(value)
  @property
  def angular_damp(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_angular_damp()
    return _ret
  @angular_damp.setter
  def angular_damp(self,  value:'float'):
    self.set_angular_damp(value)
  @property
  def linear_velocity(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_linear_velocity()
    return _ret
  @linear_velocity.setter
  def linear_velocity(self,  value:'Vector3'):
    self.set_linear_velocity(value)
  @property
  def angular_velocity(self) -> typing.Union['Vector3']:
    r''''''
    _ret = self. get_angular_velocity()
    return _ret
  @angular_velocity.setter
  def angular_velocity(self,  value:'Vector3'):
    self.set_angular_velocity(value)
  @property
  def can_sleep(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_able_to_sleep()
    return _ret
  @can_sleep.setter
  def can_sleep(self,  value:'bool'):
    self.set_can_sleep(value)
  @functools.native_method
  def _integrate_forces(self, state:'py4godot_physicsdirectbodystate3d.PhysicsDirectBodyState3D'   ) -> None:
    r'''
				Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default, it is called before the standard force integration, but the `custom_integrator` property allows you to disable the standard force integration and do fully custom force integration for a body.
			'''

    assert(not state is None)
    assert isinstance(state, get_class('PhysicsDirectBodyState3D')), 'state must be PhysicsDirectBodyState3D'







    self._ptr.call_with_return(294,tuple([state._ptr]))

  @functools.native_method
  def apply_central_impulse(self, impulse:'Vector3'   ) -> None:
    r'''
				Applies a directional impulse without affecting rotation.
				An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_integrate_forces" functions otherwise).
				This is equivalent to using `apply_impulse` at the body's center of mass.
			'''

    assert(not impulse is None)
    assert isinstance(impulse, Vector3), 'impulse must be Vector3'







    self._ptr.call_with_return(295,tuple([impulse._ptr]))

  @functools.native_method
  def apply_impulse(self, impulse:'Vector3'   , position:'Vector3' = None  ) -> None:
    r'''
				Applies a positioned impulse to the PhysicsBone3D.
				An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_integrate_forces" functions otherwise).
				`position` is the offset from the PhysicsBone3D origin in global coordinates.
			'''
    if position is None:
      position = Vector3.new0()

    assert(not impulse is None)
    assert isinstance(impulse, Vector3), 'impulse must be Vector3'








    self._ptr.call_with_return(296,tuple([impulse._ptr, position._ptr]))

  @functools.native_method
  def set_joint_type(self, joint_type:'int'  ) -> None:
    r''''''

    assert isinstance(joint_type, (int, float)), 'joint_type must be int or float'


    self.py__joint_type = joint_type






    self._ptr.call_with_return(297,tuple([joint_type]))

  @functools.native_method
  def get_joint_type(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(298,tuple([]))

    return _ret


  @functools.native_method
  def set_joint_offset(self, offset:'Transform3D'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Transform3D), 'offset must be Transform3D'


    self.py__joint_offset = offset






    self._ptr.call_with_return(299,tuple([offset._ptr]))

  @functools.native_method
  def get_joint_offset(self) -> typing.Union['Transform3D']:
    r''''''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(300,tuple([]))

    return _ret


  @functools.native_method
  def set_joint_rotation(self, euler:'Vector3'   ) -> None:
    r''''''

    assert(not euler is None)
    assert isinstance(euler, Vector3), 'euler must be Vector3'


    self.py__joint_rotation = euler






    self._ptr.call_with_return(301,tuple([euler._ptr]))

  @functools.native_method
  def get_joint_rotation(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(302,tuple([]))

    return _ret


  @functools.native_method
  def set_body_offset(self, offset:'Transform3D'   ) -> None:
    r''''''

    assert(not offset is None)
    assert isinstance(offset, Transform3D), 'offset must be Transform3D'


    self.py__body_offset = offset






    self._ptr.call_with_return(303,tuple([offset._ptr]))

  @functools.native_method
  def get_body_offset(self) -> typing.Union['Transform3D']:
    r''''''




    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(304,tuple([]))

    return _ret


  @functools.native_method
  def get_simulate_physics(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the PhysicsBone3D is allowed to simulate physics.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(305,tuple([]))
    return _ret


  @functools.native_method
  def is_simulating_physics(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the PhysicsBone3D is currently simulating physics.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(306,tuple([]))
    return _ret


  @functools.native_method
  def get_bone_id(self) -> typing.Union[int]:
    r'''
				Returns the unique identifier of the PhysicsBone3D.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(307,tuple([]))
    return _ret


  @functools.native_method
  def set_mass(self, mass:'float'   ) -> None:
    r''''''

    assert isinstance(mass, (int, float)), 'mass must be int or float'


    self.py__mass = mass






    self._ptr.call_with_return(308,tuple([mass]))

  @functools.native_method
  def get_mass(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(309,tuple([]))

    return _ret


  @functools.native_method
  def set_friction(self, friction:'float'   ) -> None:
    r''''''

    assert isinstance(friction, (int, float)), 'friction must be int or float'


    self.py__friction = friction






    self._ptr.call_with_return(310,tuple([friction]))

  @functools.native_method
  def get_friction(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(311,tuple([]))

    return _ret


  @functools.native_method
  def set_bounce(self, bounce:'float'   ) -> None:
    r''''''

    assert isinstance(bounce, (int, float)), 'bounce must be int or float'


    self.py__bounce = bounce






    self._ptr.call_with_return(312,tuple([bounce]))

  @functools.native_method
  def get_bounce(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(313,tuple([]))

    return _ret


  @functools.native_method
  def set_gravity_scale(self, gravity_scale:'float'   ) -> None:
    r''''''

    assert isinstance(gravity_scale, (int, float)), 'gravity_scale must be int or float'


    self.py__gravity_scale = gravity_scale






    self._ptr.call_with_return(314,tuple([gravity_scale]))

  @functools.native_method
  def get_gravity_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(315,tuple([]))

    return _ret


  @functools.native_method
  def set_linear_damp_mode(self, linear_damp_mode:'int'  ) -> None:
    r''''''

    assert isinstance(linear_damp_mode, (int, float)), 'linear_damp_mode must be int or float'


    self.py__linear_damp_mode = linear_damp_mode






    self._ptr.call_with_return(316,tuple([linear_damp_mode]))

  @functools.native_method
  def get_linear_damp_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(317,tuple([]))

    return _ret


  @functools.native_method
  def set_angular_damp_mode(self, angular_damp_mode:'int'  ) -> None:
    r''''''

    assert isinstance(angular_damp_mode, (int, float)), 'angular_damp_mode must be int or float'


    self.py__angular_damp_mode = angular_damp_mode






    self._ptr.call_with_return(318,tuple([angular_damp_mode]))

  @functools.native_method
  def get_angular_damp_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(319,tuple([]))

    return _ret


  @functools.native_method
  def set_linear_damp(self, linear_damp:'float'   ) -> None:
    r''''''

    assert isinstance(linear_damp, (int, float)), 'linear_damp must be int or float'


    self.py__linear_damp = linear_damp






    self._ptr.call_with_return(320,tuple([linear_damp]))

  @functools.native_method
  def get_linear_damp(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(321,tuple([]))

    return _ret


  @functools.native_method
  def set_angular_damp(self, angular_damp:'float'   ) -> None:
    r''''''

    assert isinstance(angular_damp, (int, float)), 'angular_damp must be int or float'


    self.py__angular_damp = angular_damp






    self._ptr.call_with_return(322,tuple([angular_damp]))

  @functools.native_method
  def get_angular_damp(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(323,tuple([]))

    return _ret


  @functools.native_method
  def set_linear_velocity(self, linear_velocity:'Vector3'   ) -> None:
    r''''''

    assert(not linear_velocity is None)
    assert isinstance(linear_velocity, Vector3), 'linear_velocity must be Vector3'


    self.py__linear_velocity = linear_velocity






    self._ptr.call_with_return(324,tuple([linear_velocity._ptr]))

  @functools.native_method
  def get_linear_velocity(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(325,tuple([]))

    return _ret


  @functools.native_method
  def set_angular_velocity(self, angular_velocity:'Vector3'   ) -> None:
    r''''''

    assert(not angular_velocity is None)
    assert isinstance(angular_velocity, Vector3), 'angular_velocity must be Vector3'


    self.py__angular_velocity = angular_velocity






    self._ptr.call_with_return(326,tuple([angular_velocity._ptr]))

  @functools.native_method
  def get_angular_velocity(self) -> typing.Union['Vector3']:
    r''''''




    _ret = Vector3.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(327,tuple([]))

    return _ret


  @functools.native_method
  def set_use_custom_integrator(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__custom_integrator = enable






    self._ptr.call_with_return(328,tuple([enable]))

  @functools.native_method
  def is_using_custom_integrator(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(329,tuple([]))

    return _ret


  @functools.native_method
  def set_can_sleep(self, able_to_sleep:'bool'   ) -> None:
    r''''''

    assert isinstance(able_to_sleep, bool), 'able_to_sleep must be bool'


    self.py__can_sleep = able_to_sleep






    self._ptr.call_with_return(330,tuple([able_to_sleep]))

  @functools.native_method
  def is_able_to_sleep(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(331,tuple([]))

    return _ret



register_cast_function('PhysicalBone3D', PhysicalBone3D.cast)
register_class('PhysicalBone3D', PhysicalBone3D)
