# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPCurveWrapper

class TangentMode:
  TANGENT_FREE = 0
  TANGENT_LINEAR = 1
  TANGENT_MODE_COUNT = 2


class Curve(py4godot_resource.Resource):
  r'''
		This resource describes a mathematical curve by defining a set of points and tangents at each point. By default, it ranges between `0` and `1` on the X and Y axes, but these ranges can be changed.
		Please note that many resources and nodes assume they are given _unit curves_. A unit curve is a curve whose domain (the X axis) is between `0` and `1`. Some examples of unit curve usage are `CPUParticles2D.angle_curve` and `Line2D.width_curve`.
	'''

  @staticmethod
  def constructor():
    class_ = Curve.construct_without_init()
    class_._ptr = constructor(248,0, ())
    return class_
  @staticmethod
  def new():
    class_ = Curve.construct_without_init()
    class_._ptr = constructor(248,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPCurveWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(248,0, ())


  def generate_wrapper(self):
    return CPPCurveWrapper()
  def init_signals(self):
    super().init_signals()
    range_changed_name = utils.py_string_to_string_name("range_changed")
    self.range_changed = signals.BuiltinSignal(self, range_changed_name)
    domain_changed_name = utils.py_string_to_string_name("domain_changed")
    self.domain_changed = signals.BuiltinSignal(self, domain_changed_name)

  @staticmethod
  def construct_without_init():
    cls = Curve.__new__(Curve)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'Curve'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(109, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = Curve.construct_without_init()
    cls._ptr = CPPCurveWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = Curve.construct_without_init()
    cls._ptr = CPPCurveWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def min_domain(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_min_domain()
    return _ret
  @min_domain.setter
  def min_domain(self,  value:'float'):
    self.set_min_domain(value)
  @property
  def max_domain(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_max_domain()
    return _ret
  @max_domain.setter
  def max_domain(self,  value:'float'):
    self.set_max_domain(value)
  @property
  def min_value(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_min_value()
    return _ret
  @min_value.setter
  def min_value(self,  value:'float'):
    self.set_min_value(value)
  @property
  def max_value(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_max_value()
    return _ret
  @max_value.setter
  def max_value(self,  value:'float'):
    self.set_max_value(value)
  @property
  def bake_resolution(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_bake_resolution()
    return _ret
  @bake_resolution.setter
  def bake_resolution(self,  value:'int'):
    self.set_bake_resolution(value)
  @property
  def point_count(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_point_count()
    return _ret
  @point_count.setter
  def point_count(self,  value:'int'):
    self.set_point_count(value)
  @functools.native_method
  def get_point_count(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(77,tuple([]))

    return _ret


  @functools.native_method
  def set_point_count(self, count:'int'   ) -> None:
    r''''''

    assert isinstance(count, (int, float)), 'count must be int or float'


    self.py__point_count = count






    self._ptr.call_with_return(78,tuple([count]))

  @functools.native_method
  def add_point(self, position:'Vector2'   , left_tangent:'float' =0  , right_tangent:'float' =0  , left_mode:'int'  =0, right_mode:'int'  =0) -> typing.Union[int]:
    r'''
				Adds a point to the curve. For each side, if the `*_mode` is `constant TANGENT_LINEAR`, the `*_tangent` angle (in degrees) uses the slope of the curve halfway to the adjacent point. Allows custom assignments to the `*_tangent` angle if `*_mode` is set to `constant TANGENT_FREE`.
			'''



    assert(not position is None)
    assert isinstance(position, Vector2), 'position must be Vector2'
    assert isinstance(left_tangent, (int, float)), 'left_tangent must be int or float'
    assert isinstance(right_tangent, (int, float)), 'right_tangent must be int or float'
    assert isinstance(left_mode, (int, float)), 'left_mode must be int or float'
    assert isinstance(right_mode, (int, float)), 'right_mode must be int or float'











    _ret = 0
    _ret = self._ptr.call_with_return(79,tuple([position._ptr, left_tangent, right_tangent, left_mode, right_mode]))
    return _ret


  @functools.native_method
  def remove_point(self, index:'int'   ) -> None:
    r'''
				Removes the point at `index` from the curve.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(80,tuple([index]))

  @functools.native_method
  def clear_points(self) -> None:
    r'''
				Removes all points from the curve.
			'''




    self._ptr.call_with_return(81,tuple([]))

  @functools.native_method
  def get_point_position(self, index:'int'   ) -> typing.Union['Vector2']:
    r'''
				Returns the curve coordinates for the point at `index`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(82,tuple([index]))
    return _ret


  @functools.native_method
  def set_point_value(self, index:'int'   , y:'float'   ) -> None:
    r'''
				Assigns the vertical position `y` to the point at `index`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(y, (int, float)), 'y must be int or float'








    self._ptr.call_with_return(83,tuple([index, y]))

  @functools.native_method
  def set_point_offset(self, index:'int'   , offset:'float'   ) -> typing.Union[int]:
    r'''
				Sets the offset from `0.5`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(offset, (int, float)), 'offset must be int or float'








    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([index, offset]))
    return _ret


  @functools.native_method
  def sample(self, offset:'float'   ) -> typing.Union[float]:
    r'''
				Returns the Y value for the point that would exist at the X position `offset` along the curve.
			'''

    assert isinstance(offset, (int, float)), 'offset must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([offset]))
    return _ret


  @functools.native_method
  def sample_baked(self, offset:'float'   ) -> typing.Union[float]:
    r'''
				Returns the Y value for the point that would exist at the X position `offset` along the curve using the baked cache. Bakes the curve's points if not already baked.
			'''

    assert isinstance(offset, (int, float)), 'offset must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([offset]))
    return _ret


  @functools.native_method
  def get_point_left_tangent(self, index:'int'   ) -> typing.Union[float]:
    r'''
				Returns the left tangent angle (in degrees) for the point at `index`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(87,tuple([index]))
    return _ret


  @functools.native_method
  def get_point_right_tangent(self, index:'int'   ) -> typing.Union[float]:
    r'''
				Returns the right tangent angle (in degrees) for the point at `index`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([index]))
    return _ret


  @functools.native_method
  def get_point_left_mode(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the left `enum TangentMode` for the point at `index`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(89,tuple([index]))
    return _ret


  @functools.native_method
  def get_point_right_mode(self, index:'int'   ) -> typing.Union[int]:
    r'''
				Returns the right `enum TangentMode` for the point at `index`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    _ret:int
    _ret = self._ptr.call_with_return(90,tuple([index]))
    return _ret


  @functools.native_method
  def set_point_left_tangent(self, index:'int'   , tangent:'float'   ) -> None:
    r'''
				Sets the left tangent angle for the point at `index` to `tangent`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(tangent, (int, float)), 'tangent must be int or float'








    self._ptr.call_with_return(91,tuple([index, tangent]))

  @functools.native_method
  def set_point_right_tangent(self, index:'int'   , tangent:'float'   ) -> None:
    r'''
				Sets the right tangent angle for the point at `index` to `tangent`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(tangent, (int, float)), 'tangent must be int or float'








    self._ptr.call_with_return(92,tuple([index, tangent]))

  @functools.native_method
  def set_point_left_mode(self, index:'int'   , mode:'int'  ) -> None:
    r'''
				Sets the left `enum TangentMode` for the point at `index` to `mode`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(mode, (int, float)), 'mode must be int or float'








    self._ptr.call_with_return(93,tuple([index, mode]))

  @functools.native_method
  def set_point_right_mode(self, index:'int'   , mode:'int'  ) -> None:
    r'''
				Sets the right `enum TangentMode` for the point at `index` to `mode`.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'
    assert isinstance(mode, (int, float)), 'mode must be int or float'








    self._ptr.call_with_return(94,tuple([index, mode]))

  @functools.native_method
  def get_min_value(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(95,tuple([]))

    return _ret


  @functools.native_method
  def set_min_value(self, min:'float'   ) -> None:
    r''''''

    assert isinstance(min, (int, float)), 'min must be int or float'


    self.py__min_value = min






    self._ptr.call_with_return(96,tuple([min]))

  @functools.native_method
  def get_max_value(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(97,tuple([]))

    return _ret


  @functools.native_method
  def set_max_value(self, max:'float'   ) -> None:
    r''''''

    assert isinstance(max, (int, float)), 'max must be int or float'


    self.py__max_value = max






    self._ptr.call_with_return(98,tuple([max]))

  @functools.native_method
  def get_value_range(self) -> typing.Union[float]:
    r'''
				Returns the difference between `min_value` and `max_value`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([]))
    return _ret


  @functools.native_method
  def get_min_domain(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([]))

    return _ret


  @functools.native_method
  def set_min_domain(self, min:'float'   ) -> None:
    r''''''

    assert isinstance(min, (int, float)), 'min must be int or float'


    self.py__min_domain = min






    self._ptr.call_with_return(101,tuple([min]))

  @functools.native_method
  def get_max_domain(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([]))

    return _ret


  @functools.native_method
  def set_max_domain(self, max:'float'   ) -> None:
    r''''''

    assert isinstance(max, (int, float)), 'max must be int or float'


    self.py__max_domain = max






    self._ptr.call_with_return(103,tuple([max]))

  @functools.native_method
  def get_domain_range(self) -> typing.Union[float]:
    r'''
				Returns the difference between `min_domain` and `max_domain`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(104,tuple([]))
    return _ret


  @functools.native_method
  def clean_dupes(self) -> None:
    r'''
				Removes duplicate points, i.e. points that are less than 0.00001 units (engine epsilon value) away from their neighbor on the curve.
			'''




    self._ptr.call_with_return(105,tuple([]))

  @functools.native_method
  def bake(self) -> None:
    r'''
				Recomputes the baked cache of points for the curve.
			'''




    self._ptr.call_with_return(106,tuple([]))

  @functools.native_method
  def get_bake_resolution(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(107,tuple([]))

    return _ret


  @functools.native_method
  def set_bake_resolution(self, resolution:'int'   ) -> None:
    r''''''

    assert isinstance(resolution, (int, float)), 'resolution must be int or float'


    self.py__bake_resolution = resolution






    self._ptr.call_with_return(108,tuple([resolution]))


register_cast_function('Curve', Curve.cast)
register_class('Curve', Curve)
