# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.AnimationNodeOneShot as py4godot_animationnodeoneshot 
  import py4godot.classes.AnimationNodeAdd2 as py4godot_animationnodeadd2 
  import py4godot.classes.AnimationNodeTimeScale as py4godot_animationnodetimescale 
  import py4godot.classes.Animation as py4godot_animation 
  import py4godot.classes.AnimationNodeBlend3 as py4godot_animationnodeblend3 
  import py4godot.classes.AnimationNodeBlend2 as py4godot_animationnodeblend2 
  import py4godot.classes.AnimationNodeExtension as py4godot_animationnodeextension 
  import py4godot.classes.AnimationNodeSync as py4godot_animationnodesync 
  import py4godot.classes.AnimationNodeBlendSpace1D as py4godot_animationnodeblendspace1d 
  import py4godot.classes.AnimationNodeOutput as py4godot_animationnodeoutput 
  import py4godot.classes.AnimationNodeSub2 as py4godot_animationnodesub2 
  import py4godot.classes.AnimationNodeTimeSeek as py4godot_animationnodetimeseek 
  import py4godot.classes.AnimationNodeBlendSpace2D as py4godot_animationnodeblendspace2d 
  import py4godot.classes.AnimationNodeTransition as py4godot_animationnodetransition 
  import py4godot.classes.AnimationNodeBlendTree as py4godot_animationnodeblendtree 
  import py4godot.classes.AnimationNodeAdd3 as py4godot_animationnodeadd3 
  import py4godot.classes.AnimationNodeStateMachine as py4godot_animationnodestatemachine 
  import py4godot.classes.AnimationNodeAnimation as py4godot_animationnodeanimation 
  import py4godot.classes.AnimationRootNode as py4godot_animationrootnode 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPAnimationNodeWrapper

class FilterAction:
  FILTER_IGNORE = 0
  FILTER_PASS = 1
  FILTER_STOP = 2
  FILTER_BLEND = 3


class AnimationNode(py4godot_resource.Resource):
  r'''
		Base resource for `AnimationTree` nodes. In general, it's not used directly, but you can create custom ones with custom blending formulas.
		Inherit this when creating animation nodes mainly for use in `AnimationNodeBlendTree`, otherwise `AnimationRootNode` should be used instead.
		You can access the time information as read-only parameter which is processed and stored in the previous frame for all nodes except `AnimationNodeOutput`.
		**Note:** If multiple inputs exist in the `AnimationNode`, which time information takes precedence depends on the type of `AnimationNode`.
		```gdscript
		var current_length = $AnimationTree`"parameters/AnimationNodeName/current_length"`
		var current_position = $AnimationTree`"parameters/AnimationNodeName/current_position"`
		var current_delta = $AnimationTree`"parameters/AnimationNodeName/current_delta"`
		```
	'''

  @staticmethod
  def constructor():
    class_ = AnimationNode.construct_without_init()
    class_._ptr = constructor(75,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AnimationNode.construct_without_init()
    class_._ptr = constructor(75,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAnimationNodeWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(75,0, ())


  def generate_wrapper(self):
    return CPPAnimationNodeWrapper()
  def init_signals(self):
    super().init_signals()
    tree_changed_name = utils.py_string_to_string_name("tree_changed")
    self.tree_changed = signals.BuiltinSignal(self, tree_changed_name)
    animation_node_renamed_name = utils.py_string_to_string_name("animation_node_renamed")
    self.animation_node_renamed = signals.BuiltinSignal(self, animation_node_renamed_name)
    animation_node_removed_name = utils.py_string_to_string_name("animation_node_removed")
    self.animation_node_removed = signals.BuiltinSignal(self, animation_node_removed_name)

  @staticmethod
  def construct_without_init():
    cls = AnimationNode.__new__(AnimationNode)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AnimationNode'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(102, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimationNode.construct_without_init()
    cls._ptr = CPPAnimationNodeWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimationNode.construct_without_init()
    cls._ptr = CPPAnimationNodeWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def filter_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_filter_enabled()
    return _ret
  @filter_enabled.setter
  def filter_enabled(self,  value:'bool'):
    self.set_filter_enabled(value)
  @property
  def filters(self) -> typing.Union['Array']:
    r''''''
    _ret = self. _get_filters()
    return _ret
  @filters.setter
  def filters(self,  value:'Array'):
    self._set_filters(value)
  @functools.native_method
  def _get_child_nodes(self) -> typing.Union['Dictionary']:
    r'''
				When inheriting from `AnimationRootNode`, implement this virtual method to return all child animation nodes in order as a `name: node` dictionary.
			'''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(77,tuple([]))
    return _ret


  @functools.native_method
  def _get_parameter_list(self) -> typing.Union['Array']:
    r'''
				When inheriting from `AnimationRootNode`, implement this virtual method to return a list of the properties on this animation node. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees. Format is similar to `Object.get_property_list`.
			'''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([]))
    return _ret


  @functools.native_method
  def _get_child_by_name(self, name:'object'   ) -> typing.Any:
    r'''
				When inheriting from `AnimationRootNode`, implement this virtual method to return a child animation node by its `name`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = AnimationNode.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(79,tuple([py_stringname_name._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def _get_parameter_default_value(self, parameter:'object'   ) -> typing.Union[typing.Any]:
    r'''
				When inheriting from `AnimationRootNode`, implement this virtual method to return the default value of a `parameter`. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees.
			'''

    assert(not parameter is None)
    assert isinstance(parameter, (str, StringName)), 'parameter must be str or StringName'





    assert(isinstance(parameter, (str, StringName)))
    py_stringname_parameter = parameter if isinstance(parameter, StringName) else c_utils.py_string_to_string_name(parameter)

    _ret = None
    _ret = self._ptr.call_with_return(80,tuple([py_stringname_parameter._ptr]))
    return _ret


  @functools.native_method
  def _is_parameter_read_only(self, parameter:'object'   ) -> typing.Union[bool]:
    r'''
				When inheriting from `AnimationRootNode`, implement this virtual method to return whether the `parameter` is read-only. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees.
			'''

    assert(not parameter is None)
    assert isinstance(parameter, (str, StringName)), 'parameter must be str or StringName'





    assert(isinstance(parameter, (str, StringName)))
    py_stringname_parameter = parameter if isinstance(parameter, StringName) else c_utils.py_string_to_string_name(parameter)

    _ret = 0
    _ret = self._ptr.call_with_return(81,tuple([py_stringname_parameter._ptr]))
    return _ret


  @functools.native_method
  def _process(self, time:'float'   , seek:'bool'   , is_external_seeking:'bool'   , test_only:'bool'   ) -> typing.Union[float]:
    r'''
				When inheriting from `AnimationRootNode`, implement this virtual method to run some code when this animation node is processed. The `time` parameter is a relative delta, unless `seek` is `true`, in which case it is absolute.
				Here, call the `blend_input`, `blend_node` or `blend_animation` functions. You can also use `get_parameter` and `set_parameter` to modify local memory.
				This function should return the delta.
			'''

    assert isinstance(time, (int, float)), 'time must be int or float'
    assert isinstance(seek, bool), 'seek must be bool'
    assert isinstance(is_external_seeking, bool), 'is_external_seeking must be bool'
    assert isinstance(test_only, bool), 'test_only must be bool'










    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([time, seek, is_external_seeking, test_only]))
    return _ret


  @functools.native_method
  def _get_caption(self) -> typing.Union[str]:
    r'''
				When inheriting from `AnimationRootNode`, implement this virtual method to override the text caption for this animation node.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(83,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _has_filter(self) -> typing.Union[bool]:
    r'''
				When inheriting from `AnimationRootNode`, implement this virtual method to return whether the blend tree editor should display filter editing on this animation node.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(84,tuple([]))
    return _ret


  @functools.native_method
  def add_input(self, name:'str'   ) -> typing.Union[bool]:
    r'''
				Adds an input to the animation node. This is only useful for animation nodes created for use in an `AnimationNodeBlendTree`. If the addition fails, returns `false`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def remove_input(self, index:'int'   ) -> None:
    r'''
				Removes an input, call this only when inactive.
			'''

    assert isinstance(index, (int, float)), 'index must be int or float'







    self._ptr.call_with_return(86,tuple([index]))

  @functools.native_method
  def set_input_name(self, input:'int'   , name:'str'   ) -> typing.Union[bool]:
    r'''
				Sets the name of the input at the given `input` index. If the setting fails, returns `false`.
			'''

    assert isinstance(input, (int, float)), 'input must be int or float'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(87,tuple([input, py_string_name._ptr]))
    return _ret


  @functools.native_method
  def get_input_name(self, input:'int'   ) -> typing.Union[str]:
    r'''
				Gets the name of an input by index.
			'''

    assert isinstance(input, (int, float)), 'input must be int or float'







    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(88,tuple([input]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def get_input_count(self) -> typing.Union[int]:
    r'''
				Amount of inputs in this animation node, only useful for animation nodes that go into `AnimationNodeBlendTree`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(89,tuple([]))
    return _ret


  @functools.native_method
  def find_input(self, name:'str'   ) -> typing.Union[int]:
    r'''
				Returns the input index which corresponds to `name`. If not found, returns `-1`.
			'''

    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'





    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)

    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([py_string_name._ptr]))
    return _ret


  @functools.native_method
  def set_filter_path(self, path:'object'   , enable:'bool'   ) -> None:
    r'''
				Adds or removes a path for the filter.
			'''

    assert(not path is None)
    assert isinstance(path, (str, NodePath)), 'path must be str or NodePath'
    assert isinstance(enable, bool), 'enable must be bool'





    assert(isinstance(path, (str, NodePath)))
    py_nodepath_path = path if isinstance(path,NodePath) else NodePath.new2(path)


    self._ptr.call_with_return(91,tuple([py_nodepath_path._ptr, enable]))

  @functools.native_method
  def is_path_filtered(self, path:'object'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given path is filtered.
			'''

    assert(not path is None)
    assert isinstance(path, (str, NodePath)), 'path must be str or NodePath'





    assert(isinstance(path, (str, NodePath)))
    py_nodepath_path = path if isinstance(path,NodePath) else NodePath.new2(path)

    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([py_nodepath_path._ptr]))
    return _ret


  @functools.native_method
  def set_filter_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__filter_enabled = enable






    self._ptr.call_with_return(93,tuple([enable]))

  @functools.native_method
  def is_filter_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([]))

    return _ret


  @functools.native_method
  def get_processing_animation_tree_instance_id(self) -> typing.Union[int]:
    r'''
				Returns the object id of the `AnimationTree` that owns this node.
				**Note:** This method should only be called from within the `AnimationNodeExtension._process_animation_node` method, and will return an invalid id otherwise.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(95,tuple([]))
    return _ret


  @functools.native_method
  def is_process_testing(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this animation node is being processed in test-only mode.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(96,tuple([]))
    return _ret


  @functools.native_method
  def blend_animation(self, animation:'object'   , time:'float'   , delta:'float'   , seeked:'bool'   , is_external_seeking:'bool'   , blend:'float'   , looped_flag:'int'  =0) -> None:
    r'''
				Blends an animation by `blend` amount (name must be valid in the linked `AnimationPlayer`). A `time` and `delta` may be passed, as well as whether `seeked` happened.
				A `looped_flag` is used by internal processing immediately after the loop.
			'''


    assert(not animation is None)
    assert isinstance(animation, (str, StringName)), 'animation must be str or StringName'
    assert isinstance(time, (int, float)), 'time must be int or float'
    assert isinstance(delta, (int, float)), 'delta must be int or float'
    assert isinstance(seeked, bool), 'seeked must be bool'
    assert isinstance(is_external_seeking, bool), 'is_external_seeking must be bool'
    assert isinstance(blend, (int, float)), 'blend must be int or float'
    assert isinstance(looped_flag, (int, float)), 'looped_flag must be int or float'





    assert(isinstance(animation, (str, StringName)))
    py_stringname_animation = animation if isinstance(animation, StringName) else c_utils.py_string_to_string_name(animation)







    self._ptr.call_with_return(97,tuple([py_stringname_animation._ptr, time, delta, seeked, is_external_seeking, blend, looped_flag]))

  @functools.native_method
  def blend_node(self, name:'object'   , node:'AnimationNode'   , time:'float'   , seek:'bool'   , is_external_seeking:'bool'   , blend:'float'   , filter:'int'  =0, sync:'bool' =True  , test_only:'bool' =False  ) -> typing.Union[float]:
    r'''
				Blend another animation node (in case this animation node contains child animation nodes). This function is only useful if you inherit from `AnimationRootNode` instead, otherwise editors will not display your animation node for addition.
			'''


    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    assert(not node is None)
    assert isinstance(node, get_class('AnimationNode')), 'node must be AnimationNode'
    assert isinstance(time, (int, float)), 'time must be int or float'
    assert isinstance(seek, bool), 'seek must be bool'
    assert isinstance(is_external_seeking, bool), 'is_external_seeking must be bool'
    assert isinstance(blend, (int, float)), 'blend must be int or float'
    assert isinstance(filter, (int, float)), 'filter must be int or float'
    assert isinstance(sync, bool), 'sync must be bool'
    assert isinstance(test_only, bool), 'test_only must be bool'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)









    _ret = 0
    _ret = self._ptr.call_with_return(98,tuple([py_stringname_name._ptr, node._ptr, time, seek, is_external_seeking, blend, filter, sync, test_only]))
    return _ret


  @functools.native_method
  def blend_input(self, input_index:'int'   , time:'float'   , seek:'bool'   , is_external_seeking:'bool'   , blend:'float'   , filter:'int'  =0, sync:'bool' =True  , test_only:'bool' =False  ) -> typing.Union[float]:
    r'''
				Blends an input. This is only useful for animation nodes created for an `AnimationNodeBlendTree`. The `time` parameter is a relative delta, unless `seek` is `true`, in which case it is absolute. A filter mode may be optionally passed.
			'''


    assert isinstance(input_index, (int, float)), 'input_index must be int or float'
    assert isinstance(time, (int, float)), 'time must be int or float'
    assert isinstance(seek, bool), 'seek must be bool'
    assert isinstance(is_external_seeking, bool), 'is_external_seeking must be bool'
    assert isinstance(blend, (int, float)), 'blend must be int or float'
    assert isinstance(filter, (int, float)), 'filter must be int or float'
    assert isinstance(sync, bool), 'sync must be bool'
    assert isinstance(test_only, bool), 'test_only must be bool'














    _ret = 0
    _ret = self._ptr.call_with_return(99,tuple([input_index, time, seek, is_external_seeking, blend, filter, sync, test_only]))
    return _ret


  @functools.native_method
  def set_parameter(self, name:'object'   , value:'object'   ) -> None:
    r'''
				Sets a custom parameter. These are used as local memory, because resources can be reused across the tree or scenes.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'
    

    if not (type(value).__name__ in py4godot.variant_types.core_types or isinstance(value, classes.Object.Object)):
      raise ValueError(
                f"Unsupported type for argument 'value': "
                f"{type(value).__name__}. "
                "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
                "and built-in types int, float, and bool."
            )




    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)


    self._ptr.call_with_return(100,tuple([py_stringname_name._ptr, value]))

  @functools.native_method
  def get_parameter(self, name:'object'   ) -> typing.Union[typing.Any]:
    r'''
				Gets the value of a parameter. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees.
			'''

    assert(not name is None)
    assert isinstance(name, (str, StringName)), 'name must be str or StringName'





    assert(isinstance(name, (str, StringName)))
    py_stringname_name = name if isinstance(name, StringName) else c_utils.py_string_to_string_name(name)

    _ret = None
    _ret = self._ptr.call_with_return(101,tuple([py_stringname_name._ptr]))
    return _ret



register_cast_function('AnimationNode', AnimationNode.cast)
register_class('AnimationNode', AnimationNode)
