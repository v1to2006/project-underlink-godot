# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.JavaScriptObject as py4godot_javascriptobject 
import py4godot.classes.Object as py4godot_object 
from py4godot.wrappers.wrappers import CPPJavaScriptBridgeWrapper

_JavaScriptBridge_singleton_instance = None

class JavaScriptBridge(py4godot_object.Object):
  r'''
		The JavaScriptBridge singleton is implemented only in the Web export. It's used to access the browser's JavaScript context. This allows interaction with embedding pages or calling third-party JavaScript APIs.
		**Note:** This singleton can be disabled at build-time to improve security. By default, the JavaScriptBridge singleton is enabled. Official export templates also have the JavaScriptBridge singleton enabled. See `url=$DOCS_URL/engine_details/development/compiling/compiling_for_web.html`Compiling for the Web`/url` in the documentation for more information.
	'''


  def generate_wrapper(self):
    return CPPJavaScriptBridgeWrapper()
  def init_signals(self):
    super().init_signals()
    pwa_update_available_name = utils.py_string_to_string_name("pwa_update_available")
    self.pwa_update_available = signals.BuiltinSignal(self, pwa_update_available_name)

  @staticmethod
  def construct_without_init():
    cls = JavaScriptBridge.__new__(JavaScriptBridge)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'JavaScriptBridge'

  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = JavaScriptBridge.construct_without_init()
    cls._ptr = CPPJavaScriptBridgeWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = JavaScriptBridge.construct_without_init()
    cls._ptr = CPPJavaScriptBridgeWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls
  @staticmethod
  def instance():
    global _JavaScriptBridge_singleton_instance
    if _JavaScriptBridge_singleton_instance is None:
      singleton = JavaScriptBridge()
      singleton._ptr = constructor(440,0, ())
      _JavaScriptBridge_singleton_instance = singleton
    return _JavaScriptBridge_singleton_instance

  @functools.native_method
  def eval(self, code:'str'   , use_global_execution_context:'bool' =False  ) -> typing.Union[typing.Any]:
    r'''
				Execute the string `code` as JavaScript code within the browser window. This is a call to the actual global JavaScript function `code skip-lint`eval()`.
				If `use_global_execution_context` is `true`, the code will be evaluated in the global execution context. Otherwise, it is evaluated in the execution context of a function within the engine's runtime environment.
			'''

    assert(not code is None)
    assert isinstance(code, (str, String)), 'code must be str or String'
    assert isinstance(use_global_execution_context, bool), 'use_global_execution_context must be bool'





    assert(isinstance(code, (str, String)))
    py_string_code = code if isinstance(code, StringName) else c_utils.py_string_to_string(code)


    _ret = None
    _ret = self._ptr.call_with_return(49,tuple([py_string_code._ptr, use_global_execution_context]))
    return _ret


  @functools.native_method
  def get_interface_(self, interface:'str'   ) -> typing.Union['py4godot_javascriptobject.JavaScriptObject']:
    r'''
				Returns an interface to a JavaScript object that can be used by scripts. The `interface` must be a valid property of the JavaScript `window`. The callback must accept a single `Array` argument, which will contain the JavaScript `arguments`. See `JavaScriptObject` for usage.
			'''

    assert(not interface is None)
    assert isinstance(interface, (str, String)), 'interface must be str or String'





    assert(isinstance(interface, (str, String)))
    py_string_interface = interface if isinstance(interface, StringName) else c_utils.py_string_to_string(interface)

    _ret = classes.Object.Object.construct_without_init() #Smart casted to: JavaScriptObject
    _ret._ptr = self._ptr.call_with_return(50,tuple([py_string_interface._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def create_callback(self, callable:'Callable'   ) -> typing.Union['py4godot_javascriptobject.JavaScriptObject']:
    r'''
				Creates a reference to a `Callable` that can be used as a callback by JavaScript. The reference must be kept until the callback happens, or it won't be called at all. See `JavaScriptObject` for usage.
				**Note:** The callback function must take exactly one `Array` argument, which is going to be the JavaScript `url=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments`arguments object`/url` converted to an array.
			'''

    assert(not callable is None)
    assert isinstance(callable, Callable), 'callable must be Callable'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: JavaScriptObject
    _ret._ptr = self._ptr.call_with_return(51,tuple([callable._ptr]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def is_js_buffer(self, javascript_object:'py4godot_javascriptobject.JavaScriptObject'   ) -> typing.Union[bool]:
    r'''
				Returns `true` if the given `javascript_object` is of type `url=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer``ArrayBuffer``/url`, `url=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView``DataView``/url`, or one of the many `url=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray`typed array objects`/url`.
			'''

    assert(not javascript_object is None)
    assert isinstance(javascript_object, get_class('JavaScriptObject')), 'javascript_object must be JavaScriptObject'







    _ret = 0
    _ret = self._ptr.call_with_return(52,tuple([javascript_object._ptr]))
    return _ret


  @functools.native_method
  def js_buffer_to_packed_byte_array(self, javascript_buffer:'py4godot_javascriptobject.JavaScriptObject'   ) -> typing.Union['PackedByteArray']:
    r'''
				Returns a copy of `javascript_buffer`'s contents as a `PackedByteArray`. See also `is_js_buffer`.
			'''

    assert(not javascript_buffer is None)
    assert isinstance(javascript_buffer, get_class('JavaScriptObject')), 'javascript_buffer must be JavaScriptObject'







    _ret = PackedByteArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([javascript_buffer._ptr]))
    return _ret


  @functools.native_method
  def create_object(self, object_:'str'   , *varargs) -> typing.Union[typing.Any]:
    r'''
				Creates a new JavaScript object using the `new` constructor. The `object` must a valid property of the JavaScript `window`. See `JavaScriptObject` for usage.
			'''

    assert(not object_ is None)
    assert isinstance(object_, (str, String)), 'object_ must be str or String'

    for arg in varargs:
      if not (type(arg).__name__ in py4godot.variant_types.core_types or isinstance(arg, classes.Object.Object)):
        raise ValueError(
            f"Unsupported type in varargs: {type(arg).__name__}. "
            "Supported types are: Godot types (Vector3, Vector2, Array, Object, ...) "
            "and built-in types int, float, and bool."
        )



    assert(isinstance(object_, (str, String)))
    py_string_object_ = object_ if isinstance(object_, StringName) else c_utils.py_string_to_string(object_)

    _ret = None
    _ret = self._ptr.call_with_return(54,tuple([py_string_object_._ptr, *varargs]))
    return _ret


  @functools.native_method
  def download_buffer(self, buffer:'PackedByteArray'   , name:'str'   , mime:'str' ="application/octet-stream"  ) -> None:
    r'''
				Prompts the user to download a file containing the specified `buffer`. The file will have the given `name` and `mime` type.
				**Note:** The browser may override the `url=https://en.wikipedia.org/wiki/Media_type`MIME type`/url` provided based on the file `name`'s extension.
				**Note:** Browsers might block the download if `download_buffer` is not being called from a user interaction (e.g. button click).
				**Note:** Browsers might ask the user for permission or block the download if multiple download requests are made in a quick succession.
			'''
    if mime is None:
      mime = String.new0()

    assert(not buffer is None)
    assert isinstance(buffer, PackedByteArray), 'buffer must be PackedByteArray'
    assert(not name is None)
    assert isinstance(name, (str, String)), 'name must be str or String'






    assert(isinstance(name, (str, String)))
    py_string_name = name if isinstance(name, StringName) else c_utils.py_string_to_string(name)
    assert(isinstance(mime, (str, String)))
    py_string_mime = mime if isinstance(mime, StringName) else c_utils.py_string_to_string(mime)

    self._ptr.call_with_return(55,tuple([buffer._ptr, py_string_name._ptr, py_string_mime._ptr]))

  @functools.native_method
  def pwa_needs_update(self) -> typing.Union[bool]:
    r'''
				Returns `true` if a new version of the progressive web app is waiting to be activated.
				**Note:** Only relevant when exported as a Progressive Web App.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([]))
    return _ret


  @functools.native_method
  def pwa_update(self) -> typing.Union[int]:
    r'''
				Performs the live update of the progressive web app. Forcing the new version to be installed and the page to be reloaded.
				**Note:** Your application will be **reloaded in all browser tabs**.
				**Note:** Only relevant when exported as a Progressive Web App and `pwa_needs_update` returns `true`.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(57,tuple([]))
    return _ret


  @functools.native_method
  def force_fs_sync(self) -> None:
    r'''
				Force synchronization of the persistent file system (when enabled).
				**Note:** This is only useful for modules or extensions that can't use `FileAccess` to write files.
			'''




    self._ptr.call_with_return(58,tuple([]))


register_cast_function('JavaScriptBridge', JavaScriptBridge.cast)
register_class('JavaScriptBridge', JavaScriptBridge)
