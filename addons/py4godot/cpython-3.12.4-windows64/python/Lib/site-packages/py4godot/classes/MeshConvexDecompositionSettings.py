# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPMeshConvexDecompositionSettingsWrapper

class Mode:
  CONVEX_DECOMPOSITION_MODE_VOXEL = 0
  CONVEX_DECOMPOSITION_MODE_TETRAHEDRON = 1


class MeshConvexDecompositionSettings(py4godot_refcounted.RefCounted):
  r'''
		Parameters to be used with a `Mesh` convex decomposition operation.
	'''

  @staticmethod
  def constructor():
    class_ = MeshConvexDecompositionSettings.construct_without_init()
    class_._ptr = constructor(471,0, ())
    return class_
  @staticmethod
  def new():
    class_ = MeshConvexDecompositionSettings.construct_without_init()
    class_._ptr = constructor(471,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPMeshConvexDecompositionSettingsWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(471,0, ())


  def generate_wrapper(self):
    return CPPMeshConvexDecompositionSettingsWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = MeshConvexDecompositionSettings.__new__(MeshConvexDecompositionSettings)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'MeshConvexDecompositionSettings'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(79, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = MeshConvexDecompositionSettings.construct_without_init()
    cls._ptr = CPPMeshConvexDecompositionSettingsWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = MeshConvexDecompositionSettings.construct_without_init()
    cls._ptr = CPPMeshConvexDecompositionSettingsWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def max_concavity(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_max_concavity()
    return _ret
  @max_concavity.setter
  def max_concavity(self,  value:'float'):
    self.set_max_concavity(value)
  @property
  def symmetry_planes_clipping_bias(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_symmetry_planes_clipping_bias()
    return _ret
  @symmetry_planes_clipping_bias.setter
  def symmetry_planes_clipping_bias(self,  value:'float'):
    self.set_symmetry_planes_clipping_bias(value)
  @property
  def revolution_axes_clipping_bias(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_revolution_axes_clipping_bias()
    return _ret
  @revolution_axes_clipping_bias.setter
  def revolution_axes_clipping_bias(self,  value:'float'):
    self.set_revolution_axes_clipping_bias(value)
  @property
  def min_volume_per_convex_hull(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_min_volume_per_convex_hull()
    return _ret
  @min_volume_per_convex_hull.setter
  def min_volume_per_convex_hull(self,  value:'float'):
    self.set_min_volume_per_convex_hull(value)
  @property
  def resolution(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_resolution()
    return _ret
  @resolution.setter
  def resolution(self,  value:'int'):
    self.set_resolution(value)
  @property
  def max_num_vertices_per_convex_hull(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_num_vertices_per_convex_hull()
    return _ret
  @max_num_vertices_per_convex_hull.setter
  def max_num_vertices_per_convex_hull(self,  value:'int'):
    self.set_max_num_vertices_per_convex_hull(value)
  @property
  def plane_downsampling(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_plane_downsampling()
    return _ret
  @plane_downsampling.setter
  def plane_downsampling(self,  value:'int'):
    self.set_plane_downsampling(value)
  @property
  def convex_hull_downsampling(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_convex_hull_downsampling()
    return _ret
  @convex_hull_downsampling.setter
  def convex_hull_downsampling(self,  value:'int'):
    self.set_convex_hull_downsampling(value)
  @property
  def normalize_mesh(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_normalize_mesh()
    return _ret
  @normalize_mesh.setter
  def normalize_mesh(self,  value:'bool'):
    self.set_normalize_mesh(value)
  @property
  def mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_mode()
    return _ret
  @mode.setter
  def mode(self,  value:'int'):
    self.set_mode(value)
  @property
  def convex_hull_approximation(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_convex_hull_approximation()
    return _ret
  @convex_hull_approximation.setter
  def convex_hull_approximation(self,  value:'bool'):
    self.set_convex_hull_approximation(value)
  @property
  def max_convex_hulls(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_max_convex_hulls()
    return _ret
  @max_convex_hulls.setter
  def max_convex_hulls(self,  value:'int'):
    self.set_max_convex_hulls(value)
  @property
  def project_hull_vertices(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_project_hull_vertices()
    return _ret
  @project_hull_vertices.setter
  def project_hull_vertices(self,  value:'bool'):
    self.set_project_hull_vertices(value)
  @functools.native_method
  def set_max_concavity(self, max_concavity:'float'   ) -> None:
    r''''''

    assert isinstance(max_concavity, (int, float)), 'max_concavity must be int or float'


    self.py__max_concavity = max_concavity






    self._ptr.call_with_return(53,tuple([max_concavity]))

  @functools.native_method
  def get_max_concavity(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(54,tuple([]))

    return _ret


  @functools.native_method
  def set_symmetry_planes_clipping_bias(self, symmetry_planes_clipping_bias:'float'   ) -> None:
    r''''''

    assert isinstance(symmetry_planes_clipping_bias, (int, float)), 'symmetry_planes_clipping_bias must be int or float'


    self.py__symmetry_planes_clipping_bias = symmetry_planes_clipping_bias






    self._ptr.call_with_return(55,tuple([symmetry_planes_clipping_bias]))

  @functools.native_method
  def get_symmetry_planes_clipping_bias(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(56,tuple([]))

    return _ret


  @functools.native_method
  def set_revolution_axes_clipping_bias(self, revolution_axes_clipping_bias:'float'   ) -> None:
    r''''''

    assert isinstance(revolution_axes_clipping_bias, (int, float)), 'revolution_axes_clipping_bias must be int or float'


    self.py__revolution_axes_clipping_bias = revolution_axes_clipping_bias






    self._ptr.call_with_return(57,tuple([revolution_axes_clipping_bias]))

  @functools.native_method
  def get_revolution_axes_clipping_bias(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(58,tuple([]))

    return _ret


  @functools.native_method
  def set_min_volume_per_convex_hull(self, min_volume_per_convex_hull:'float'   ) -> None:
    r''''''

    assert isinstance(min_volume_per_convex_hull, (int, float)), 'min_volume_per_convex_hull must be int or float'


    self.py__min_volume_per_convex_hull = min_volume_per_convex_hull






    self._ptr.call_with_return(59,tuple([min_volume_per_convex_hull]))

  @functools.native_method
  def get_min_volume_per_convex_hull(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(60,tuple([]))

    return _ret


  @functools.native_method
  def set_resolution(self, min_volume_per_convex_hull:'int'   ) -> None:
    r''''''

    assert isinstance(min_volume_per_convex_hull, (int, float)), 'min_volume_per_convex_hull must be int or float'


    self.py__resolution = min_volume_per_convex_hull






    self._ptr.call_with_return(61,tuple([min_volume_per_convex_hull]))

  @functools.native_method
  def get_resolution(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(62,tuple([]))

    return _ret


  @functools.native_method
  def set_max_num_vertices_per_convex_hull(self, max_num_vertices_per_convex_hull:'int'   ) -> None:
    r''''''

    assert isinstance(max_num_vertices_per_convex_hull, (int, float)), 'max_num_vertices_per_convex_hull must be int or float'


    self.py__max_num_vertices_per_convex_hull = max_num_vertices_per_convex_hull






    self._ptr.call_with_return(63,tuple([max_num_vertices_per_convex_hull]))

  @functools.native_method
  def get_max_num_vertices_per_convex_hull(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(64,tuple([]))

    return _ret


  @functools.native_method
  def set_plane_downsampling(self, plane_downsampling:'int'   ) -> None:
    r''''''

    assert isinstance(plane_downsampling, (int, float)), 'plane_downsampling must be int or float'


    self.py__plane_downsampling = plane_downsampling






    self._ptr.call_with_return(65,tuple([plane_downsampling]))

  @functools.native_method
  def get_plane_downsampling(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(66,tuple([]))

    return _ret


  @functools.native_method
  def set_convex_hull_downsampling(self, convex_hull_downsampling:'int'   ) -> None:
    r''''''

    assert isinstance(convex_hull_downsampling, (int, float)), 'convex_hull_downsampling must be int or float'


    self.py__convex_hull_downsampling = convex_hull_downsampling






    self._ptr.call_with_return(67,tuple([convex_hull_downsampling]))

  @functools.native_method
  def get_convex_hull_downsampling(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(68,tuple([]))

    return _ret


  @functools.native_method
  def set_normalize_mesh(self, normalize_mesh:'bool'   ) -> None:
    r''''''

    assert isinstance(normalize_mesh, bool), 'normalize_mesh must be bool'


    self.py__normalize_mesh = normalize_mesh






    self._ptr.call_with_return(69,tuple([normalize_mesh]))

  @functools.native_method
  def get_normalize_mesh(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(70,tuple([]))

    return _ret


  @functools.native_method
  def set_mode(self, mode:'int'  ) -> None:
    r''''''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__mode = mode






    self._ptr.call_with_return(71,tuple([mode]))

  @functools.native_method
  def get_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(72,tuple([]))

    return _ret


  @functools.native_method
  def set_convex_hull_approximation(self, convex_hull_approximation:'bool'   ) -> None:
    r''''''

    assert isinstance(convex_hull_approximation, bool), 'convex_hull_approximation must be bool'


    self.py__convex_hull_approximation = convex_hull_approximation






    self._ptr.call_with_return(73,tuple([convex_hull_approximation]))

  @functools.native_method
  def get_convex_hull_approximation(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(74,tuple([]))

    return _ret


  @functools.native_method
  def set_max_convex_hulls(self, max_convex_hulls:'int'   ) -> None:
    r''''''

    assert isinstance(max_convex_hulls, (int, float)), 'max_convex_hulls must be int or float'


    self.py__max_convex_hulls = max_convex_hulls






    self._ptr.call_with_return(75,tuple([max_convex_hulls]))

  @functools.native_method
  def get_max_convex_hulls(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(76,tuple([]))

    return _ret


  @functools.native_method
  def set_project_hull_vertices(self, project_hull_vertices:'bool'   ) -> None:
    r''''''

    assert isinstance(project_hull_vertices, bool), 'project_hull_vertices must be bool'


    self.py__project_hull_vertices = project_hull_vertices






    self._ptr.call_with_return(77,tuple([project_hull_vertices]))

  @functools.native_method
  def get_project_hull_vertices(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(78,tuple([]))

    return _ret



register_cast_function('MeshConvexDecompositionSettings', MeshConvexDecompositionSettings.cast)
register_class('MeshConvexDecompositionSettings', MeshConvexDecompositionSettings)
