# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
import py4godot.classes.Shape2D as py4godot_shape2d 
from py4godot.wrappers.wrappers import CPPConcavePolygonShape2DWrapper


class ConcavePolygonShape2D(py4godot_shape2d.Shape2D):
  r'''
		A 2D polyline shape, intended for use in physics. Used internally in `CollisionPolygon2D` when it's in `constant CollisionPolygon2D.BUILD_SEGMENTS` mode.
		Being just a collection of interconnected line segments, `ConcavePolygonShape2D` is the most freely configurable single 2D shape. It can be used to form polygons of any nature, or even shapes that don't enclose an area. However, `ConcavePolygonShape2D` is _hollow_ even if the interconnected line segments do enclose an area, which often makes it unsuitable for physics or detection.
		**Note:** When used for collision, `ConcavePolygonShape2D` is intended to work with static `CollisionShape2D` nodes like `StaticBody2D` and will likely not behave well for `CharacterBody2D`s or `RigidBody2D`s in a mode other than Static.
		**Warning:** Physics bodies that are small have a chance to clip through this shape when moving fast. This happens because on one frame, the physics body may be on the "outside" of the shape, and on the next frame it may be "inside" it. `ConcavePolygonShape2D` is hollow, so it won't detect a collision.
		**Performance:** Due to its complexity, `ConcavePolygonShape2D` is the slowest 2D collision shape to check collisions against. Its use should generally be limited to level geometry. If the polyline is closed, `CollisionPolygon2D`'s `constant CollisionPolygon2D.BUILD_SOLIDS` mode can be used, which decomposes the polygon into convex ones; see `ConvexPolygonShape2D`'s documentation for instructions.
	'''

  @staticmethod
  def constructor():
    class_ = ConcavePolygonShape2D.construct_without_init()
    class_._ptr = constructor(233,0, ())
    return class_
  @staticmethod
  def new():
    class_ = ConcavePolygonShape2D.construct_without_init()
    class_._ptr = constructor(233,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPConcavePolygonShape2DWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(233,0, ())


  def generate_wrapper(self):
    return CPPConcavePolygonShape2DWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = ConcavePolygonShape2D.__new__(ConcavePolygonShape2D)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'ConcavePolygonShape2D'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(87, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = ConcavePolygonShape2D.construct_without_init()
    cls._ptr = CPPConcavePolygonShape2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = ConcavePolygonShape2D.construct_without_init()
    cls._ptr = CPPConcavePolygonShape2DWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def segments(self) -> typing.Union['PackedVector2Array']:
    r''''''
    _ret = self. get_segments()
    return _ret
  @segments.setter
  def segments(self,  value:'PackedVector2Array'):
    self.set_segments(value)
  @functools.native_method
  def set_segments(self, segments:'PackedVector2Array'   ) -> None:
    r''''''

    assert(not segments is None)
    assert isinstance(segments, PackedVector2Array), 'segments must be PackedVector2Array'


    self.py__segments = segments






    self._ptr.call_with_return(85,tuple([segments._ptr]))

  @functools.native_method
  def get_segments(self) -> typing.Union['PackedVector2Array']:
    r''''''




    _ret = PackedVector2Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(86,tuple([]))

    return _ret



register_cast_function('ConcavePolygonShape2D', ConcavePolygonShape2D.cast)
register_class('ConcavePolygonShape2D', ConcavePolygonShape2D)
