# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.OpenXRInterface as py4godot_openxrinterface 
  import py4godot.classes.XRInterfaceExtension as py4godot_xrinterfaceextension 
  import py4godot.classes.WebXRInterface as py4godot_webxrinterface 
  import py4godot.classes.MobileVRInterface as py4godot_mobilevrinterface 
import py4godot.classes.RefCounted as py4godot_refcounted 
from py4godot.wrappers.wrappers import CPPXRInterfaceWrapper

class Capabilities:
  XR_NONE = 0
  XR_MONO = 1
  XR_STEREO = 2
  XR_QUAD = 4
  XR_VR = 8
  XR_AR = 16
  XR_EXTERNAL = 32
class TrackingStatus:
  XR_NORMAL_TRACKING = 0
  XR_EXCESSIVE_MOTION = 1
  XR_INSUFFICIENT_FEATURES = 2
  XR_UNKNOWN_TRACKING = 3
  XR_NOT_TRACKING = 4
class PlayAreaMode:
  XR_PLAY_AREA_UNKNOWN = 0
  XR_PLAY_AREA_3DOF = 1
  XR_PLAY_AREA_SITTING = 2
  XR_PLAY_AREA_ROOMSCALE = 3
  XR_PLAY_AREA_STAGE = 4
  XR_PLAY_AREA_CUSTOM = 2147483647
class EnvironmentBlendMode:
  XR_ENV_BLEND_MODE_OPAQUE = 0
  XR_ENV_BLEND_MODE_ADDITIVE = 1
  XR_ENV_BLEND_MODE_ALPHA_BLEND = 2
class VRSTextureFormat:
  XR_VRS_TEXTURE_FORMAT_UNIFIED = 0
  XR_VRS_TEXTURE_FORMAT_FRAGMENT_SHADING_RATE = 1
  XR_VRS_TEXTURE_FORMAT_FRAGMENT_DENSITY_MAP = 2


class XRInterface(py4godot_refcounted.RefCounted):
  r'''
		This class needs to be implemented to make an AR or VR platform available to Godot and these should be implemented as C++ modules or GDExtension modules. Part of the interface is exposed to GDScript so you can detect, enable and configure an AR or VR platform.
		Interfaces should be written in such a way that simply enabling them will give us a working setup. You can query the available interfaces through `XRServer`.
	'''

  @staticmethod
  def constructor():
    class_ = XRInterface.construct_without_init()
    class_._ptr = constructor(1021,0, ())
    return class_
  @staticmethod
  def new():
    class_ = XRInterface.construct_without_init()
    class_._ptr = constructor(1021,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPXRInterfaceWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(1021,0, ())


  def generate_wrapper(self):
    return CPPXRInterfaceWrapper()
  def init_signals(self):
    super().init_signals()
    play_area_changed_name = utils.py_string_to_string_name("play_area_changed")
    self.play_area_changed = signals.BuiltinSignal(self, play_area_changed_name)

  @staticmethod
  def construct_without_init():
    cls = XRInterface.__new__(XRInterface)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'XRInterface'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(81, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = XRInterface.construct_without_init()
    cls._ptr = CPPXRInterfaceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = XRInterface.construct_without_init()
    cls._ptr = CPPXRInterfaceWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def interface_is_primary(self) -> typing.Union[bool]:
    r''''''
    _ret = self. is_primary()
    return _ret
  @interface_is_primary.setter
  def interface_is_primary(self,  value:'bool'):
    self.set_primary(value)
  @property
  def xr_play_area_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_play_area_mode()
    return _ret
  @xr_play_area_mode.setter
  def xr_play_area_mode(self,  value:'int'):
    self.set_play_area_mode(value)
  @property
  def environment_blend_mode(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_environment_blend_mode()
    return _ret
  @environment_blend_mode.setter
  def environment_blend_mode(self,  value:'int'):
    self.set_environment_blend_mode(value)
  @property
  def ar_is_anchor_detection_enabled(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_anchor_detection_is_enabled()
    return _ret
  @ar_is_anchor_detection_enabled.setter
  def ar_is_anchor_detection_enabled(self,  value:'bool'):
    self.set_anchor_detection_is_enabled(value)
  @functools.native_method
  def get_name(self) -> typing.Union['StringName']:
    r'''
				Returns the name of this interface (`"OpenXR"`, `"OpenVR"`, `"OpenHMD"`, `"ARKit"`, etc.).
			'''




    _ret = StringName.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(53,tuple([]))
    return str(_ret)


  @functools.native_method
  def get_capabilities(self) -> typing.Union[int]:
    r'''
				Returns a combination of `enum Capabilities` flags providing information about the capabilities of this interface.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(54,tuple([]))
    return _ret


  @functools.native_method
  def is_primary(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(55,tuple([]))

    return _ret


  @functools.native_method
  def set_primary(self, primary:'bool'   ) -> None:
    r''''''

    assert isinstance(primary, bool), 'primary must be bool'


    self.py__interface_is_primary = primary






    self._ptr.call_with_return(56,tuple([primary]))

  @functools.native_method
  def is_initialized(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this interface has been initialized.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(57,tuple([]))
    return _ret


  @functools.native_method
  def initialize(self) -> typing.Union[bool]:
    r'''
				Call this to initialize this interface. The first interface that is initialized is identified as the primary interface and it will be used for rendering output.
				After initializing the interface you want to use you then need to enable the AR/VR mode of a viewport and rendering should commence.
				**Note:** You must enable the XR mode on the main viewport for any device that uses the main output of Godot, such as for mobile VR.
				If you do this for a platform that handles its own output (such as OpenVR) Godot will show just one eye without distortion on screen. Alternatively, you can add a separate viewport node to your scene and enable AR/VR on that viewport. It will be used to output to the HMD, leaving you free to do anything you like in the main window, such as using a separate camera as a spectator camera or rendering something completely different.
				While currently not used, you can activate additional interfaces. You may wish to do this if you want to track controllers from other platforms. However, at this point in time only one interface can render to an HMD.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(58,tuple([]))
    return _ret


  @functools.native_method
  def uninitialize(self) -> None:
    r'''
				Turns the interface off.
			'''




    self._ptr.call_with_return(59,tuple([]))

  @functools.native_method
  def get_system_info(self) -> typing.Union['Dictionary']:
    r'''
				Returns a `Dictionary` with extra system info. Interfaces are expected to return `XRRuntimeName` and `XRRuntimeVersion` providing info about the used XR runtime. Additional entries may be provided specific to an interface.
				**Note:**This information may only be available after `initialize` was successfully called.
			'''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(60,tuple([]))
    return _ret


  @functools.native_method
  def get_tracking_status(self) -> typing.Union[int]:
    r'''
				If supported, returns the status of our tracking. This will allow you to provide feedback to the user whether there are issues with positional tracking.
			'''




    _ret:int
    _ret = self._ptr.call_with_return(61,tuple([]))
    return _ret


  @functools.native_method
  def get_render_target_size(self) -> typing.Union['Vector2']:
    r'''
				Returns the resolution at which we should render our intermediate results before things like lens distortion are applied by the VR platform.
			'''




    _ret = Vector2.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(62,tuple([]))
    return _ret


  @functools.native_method
  def get_view_count(self) -> typing.Union[int]:
    r'''
				Returns the number of views that need to be rendered for this device. 1 for Monoscopic, 2 for Stereoscopic.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(63,tuple([]))
    return _ret


  @functools.native_method
  def trigger_haptic_pulse(self, action_name:'str'   , tracker_name:'object'   , frequency:'float'   , amplitude:'float'   , duration_sec:'float'   , delay_sec:'float'   ) -> None:
    r'''
				Triggers a haptic pulse on a device associated with this interface.
				`action_name` is the name of the action for this pulse.
				`tracker_name` is optional and can be used to direct the pulse to a specific device provided that device is bound to this haptic.
				`frequency` is the frequency of the pulse, set to `0.0` to have the system use a default frequency.
				`amplitude` is the amplitude of the pulse between `0.0` and `1.0`.
				`duration_sec` is the duration of the pulse in seconds.
				`delay_sec` is a delay in seconds before the pulse is given.
			'''

    assert(not action_name is None)
    assert isinstance(action_name, (str, String)), 'action_name must be str or String'
    assert(not tracker_name is None)
    assert isinstance(tracker_name, (str, StringName)), 'tracker_name must be str or StringName'
    assert isinstance(frequency, (int, float)), 'frequency must be int or float'
    assert isinstance(amplitude, (int, float)), 'amplitude must be int or float'
    assert isinstance(duration_sec, (int, float)), 'duration_sec must be int or float'
    assert isinstance(delay_sec, (int, float)), 'delay_sec must be int or float'





    assert(isinstance(action_name, (str, String)))
    py_string_action_name = action_name if isinstance(action_name, StringName) else c_utils.py_string_to_string(action_name)
    assert(isinstance(tracker_name, (str, StringName)))
    py_stringname_tracker_name = tracker_name if isinstance(tracker_name, StringName) else c_utils.py_string_to_string_name(tracker_name)





    self._ptr.call_with_return(64,tuple([py_string_action_name._ptr, py_stringname_tracker_name._ptr, frequency, amplitude, duration_sec, delay_sec]))

  @functools.native_method
  def supports_play_area_mode(self, mode:'int'  ) -> typing.Union[bool]:
    r'''
				Call this to find out if a given play area mode is supported by this interface.
			'''

    assert isinstance(mode, (int, float)), 'mode must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(65,tuple([mode]))
    return _ret


  @functools.native_method
  def get_play_area_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(66,tuple([]))

    return _ret


  @functools.native_method
  def set_play_area_mode(self, mode:'int'  ) -> typing.Union[bool]:
    r'''
				Sets the active play area mode, will return `false` if the mode can't be used with this interface.
				**Note:** Changing this after the interface has already been initialized can be jarring for the player, so it's recommended to recenter on the HMD with `XRServer.center_on_hmd` (if switching to `constant XRInterface.XR_PLAY_AREA_STAGE`) or make the switch during a scene change.
			'''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__xr_play_area_mode = mode






    _ret = 0
    _ret = self._ptr.call_with_return(67,tuple([mode]))
    return _ret


  @functools.native_method
  def get_play_area(self) -> typing.Union['PackedVector3Array']:
    r'''
				Returns an array of vectors that represent the physical play area mapped to the virtual space around the `XROrigin3D` point. The points form a convex polygon that can be used to react to or visualize the play area. This returns an empty array if this feature is not supported or if the information is not yet available.
			'''




    _ret = PackedVector3Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(68,tuple([]))
    return _ret


  @functools.native_method
  def get_anchor_detection_is_enabled(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(69,tuple([]))

    return _ret


  @functools.native_method
  def set_anchor_detection_is_enabled(self, enable:'bool'   ) -> None:
    r''''''

    assert isinstance(enable, bool), 'enable must be bool'


    self.py__ar_is_anchor_detection_enabled = enable






    self._ptr.call_with_return(70,tuple([enable]))

  @functools.native_method
  def get_camera_feed_id(self) -> typing.Union[int]:
    r'''
				If this is an AR interface that requires displaying a camera feed as the background, this method returns the feed ID in the `CameraServer` for this interface.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(71,tuple([]))
    return _ret


  @functools.native_method
  def is_passthrough_supported(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this interface supports passthrough.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(72,tuple([]))
    return _ret


  @functools.native_method
  def is_passthrough_enabled(self) -> typing.Union[bool]:
    r'''
				Returns `true` if passthrough is enabled.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(73,tuple([]))
    return _ret


  @functools.native_method
  def start_passthrough(self) -> typing.Union[bool]:
    r'''
				Starts passthrough, will return `false` if passthrough couldn't be started.
				**Note:** The viewport used for XR must have a transparent background, otherwise passthrough may not properly render.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(74,tuple([]))
    return _ret


  @functools.native_method
  def stop_passthrough(self) -> None:
    r'''
				Stops passthrough.
			'''




    self._ptr.call_with_return(75,tuple([]))

  @functools.native_method
  def get_transform_for_view(self, view:'int'   , cam_transform:'Transform3D'   ) -> typing.Union['Transform3D']:
    r'''
				Returns the transform for a view/eye.
				`view` is the view/eye index.
				`cam_transform` is the transform that maps device coordinates to scene coordinates, typically the `Node3D.global_transform` of the current XROrigin3D.
			'''

    assert isinstance(view, (int, float)), 'view must be int or float'
    assert(not cam_transform is None)
    assert isinstance(cam_transform, Transform3D), 'cam_transform must be Transform3D'








    _ret = Transform3D.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(76,tuple([view, cam_transform._ptr]))
    return _ret


  @functools.native_method
  def get_projection_for_view(self, view:'int'   , aspect:'float'   , near:'float'   , far:'float'   ) -> typing.Union['Projection']:
    r'''
				Returns the projection matrix for a view/eye.
			'''

    assert isinstance(view, (int, float)), 'view must be int or float'
    assert isinstance(aspect, (int, float)), 'aspect must be int or float'
    assert isinstance(near, (int, float)), 'near must be int or float'
    assert isinstance(far, (int, float)), 'far must be int or float'










    _ret = Projection.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(77,tuple([view, aspect, near, far]))
    return _ret


  @functools.native_method
  def get_supported_environment_blend_modes(self) -> typing.Union['Array']:
    r'''
				Returns the an array of supported environment blend modes, see `enum XRInterface.EnvironmentBlendMode`.
			'''




    _ret = Array.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([]))
    return _ret


  @functools.native_method
  def set_environment_blend_mode(self, mode:'int'  ) -> typing.Union[bool]:
    r'''
				Sets the active environment blend mode.
				`mode` is the environment blend mode starting with the next frame.
				**Note:** Not all runtimes support all environment blend modes, so it is important to check this at startup. For example:
				```gdscript
				func _ready():
					var xr_interface = XRServer.find_interface("OpenXR")
					if xr_interface and xr_interface.is_initialized():
						var vp = get_viewport()
						vp.use_xr = true
						var acceptable_modes = `XRInterface.XR_ENV_BLEND_MODE_OPAQUE, XRInterface.XR_ENV_BLEND_MODE_ADDITIVE`
						var modes = xr_interface.get_supported_environment_blend_modes()
						for mode in acceptable_modes:
							if mode in modes:
								xr_interface.set_environment_blend_mode(mode)
								break
				```
			'''

    assert isinstance(mode, (int, float)), 'mode must be int or float'


    self.py__environment_blend_mode = mode






    _ret = 0
    _ret = self._ptr.call_with_return(79,tuple([mode]))
    return _ret


  @functools.native_method
  def get_environment_blend_mode(self) -> typing.Union[int]:
    r''''''




    _ret:int
    _ret = self._ptr.call_with_return(80,tuple([]))

    return _ret



register_cast_function('XRInterface', XRInterface.cast)
register_class('XRInterface', XRInterface)
