# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.AudioStreamGeneratorPlayback as py4godot_audiostreamgeneratorplayback 
  import py4godot.classes.AudioStreamPlaybackPolyphonic as py4godot_audiostreamplaybackpolyphonic 
  import py4godot.classes.AudioSample as py4godot_audiosample 
  import py4godot.classes.AudioStreamPlayback as py4godot_audiostreamplayback 
  import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
  import py4godot.classes.AudioStreamPlaybackPlaylist as py4godot_audiostreamplaybackplaylist 
  import py4godot.classes.AudioStreamPlaybackInteractive as py4godot_audiostreamplaybackinteractive 
  import py4godot.classes.AudioStreamPlaybackResampled as py4godot_audiostreamplaybackresampled 
  import py4godot.classes.AudioStreamPlaybackOggVorbis as py4godot_audiostreamplaybackoggvorbis 
  import py4godot.classes.AudioStreamPlaybackSynchronized as py4godot_audiostreamplaybacksynchronized 
import py4godot.classes.DictionaryTypedArray as py4godot_dictionarytypedarray 
import py4godot.classes.Resource as py4godot_resource 
from py4godot.wrappers.wrappers import CPPAudioStreamWrapper


class AudioStream(py4godot_resource.Resource):
  r'''
		Base class for audio streams. Audio streams are used for sound effects and music playback, and support WAV (via `AudioStreamWAV`) and Ogg (via `AudioStreamOggVorbis`) file formats.
	'''

  @staticmethod
  def constructor():
    class_ = AudioStream.construct_without_init()
    class_._ptr = constructor(140,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AudioStream.construct_without_init()
    class_._ptr = constructor(140,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAudioStreamWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(140,0, ())


  def generate_wrapper(self):
    return CPPAudioStreamWrapper()
  def init_signals(self):
    super().init_signals()
    parameter_list_changed_name = utils.py_string_to_string_name("parameter_list_changed")
    self.parameter_list_changed = signals.BuiltinSignal(self, parameter_list_changed_name)

  @staticmethod
  def construct_without_init():
    cls = AudioStream.__new__(AudioStream)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AudioStream'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(93, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AudioStream.construct_without_init()
    cls._ptr = CPPAudioStreamWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AudioStream.construct_without_init()
    cls._ptr = CPPAudioStreamWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @functools.native_method
  def _instantiate_playback(self) -> typing.Any:
    r'''
				Override this method to customize the returned value of `instantiate_playback`. Should return a new `AudioStreamPlayback` created when the stream is played (such as by an `AudioStreamPlayer`).
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioStreamPlayback
    _ret._ptr = self._ptr.call_with_return(77,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def _get_stream_name(self) -> typing.Union[str]:
    r'''
				Override this method to customize the name assigned to this audio stream. Unused by the engine.
			'''




    _ret = String.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(78,tuple([]))
    return utils.gd_string_to_py_string(_ret)


  @functools.native_method
  def _get_length(self) -> typing.Union[float]:
    r'''
				Override this method to customize the returned value of `get_length`. Should return the length of this audio stream, in seconds.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(79,tuple([]))
    return _ret


  @functools.native_method
  def _is_monophonic(self) -> typing.Union[bool]:
    r'''
				Override this method to customize the returned value of `is_monophonic`. Should return `true` if this audio stream only supports one channel.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(80,tuple([]))
    return _ret


  @functools.native_method
  def _get_bpm(self) -> typing.Union[float]:
    r'''
				Overridable method. Should return the tempo of this audio stream, in beats per minute (BPM). Used by the engine to determine the position of every beat.
				Ideally, the returned value should be based off the stream's sample rate (`AudioStreamWAV.mix_rate`, for example).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(81,tuple([]))
    return _ret


  @functools.native_method
  def _get_beat_count(self) -> typing.Union[int]:
    r'''
				Overridable method. Should return the total number of beats of this audio stream. Used by the engine to determine the position of every beat.
				Ideally, the returned value should be based off the stream's sample rate (`AudioStreamWAV.mix_rate`, for example).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(82,tuple([]))
    return _ret


  @functools.native_method
  def _get_tags(self) -> typing.Union['Dictionary']:
    r'''
				Override this method to customize the tags for this audio stream. Should return a `Dictionary` of strings with the tag as the key and its content as the value.
				Commonly used tags include `title`, `artist`, `album`, `tracknumber`, and `date`.
			'''




    _ret = Dictionary.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(83,tuple([]))
    return _ret


  @functools.native_method
  def _get_parameter_list(self) -> typing.Union['py4godot_dictionarytypedarray.DictionaryTypedArray']:
    r'''
				Return the controllable parameters of this stream. This array contains dictionaries with a property info description format (see `Object.get_property_list`). Additionally, the default value for this parameter must be added tho each dictionary in "default_value" field.
			'''




    _ret = py4godot_dictionarytypedarray.DictionaryTypedArray.construct_without_init()
    _ret._ptr = self._ptr.call_with_return(84,tuple([]))
    return _ret


  @functools.native_method
  def _has_loop(self) -> typing.Union[bool]:
    r'''
				Override this method to return `true` if this stream has a loop.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(85,tuple([]))
    return _ret


  @functools.native_method
  def _get_bar_beats(self) -> typing.Union[int]:
    r'''
				Override this method to return the bar beats of this stream.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(86,tuple([]))
    return _ret


  @functools.native_method
  def get_length(self) -> typing.Union[float]:
    r'''
				Returns the length of the audio stream in seconds. If this stream is an `AudioStreamRandomizer`, returns the length of the last played stream. If this stream has an indefinite length (such as for `AudioStreamGenerator` and `AudioStreamMicrophone`), returns `0.0`.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(87,tuple([]))
    return _ret


  @functools.native_method
  def is_monophonic(self) -> typing.Union[bool]:
    r'''
				Returns `true` if this audio stream only supports one channel (_monophony_), or `false` if the audio stream supports two or more channels (_polyphony_).
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(88,tuple([]))
    return _ret


  @functools.native_method
  def instantiate_playback(self) -> typing.Any:
    r'''
				Returns a newly created `AudioStreamPlayback` intended to play this audio stream. Useful for when you want to extend `_instantiate_playback` but call `instantiate_playback` from an internally held AudioStream subresource. An example of this can be found in the source code for `AudioStreamRandomPitch::instantiate_playback`.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioStreamPlayback
    _ret._ptr = self._ptr.call_with_return(89,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def can_be_sampled(self) -> typing.Union[bool]:
    r'''
				Returns if the current `AudioStream` can be used as a sample. Only static streams can be sampled.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(90,tuple([]))
    return _ret


  @functools.native_method
  def generate_sample(self) -> typing.Union['py4godot_audiosample.AudioSample']:
    r'''
				Generates an `AudioSample` based on the current stream.
			'''




    _ret = classes.Object.Object.construct_without_init() #Smart casted to: AudioSample
    _ret._ptr = self._ptr.call_with_return(91,tuple([]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def is_meta_stream(self) -> typing.Union[bool]:
    r'''
				Returns `true` if the stream is a collection of other streams, `false` otherwise.
			'''




    _ret = 0
    _ret = self._ptr.call_with_return(92,tuple([]))
    return _ret



register_cast_function('AudioStream', AudioStream.cast)
register_class('AudioStream', AudioStream)
