# distutils: language=c++
import py4godot.utils.functools as  functools
import py4godot.utils.utils as utils
from py4godot.classes.core import *
from py4godot.utils.smart_cast import smart_cast, register_cast_function, register_class, get_class
from py4godot.utils.CPPWrapper import CPPWrapper, constructor, static_method
import py4godot.utils.utils as c_utils
from py4godot.utils.CoreType import CoreType
import typing
import py4godot.variant_types
import py4godot.classes as classes
import py4godot.classes as classes
import py4godot.signals as signals

import typing
if typing.TYPE_CHECKING:
  pass
  import py4godot.classes.PortableCompressedTexture2D as py4godot_portablecompressedtexture2d 
  import py4godot.classes.CurveTexture as py4godot_curvetexture 
  import py4godot.classes.ExternalTexture as py4godot_externaltexture 
  import py4godot.classes.MeshTexture as py4godot_meshtexture 
  import py4godot.classes.GradientTexture2D as py4godot_gradienttexture2d 
  import py4godot.classes.PlaceholderTexture2D as py4godot_placeholdertexture2d 
  import py4godot.classes.GradientTexture1D as py4godot_gradienttexture1d 
  import py4godot.classes.DPITexture as py4godot_dpitexture 
  import py4godot.classes.ViewportTexture as py4godot_viewporttexture 
  import py4godot.classes.Texture2DRD as py4godot_texture2drd 
  import py4godot.classes.NoiseTexture2D as py4godot_noisetexture2d 
  import py4godot.classes.CompressedTexture2D as py4godot_compressedtexture2d 
  import py4godot.classes.AtlasTexture as py4godot_atlastexture 
  import py4godot.classes.ImageTexture as py4godot_imagetexture 
  import py4godot.classes.CanvasTexture as py4godot_canvastexture 
  import py4godot.classes.CurveXYZTexture as py4godot_curvexyztexture 
  import py4godot.classes.CameraTexture as py4godot_cameratexture 
import py4godot.classes.Texture2D as py4godot_texture2d 
from py4godot.wrappers.wrappers import CPPAnimatedTextureWrapper


class AnimatedTexture(py4godot_texture2d.Texture2D):
  r'''
		`AnimatedTexture` is a resource format for frame-based animations, where multiple textures can be chained automatically with a predefined delay for each frame. Unlike `AnimationPlayer` or `AnimatedSprite2D`, it isn't a `Node`, but has the advantage of being usable anywhere a `Texture2D` resource can be used, e.g. in a `TileSet`.
		The playback of the animation is controlled by the `speed_scale` property, as well as each frame's duration (see `set_frame_duration`). The animation loops, i.e. it will restart at frame 0 automatically after playing the last frame.
		`AnimatedTexture` currently requires all frame textures to have the same size, otherwise the bigger ones will be cropped to match the smallest one.
		**Note:** AnimatedTexture doesn't support using `AtlasTexture`s. Each frame needs to be a separate `Texture2D`.
		**Warning:** The current implementation is not efficient for the modern renderers.
	'''
  MAX_FRAMES:typing.ClassVar[int]

  @staticmethod
  def constructor():
    class_ = AnimatedTexture.construct_without_init()
    class_._ptr = constructor(71,0, ())
    return class_
  @staticmethod
  def new():
    class_ = AnimatedTexture.construct_without_init()
    class_._ptr = constructor(71,0, ())
    return class_
  def __init__(self):
    self._ptr =  CPPAnimatedTextureWrapper()
    self.casted_from = None
    if c_utils.shouldCreateObject:
      self._ptr = constructor(71,0, ())


  def generate_wrapper(self):
    return CPPAnimatedTextureWrapper()
  def init_signals(self):
    super().init_signals()

  @staticmethod
  def construct_without_init():
    cls = AnimatedTexture.__new__(AnimatedTexture)
    cls.shouldBeDeleted = True
    cls.casted_from = None
    cls.constructed_from_python = False
    cls.init_signals()
    return cls
  @staticmethod
  def get_type():
    return 'AnimatedTexture'

  def __del__(self):
    if self.casted_from is None:
      self._ptr.call_with_return(107, ())
      self._ptr = None
  @staticmethod
  def cast(other:'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimatedTexture.construct_without_init()
    cls._ptr = CPPAnimatedTextureWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    cls.casted_from = other
    return cls
  @staticmethod
  def cast_without_reference(other: 'Object'):
    assert other != None # Object to be casted must not be None
    cls = AnimatedTexture.construct_without_init()
    cls._ptr = CPPAnimatedTextureWrapper()
    cls._ptr_before = other._ptr # Save pointer
    cls._ptr.copy_gdowner(cls._ptr_before)
    return cls

  @property
  def frames(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_frames()
    return _ret
  @frames.setter
  def frames(self,  value:'int'):
    self.set_frames(value)
  @property
  def current_frame(self) -> typing.Union[int]:
    r''''''
    _ret = self. get_current_frame()
    return _ret
  @current_frame.setter
  def current_frame(self,  value:'int'):
    self.set_current_frame(value)
  @property
  def pause(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_pause()
    return _ret
  @pause.setter
  def pause(self,  value:'bool'):
    self.set_pause(value)
  @property
  def one_shot(self) -> typing.Union[bool]:
    r''''''
    _ret = self. get_one_shot()
    return _ret
  @one_shot.setter
  def one_shot(self,  value:'bool'):
    self.set_one_shot(value)
  @property
  def speed_scale(self) -> typing.Union[float]:
    r''''''
    _ret = self. get_speed_scale()
    return _ret
  @speed_scale.setter
  def speed_scale(self,  value:'float'):
    self.set_speed_scale(value)
  @functools.native_method
  def set_frames(self, frames:'int'   ) -> None:
    r''''''

    assert isinstance(frames, (int, float)), 'frames must be int or float'


    self.py__frames = frames






    self._ptr.call_with_return(93,tuple([frames]))

  @functools.native_method
  def get_frames(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(94,tuple([]))

    return _ret


  @functools.native_method
  def set_current_frame(self, frame:'int'   ) -> None:
    r''''''

    assert isinstance(frame, (int, float)), 'frame must be int or float'


    self.py__current_frame = frame






    self._ptr.call_with_return(95,tuple([frame]))

  @functools.native_method
  def get_current_frame(self) -> typing.Union[int]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(96,tuple([]))

    return _ret


  @functools.native_method
  def set_pause(self, pause:'bool'   ) -> None:
    r''''''

    assert isinstance(pause, bool), 'pause must be bool'


    self.py__pause = pause






    self._ptr.call_with_return(97,tuple([pause]))

  @functools.native_method
  def get_pause(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(98,tuple([]))

    return _ret


  @functools.native_method
  def set_one_shot(self, one_shot:'bool'   ) -> None:
    r''''''

    assert isinstance(one_shot, bool), 'one_shot must be bool'


    self.py__one_shot = one_shot






    self._ptr.call_with_return(99,tuple([one_shot]))

  @functools.native_method
  def get_one_shot(self) -> typing.Union[bool]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(100,tuple([]))

    return _ret


  @functools.native_method
  def set_speed_scale(self, scale:'float'   ) -> None:
    r''''''

    assert isinstance(scale, (int, float)), 'scale must be int or float'


    self.py__speed_scale = scale






    self._ptr.call_with_return(101,tuple([scale]))

  @functools.native_method
  def get_speed_scale(self) -> typing.Union[float]:
    r''''''




    _ret = 0
    _ret = self._ptr.call_with_return(102,tuple([]))

    return _ret


  @functools.native_method
  def set_frame_texture(self, frame:'int'   , texture:'py4godot_texture2d.Texture2D'   ) -> None:
    r'''
				Assigns a `Texture2D` to the given frame. Frame IDs start at 0, so the first frame has ID 0, and the last frame of the animation has ID `frames` - 1.
				You can define any number of textures up to `constant MAX_FRAMES`, but keep in mind that only frames from 0 to `frames` - 1 will be part of the animation.
			'''

    assert isinstance(frame, (int, float)), 'frame must be int or float'
    assert(not texture is None)
    assert isinstance(texture, get_class('Texture2D')), 'texture must be Texture2D'








    self._ptr.call_with_return(103,tuple([frame, texture._ptr]))

  @functools.native_method
  def get_frame_texture(self, frame:'int'   ) -> typing.Any:
    r'''
				Returns the given frame's `Texture2D`.
			'''

    assert isinstance(frame, (int, float)), 'frame must be int or float'







    _ret = classes.Object.Object.construct_without_init() #Smart casted to: Texture2D
    _ret._ptr = self._ptr.call_with_return(104,tuple([frame]))
    return smart_cast(_ret) if not _ret._ptr.is_null() else None


  @functools.native_method
  def set_frame_duration(self, frame:'int'   , duration:'float'   ) -> None:
    r'''
				Sets the duration of any given `frame`. The final duration is affected by the `speed_scale`. If set to `0`, the frame is skipped during playback.
			'''

    assert isinstance(frame, (int, float)), 'frame must be int or float'
    assert isinstance(duration, (int, float)), 'duration must be int or float'








    self._ptr.call_with_return(105,tuple([frame, duration]))

  @functools.native_method
  def get_frame_duration(self, frame:'int'   ) -> typing.Union[float]:
    r'''
				Returns the given `frame`'s duration, in seconds.
			'''

    assert isinstance(frame, (int, float)), 'frame must be int or float'







    _ret = 0
    _ret = self._ptr.call_with_return(106,tuple([frame]))
    return _ret



register_cast_function('AnimatedTexture', AnimatedTexture.cast)
register_class('AnimatedTexture', AnimatedTexture)
